diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/Makefile linux-3.14.43/arch/arm/boot/dts/Makefile
--- linux-3.14.43.org/arch/arm/boot/dts/Makefile	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/Makefile	2016-02-02 11:43:18.252598450 +0800
@@ -253,6 +253,7 @@
 	qcom-ipq40xx-ap.dk01.1-c1.dtb \
 	qcom-ipq40xx-ap.dk01.1-c2.dtb \
 	qcom-ipq40xx-ap.dk04.1-c1.dtb \
+	qcom-ipq40xx-ap.dk06.1-c1.dtb \
 	qcom-ipq40xx-ap.dk04.1-c2.dtb \
 	qcom-ipq40xx-ap.dk04.1-c3.dtb \
 	qcom-ipq40xx-ap.dk04.1-c4.dtb \
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -31,9 +31,18 @@
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges;
-		rsvd@87000000 {
+		rsvd1@87000000 {
 			/* Reserved for other subsystem */
-			reg = <0x87000000 0x01000000>;
+			reg = <0x87000000 0x500000>;
+			no-map;
+		};
+		wifi_dump@87500000 {
+			reg = <0x87500000 0x600000>;
+			no-map;
+		};
+		rsvd2@87B00000 {
+			/* Reserved for other subsystem */
+			reg = <0x87B00000 0x500000>;
 			no-map;
 		};
 	};
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -32,9 +32,19 @@
 		#address-cells = <1>;
 		#size-cells = <1>;
 		ranges;
-		rsvd@87000000 {
+		rsvd1@87000000 {
 			/* Reserved for other subsystem */
-			reg = <0x87000000 0x01000000>;
+			reg = <0x87000000 0x500000>;
+			no-map;
+		};
+		wifi_dump@87500000 {
+			reg = <0x87500000 0x600000>;
+			no-map;
+		};
+
+		rsvd2@87B00000 {
+			/* Reserved for other subsystem */
+			reg = <0x87B00000 0x500000>;
 			no-map;
 		};
 	};
@@ -321,6 +331,7 @@
 			pinctrl-names = "default";
 			vqmmc-supply = <&vccq_sd0>;
 			cd-gpios = <&tlmm 22 0x1>;
+			sd-ldo-gpios = <&tlmm 33 0x1>;
 		};
 
 		qcom,nand@7980000 {
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts	2016-02-02 11:43:18.268598287 +0800
@@ -0,0 +1,33 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+#include "qcom-ipq40xx-ap.dk04.1.dtsi"
+/{
+	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK06.1-C1";
+	soc {
+		qcom,nand@7980000 {
+			status = "ok";
+		};
+
+		qcom,msm_qpic@7980000 {
+			status = "ok";
+		};
+
+		qcom,Gobi {
+			compatible = "qcom,gobi-9x35";
+			status = "ok";
+		};
+	};
+};
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-db.dk02.1-c1.dts linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-db.dk02.1-c1.dts
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq40xx-db.dk02.1-c1.dts	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-db.dk02.1-c1.dts	2016-02-02 11:43:18.268598287 +0800
@@ -41,5 +41,17 @@
 				reg = <0x50>;
 			};
 		};
+
+		ess_tcsr: ess_tcsr@1953000 {
+			qcom,ess-interface-select = <TCSR_ESS_PSGMII_RGMII4>;
+		};
+
+		sdhci@7824000 {
+			status = "disabled";
+		};
+
+		ess-switch@c000000 {
+			switch_mac_mode = <0xa>; /* mac mode for RGMII MAC4 */
+		};
 	};
 };
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -169,16 +169,6 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
@@ -286,7 +276,6 @@
 		};
 
 		nss0: nss@40000000 {
-			compatible = "qcom,nss0";
 			pinctrl-names = "default";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
 				GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
@@ -304,9 +293,6 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -314,6 +300,9 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
 			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
 			qcom,gmac0_enabled = <1>;
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -140,6 +140,16 @@
 
 	};
 
+	aliases {
+                mdio-gpio0 = &mdio0;
+                /*
+                 * U-Boot searches for these entries and patches
+                 * 'local-mac-address'
+                 */
+                ethernet0 = &gmac1;
+                ethernet1 = &gmac2;
+        };
+
 	soc {
 
 		pinmux@800000 {
@@ -195,6 +205,23 @@
 				};
 			};
 
+			nss_spi_pins: nss_spi_pins {
+				mux {
+					pins = "gpio14", "gpio15", "gpio16", "gpio17",
+						"gpio55", "gpio56", "gpio57", "gpio58";
+					function = "nss_spi";
+					drive-strengh = <10>;
+				};
+				data {
+					pins = "gpio14", "gpio15", "gpio55", "gpio56";
+					bias-none;
+				};
+				cs {
+					pins = "gpio16", "gpio17", "gpio57", "gpio58";
+					bias-pull-up;
+				};
+                        };
+
 			spi_pins: spi_pins {
 				mux {
 					pins = "gpio18", "gpio19", "gpio21";
@@ -238,11 +265,6 @@
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
-				};
 			};
 		};
 
@@ -287,20 +309,14 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
 
+		sata-phy@1b400000 {
+			status = "ok";
+		};
+
 		pci@1b500000 {
 			status = "ok";
 			reset-gpio = <&qcom_pinmux 3 0>;
@@ -373,6 +389,32 @@
 			};
 		};
 
+		mdio0: mdio {
+                        compatible = "virtual,mdio-gpio";
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+
+                        phy0: ethernet-phy@0 {
+                                device_type = "ethernet-phy";
+                                reg = <0>;
+                                qca,ar8327-initvals = <
+                                        0x00004 0x7600000   /* PAD0_MODE */
+                                        0x00008 0x1000000   /* PAD5_MODE */
+                                        0x0000c 0x80        /* PAD6_MODE */
+                                        0x000e4 0xaa545     /* MAC_POWER_SEL */
+                                        0x000e0 0xc74164de  /* SGMII_CTRL */
+                                        0x0007c 0x4e        /* PORT0_STATUS */
+                                        0x00094 0x4e        /* PORT6_STATUS */
+                                >;
+                        };
+
+                        phy4: ethernet-phy@4 {
+                                device_type = "ethernet-phy";
+                                reg = <4>;
+                        };
+                };
+
 		amba {
 			/* eMMC */
 			sdcc1: sdcc@12400000 {
@@ -381,5 +423,160 @@
 				pinctrl-names = "default";
 			};
 		};
+
+		nss0: nss@40000000 {
+			pinctrl-0 = <&nss_spi_pins>;
+			pinctrl-names = "default";
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x10000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_AHB_RESET>,
+				 <&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <0>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <0>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
+		};
+
+		nss-gmac-common@03000000 {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+		};
+
+		gmac1: ethernet@37200000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37200000 0x200000>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <1>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <4>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <1>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac2: ethernet@37400000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37400000 0x200000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "sgmii";
+			qcom,id = <2>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <0>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
 	};
 };
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -140,6 +140,16 @@
 
 	};
 
+	aliases {
+		mdio-gpio0 = &mdio0;
+		/*
+		 * U-Boot searches for these entries and patches
+		 * 'local-mac-address'
+		 */
+		ethernet0 = &gmac1;
+		ethernet1 = &gmac2;
+        };
+
 	soc {
 
 		pinmux@800000 {
@@ -168,6 +178,23 @@
 				};
 			};
 
+			nss_spi_pins: nss_spi_pins {
+				mux {
+					pins = "gpio14", "gpio15", "gpio16", "gpio17",
+					       "gpio55", "gpio56", "gpio57", "gpio58";
+					function = "nss_spi";
+					drive-strengh = <10>;
+				};
+				data {
+					pins = "gpio14", "gpio15", "gpio55", "gpio56";
+					bias-none;
+				};
+				cs {
+					pins = "gpio16", "gpio17", "gpio57", "gpio58";
+					bias-pull-up;
+				};
+			};
+
 			spi_pins: spi_pins {
 				mux {
 					pins = "gpio18", "gpio19", "gpio21";
@@ -205,15 +232,10 @@
 			mdio0_pins_default: mdio0_pins_default {
 				mux {
 					pins = "gpio0", "gpio1";
-					function = "mdio";
+					function = "gpio";
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				clk {
-					pins = "gpio1";
-					input-disable;
-				};
 			};
 			rgmii2_pins_default: rgmii2_pins_default {
 				mux {
@@ -223,11 +245,6 @@
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
-				};
 			};
 			sdcc1_pins: sdcc1_pinmux {
 				mux {
@@ -298,20 +315,14 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
 
+		sata-phy@1b400000 {
+			status = "ok";
+		};
+
 		pci@1b500000 {
 			status = "ok";
 			reset-gpio = <&qcom_pinmux 3 0>;
@@ -391,6 +402,32 @@
 			};
 		};
 
+		mdio0: mdio {
+                        compatible = "virtual,mdio-gpio";
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+
+                        phy0: ethernet-phy@0 {
+                                device_type = "ethernet-phy";
+                                reg = <0>;
+                                qca,ar8327-initvals = <
+                                        0x00004 0x7600000   /* PAD0_MODE */
+                                        0x00008 0x1000000   /* PAD5_MODE */
+                                        0x0000c 0x80        /* PAD6_MODE */
+                                        0x000e4 0xaa545     /* MAC_POWER_SEL */
+                                        0x000e0 0xc74164de  /* SGMII_CTRL */
+                                        0x0007c 0x4e        /* PORT0_STATUS */
+                                        0x00094 0x4e        /* PORT6_STATUS */
+                                >;
+                        };
+
+                        phy4: ethernet-phy@4 {
+                                device_type = "ethernet-phy";
+                                reg = <4>;
+                        };
+                };
+
 		amba {
 			/* eMMC */
 			sdcc1: sdcc@12400000 {
@@ -400,5 +437,159 @@
 			};
 		};
 
+		nss0: nss@40000000 {
+			pinctrl-0 = <&nss_spi_pins>;
+			pinctrl-names = "default";
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x10000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_AHB_RESET>,
+				 <&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <0>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <0>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
+		};
+
+		nss-gmac-common@03000000 {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+		};
+
+		gmac1: ethernet@37200000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37200000 0x200000>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <1>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <4>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <1>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac2: ethernet@37400000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37400000 0x200000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "sgmii";
+			qcom,id = <2>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <0>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
 	};
 };
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -136,15 +136,10 @@
 			mdio0_pins_default: mdio0_pins_default {
 				mux {
 					pins = "gpio0", "gpio1";
-					function = "mdio";
+					function = "gpio";
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				clk {
-					pins = "gpio1";
-					input-disable;
-				};
 			};
 
 			rgmii2_pins_default: rgmii2_pins_default {
@@ -155,11 +150,6 @@
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
-				};
 			};
 
 			uart2_pins: uart2_pins {
@@ -336,7 +326,6 @@
 		};
 
 		nss0: nss@40000000 {
-			compatible = "qcom,nss0";
 			pinctrl-0 = <&nss_spi_pins>;
 			pinctrl-names = "default";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
@@ -355,9 +344,6 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -366,6 +352,8 @@
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
 			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
 			qcom,gmac0_enabled = <1>;
@@ -375,7 +363,6 @@
 		};
 
 		nss1: nss@40800000 {
-			compatible = "qcom,nss1";
 			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
@@ -390,9 +377,6 @@
 			qcom,rst_addr = <0x40800000>;
 			qcom,load_addr = <0x40800000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <0>;
 			qcom,ipv6_enabled = <0>;
 			qcom,l2switch_enabled = <0>;
@@ -400,6 +384,9 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
 			qcom,tunipip6_enabled = <0>;
 			qcom,shaping_enabled = <0>;
 			qcom,gmac0_enabled = <0>;
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -118,15 +118,10 @@
 			mdio0_pins_default: mdio0_pins_default {
 				mux {
 					pins = "gpio0", "gpio1";
-					function = "mdio";
+					function = "gpio";
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				clk {
-					pins = "gpio1";
-					input-disable;
-				};
 			};
 
 			rgmii2_pins_default: rgmii2_pins_default {
@@ -137,11 +132,6 @@
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
-				};
 			};
 		};
 
@@ -301,7 +291,6 @@
 		};
 
 		nss0: nss@40000000 {
-			compatible = "qcom,nss0";
 			pinctrl-0 = <&nss_spi_pins>;
 			pinctrl-names = "default";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
@@ -320,9 +309,6 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -331,6 +317,8 @@
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
+			qcom,portid_enabled = <1>;
+			qcom,pptp_enabled = <1>;
 			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
 			qcom,gmac0_enabled = <0>;
@@ -341,7 +329,6 @@
 		};
 
 		nss1: nss@40800000 {
-			compatible = "qcom,nss1";
 			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
@@ -356,9 +343,6 @@
 			qcom,rst_addr = <0x40800000>;
 			qcom,load_addr = <0x40800000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <0>;
 			qcom,ipv6_enabled = <0>;
 			qcom,l2switch_enabled = <0>;
@@ -366,6 +350,9 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
 			qcom,tunipip6_enabled = <0>;
 			qcom,shaping_enabled = <0>;
 			qcom,gmac0_enabled = <0>;
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -33,6 +33,19 @@
 		};
 	};
 
+	aliases {
+		mdio-gpio0 = &mdio0;
+		mdio-gpio1 = &mdio1;
+		/*
+		 * U-Boot searches for these entries and patches
+		 * 'local-mac-address'
+		 */
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		ethernet2 = &gmac2;
+		ethernet3 = &gmac3;
+	};
+
 	soc {
 		pinmux@800000 {
 			pinctrl-0 = <&mdio0_pins_default &mdio1_pins_default &rgmii2_pins_default>;
@@ -97,31 +110,23 @@
 					bias-bus-hold;
 				};
 			};
+
 			mdio0_pins_default: mdio0_pins_default {
 				mux {
 					pins = "gpio0", "gpio1";
-					function = "mdio";
+					function = "gpio";
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				clk {
-					pins = "gpio1";
-					input-disable;
-				};
 			};
+
 			mdio1_pins_default: mdio1_pins_default {
 				mux {
 					pins = "gpio2", "gpio66";
-					function = "mdio";
+					function = "gpio";
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				clk {
-					pins = "gpio66";
-					input-disable;
-				};
 			};
 
 			rgmii2_pins_default: rgmii2_pins_default {
@@ -132,11 +137,6 @@
 					drive-strength = <8>;
 					bias-disable;
 				};
-
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
-				};
 			};
 		};
 
@@ -172,16 +172,6 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
@@ -276,6 +266,252 @@
 			};
 		};
 
+		mdio0: mdio0 {
+			compatible = "virtual,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+		};
+
+		mdio1: mdio1 {
+			compatible = "virtual,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			gpios = <&qcom_pinmux 66 0 &qcom_pinmux 2 0>;
+
+			phy5: ethernet-phy@5 {
+				device_type = "ethernet-phy";
+				reg = <5>;
+			};
+		};
+
+		nss0: nss@40000000 {
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+					GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x20000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>,  <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				<&gcc UBI32_CORE1_CLAMP_RESET>,
+				<&gcc UBI32_CORE1_AHB_RESET>,
+				<&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <1>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <1>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <1>;
+			qcom,wlan_dataplane_offload_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <1>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
+		};
+
+		 nss-gmac-common {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+			qcom,gmac-phy-profile = <2>;
+		};
+
+		gmac0: ethernet@37000000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37000000 0x200000>;
+			interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "qsgmii";
+			qcom,id = <0>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <5>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,mmds-mask = <0>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio1>;
+		};
+
+                gmac1: ethernet@37200000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37200000 0x200000>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "qsgmii";
+			qcom,id = <1>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <16>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,mmds-mask = <0x6000009a>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio1>;
+		};
+
+                gmac2: ethernet@37400000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37400000 0x200000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "qsgmii";
+			qcom,id = <2>;
+			qcom,pcs-chanid = <2>;
+			qcom,phy-mdio-addr = <32>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,mmds-mask = <0>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio1>;
+		};
+
+                gmac3: ethernet@37600000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37600000 0x200000>;
+			interrupts = <GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "qsgmii";
+			qcom,id = <3>;
+			qcom,pcs-chanid = <3>;
+			qcom,phy-mdio-addr = <32>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,mmds-mask = <0>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio1>;
+		};
+
+		aq-phy {
+			compatible = "qcom,aq-phy";
+			qcom,phy-addr = <0x10>;
+			mdiobus = <&mdio1>;
+		};
+
+		 qca-85xx-sw {
+			compatible = "qcom,qca-85xx-sw";
+			qcom,sgmii-plus-if-phy-addr = <0x10>;
+			qcom,chip-id = <1>;
+			qcom,qsgmii-cfg-port-mode = <1>;
+			qcom,qsgmii-cfg-port-base = <1>;
+			qcom,qsgmii-cfg-is-speed-forced = <1>;
+			qcom,qsgmii-cfg-forced-speed = <1000>;
+			qcom,qsgmii-cfg-forced-duplex = <1>;
+			qcom,port-26-cfg-port-mode = <2>;
+			qcom,port-26-cfg-is-speed-forced = <0>;
+			qcom,port-27-cfg-port-mode = <3>;
+			qcom,port-27-cfg-is-speed-forced = <1>;
+			qcom,port-27-cfg-forced-speed = <2500>;
+			qcom,port-27-cfg-forced-duplex = <1>;
+			qcom,trunk-cfg-is-trunk-enabled = <1>;
+			qcom,trunk-cfg-trunk-id = <0>;
+			qcom,trunk-cfg-trunk-hash-policy = <0x6c>;
+			qcom,trunk-cfg-trunk-ports-bit-map = <0x1c>;
+			mdiobus = <&mdio0>;
+			sgmii-plus-if-phy-mdiobus = <&mdio1>;
+		};
+
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
 		rpm@108000 {
 			pinctrl-0 = <&rpm_i2c_pinmux>;
 			pinctrl-names = "default";
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015, 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -41,7 +41,7 @@
 		 */
 		ethernet0 = &gmac0;
 		ethernet1 = &gmac1;
-		ethernet3 = &gmac2;
+		ethernet2 = &gmac2;
 	};
 
 	soc {
@@ -194,16 +194,6 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
@@ -370,7 +360,6 @@
 		};
 
 		nss0: nss@40000000 {
-			compatible = "qcom,nss0";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
@@ -387,9 +376,6 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <0>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -397,6 +383,9 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
 			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
 			qcom,gmac0_enabled = <1>;
@@ -407,7 +396,6 @@
 		};
 
 		nss1: nss@40800000 {
-			compatible = "qcom,nss1";
 			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
@@ -422,9 +410,6 @@
 			qcom,rst_addr = <0x40800000>;
 			qcom,load_addr = <0x40800000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <0>;
 			qcom,ipv6_enabled = <0>;
 			qcom,l2switch_enabled = <0>;
@@ -432,6 +417,9 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
 			qcom,tunipip6_enabled = <0>;
 			qcom,shaping_enabled = <0>;
 			qcom,gmac0_enabled = <0>;
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015, 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -41,7 +41,7 @@
 		 */
 		ethernet0 = &gmac0;
 		ethernet1 = &gmac1;
-		ethernet3 = &gmac2;
+		ethernet2 = &gmac2;
 	};
 
 	soc {
@@ -211,16 +211,6 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
@@ -354,7 +344,6 @@
 		};
 
 		nss0: nss@40000000 {
-			compatible = "qcom,nss0";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
@@ -371,9 +360,6 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <0>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -381,7 +367,10 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
-			com,tunipip6_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
 			qcom,gmac0_enabled = <1>;
 			qcom,gmac1_enabled = <1>;
@@ -391,7 +380,6 @@
 		};
 
 		nss1: nss@40800000 {
-			compatible = "qcom,nss1";
 			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
@@ -406,9 +394,6 @@
 			qcom,rst_addr = <0x40800000>;
 			qcom,load_addr = <0x40800000>;
 			qcom,turbo_frequency = <1>;
-			qcom,low_frequency = <110000000>;
-			qcom,mid_frequency = <550000000>;
-			qcom,max_frequency = <733000000>;
 			qcom,ipv4_enabled = <0>;
 			qcom,ipv6_enabled = <0>;
 			qcom,l2switch_enabled = <0>;
@@ -416,6 +401,9 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,pptp_enabled = <0>;
+			qcom,portid_enabled = <0>;
 			qcom,tunipip6_enabled = <0>;
 			qcom,shaping_enabled = <0>;
 			qcom,gmac0_enabled = <0>;
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -41,8 +41,8 @@
 		 */
 		ethernet0 = &gmac0;
 		ethernet1 = &gmac1;
-		ethernet3 = &gmac2;
-		ethernet4 = &gmac3;
+		ethernet2 = &gmac2;
+		ethernet3 = &gmac3;
 	};
 
 	soc {
@@ -232,16 +232,6 @@
 					spi-max-frequency = <50000000>;
 					reg = <0>;
 					m25p,fast-read;
-
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
@@ -398,13 +388,12 @@
 		};
 
 		nss0: nss@40000000 {
-			compatible = "qcom,nss0";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
 			reg-names = "nphys", "vphys";
-			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>;
-			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
 			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
 				 <&gcc UBI32_CORE1_CLAMP_RESET>,
 				 <&gcc UBI32_CORE1_AHB_RESET>,
@@ -423,14 +412,57 @@
 			qcom,l2switch_enabled = <1>;
 			qcom,crypto_enabled = <0>;
 			qcom,ipsec_enabled = <0>;
-			qcom,wlan_enabled = <0>;
+			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,pptp_enabled = <1>;
+			qcom,portid_enabled = <1>;
 			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
 			qcom,gmac0_enabled = <1>;
 			qcom,gmac1_enabled = <1>;
 			qcom,gmac2_enabled = <1>;
 			qcom,gmac3_enabled = <1>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
+		};
+
+		nss1: nss@40800000 {
+			compatible = "qcom,nss1";
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <275000000>;
+			qcom,max_frequency = <550000000>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,l2tpv2_enabled = <0>;
+			qcom,portid_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
 		};
 
 		nss-gmac-common {
@@ -533,6 +565,46 @@
 			mdiobus = <&mdio0>;
 		};
 
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
 	};
 };
 
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064.dtsi	2016-02-02 11:43:18.272598247 +0800
@@ -214,6 +214,20 @@
 		ranges;
 		compatible = "simple-bus";
 
+		nss0: nss@40000000 {
+			compatible = "qcom,nss0";
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+		};
+
+		nss1: nss@40800000 {
+			compatible = "qcom,nss1";
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+		};
+
 		imem: memory@700000 {
 			compatible = "qcom,imem-ipq8064", "syscon";
 			reg = <0x00700000 0x1000>;
@@ -971,7 +985,7 @@
 				#mmc-ddr-1_8v;
 				sd-uhs-sdr104;
 				sd-uhs-ddr50;
-				vmmc-supply = <&vsdcc_fixed>;
+				vqmmc-supply = <&vsdcc_fixed>;
 				#dmas = <&sdcc3bam 2>, <&sdcc3bam 1>;
 				#dma-names = "tx", "rx";
 			};
diff -Naur -x .git linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi
--- linux-3.14.43.org/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi	2015-12-02 04:03:04.000000000 +0800
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi	2016-02-02 11:43:18.268598287 +0800
@@ -102,5 +102,17 @@
 				regulator-max-microvolt = <1275000>;
 			};
 		};
+
+		nss0: nss@40000000 {
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <600000000>;
+			qcom,max_frequency = <800000000>;
+		};
+
+		nss1: nss@40800000 {
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <600000000>;
+			qcom,max_frequency = <800000000>;
+		};
 	};
 };
diff -Naur -x .git linux-3.14.43.org/Documentation/devicetree/bindings/net/qcom-nss-gmac.txt linux-3.14.43/Documentation/devicetree/bindings/net/qcom-nss-gmac.txt
--- linux-3.14.43.org/Documentation/devicetree/bindings/net/qcom-nss-gmac.txt	2015-12-02 04:03:03.000000000 +0800
+++ linux-3.14.43/Documentation/devicetree/bindings/net/qcom-nss-gmac.txt	2016-02-02 11:43:18.128599707 +0800
@@ -12,6 +12,13 @@
 		These correspond to different register bases of GMAC.
 - reg: physical address and length of the register set for the device.
 
+Optional properties:
+- gmac-phy-profile: Indicates different phy profiles, depending on the board.
+			RGMII,SGMII, QSGMII and also can be combination of the three.
+			0 -> 2 RGMII, 2 SGMII
+			1 -> 1 RGMII, 3 SGMII
+			2 -> 4 QSGMII
+
 Example:
 nss-gmac-common@fc800000 {
 	compatible = "qcom,nss-gmac-common";
diff -Naur -x .git linux-3.14.43.org/Documentation/devicetree/bindings/phy/phy-bindings.txt linux-3.14.43/Documentation/devicetree/bindings/phy/phy-bindings.txt
--- linux-3.14.43.org/Documentation/devicetree/bindings/phy/phy-bindings.txt	2015-12-02 04:03:03.000000000 +0800
+++ linux-3.14.43/Documentation/devicetree/bindings/phy/phy-bindings.txt	2016-02-02 11:43:18.128599707 +0800
@@ -64,3 +64,69 @@
 This node represents a controller that uses one of the PHYs of the PHY provider
 device defined previously. Note that the phy handle has an additional specifier
 "1" to differentiate between the two PHYs.
+
+AQ-PHY user node
+================
+
+Required Properties:
+phy-addr: phy_addr of the phy which will use Aquantia
+mdiobus: mdio bus name#number on which the phy is located.
+
+Example:
+aq-phy {
+	compatible = "qcom,aq-phy";
+	qcom,phy-addr = <0x10>;
+	mdiobus = <&mdio1>;
+};
+
+85XX_MUSIC_SWITCH node
+=====================
+
+Required Properties:
+sgmii-plus-if-phy-addr: phy addr of the AQ-PHY
+chip-id:
+	1 -> 8511 chip
+	2 -> 8512 chip
+	3 -> 8513 chip
+	4 -> 8519 chip
+qsgmii-cfg-port-mode: GMAC port modes. set 1 for QSGMII
+qsgmii-cfg-port-base: 85xx Switch GMAC port ID
+qsgmii-cfg-is-speed-forced: GMAC forced speed enable/disable
+qsgmii-cfg-forced-speed: GMAC forced speed
+qsgmii-cfg-forced-duplex: GMAC mode.
+port-26-cfg-port-mode: port 26 is for 8033 phy configuration
+port-26-cfg-is-speed-forced: GMAC forced speed
+port-27-cfg-port-mode: port 27 is for AQ-PHY configuration
+port-27-cfg-is-speed-forced: GMAC forced speed enable/disable
+port-27-cfg-forced-speed: GMAC forced speed
+port-27-cfg-forced-duplex: GMAC mode.
+trunk-cfg-is-trunk-enabled: LAG enable/disable on switch
+trunk-cfg-trunk-id: LAG mode
+trunk-cfg-trunk-hash-policy: LAG policy
+trunk-cfg-trunk-ports-bit-map: LAG bitmap
+mdiobus: mdiobus for the 8033 PHY
+sgmii-plus-if-phy-mdiobus: mdiobus for AQ-PHY
+
+Example:
+qca-85xx-sw {
+	compatible = "qcom,qca-85xx-sw";
+	qcom,sgmii-plus-if-phy-addr = <0x10>;
+	qcom,chip-id = <1>;
+	qcom,qsgmii-cfg-port-mode = <1>;
+	qcom,qsgmii-cfg-port-base = <1>;
+	qcom,qsgmii-cfg-is-speed-forced = <1>;
+	qcom,qsgmii-cfg-forced-speed = <1000>;
+	qcom,qsgmii-cfg-forced-duplex = <1>;
+	qcom,port-26-cfg-port-mode = <2>;
+	qcom,port-26-cfg-is-speed-forced = <0>;
+	qcom,port-27-cfg-port-mode = <3>;
+	qcom,port-27-cfg-is-speed-forced = <1>;
+	qcom,port-27-cfg-forced-speed = <2500>;
+	qcom,port-27-cfg-forced-duplex = <1>;
+	qcom,trunk-cfg-is-trunk-enabled = <1>;
+	qcom,trunk-cfg-trunk-id = <0>;
+	qcom,trunk-cfg-trunk-hash-policy = <0x6c>;
+	qcom,trunk-cfg-trunk-ports-bit-map = <0x1c>;
+	mdiobus = <&mdio0>;
+	sgmii-plus-if-phy-mdiobus = <&mdio1>;
+};
diff -Naur -x .git linux-3.14.43.org/Documentation/devicetree/bindings/soc/qcom/qcom,gobi-9x35.txt linux-3.14.43/Documentation/devicetree/bindings/soc/qcom/qcom,gobi-9x35.txt
--- linux-3.14.43.org/Documentation/devicetree/bindings/soc/qcom/qcom,gobi-9x35.txt	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/Documentation/devicetree/bindings/soc/qcom/qcom,gobi-9x35.txt	2016-02-02 11:43:18.136599625 +0800
@@ -0,0 +1,10 @@
+QCA GOBI-9X35
+
+GobiNet driver is used to communicate with Gobi modems
+using QMI protocol over usb interface
+
+Example for ipq40xx:
+			qcom,Gobi {
+				compatible = "qcom,gobi-9x35";
+				status = "ok"
+				};
diff -Naur -x .git linux-3.14.43.org/Documentation/devicetree/bindings/vendor-prefixes.txt linux-3.14.43/Documentation/devicetree/bindings/vendor-prefixes.txt
--- linux-3.14.43.org/Documentation/devicetree/bindings/vendor-prefixes.txt	2015-12-02 04:03:03.000000000 +0800
+++ linux-3.14.43/Documentation/devicetree/bindings/vendor-prefixes.txt	2016-02-02 11:43:18.140599586 +0800
@@ -54,6 +54,7 @@
 lsi	LSI Corp. (LSI Logic)
 marvell	Marvell Technology Group Ltd.
 maxim	Maxim Integrated Products
+mdio-gpio	MDIO-GPIO Bus
 microchip	Microchip Technology Inc.
 mosaixtech	Mosaix Technologies, Inc.
 national	National Semiconductor
diff -Naur -x .git linux-3.14.43.org/drivers/clk/qcom/gcc-ipq806x.c linux-3.14.43/drivers/clk/qcom/gcc-ipq806x.c
--- linux-3.14.43.org/drivers/clk/qcom/gcc-ipq806x.c	2015-12-02 04:03:05.000000000 +0800
+++ linux-3.14.43/drivers/clk/qcom/gcc-ipq806x.c	2016-02-02 11:43:19.344587387 +0800
@@ -1230,6 +1230,8 @@
 		.parent_map = gcc_pxo_pll8_map,
 	},
 	.clkr = {
+		.enable_reg = 0x2e80,
+		.enable_mask = BIT(11),
 		.hw.init = &(struct clk_init_data){
 			.name = "prng_src",
 			.parent_names = gcc_pxo_pll8,
diff -Naur -x .git linux-3.14.43.org/drivers/dma/Kconfig linux-3.14.43/drivers/dma/Kconfig
--- linux-3.14.43.org/drivers/dma/Kconfig	2015-12-02 04:03:05.000000000 +0800
+++ linux-3.14.43/drivers/dma/Kconfig	2016-02-02 11:43:19.404586780 +0800
@@ -412,7 +412,7 @@
 
 config QCOM_ADM
 	tristate "Qualcomm ADM support"
-	depends on !QCOM_ADM_DMA && (ARCH_QCOM || (COMPILE_TEST && OF && ARM))
+	depends on ARCH_QCOM || (COMPILE_TEST && OF && ARM)
 	select DMA_ENGINE
 	select DMA_VIRTUAL_CHANNELS
 	---help---
diff -Naur -x .git linux-3.14.43.org/drivers/dma/qcom_adm_dma.c linux-3.14.43/drivers/dma/qcom_adm_dma.c
--- linux-3.14.43.org/drivers/dma/qcom_adm_dma.c	2015-12-02 04:03:05.000000000 +0800
+++ linux-3.14.43/drivers/dma/qcom_adm_dma.c	2016-02-02 11:43:19.412586699 +0800
@@ -400,7 +400,8 @@
 	init_completion(&cmd.complete);
 
 	__msm_dmov_enqueue_cmd_ext(id, &cmd.dmov_cmd);
-	wait_for_completion_timeout(&cmd.complete, msecs_to_jiffies(1000));
+	wait_for_completion(&cmd.complete);
+	flush_work(&cmd.dmov_cmd.work);
 
 	if (cmd.result != 0x80000002) {
 		PRINT_ERROR("dmov_exec_cmdptr(%d): ERROR, result: %x\n", id, cmd.result);
diff -Naur -x .git linux-3.14.43.org/drivers/misc/qseecom.c linux-3.14.43/drivers/misc/qseecom.c
--- linux-3.14.43.org/drivers/misc/qseecom.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/misc/qseecom.c	2016-02-02 11:43:20.032580427 +0800
@@ -387,15 +387,24 @@
 	}
 	if (option != 1) {
 		msgreq->data = dma_map_single(NULL, input,
-				sizeof(*input), DMA_TO_DEVICE);
+				input_len, DMA_TO_DEVICE);
 		msgreq->data2 = dma_map_single(NULL, output,
-				sizeof(*output), DMA_FROM_DEVICE);
+				input_len, DMA_FROM_DEVICE);
 
 		ret1 = dma_mapping_error(NULL, msgreq->data);
 		ret2 = dma_mapping_error(NULL, msgreq->data2);
+
 		if (ret1 || ret2) {
 			pr_err("\nDMA Mapping Error Return Values:"
 				"input data %d output data %d", ret1, ret2) ;
+			if (!ret1) {
+				dma_unmap_single(NULL, msgreq->data,
+					input_len, DMA_TO_DEVICE);
+			}
+			if (!ret2) {
+				dma_unmap_single(NULL, msgreq->data2,
+					input_len, DMA_FROM_DEVICE);
+			}
 			return ret1 ? ret1 : ret2;
 		}
 
@@ -410,10 +419,10 @@
 				sizeof(*msgreq), DMA_TO_DEVICE);
 	send_data_req.rsp_ptr = dma_map_single(NULL, msgrsp,
 				sizeof(*msgrsp), DMA_FROM_DEVICE);
-
 	ret1 = dma_mapping_error(NULL, send_data_req.req_ptr);
 	ret2 = dma_mapping_error(NULL, send_data_req.rsp_ptr);
 
+
 	if (!ret1 && !ret2) {
 		send_data_req.req_len = sizeof(struct qsc_send_cmd);
 		send_data_req.rsp_len = sizeof(struct qsc_send_cmd_rsp);
@@ -422,6 +431,12 @@
 					sizeof(send_data_req),
 					&resp, sizeof(resp));
 	}
+
+	dma_unmap_single(NULL, msgreq->data,
+				input_len, DMA_TO_DEVICE);
+	dma_unmap_single(NULL, msgreq->data2,
+				input_len, DMA_FROM_DEVICE);
+
 	if (!ret1) {
 		dma_unmap_single(NULL, send_data_req.req_ptr,
 			sizeof(*msgreq), DMA_TO_DEVICE);
@@ -588,7 +603,8 @@
 show_encrypt_output(struct device *dev, struct device_attribute *attr,
 					char *buf)
 {
-	return snprintf(buf, (enc_len + 1), "%s", (char *) encrypt_text);
+	memcpy(buf, encrypt_text, enc_len);
+	return enc_len;
 }
 
 /* To Encrypt input plain text */
@@ -600,12 +616,12 @@
 	uint8_t *input_pt;
 	uint8_t *output_pt;
 
-	enc_len = count - 1;
+	enc_len = count;
 	if (enc_len == 0) {
 		pr_err("\n Input cannot be NULL!");
 		return -EINVAL;
 	}
-	if ((enc_len % 16 != 0) && (enc_len <= MAX_INPUT_SIZE)) {
+	if ((enc_len % 16 != 0) || (enc_len > MAX_INPUT_SIZE)) {
 		pr_info("\n Input Length must be multiple of 16 & < 4096 bytes");
 		return -EINVAL;
 	}
@@ -636,7 +652,8 @@
 show_decrypt_output(struct device *dev, struct device_attribute *attr,
 		 char *buf)
 {
-	return snprintf(buf, (dec_len + 1), "%s", (char *) decrypt_text);
+	memcpy(buf, decrypt_text, dec_len);
+	return dec_len;
 }
 
 /* To decrypt input cipher text */
@@ -648,13 +665,13 @@
 	uint8_t *input_pt;
 	uint8_t *output_pt;
 
-	dec_len = count - 1;
+	dec_len = count;
 	if (dec_len == 0) {
 		pr_err("\n Input cannot be NULL!");
 		return -EINVAL;
 	}
 
-	if ((dec_len % 16 != 0) && (dec_len <= MAX_INPUT_SIZE)) {
+	if ((dec_len % 16 != 0) || (dec_len > MAX_INPUT_SIZE)) {
 		pr_info("\n Input Length must be multiple of 16 & < 4096 bytes");
 		return -EINVAL;
 	}
diff -Naur -x .git linux-3.14.43.org/drivers/mmc/host/mmci.c linux-3.14.43/drivers/mmc/host/mmci.c
--- linux-3.14.43.org/drivers/mmc/host/mmci.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mmc/host/mmci.c	2016-02-02 11:43:20.040580346 +0800
@@ -296,8 +296,8 @@
 
 		clk |= variant->clkreg_enable;
 		clk |= MCI_CLK_ENABLE;
-		/* This hasn't proven to be worthwhile */
-		/* clk |= MCI_CLK_PWRSAVE; */
+		/* Enable power save mode (needed for UHS card support) */
+		clk |= MCI_CLK_PWRSAVE;
 	}
 
 	/* Set actual clock for debug */
@@ -1406,6 +1406,7 @@
 
 static int mmci_sig_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)
 {
+	struct mmci_host *host = mmc_priv(mmc);
 	int ret = 0;
 	if (!IS_ERR(mmc->supply.vqmmc)) {
 
@@ -1413,11 +1414,17 @@
 
 		switch (ios->signal_voltage) {
 		case MMC_SIGNAL_VOLTAGE_330:
-			ret = regulator_set_voltage(mmc->supply.vqmmc,
+			if (gpio_is_valid(host->variant->qcom_uhs_gpio))
+				ret = mmci_qcom_set_uhs_gpio(mmc, 0);
+			else
+				ret = regulator_set_voltage(mmc->supply.vqmmc,
 						2700000, 3600000);
 			break;
 		case MMC_SIGNAL_VOLTAGE_180:
-			ret = regulator_set_voltage(mmc->supply.vqmmc,
+			if (gpio_is_valid(host->variant->qcom_uhs_gpio))
+				ret = mmci_qcom_set_uhs_gpio(mmc, 1);
+			else
+				ret = regulator_set_voltage(mmc->supply.vqmmc,
 						1700000, 1950000);
 			break;
 		case MMC_SIGNAL_VOLTAGE_120:
diff -Naur -x .git linux-3.14.43.org/drivers/mmc/host/mmci_qcom_tuning.c linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.c
--- linux-3.14.43.org/drivers/mmc/host/mmci_qcom_tuning.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.c	2016-02-02 11:43:20.044580306 +0800
@@ -589,6 +589,66 @@
 
 }
 
+int mmci_qcom_set_uhs_gpio(struct mmc_host *mmc, unsigned int val)
+{
+	struct mmci_host *host = mmc_priv(mmc);
+	unsigned long flags = 0;
+	int rc = 0;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	/* Stop SD CLK output. */
+	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
+			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
+	udelay(30);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/*
+	 * Switch VDD Io from high voltage range (2.7v - 3.6v) to
+	 * low voltage range (1.7v - 1.95v).
+	 */
+	rc = gpio_direction_output(host->variant->qcom_uhs_gpio, val);
+	if (rc) {
+		pr_err("gpio direction failed\n");
+		gpio_free(host->variant->qcom_uhs_gpio);
+		rc = -EAGAIN;
+		goto out;
+	}
+	spin_lock_irqsave(&host->lock, flags);
+	writel_relaxed((readl_relaxed(host->base + MMCICLOCK)
+			| MCI_QCOM_IO_PAD_PWR_SWITCH), host->base
+			+ MMCICLOCK);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/* Wait 5 ms for the voltage regulater in the card to become stable. */
+	usleep_range(5000, 5500);
+
+	spin_lock_irqsave(&host->lock, flags);
+	/* Disable PWRSAVE would make sure that SD CLK is always running */
+	writel_relaxed((readl_relaxed(host->base + MMCICLOCK)
+			& ~MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
+	udelay(30);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/*
+	 * If MCIDATIN_3_0 and MCICMDIN bits of MCI_TEST_INPUT register
+	 * don't become all ones within 1 ms then a Voltage Switch
+	 * sequence has failed and a power cycle to the card is required.
+	 * Otherwise Voltage Switch sequence is completed successfully.
+	 */
+	usleep_range(1000, 1500);
+
+	spin_lock_irqsave(&host->lock, flags);
+	/* Enable PWRSAVE */
+	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
+			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
+	udelay(30);
+	spin_unlock_irqrestore(&host->lock, flags);
+out:
+	return rc;
+}
+
 void set_default_hw_caps(struct mmci_host *host)
 {
 	u32 version;
@@ -624,7 +684,6 @@
 int mmci_qtune_init(struct mmci_host *host, struct device_node *np)
 {
 	uint32_t gpio;
-	int ret;
 
 	if (of_property_read_u32(np, "qcom-uhs-gpio", &gpio))
 		host->variant->qcom_uhs_gpio = -1;
@@ -635,18 +694,6 @@
 
 	host->variant->saved_tuning_phase = INVALID_TUNING_PHASE;
 
-	if (gpio_is_valid(host->variant->qcom_uhs_gpio)) {
-		ret = gpio_direction_output(host->variant->qcom_uhs_gpio, 1);
-		if (ret) {
-			pr_err("gpio direction failed\n");
-			gpio_free(host->variant->qcom_uhs_gpio);
-			return ret;
-		}
-		writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
-				MCI_QCOM_IO_PAD_PWR_SWITCH),
-				host->base + MMCICLOCK);
-	}
-
 	return 0;
 }
 
diff -Naur -x .git linux-3.14.43.org/drivers/mmc/host/mmci_qcom_tuning.h linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.h
--- linux-3.14.43.org/drivers/mmc/host/mmci_qcom_tuning.h	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.h	2016-02-02 11:43:20.044580306 +0800
@@ -54,6 +54,7 @@
 int mmci_qtune_execute_tuning(struct mmc_host *mmc, u32 opcode);
 void set_default_hw_caps(struct mmci_host *host);
 void mmci_qcom_ddr_tuning(struct mmci_host *host);
+int mmci_qcom_set_uhs_gpio(struct mmc_host *mmc, unsigned int val);
 int mmci_qtune_init(struct mmci_host *host, struct device_node *np);
 
 #endif /* __MMCI_QCOM_TUNING_H_ */
diff -Naur -x .git linux-3.14.43.org/drivers/mmc/host/sdhci.c linux-3.14.43/drivers/mmc/host/sdhci.c
--- linux-3.14.43.org/drivers/mmc/host/sdhci.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mmc/host/sdhci.c	2016-02-02 11:43:20.048580266 +0800
@@ -2956,7 +2956,8 @@
 	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK)
 		host->timeout_clk = mmc->f_max / 1000;
 
-	mmc->max_discard_to = (1 << 27) / host->timeout_clk;
+	if (!(host->quirks2 & SDHCI_QUIRK2_USE_MAX_DISCARD_SIZE))
+		mmc->max_discard_to = (1 << 27) / host->timeout_clk;
 
 	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE | MMC_CAP_CMD23;
 
diff -Naur -x .git linux-3.14.43.org/drivers/mmc/host/sdhci-msm.c linux-3.14.43/drivers/mmc/host/sdhci-msm.c
--- linux-3.14.43.org/drivers/mmc/host/sdhci-msm.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mmc/host/sdhci-msm.c	2016-02-02 11:43:20.044580306 +0800
@@ -20,6 +20,7 @@
 #include <linux/delay.h>
 #include <linux/mmc/mmc.h>
 #include <linux/slab.h>
+#include <linux/of_gpio.h>
 
 #include "sdhci-pltfm.h"
 
@@ -519,6 +520,7 @@
 	struct sdhci_msm_host *msm_host;
 	struct resource *core_memres;
 	int ret;
+	int sd_ldo;
 	u16 host_version;
 	struct device_node *np = pdev->dev.of_node;
 
@@ -536,6 +538,24 @@
 	msm_host->mmc = host->mmc;
 	msm_host->pdev = pdev;
 
+	sd_ldo = of_get_named_gpio(np, "sd-ldo-gpios", 0);
+	if (gpio_is_valid(sd_ldo)) {
+		ret = devm_gpio_request(&pdev->dev, sd_ldo, "sd-ldo-gpios");
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to request sd-ldo-gpios %d\n",
+				sd_ldo);
+			return ret;
+		}
+		dev_info(&pdev->dev, "Got SD LDO GPIO #%d\n", sd_ldo);
+
+		/* Toggle SD LDO GPIO on Init */
+		gpio_direction_output(sd_ldo, 1);
+		gpio_set_value(sd_ldo, 0);
+		mdelay(100);
+		gpio_set_value(sd_ldo, 1);
+	}
+
 	msm_host->emulation = of_property_read_bool(np, "qca,emulation");
 
 	ret = mmc_of_parse(host->mmc);
@@ -644,6 +664,7 @@
 	writel_relaxed(HC_MODE_EN, (msm_host->core_mem + CORE_HC_MODE));
 
 	host->quirks |= SDHCI_QUIRK_SINGLE_POWER_WRITE;
+	host->quirks2 |= SDHCI_QUIRK2_USE_MAX_DISCARD_SIZE;
 
 	host_version = readw_relaxed((host->ioaddr + SDHCI_HOST_VERSION));
 	dev_dbg(&pdev->dev, "Host Version: 0x%x Vendor Version 0x%x\n",
diff -Naur -x .git linux-3.14.43.org/drivers/mtd/devices/m25p80.c linux-3.14.43/drivers/mtd/devices/m25p80.c
--- linux-3.14.43.org/drivers/mtd/devices/m25p80.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mtd/devices/m25p80.c	2016-02-02 11:43:20.056580185 +0800
@@ -943,6 +943,7 @@
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
 	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024, M25P80_QUAD_READ) },
+	{ "mx25u12835f", INFO(0xc22538, 0, 64 * 1024, 256, 0) },
 	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512, 0) },
 	{ "mx25u3235f",  INFO(0xc22536, 0, 64 * 1024, 64, 0) },
 	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, 0) },
@@ -979,6 +980,7 @@
 	{ "s25sl064a",  INFO(0x010216,      0,  64 * 1024, 128, 0) },
 	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K) },
 	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
+	{ "s25fl128s",  INFO(0x012018, 0x4d01,  64 * 1024, 256, 0) },
 
 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
 	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
@@ -1043,6 +1045,7 @@
 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
+	{ "w25q128fw", INFO(0xef6018, 0, 64 * 1024, 256, SECT_4K) },
 	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) },
 
 	/* Catalyst / On Semiconductor -- non-JEDEC */
diff -Naur -x .git linux-3.14.43.org/drivers/mtd/nand/nand_ids.c linux-3.14.43/drivers/mtd/nand/nand_ids.c
--- linux-3.14.43.org/drivers/mtd/nand/nand_ids.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mtd/nand/nand_ids.c	2016-02-02 11:43:20.072580023 +0800
@@ -41,7 +41,7 @@
 		{ .id = {0xc2, 0x12} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
 
 	{"W25N01GV 128MiB 3.3V",
-		{ .id = {0xef, 0xaa, 0x21} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
+		{ .id = {0xef, 0xaa} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
 
 	{"GD5F1GQ1RC 128MiB 1.8V",
 		{ .id = {0xc8, 0xA1} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
diff -Naur -x .git linux-3.14.43.org/drivers/mtd/nand/qcom_nand.c linux-3.14.43/drivers/mtd/nand/qcom_nand.c
--- linux-3.14.43.org/drivers/mtd/nand/qcom_nand.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/mtd/nand/qcom_nand.c	2016-02-02 11:43:20.072580023 +0800
@@ -7393,12 +7393,11 @@
 	if (dual_nand_ctlr_present)
 		msm_nand_nc10_xfr_settings(&info->mtd);
 
-	if (msm_nand_scan(&info->mtd, 1))
-		if (msm_onenand_scan(&info->mtd, 1)) {
-			pr_err("%s: No nand device found\n", __func__);
-			err = -ENXIO;
-			goto out_free_dma_buffer;
-		}
+	if (msm_nand_scan(&info->mtd, 1)) {
+		pr_err("%s: No nand device found\n", __func__);
+		err = -ENXIO;
+		goto out_free_dma_buffer;
+	}
 
 	flash_wr_reg(&info->msm_nand, MSM_NAND_DEV_CMD_VLD,
 				DEV_CMD_VLD_SEQ_READ_START_VLD |
diff -Naur -x .git linux-3.14.43.org/drivers/net/ethernet/Kconfig linux-3.14.43/drivers/net/ethernet/Kconfig
--- linux-3.14.43.org/drivers/net/ethernet/Kconfig	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/ethernet/Kconfig	2016-02-02 11:43:20.104579701 +0800
@@ -12,7 +12,9 @@
 if ETHERNET
 
 config MDIO
-	tristate
+	tristate "MDIO IOCTL support"
+	---help---
+	  This section contains the generic MDIO support.
 
 config SUNGEM_PHY
 	tristate
diff -Naur -x .git linux-3.14.43.org/drivers/net/ethernet/qcom/essedma/edma_axi.c linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma_axi.c
--- linux-3.14.43.org/drivers/net/ethernet/qcom/essedma/edma_axi.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma_axi.c	2016-02-02 11:43:20.264578084 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014 - 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014 - 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -47,14 +47,19 @@
 int edma_queue_to_virtual_q __read_mostly;
 bool edma_enable_rstp  __read_mostly;
 int edma_athr_hdr_eth_type __read_mostly;
-int page_mode __read_mostly;
-int overwrite_mode __read_mostly;
 
+static int page_mode;
 module_param(page_mode, int, 0);
-module_param(overwrite_mode, int, 0);
 MODULE_PARM_DESC(page_mode, "enable page mode");
+
+static int overwrite_mode;
+module_param(overwrite_mode, int, 0);
 MODULE_PARM_DESC(overwrite_mode, "overwrite default page_mode setting");
 
+static int num_rxq = 4;
+module_param(num_rxq, int, 0);
+MODULE_PARM_DESC(num_rxq, "change the number of rx queues");
+
 void edma_write_reg(u16 reg_addr, u32 reg_value)
 {
 	writel(reg_value, ((void __iomem *)(edma_hw_addr + reg_addr)));
@@ -330,9 +335,14 @@
 	struct platform_device *mdio_plat = NULL;
 	struct mii_bus *miibus = NULL;
 	struct edma_mdio_data *mdio_data = NULL;
-	int i, j, err = 0, ret = 0;
+	int i, j, k, err = 0, ret = 0;
 	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
 
+	if ((num_rxq != 4) && (num_rxq != 8)) {
+		dev_err(&pdev->dev, "Invalid RX queue, edma probe failed\n");
+		return -EINVAL;
+	}
+
 	/* Use to allocate net devices for multiple TX/RX queues */
 	netdev[0] = alloc_etherdev_mqs(sizeof(struct edma_adapter),
 			EDMA_NETDEV_TX_QUEUE, EDMA_NETDEV_RX_QUEUE);
@@ -365,8 +375,13 @@
 
 	/* Fill ring details */
 	edma_cinfo->num_tx_queues = EDMA_MAX_TRANSMIT_QUEUE;
+	edma_cinfo->num_txq_per_core = (EDMA_MAX_TRANSMIT_QUEUE / 4);
 	edma_cinfo->tx_ring_count = EDMA_TX_RING_SIZE;
-	edma_cinfo->num_rx_queues = EDMA_MAX_RECEIVE_QUEUE;
+
+	/* Update num rx queues based on module parameter */
+	edma_cinfo->num_rx_queues = num_rxq;
+	edma_cinfo->num_rxq_per_core = ((num_rxq == 4) ? 1 : 2);
+
 	edma_cinfo->rx_ring_count = EDMA_RX_RING_SIZE;
 
 	hw = &edma_cinfo->hw;
@@ -421,9 +436,11 @@
 	 * left tx interrupt parsing(i.e 16) and run run the loop
 	 * from 0 to 7 to parse rx interrupt number.
 	 */
-	for (i = 0, j = edma_cinfo->num_tx_queues; i < edma_cinfo->num_rx_queues;
-			i++, j++)
-		edma_cinfo->rx_irq[i] = platform_get_irq(pdev, j);
+	for (i = 0, j = edma_cinfo->num_tx_queues, k = 0; i < edma_cinfo->num_rx_queues; i++) {
+		edma_cinfo->rx_irq[k] = platform_get_irq(pdev, j);
+		k += ((num_rxq == 4) ?  2 : 1);
+		j += ((num_rxq == 4) ?  2 : 1);
+	}
 
 	edma_cinfo->rx_head_buffer_len = edma_cinfo->hw.rx_head_buff_size;
 	edma_cinfo->rx_page_buffer_len = PAGE_SIZE;
@@ -623,7 +640,7 @@
 				IRQF_DISABLED, &edma_tx_irq[j][0], &edma_cinfo->edma_percpu_info[i]);
 		}
 
-		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < rx_start + 2; j++) {
+		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < (rx_start + ((edma_cinfo->num_rx_queues == 4) ? 1 : 2)); j++) {
 			sprintf(&edma_rx_irq[j][0], "edma_eth_rx%d", j);
 			err = request_irq(edma_cinfo->rx_irq[j], edma_interrupt,
 				IRQF_DISABLED, &edma_rx_irq[j][0], &edma_cinfo->edma_percpu_info[i]);
diff -Naur -x .git linux-3.14.43.org/drivers/net/ethernet/qcom/essedma/edma.c linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.c
--- linux-3.14.43.org/drivers/net/ethernet/qcom/essedma/edma.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.c	2016-02-02 11:43:20.264578084 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014 - 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014 - 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -272,7 +272,7 @@
 {
 	struct edma_rfd_desc_ring *rfd_ring;
 	struct edma_tx_desc_ring *etdr;
-	int i = 0;
+	int i = 0, j = 0;
 	volatile u32 data = 0;
 	u16 hw_cons_idx = 0;
 
@@ -303,13 +303,12 @@
 			(u32)(edma_cinfo->tx_ring_count & EDMA_TPD_RING_SIZE_MASK));
 	}
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
-		rfd_ring = edma_cinfo->rfd_ring[i];
-
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
+		rfd_ring = edma_cinfo->rfd_ring[j];
 		/* Update Receive Free descriptor ring base address */
-		edma_write_reg(EDMA_REG_RFD_BASE_ADDR_Q(i),
+		edma_write_reg(EDMA_REG_RFD_BASE_ADDR_Q(j),
 			(u32)(rfd_ring->dma & 0xffffffff));
-
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
 	}
 
 	if (unlikely(edma_cinfo->page_mode))
@@ -394,6 +393,7 @@
 	u16 count = erdr->count, rfd_avail;
 	u8 queue_to_rxid[8] = {0, 0, 1, 1, 2, 2, 3, 3};
 	sw_next_to_clean = erdr->sw_next_to_clean;
+
         edma_read_reg(EDMA_REG_RFD_IDX_Q(queue_id), &data);
         hw_next_to_clean = (data >> EDMA_RFD_CONS_IDX_SHIFT) &
                         EDMA_RFD_CONS_IDX_MASK;
@@ -1525,14 +1525,15 @@
 int edma_alloc_rx_rings(struct edma_common_info *edma_cinfo)
 {
 	struct platform_device *pdev = edma_cinfo->pdev;
-	int i, err = 0;
+	int i, j, err = 0;
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
-		err = edma_alloc_rx_ring(edma_cinfo, edma_cinfo->rfd_ring[i]);
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
+		err = edma_alloc_rx_ring(edma_cinfo, edma_cinfo->rfd_ring[j]);
 		if (err) {
 			dev_err(&pdev->dev, "Rx Queue alloc%u failed\n", i);
 			return err;
 		}
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
 	}
 
 	return 0;
@@ -1544,10 +1545,12 @@
  */
 void edma_free_rx_rings(struct edma_common_info *edma_cinfo)
 {
-	int i;
+	int i, j;
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
-		edma_free_rx_ring(edma_cinfo, edma_cinfo->rfd_ring[i]);
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
+		edma_free_rx_ring(edma_cinfo, edma_cinfo->rfd_ring[j]);
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
+	}
 }
 
 /*
@@ -1556,7 +1559,7 @@
  */
 void edma_free_queues(struct edma_common_info *edma_cinfo)
 {
-	int i;
+	int i , j;
 
 	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
 		if (edma_cinfo->tpd_ring[i])
@@ -1564,10 +1567,11 @@
 		edma_cinfo->tpd_ring[i] = NULL;
 	}
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
-		if (edma_cinfo->rfd_ring[i])
-			kfree(edma_cinfo->rfd_ring[i]);
-		edma_cinfo->rfd_ring[i] = NULL;
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
+		if (edma_cinfo->rfd_ring[j])
+			kfree(edma_cinfo->rfd_ring[j]);
+		edma_cinfo->rfd_ring[j] = NULL;
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
 	}
 
 	edma_cinfo->num_rx_queues = 0;
@@ -1585,10 +1589,10 @@
         struct edma_rfd_desc_ring *erdr;
 	struct edma_sw_desc *sw_desc;
 	struct platform_device *pdev = edma_cinfo->pdev;
-	int i, j;
+	int i, j, k;
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
-		erdr = edma_cinfo->rfd_ring[i];
+	for (i = 0, k = 0; i < edma_cinfo->num_rx_queues; i++) {
+		erdr = edma_cinfo->rfd_ring[k];
 		for (j = 0; j < EDMA_RX_RING_SIZE; j++) {
 			sw_desc = &erdr->sw_desc[j];
 			if (likely(sw_desc->flags & EDMA_SW_DESC_FLAG_SKB_HEAD)) {
@@ -1601,6 +1605,8 @@
 				edma_clean_rfd(erdr, j);
 			}
 		}
+		k += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
+
 	}
 }
 
@@ -1633,16 +1639,17 @@
  */
 int edma_alloc_queues_rx(struct edma_common_info *edma_cinfo)
 {
-	int i;
+	int i, j;
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
 		struct edma_rfd_desc_ring *rfd_ring;
 		rfd_ring = kzalloc(sizeof(struct edma_rfd_desc_ring),
 				GFP_KERNEL);
 		if (!rfd_ring)
 			goto err;
 		rfd_ring->count = edma_cinfo->rx_ring_count;
-		edma_cinfo->rfd_ring[i] = rfd_ring;
+		edma_cinfo->rfd_ring[j] = rfd_ring;
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
 	}
 	return 0;
 err:
@@ -1659,7 +1666,7 @@
 	struct edma_hw *hw = &edma_cinfo->hw;
 	u32 intr_modrt_data;
 	u32 intr_ctrl_data = 0;
-	int i, ret_count;
+	int i, j, ret_count;
 
 	edma_read_reg(EDMA_REG_INTR_CTRL, &intr_ctrl_data);
 	intr_ctrl_data &= ~(1 << EDMA_INTR_SW_IDX_W_TYP_SHIFT);
@@ -1681,12 +1688,13 @@
 	edma_configure_rx(edma_cinfo);
 
 	/* Allocate the RX buffer */
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
-		struct edma_rfd_desc_ring *ring = edma_cinfo->rfd_ring[i];
-		ret_count = edma_alloc_rx_buf(edma_cinfo, ring, ring->count, i);
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
+		struct edma_rfd_desc_ring *ring = edma_cinfo->rfd_ring[j];
+		ret_count = edma_alloc_rx_buf(edma_cinfo, ring, ring->count, j);
 		if (ret_count) {
 			dev_dbg(&edma_cinfo->pdev->dev, "not all rx buffers allocated\n");
 		}
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
 	}
 
 	/* Configure descriptor Ring */
@@ -1701,11 +1709,13 @@
 void edma_irq_enable(struct edma_common_info *edma_cinfo)
 {
 	struct edma_hw *hw = &edma_cinfo->hw;
-	int i;
+	int i, j;
 
 	edma_write_reg(EDMA_REG_RX_ISR, 0xFF);
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
-		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(i), hw->rx_intr_mask);
+	for (i = 0, j = 0; i < edma_cinfo->num_rx_queues; i++) {
+		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(j), hw->rx_intr_mask);
+		j += ((edma_cinfo->num_rx_queues == 4) ? 2 : 1);
+	}
 	edma_write_reg(EDMA_REG_TX_ISR, 0xFFFF);
 	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
 		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(i), hw->tx_intr_mask);
@@ -1719,9 +1729,10 @@
 {
 	int i;
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
+	for (i = 0; i < EDMA_MAX_RECEIVE_QUEUE; i++)
 		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(i), 0x0);
-	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+
+	for (i = 0; i < EDMA_MAX_TRANSMIT_QUEUE; i++)
 		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(i), 0x0);
 	edma_write_reg(EDMA_REG_MISC_IMR, 0);
 	edma_write_reg(EDMA_REG_WOL_IMR, 0);
@@ -1735,13 +1746,14 @@
 {
 	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 	int i, j;
+	int k = ((edma_cinfo->num_rx_queues == 4) ? 1 : 2);
 
 	for (i = 0; i < EDMA_NR_CPU; i++) {
 		for (j = edma_cinfo->edma_percpu_info[i].tx_start; j < (edma_cinfo->edma_percpu_info[i].tx_start + 4); j++)
-			free_irq(edma_cinfo->tx_irq[j], adapter->netdev);
+			free_irq(edma_cinfo->tx_irq[j], &edma_cinfo->edma_percpu_info[i]);
 
-		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < (edma_cinfo->edma_percpu_info[i].rx_start + 2); j++)
-			free_irq(edma_cinfo->rx_irq[j], adapter->netdev);
+		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < (edma_cinfo->edma_percpu_info[i].rx_start + k); j++)
+			free_irq(edma_cinfo->rx_irq[j], &edma_cinfo->edma_percpu_info[i]);
 	}
 }
 
@@ -1796,9 +1808,9 @@
 	struct edma_hw *hw = &edma_cinfo->hw;
 	int i;
 
-	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
+	for (i = 0; i < EDMA_MAX_RECEIVE_QUEUE; i++)
 		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(i), 0);
-	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+	for (i = 0; i < EDMA_MAX_TRANSMIT_QUEUE; i++)
 		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(i), 0);
 	edma_write_reg(EDMA_REG_MISC_IMR, 0);
 	edma_write_reg(EDMA_REG_WOL_IMR, 0);
@@ -2033,9 +2045,9 @@
 		napi_complete(napi);
 
 		/* re-enable the interrupts */
-		for (i = 0; i < 2; i++)
+		for (i = 0; i < edma_cinfo->num_rxq_per_core; i++)
 			edma_write_reg(EDMA_REG_RX_INT_MASK_Q(edma_percpu_info->rx_start + i), 0x1);
-		for (i = 0; i < 4; i++)
+		for (i = 0; i < edma_cinfo->num_txq_per_core; i++)
 			edma_write_reg(EDMA_REG_TX_INT_MASK_Q(edma_percpu_info->tx_start + i), 0x1);
 	}
 
@@ -2049,13 +2061,14 @@
 irqreturn_t edma_interrupt(int irq, void *dev)
 {
 	struct edma_per_cpu_queues_info *edma_percpu_info = (struct edma_per_cpu_queues_info *) dev;
+	struct edma_common_info *edma_cinfo = edma_percpu_info->edma_cinfo;
 	int i;
 
 	/* Unmask the TX/RX interrupt register */
-	for (i = 0; i < 2; i++)
+	for (i = 0; i < edma_cinfo->num_rxq_per_core; i++)
 		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(edma_percpu_info->rx_start + i), 0x0);
 
-	for (i = 0; i < 4; i++)
+	for (i = 0; i < edma_cinfo->num_txq_per_core; i++)
 		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(edma_percpu_info->tx_start + i), 0x0);
 
 	napi_schedule(&edma_percpu_info->napi);
diff -Naur -x .git linux-3.14.43.org/drivers/net/ethernet/qcom/essedma/edma.h linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.h
--- linux-3.14.43.org/drivers/net/ethernet/qcom/essedma/edma.h	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.h	2016-02-02 11:43:20.264578084 +0800
@@ -309,6 +309,8 @@
 	int edma_port_id_wan; /* wan port id */
 	int from_cpu; /* from CPU TPD field */
 	int dp_bitmap; /* port bitmap */
+	int num_rxq_per_core; /* Rx queues per core */
+	int num_txq_per_core; /* Tx queues per core */
 	u16 tx_ring_count; /* Tx ring count */
 	u16 rx_ring_count; /* Rx ring*/
 	u16 rx_head_buffer_len; /* rx buffer length */
diff -Naur -x .git linux-3.14.43.org/drivers/net/phy/aq_phy.c linux-3.14.43/drivers/net/phy/aq_phy.c
--- linux-3.14.43.org/drivers/net/phy/aq_phy.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/drivers/net/phy/aq_phy.c	2016-02-02 11:43:20.328577438 +0800
@@ -0,0 +1,827 @@
+/*
+ * aq_phy.c: AQ105 Phy driver
+
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/if_ether.h>
+#include <linux/phy.h>
+#include <linux/mdio.h>
+#include <linux/debugfs.h>
+#include <linux/aq_phy.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/reset.h>
+
+static struct of_device_id dt_aq_phy[] = {
+	{ .compatible =  "qcom,aq-phy" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dt_aq_phy);
+
+/* Driver private data structure */
+struct aq_priv {
+	struct phy_device *phydev;	/* Pointer to PHY device */
+	struct device *dev;		/* Pointer to struct device */
+	struct dentry *aq_top_dentry;	/* Top dentry for AQ105 PHY Driver */
+	struct dentry *aq_write_dentry;	/* write-reg file dentry for */
+					/* AQ105 PHY Driver */
+	struct dentry *aq_read_dentry;	/* read-reg file dentry for */
+					/* AQ105 PHY Driver */
+	struct dentry *aq_stats_dentry;	/* Statistics file dentry for */
+					/* AQ105 PHY Driver */
+	struct aq_stats stats;		/* AQ PHY stats block */
+	uint32_t phy_addr;		/* AQ105 PHY Address */
+	uint32_t reg_addr;		/* Previous register address */
+	uint16_t reg_val;		/* Hold the value of the */
+					/* previous register read */
+};
+
+/* Check for a valid range of PHY register */
+static bool aq_phy_check_valid_reg(unsigned int reg_addr)
+{
+	bool ret = false;
+	uint8_t mmd;
+
+	if (reg_addr < 0x10000)
+		return false;
+
+	if ((reg_addr & 0xffff) > 0xfc02)
+		return false;
+
+	mmd = (reg_addr & 0x1f0000) >> 16;
+
+	switch (mmd) {
+	case MDIO_MMD_PMAPMD:
+	case MDIO_MMD_PCS:
+	case MDIO_MMD_PHYXS:
+	case MDIO_MMD_AN:
+	case MDIO_MMD_C22EXT:
+	case MDIO_MMD_VEND1:
+		ret = true;
+		break;
+	default:
+		ret = false;
+	}
+
+	return ret;
+}
+
+/* Read a statistics register address */
+static void aq_phy_read_stats_regs(struct phy_device *phydev,
+				struct aq_stats_reg *st_reg)
+{
+	uint16_t lsw, msw;
+	msw =  phy_read(phydev, MII_ADDR_C45 | st_reg->regaddr_msw);
+	lsw =  phy_read(phydev, MII_ADDR_C45 | st_reg->regaddr_lsw);
+	st_reg->regval = ((msw << 16) | lsw);
+}
+
+/* A debug-fs file read op to print the AQ PHY stats */
+static ssize_t aq_phy_read_stats(struct file *fp, char __user *ubuf,
+				 size_t sz, loff_t *ppos)
+{
+	struct aq_priv *priv = (struct aq_priv *)fp->private_data;
+	struct aq_stats *st;
+	int bytes_read;
+	int size_wr;
+	int size_al = AQ_PHY_STATS_MAX_STR_LENGTH * AQ_PHY_STATS_MAX_OUTPUT_LINE;
+	uint16_t reg_value;
+	uint32_t reg_addr;
+	char *lbuf;
+
+	if (!priv)
+		return -EFAULT;
+
+	/* Check if PHY is out of reset and FW has loaded successfully */
+	reg_addr = MII_ADDR_C45 | MDIO_MMD_PMAPMD << 16 |
+			AQ_PHY_PMA_STANDARD_CTRL_1_REG;
+
+	reg_value = phy_read(priv->phydev, reg_addr);
+	if (reg_value & AQ_PHY_PMA_STANDARD_CTRL_1_MASK) {
+		pr_err("aq105 PHY is not ready\n");
+		return -EIO;
+	}
+
+	lbuf = kzalloc(size_al, GFP_KERNEL);
+	if (unlikely(lbuf == NULL)) {
+		dev_dbg(priv->dev, "%s: Could not allocate memory for local statistics buffer",
+			__func__);
+		return -EIO;
+	}
+
+	st = &priv->stats;
+
+	size_wr = scnprintf(lbuf, size_al, "Link Status: %u\n",
+						priv->phydev->link);
+
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+			"Link Speed: %u\n", priv->phydev->speed);
+
+	aq_phy_read_stats_regs(priv->phydev, &st->line_tx_good);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+		"Line Side TX Good: %u\n", st->line_tx_good.regval);
+
+	aq_phy_read_stats_regs(priv->phydev, &st->line_tx_bad);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+		"Line Side TX Bad: %u\n", st->line_tx_bad.regval);
+
+	aq_phy_read_stats_regs(priv->phydev, &st->line_rx_good);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+		"Line Side RX Good: %u\n", st->line_rx_good.regval);
+
+	aq_phy_read_stats_regs(priv->phydev, &st->line_rx_bad);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+		"Line Side RX Bad: %u\n", st->line_rx_bad.regval);
+
+	if ((priv->phydev->speed == SPEED_1000) ||
+		(priv->phydev->speed == SPEED_100)) {
+		aq_phy_read_stats_regs(priv->phydev, &st->sys_tx_good);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+			"System Side TX Good: %u\n", st->sys_tx_good.regval);
+
+		aq_phy_read_stats_regs(priv->phydev, &st->sys_tx_bad);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+			"System Side TX Bad: %u\n", st->sys_tx_bad.regval);
+
+		aq_phy_read_stats_regs(priv->phydev, &st->sys_rx_good);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+			"System Side RX Good: %u\n", st->sys_rx_good.regval);
+
+		aq_phy_read_stats_regs(priv->phydev, &st->sys_rx_bad);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+			"System Side RX Bad: %u\n", st->sys_rx_bad.regval);
+	}
+
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos,
+						lbuf, strlen(lbuf));
+	kfree(lbuf);
+	return bytes_read;
+}
+
+/* read from debug-fs file */
+static ssize_t aq_phy_read_reg_get(struct file *fp, char __user *ubuf,
+				   size_t sz, loff_t *ppos)
+{
+	struct aq_priv *priv = (struct aq_priv *)fp->private_data;
+	char lbuf[40];
+	int bytes_read;
+
+	if (!priv)
+		return -EFAULT;
+
+	snprintf(lbuf, sizeof(lbuf), "0x%x: 0x%x\n",
+					priv->reg_addr,
+					priv->reg_val);
+
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos,
+						lbuf, strlen(lbuf));
+
+	dev_dbg(priv->dev, "%s: lbuf %s, bytes_read %d\n",
+				__func__, lbuf, bytes_read);
+
+	return bytes_read;
+}
+
+/* Write into the file and read back the PHY register */
+static ssize_t aq_phy_read_reg_set(struct file *fp, const char __user *ubuf,
+				   size_t sz, loff_t *ppos)
+{
+	struct aq_priv *priv = (struct aq_priv *)fp->private_data;
+	char lbuf[32];
+	size_t lbuf_size;
+	char *curr_ptr = lbuf;
+	unsigned long reg_addr = 0;
+	uint16_t reg_value;
+	uint32_t byte_cnt = 0;
+	bool is_reabable = false;
+
+	if (!priv)
+		return -EFAULT;
+
+	lbuf_size = min(sz, (sizeof(lbuf) - 1));
+
+	dev_dbg(priv->dev, "PHY ADDR:DEVID 0x%x:0x%x, user buf size  %d\n",
+		priv->phy_addr, priv->phydev->c45_ids.device_ids[1], lbuf_size);
+
+	if (copy_from_user(lbuf, ubuf, lbuf_size)) {
+		dev_dbg(priv->dev, "%s: failed in copy_from_user\n", __func__);
+		return -EFAULT;
+	}
+
+	lbuf[lbuf_size] = 0;
+
+	while (*curr_ptr == ' ') {
+		curr_ptr++;
+		byte_cnt++;
+	}
+
+	if (byte_cnt >= (lbuf_size - 1))
+		return -EINVAL;
+
+	if (kstrtoul(curr_ptr, 16, &reg_addr)) {
+		dev_dbg(priv->dev, "%s: Invalid register\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Read into PHY reg and store value in previous reg read */
+	is_reabable = aq_phy_check_valid_reg(reg_addr);
+	if (is_reabable) {
+		priv->reg_addr = reg_addr;
+		reg_addr = MII_ADDR_C45 | reg_addr;
+		reg_value = phy_read(priv->phydev, reg_addr);
+		priv->reg_val = reg_value;
+		dev_dbg(priv->dev, "%s: reg = 0x%lx, value = 0x%x\n",
+						__func__, reg_addr, reg_value);
+	} else {
+		return -EINVAL;
+	}
+
+	return lbuf_size;
+}
+
+/* Debug-fs function to write a PHY register */
+static ssize_t aq_phy_write_reg_set(struct file *fp, const char __user *ubuf,
+				    size_t sz, loff_t *ppos)
+{
+	struct aq_priv *priv = (struct aq_priv *)fp->private_data;
+	char lbuf[32];
+	size_t lbuf_size;
+	char *curr_ptr = lbuf;
+	unsigned long reg_addr = 0;
+	unsigned long reg_value = 0;
+	uint32_t check_16bit_boundary = 0xffff0000;
+	uint32_t byte_cnt = 0;
+	bool is_writeable = false;
+
+	if (!priv)
+		return -EFAULT;
+
+	lbuf_size = min(sz, (sizeof(lbuf) - 1));
+
+	dev_dbg(priv->dev, "PHY ADDR 0x%x, user buf size  %d\n",
+					priv->phy_addr, lbuf_size);
+
+	if (copy_from_user(lbuf, ubuf, lbuf_size)) {
+		dev_dbg(priv->dev, "%s: failed in copy_from_user\n", __func__);
+		return -EFAULT;
+	}
+
+	lbuf[lbuf_size] = 0;
+
+	while (*curr_ptr == ' ') {
+		curr_ptr++;
+		byte_cnt++;
+	}
+
+	if (byte_cnt >= (lbuf_size - 1))
+		return -EINVAL;
+
+	kstrtoul(curr_ptr, 16, &reg_addr);
+
+	while (*curr_ptr == ' ')
+		curr_ptr++;
+
+	if (byte_cnt >= (lbuf_size - 1))
+		return -EINVAL;
+
+	if (kstrtoul(curr_ptr, 16, &reg_value)) {
+		dev_dbg(priv->dev, "%s: Invalid reg value\n", __func__);
+		return -EINVAL;
+	}
+
+	 /* Check for 16BIT register value boundary,
+	  * if it cross 16 Bit return error
+	  */
+	if (check_16bit_boundary & reg_value) {
+		dev_dbg(priv->dev, "%s: Invalid reg value\n", __func__);
+		return -EINVAL;
+	}
+
+	 /* Check for a valid Range of register and write into Phy dev */
+	is_writeable = aq_phy_check_valid_reg(reg_addr);
+	if (is_writeable) {
+		reg_addr = MII_ADDR_C45 | reg_addr;
+		dev_dbg(priv->dev, "%s: Reg val 0x%lx, Data 0x%lx\n",
+						__func__, reg_addr, reg_value);
+		phy_write(priv->phydev, reg_addr, reg_value);
+	} else {
+		return -EINVAL;
+	}
+
+	return lbuf_size;
+}
+
+static const struct file_operations aq_phy_read_reg_ops = {
+	.open = simple_open,
+	.read = aq_phy_read_reg_get,
+	.write = aq_phy_read_reg_set,
+	.llseek = no_llseek,
+};
+
+static const struct file_operations aq_phy_write_reg_ops = {
+	.open = simple_open,
+	.write = aq_phy_write_reg_set,
+	.llseek = no_llseek,
+};
+
+static const struct file_operations aq_phy_stats_ops = {
+	.open = simple_open,
+	.read = aq_phy_read_stats,
+	.llseek = no_llseek,
+};
+
+/* Create debug-fs aq-phy dir and files */
+static int aq_phy_init_debugfs_entries(struct aq_priv *priv)
+{
+	priv->aq_top_dentry = debugfs_create_dir("aq-phy", NULL);
+	if (priv->aq_top_dentry == NULL) {
+		dev_dbg(priv->dev,
+			"Failed to create aq-phy directory in debugfs\n");
+		return -1;
+	}
+
+	priv->aq_write_dentry = debugfs_create_file("write-reg", 0400,
+						priv->aq_top_dentry,
+						priv, &aq_phy_write_reg_ops);
+
+	if (unlikely(priv->aq_write_dentry == NULL)) {
+		dev_dbg(priv->dev,
+			"Failed to create aq-phy/write-reg file in debugfs\n");
+		debugfs_remove_recursive(priv->aq_top_dentry);
+		return -1;
+	}
+
+	priv->aq_read_dentry = debugfs_create_file("read-reg", 0400,
+						priv->aq_top_dentry,
+						priv, &aq_phy_read_reg_ops);
+
+	if (unlikely(priv->aq_read_dentry == NULL)) {
+		dev_dbg(priv->dev,
+			"Failed to create aq-phy/read-reg file in debugfs\n");
+		debugfs_remove_recursive(priv->aq_top_dentry);
+		return -1;
+	}
+
+	priv->aq_stats_dentry = debugfs_create_file("stats", 0400,
+						priv->aq_top_dentry,
+						priv, &aq_phy_stats_ops);
+
+	if (unlikely(priv->aq_stats_dentry == NULL)) {
+		dev_dbg(priv->dev,
+			"Failed to create aq-phy/stats file in debugfs\n");
+		debugfs_remove_recursive(priv->aq_top_dentry);
+		return -1;
+	}
+
+	priv->reg_val = 0;
+	priv->reg_addr = 0;
+	return 0;
+}
+
+/* Initialize all AQ PHY stats register address */
+static void aq_phy_init_stats(struct aq_stats *st)
+{
+	st->line_tx_good.regaddr_lsw = AQ_LINE_SIDE_TX_GOOD_REG_LSW;
+	st->line_tx_good.regaddr_msw = AQ_LINE_SIDE_TX_GOOD_REG_MSW;
+	st->line_tx_bad.regaddr_lsw = AQ_LINE_SIDE_TX_BAD_REG_LSW;
+	st->line_tx_bad.regaddr_msw = AQ_LINE_SIDE_TX_BAD_REG_MSW;
+
+	st->line_rx_good.regaddr_lsw = AQ_LINE_SIDE_RX_GOOD_REG_LSW;
+	st->line_rx_good.regaddr_msw = AQ_LINE_SIDE_RX_GOOD_REG_MSW;
+	st->line_rx_bad.regaddr_lsw = AQ_LINE_SIDE_RX_BAD_REG_LSW;
+	st->line_rx_bad.regaddr_msw = AQ_LINE_SIDE_RX_BAD_REG_MSW;
+
+	st->sys_tx_good.regaddr_lsw = AQ_SYS_SIDE_TX_GOOD_REG_LSW;
+	st->sys_tx_good.regaddr_msw = AQ_SYS_SIDE_TX_GOOD_REG_MSW;
+	st->sys_tx_bad.regaddr_lsw = AQ_SYS_SIDE_TX_BAD_REG_LSW;
+	st->sys_tx_bad.regaddr_msw = AQ_SYS_SIDE_TX_BAD_REG_MSW;
+
+	st->sys_rx_good.regaddr_lsw = AQ_SYS_SIDE_RX_GOOD_REG_LSW;
+	st->sys_rx_good.regaddr_msw = AQ_SYS_SIDE_RX_GOOD_REG_MSW;
+	st->sys_rx_bad.regaddr_lsw = AQ_SYS_SIDE_RX_BAD_REG_LSW;
+	st->sys_rx_bad.regaddr_msw = AQ_SYS_SIDE_RX_BAD_REG_MSW;
+}
+
+/* Read the current status of the PHY i.e. Link, Speed, Duplex */
+static int
+aq_phy_read_status(struct phy_device *phydev)
+{
+	uint16_t reg_value = 0;
+	uint32_t reg_addr;
+
+	/* Read the PMD Standard Signal Detect register to check
+	 * valid Ethernet signals are present on the wire.
+	 */
+	reg_addr = MII_ADDR_C45 | MDIO_MMD_PMAPMD << 16 |
+			AQ_PHY_PMD_SIGNAL_DETECT_REG;
+
+	reg_value = phy_read(phydev, reg_addr);
+	if (!(reg_value & AQ_PHY_PMD_SIGNAL_DETECT_MASK)) {
+		phydev->link = 0;
+		return 0;
+	}
+
+	/* Read the line side current link status register. */
+	reg_addr = MII_ADDR_C45 | MDIO_MMD_PMAPMD << 16 |
+		AQ_PHY_PMA_RX_LINK_CURRENT_STATUS_REG;
+
+	reg_value = phy_read(phydev, reg_addr);
+	if (!(reg_value & AQ_PHY_PMA_RX_LINK_CURRENT_STATUS_MASK)) {
+		phydev->link = 0;
+		return 0;
+	}
+
+	/* Find the connect rate. The rate the PHY connected
+	 * or attempting to connect.
+	 */
+	reg_addr = MII_ADDR_C45 | MDIO_MMD_AN << 16 | AQ_PHY_LINK_REG;
+	reg_value = phy_read(phydev, reg_addr);
+
+	switch ((reg_value >> 1) & 0x7) {
+	case AQ_PHY_LINK_SPEED_2500:
+		phydev->speed = SPEED_2500;
+		phydev->advertising = ADVERTISED_2500baseX_Full;
+		break;
+	case AQ_PHY_LINK_SPEED_1000:
+		phydev->speed = SPEED_1000;
+		phydev->advertising = ADVERTISED_1000baseT_Full;
+		break;
+	case AQ_PHY_LINK_SPEED_100:
+		phydev->speed = SPEED_100;
+		if (reg_value & AQ_PHY_LINK_DUPLEX_MASK)
+			phydev->advertising = ADVERTISED_100baseT_Full;
+		else
+			phydev->advertising = ADVERTISED_100baseT_Half;
+		break;
+	case AQ_PHY_LINK_SPEED_5000:
+	case AQ_PHY_LINK_SPEED_10000:
+	default:
+		dev_dbg(&phydev->dev, "%s: unknown speed\n", __func__);
+		phydev->speed = SPEED_UNKNOWN;
+		phydev->advertising = SPEED_UNKNOWN;
+	}
+
+	phydev->link = 1;
+	phydev->duplex = reg_value & AQ_PHY_LINK_DUPLEX_MASK;
+	phydev->adjust_link(phydev->attached_dev);
+	return 0;
+}
+
+/* Function for configuration of auto-negotiation */
+static int
+aq_phy_config_aneg(struct phy_device *phydev)
+{
+	return 0;
+}
+
+/* Initialize the Speed, Link and Duplex */
+static int
+aq_phy_config_init(struct phy_device *phydev)
+{
+	phydev->speed = SPEED_UNKNOWN;
+	phydev->link = 0;
+	phydev->duplex = 1;
+	phydev->autoneg = 1;
+	phydev->supported =	SUPPORTED_100baseT_Half |
+				SUPPORTED_100baseT_Full |
+				SUPPORTED_1000baseT_Full |
+				SUPPORTED_2500baseX_Full;
+
+	phydev->advertising =	ADVERTISED_100baseT_Half |
+				ADVERTISED_100baseT_Full |
+				ADVERTISED_1000baseT_Full |
+				ADVERTISED_2500baseX_Full;
+	return 0;
+}
+
+/* PHY driver probe function */
+static int
+aq_phy_probe(struct phy_device *phydev)
+{
+	return 0;
+}
+
+/* PHY driver remove function */
+static void
+aq_phy_remove(struct phy_device *pdev)
+{
+	return;
+}
+
+/* Match the PHY device ID */
+static int aq_phy_match_phy_device(struct phy_device *phydev)
+{
+	int found = 0;
+
+	if (((phydev->c45_ids.device_ids[0] & AQ_DEVICE_ID_MASK)
+			== AQ_DEVICE_ID) ||
+	    ((phydev->c45_ids.device_ids[1] & AQ_DEVICE_ID_MASK)
+			== AQ_DEVICE_ID) ||
+	    ((phydev->c45_ids.device_ids[2] & AQ_DEVICE_ID_MASK)
+			== AQ_DEVICE_ID) ||
+	    ((phydev->c45_ids.device_ids[3] & AQ_DEVICE_ID_MASK)
+			== AQ_DEVICE_ID)) {
+
+		found = 1;
+	}
+
+	return found;
+}
+
+static struct phy_driver aq_phy_driver = {
+	.phy_id		= AQ_DEVICE_ID,
+	.name		= "AQ105",
+	.phy_id_mask	= AQ_DEVICE_ID_MASK,
+	.features	= PHY_BASIC_FEATURES,
+	.probe		= aq_phy_probe,
+	.remove		= aq_phy_remove,
+	.config_init	= &aq_phy_config_init,
+	.config_aneg	= &aq_phy_config_aneg,
+	.read_status	= &aq_phy_read_status,
+	.match_phy_device = aq_phy_match_phy_device,
+	.driver		= { .owner = THIS_MODULE },
+};
+
+/* Platform driver probe function */
+static int aq_driver_probe(struct platform_device *pdev)
+{
+	struct aq_priv *priv;
+	struct mii_bus *miibus;
+	struct phy_device *phydev;
+	struct device *dev;
+	uint8_t busid[MII_BUS_ID_SIZE];
+	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
+	int ret;
+	struct device_node *np = NULL;
+	const __be32 *prop = NULL;
+	struct device_node *mdio_node = NULL;
+	struct platform_device *mdio_plat = NULL;
+	uint32_t phy_addr = 0;
+
+	dev_dbg(&pdev->dev, "aq_driver_probe\n");
+
+	np = of_node_get(pdev->dev.of_node);
+	of_property_read_u32(np, "qcom,phy-addr", &phy_addr);
+	priv = vzalloc(sizeof(struct aq_priv));
+	if (priv == NULL) {
+		dev_dbg(&pdev->dev, "%s: Could not allocate private memory for driver\n",
+			 __func__);
+		return -EIO;
+	}
+
+	/* Register the AQ_PHY PHY Driver */
+	ret = phy_driver_register(&aq_phy_driver);
+	if (ret) {
+		dev_dbg(&pdev->dev, "PHY driver register fail\n", __func__);
+		vfree(priv);
+		return -EIO;
+	}
+
+	/* Get MII BUS pointer */
+	prop = of_get_property(np, "mdiobus", NULL);
+	if (!prop) {
+		dev_dbg(&pdev->dev,
+		"cannot get 'mdiobus' property\n",
+		__func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	mdio_node = of_find_node_by_phandle(be32_to_cpup(prop));
+	if (!mdio_node) {
+		dev_dbg(&pdev->dev,
+		"cannot find mdio node by phandle\n",
+		__func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	mdio_plat = of_find_device_by_node(mdio_node);
+	if (!mdio_plat) {
+		dev_dbg(&pdev->dev,
+		"cannot find platform device from mdio node\n",
+		__func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	miibus = dev_get_drvdata(&mdio_plat->dev);
+	if (!miibus) {
+		dev_dbg(&pdev->dev,
+		"cannot get mii bus reference from device data\n",
+		__func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	of_node_put(np);
+
+	dev_dbg(&pdev->dev,
+	"mdio bus '%s' OK.\n",
+	miibus->id);
+
+	/* Find the PHY Device and Attach with PHY Driver */
+	phydev = get_phy_device(miibus, phy_addr, true);
+	if (IS_ERR(phydev) || phydev == NULL) {
+		dev_dbg(&pdev->dev,
+		" No phy dev at address 0x%x.\n",
+		phy_addr);
+
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	ret = phy_device_register(phydev);
+	if (ret) {
+		phy_device_free(phydev);
+		phy_driver_unregister(&aq_phy_driver);
+		dev_dbg(&pdev->dev,
+		"PHY device register fail.\n");
+		vfree(priv);
+		return -EIO;
+	}
+
+	/* create a phyid using MDIO bus id and MDIO bus address of phy */
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3,
+				PHY_ID_FMT,
+				miibus->id,
+				phy_addr);
+
+	priv->phydev = phydev;
+	priv->phy_addr = phy_addr;
+
+	/* Search the list of PHY devices on the mdio bus for the
+	 * PHY with the requested name
+	 */
+	dev = bus_find_device_by_name(&mdio_bus_type, NULL, phy_id);
+	if (!dev) {
+		dev_dbg(&pdev->dev, "PHY %s not found\n", phy_id);
+		phy_driver_unregister(&aq_phy_driver);
+		device_unregister(&phydev->dev);
+		miibus->phy_map[priv->phy_addr] = NULL;
+		vfree(priv);
+		return -ENODEV;
+	}
+
+	priv->dev = dev;
+
+	/* Initialize the debug-fs entries */
+	ret = aq_phy_init_debugfs_entries(priv);
+	if (ret < 0) {
+		phy_driver_unregister(&aq_phy_driver);
+		device_unregister(&phydev->dev);
+		miibus->phy_map[priv->phy_addr] = NULL;
+		vfree(priv);
+		return ret;
+	}
+
+	/* Initialize AQ Phy Stats Registers addresses */
+	aq_phy_init_stats(&priv->stats);
+
+	phydev->dev.platform_data = (void *)priv;
+
+	pr_notice("AQ PHY Device registered\n");
+	return 0;
+}
+
+/* Unregister the PHY device and PHY driver. */
+static int aq_driver_remove(struct platform_device *pdev)
+{
+	struct aq_priv *priv;
+	struct mii_bus *miibus;
+	struct phy_device *phydev;
+	struct device *dev;
+	uint8_t busid[MII_BUS_ID_SIZE];
+	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
+	struct device_node *np = NULL;
+	const __be32 *prop = NULL;
+	struct device_node *mdio_node = NULL;
+	struct platform_device *mdio_plat = NULL;
+	uint32_t phy_addr = 0;
+
+	np = of_node_get(pdev->dev.of_node);
+	of_property_read_u32(np, "qcom,phy-addr", &phy_addr);
+
+	/* Get MII BUS pointer */
+	prop = of_get_property(np, "mdiobus", NULL);
+	if (!prop) {
+		dev_dbg(&pdev->dev, "cannot get 'mdiobus' property\n", __func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	mdio_node = of_find_node_by_phandle(be32_to_cpup(prop));
+	if (!mdio_node) {
+		dev_dbg(&pdev->dev, "cannot find mdio node by phandle\n", __func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	mdio_plat = of_find_device_by_node(mdio_node);
+	if (!mdio_plat) {
+		dev_dbg(&pdev->dev, "cannot find platform device from mdio node\n", __func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	miibus = dev_get_drvdata(&mdio_plat->dev);
+	if (!miibus) {
+		dev_dbg(&pdev->dev, "cannot get mii bus reference from device data\n", __func__);
+		phy_driver_unregister(&aq_phy_driver);
+		vfree(priv);
+		return -EIO;
+	}
+
+	of_node_put(np);
+
+	/* create a phyid using MDIO bus id and MDIO bus address of phy */
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3,
+				PHY_ID_FMT,
+				miibus->id,
+				phy_addr);
+
+	dev = bus_find_device_by_name(&mdio_bus_type, NULL, phy_id);
+	if (!dev)
+		return -ENODEV;
+
+	phydev = to_phy_device(dev);
+	if (!phydev)
+		return -ENODEV;
+
+	priv = (struct aq_priv *)phydev->dev.platform_data;
+	if (!priv)
+		return -EIO;
+
+	phy_driver_unregister(&aq_phy_driver);
+	device_unregister(&phydev->dev);
+	miibus->phy_map[priv->phy_addr] = NULL;
+
+	/* Remove debugfs tree */
+	if (likely(priv->aq_top_dentry != NULL))
+		debugfs_remove_recursive(priv->aq_top_dentry);
+
+	/* Free the driver private data */
+	vfree(priv);
+
+	dev_dbg(&pdev->dev, "%s: Unregistered AQ PHY device\n", __func__);
+	return 0;
+}
+
+static struct platform_driver aq_driver = {
+	.probe = aq_driver_probe,
+	.remove = aq_driver_remove,
+	.driver		= {
+		.name	= "aq-phy",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(dt_aq_phy),
+	},
+};
+
+/* Platform driver module init function */
+static int __init aq_driver_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&aq_driver);
+	if (ret < 0)
+		pr_debug("platform_driver_register fail.\n");
+
+	return ret;
+}
+module_init(aq_driver_init);
+
+/* Platform driver module exit function */
+static void __exit aq_driver_exit(void)
+{
+	platform_driver_unregister(&aq_driver);
+}
+module_exit(aq_driver_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
diff -Naur -x .git linux-3.14.43.org/drivers/net/phy/Kconfig linux-3.14.43/drivers/net/phy/Kconfig
--- linux-3.14.43.org/drivers/net/phy/Kconfig	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/phy/Kconfig	2016-02-02 11:43:20.328577438 +0800
@@ -150,6 +150,12 @@
 	---help---
 	  Currently has a driver for the KSZ8041
 
+config QCA_85XX_SWITCH
+	tristate "Driver for 841x, 851x, 861x, 871x family of switches"
+	select SWCONFIG
+	---help---
+	 Driver for 841x, 851x, 861x, 871x family of switches
+
 config FIXED_PHY
 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB=y
@@ -269,6 +275,12 @@
 
 endif # RTL8366_SMI
 
+config AQ_PHY
+        tristate "Driver for Aquantia PHY"
+        depends on MDIO_GPIO
+        ---help---
+        Supports the Aquantia PHY
+
 source "drivers/net/phy/b53/Kconfig"
 
 endif # PHYLIB
diff -Naur -x .git linux-3.14.43.org/drivers/net/phy/Makefile linux-3.14.43/drivers/net/phy/Makefile
--- linux-3.14.43.org/drivers/net/phy/Makefile	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/phy/Makefile	2016-02-02 11:43:20.328577438 +0800
@@ -36,6 +36,7 @@
 obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
 obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
 obj-$(CONFIG_NATIONAL_PHY)	+= national.o
+obj-$(CONFIG_AQ_PHY)            += aq_phy.o
 obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
 obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_MICREL_PHY)	+= micrel.o
@@ -43,6 +44,7 @@
 obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 obj-$(CONFIG_AT803X_PHY)	+= at803x.o
 obj-$(CONFIG_AMD_PHY)		+= amd.o
+obj-$(CONFIG_QCA_85XX_SWITCH)   += qca_85xx_sw.o
 obj-$(CONFIG_MDIO_BUS_MUX)	+= mdio-mux.o
 obj-$(CONFIG_MDIO_BUS_MUX_GPIO)	+= mdio-mux-gpio.o
 obj-$(CONFIG_MDIO_BUS_MUX_MMIOREG) += mdio-mux-mmioreg.o
diff -Naur -x .git linux-3.14.43.org/drivers/net/phy/phy_device.c linux-3.14.43/drivers/net/phy/phy_device.c
--- linux-3.14.43.org/drivers/net/phy/phy_device.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/phy/phy_device.c	2016-02-02 11:43:20.328577438 +0800
@@ -539,13 +539,16 @@
 	if (!phydev->drv || !phydev->drv->config_init)
 		return 0;
 
-	ret = phy_write(phydev, MII_BMCR, BMCR_RESET);
-	if (ret < 0)
-		return ret;
+	/* Reset PHYs that are not C45 */
+	if (!phydev->is_c45) {
+		ret = phy_write(phydev, MII_BMCR, BMCR_RESET);
+		if (ret < 0)
+			return ret;
 
-	ret = phy_poll_reset(phydev);
-	if (ret < 0)
-		return ret;
+		ret = phy_poll_reset(phydev);
+		if (ret < 0)
+			return ret;
+	}
 
 	ret = phy_scan_fixups(phydev);
 	if (ret < 0)
diff -Naur -x .git linux-3.14.43.org/drivers/net/phy/qca_85xx_sw.c linux-3.14.43/drivers/net/phy/qca_85xx_sw.c
--- linux-3.14.43.org/drivers/net/phy/qca_85xx_sw.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/drivers/net/phy/qca_85xx_sw.c	2016-02-02 11:43:20.328577438 +0800
@@ -0,0 +1,1842 @@
+/*
+ * qca_85xx_sw.c: QCA 85xx switch driver
+ *
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/qca_85xx_sw.h>
+#include <linux/debugfs.h>
+#include <linux/phy.h>
+#include <uapi/linux/switch.h>
+#include <linux/switch.h>
+#include <linux/aq_phy.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/reset.h>
+#include "qca_85xx_sw_regdef.h"
+
+struct of_device_id dt_qca_85xx_sw[] = {
+	{ .compatible =  "qcom,qca-85xx-sw" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dt_qca_85xx_sw);
+
+/* MIB Descriptor */
+struct qca_85xx_sw_mib_desc {
+	unsigned int size;
+	unsigned int offset;
+	const char *name;
+};
+
+ /* 85xx chipset specific data */
+struct qca_85xx_sw_chip {
+	int (*hw_init)(struct qca_85xx_sw_platform_data *pdata);
+	uint32_t max_qsgmii_if;
+	uint32_t max_sgmii_plus_if;
+	uint32_t max_ge_if;
+};
+
+/* 85xx private data */
+struct qca_85xx_sw_priv {
+	struct switch_dev dev;
+	uint32_t (*read)(uint32_t reg_addr);
+	void (*write)(uint32_t reg_addr, uint32_t val);
+	struct mii_bus *mdio_bus;
+	struct net_device *eth_dev;
+	const struct qca_85xx_sw_chip *chip;
+
+	uint32_t reg_val;		/* Hold the result of the previous
+					   debug-fs based register read op */
+
+	uint32_t reg_addr;		/* Hold the register address for the
+					   previous debug-fs based register
+					   read op */
+	uint32_t sgmii_plus_link_speed;	/* SGMII+ if link speed */
+	uint32_t sgmii_plus_duplex;	/* SFMII+ if link duplex */
+	uint32_t sgmii_plus_port_num;	/* SGMII+ if port number */
+	struct dentry *top_dentry;	/* Top dentry */
+	struct dentry *write_dentry;	/* write-reg file dentry */
+	struct dentry *read_dentry;	/* read-reg file dentry */
+
+	/* VLAN enable */
+	bool vlan_enable;
+
+	/* VLAN tag ID configured for VLANs */
+	uint16_t vlan_tag_id[QCA_85XX_MAX_VLANS];
+
+	/* Member ports for port VLANs */
+	uint32_t vlan_port_map[QCA_85XX_MAX_VLANS];
+
+	/* Bitmap of tagged ports */
+	uint32_t vlan_tagged_ports_bm;
+
+	/* Port VLAN ID for each port */
+	uint16_t port_vlan_id[QCA_85XX_MAX_PORTS];
+
+	/* MIB Descritor table */
+	const struct qca_85xx_sw_mib_desc *mib;
+
+	/* Number of MIB counters */
+	unsigned num_mib_counters;
+
+	/* Buffer used for MIB get op */
+	char port_mib[2048];
+
+};
+
+struct qca_85xx_sw_priv *priv;
+
+/* MIB Descriptor table */
+static const struct qca_85xx_sw_mib_desc qca_85xx_mib[] = {
+	MIB_DESC(1, MIB_STATS_RX_BROAD, "RxBroad"),
+	MIB_DESC(1, MIB_STATS_RX_PAUSE, "RxPause"),
+	MIB_DESC(1, MIB_STATS_RX_MULTI, "RxMulti"),
+	MIB_DESC(1, MIB_STATS_RX_FCS_ERR, "RxFcsErr"),
+	MIB_DESC(1, MIB_STATS_RX_ALIGN_ERR, "RxAlignErr"),
+	MIB_DESC(1, MIB_STATS_RX_JUMBO_FCS_ERR, "RxJumboFcsErr"),
+	MIB_DESC(1, MIB_STATS_RX_JUMBO_ALIGN_ERR, "RxJumboAlignErr"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_64B, "Rx64Byte"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_65_127B, "Rx_65_to_127_Byte"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_128_255B, "Rx_128_to_255_Byte"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_256_511B, "Rx_256_to_511_Byte"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_512_1023B, "Rx_512_to_1023_Byte"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_1024_1518B, "Rx_1024_to_1518_Byte"),
+	MIB_DESC(1, MIB_STATS_RX_PKT_1519_XB, "Rx_1519_or more_Byte"),
+	MIB_DESC(1, MIB_STATS_RX_TOO_LONG, "RxTooLong"),
+	MIB_DESC(2, MIB_STATS_RX_GOOD_BYTE, "RxGoodByte"),
+	MIB_DESC(2, MIB_STATS_RX_BAD_BYTE, "RxBadByte"),
+	MIB_DESC(1, MIB_STATS_RX_OVER_FLOW, "RxOverFlow"),
+	MIB_DESC(1, MIB_STATS_RX_RUNT_NUM, "RxRuntNum"),
+	MIB_DESC(1, MIB_STATS_RX_RUNT_BYTE, "RxRuntByte"),
+	MIB_DESC(1, MIB_STATS_RX_FRAG_NUM, "RxFragNum"),
+	MIB_DESC(1, MIB_STATS_RX_FRAG_BYTE, "RxFragByte"),
+	MIB_DESC(1, MIB_STATS_TX_BROAD, "TxBroad"),
+	MIB_DESC(1, MIB_STATS_TX_PAUSE, "TxPause"),
+	MIB_DESC(1, MIB_STATS_TX_MULTI, "TxMulti"),
+	MIB_DESC(1, MIB_STATS_TX_UNDER_RUN, "TxUnderRun"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_64B, "Tx64Byte"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_65_127B, "Tx_65_to_127_Byte"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_128_255B, "Tx_128_to_255_Byte"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_256_511B, "Tx_256_to_511_Byte"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_512_1023B, "Tx_512_to_1023_Byte"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_1024_1518B, "Tx_1024_to_1518_Byte"),
+	MIB_DESC(1, MIB_STATS_TX_PKT_1519_XB, "Tx_1519_or more_Byte"),
+	MIB_DESC(2, MIB_STATS_TX_BYTE, "TxByte"),
+	MIB_DESC(1, MIB_STATS_TX_COLLISION, "TxCollision"),
+	MIB_DESC(1, MIB_STATS_TX_ABORTCOL, "TxAbortCol"),
+	MIB_DESC(1, MIB_STATS_TX_MULTICOL, "TxMultiCol"),
+	MIB_DESC(1, MIB_STATS_TX_SINGLECOL, "TxSingleCol"),
+	MIB_DESC(1, MIB_STATS_TX_EXCESSIVE_DEFER, "TxExcDefer"),
+	MIB_DESC(1, MIB_STATS_TX_DEFER, "TxDefer"),
+	MIB_DESC(1, MIB_STATS_TX_LATE_COL, "TxLateCol"),
+};
+
+/*
+ * Identify the new link speed and duplex setting for the SGMII+ if link, and
+ * and force the SGMII+ speed/duplex accordingly
+ */
+static void qca_85xx_sw_sgmii_plus_if_change_speed(struct net_device *dev)
+{
+	uint32_t val, sgmii_ctrl0_val;
+	int curr_speed = dev->phydev->speed;
+	int curr_duplex = dev->phydev->duplex;
+
+	if (curr_speed == priv->sgmii_plus_link_speed &&
+	    curr_duplex == priv->sgmii_plus_duplex)
+		return;
+
+	switch (curr_speed) {
+	case SPEED_2500:
+		/* Set port 27 into SGMII+ Mode(2.5 Gig speed) */
+		val = priv->read(GLOBAL_CTRL_1);
+		val |= GLOBAL_CTRL_1_PORT_27_SGMII_PLUS_EN;
+		val &= ~(GLOBAL_CTRL_1_PORT_27_SGMII_EN);
+		priv->write(GLOBAL_CTRL_1, val);
+		break;
+	case SPEED_1000:
+	case SPEED_100:
+		if (priv->sgmii_plus_link_speed != SPEED_1000 &&
+			priv->sgmii_plus_link_speed != SPEED_100) {
+			/* Set port 27 into SGMII Mode(100/1000Mbps speed) */
+			val = priv->read(GLOBAL_CTRL_1);
+			val |= GLOBAL_CTRL_1_PORT_27_SGMII_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_27_SGMII_PLUS_EN);
+			priv->write(GLOBAL_CTRL_1, val);
+		}
+		break;
+	default:
+		priv->sgmii_plus_link_speed = SPEED_UNKNOWN;
+		return;
+	}
+
+	sgmii_ctrl0_val = priv->read(SGMII_CTRL0_PORT27);
+	val = priv->read(port_status_cfg(priv->sgmii_plus_port_num));
+
+	/* Clear the previous link speed and duplex setting */
+	if (priv->sgmii_plus_link_speed == SPEED_100 ||
+	    priv->sgmii_plus_link_speed == SPEED_1000 ||
+	    priv->sgmii_plus_link_speed == SPEED_UNKNOWN) {
+		sgmii_ctrl0_val &= ~(SGMII_CTRL0_SGMII_MODE_MAC |
+				     SGMII_CTRL0_FORCE_SPEED_100 |
+				     SGMII_CTRL0_FORCE_SPEED_1000 |
+				     SGMII_CTRL0_FORCE_DUPLEX_FULL);
+
+		val &= ~(PORT_STATUS_FORCE_SPEED_100 |
+			 PORT_STATUS_FORCE_SPEED_1000 |
+			 PORT_STATUS_FORCE_DUPLEX_FULL);
+
+	}
+
+	if (curr_speed == SPEED_1000 || curr_speed == SPEED_2500) {
+		/* Force the 1000Mbps link speed and duplex setting */
+		val |= PORT_STATUS_FORCE_SPEED_1000 |
+		       PORT_STATUS_FORCE_DUPLEX_FULL;
+		sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_SPEED_1000 |
+				   SGMII_CTRL0_FORCE_DUPLEX_FULL;
+	} else {
+		/* Force the 100Mbps link speed and duplex setting */
+		sgmii_ctrl0_val |= SGMII_CTRL0_SGMII_MODE_MAC |
+				   SGMII_CTRL0_FORCE_SPEED_100;
+
+		val |=  PORT_STATUS_FORCE_SPEED_100;
+
+		if (curr_duplex) {
+			/* Set 100Mbps Full Duplex */
+			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_DUPLEX_FULL;
+			val |=  PORT_STATUS_FORCE_DUPLEX_FULL;
+		} else {
+			/* Set 100Mbps Half Duplex */
+			sgmii_ctrl0_val &= ~SGMII_CTRL0_FORCE_DUPLEX_FULL;
+			val &= ~PORT_STATUS_FORCE_DUPLEX_FULL;
+		}
+	}
+	priv->write(port_status_cfg(priv->sgmii_plus_port_num), val);
+	priv->write(SGMII_CTRL0_PORT27, sgmii_ctrl0_val);
+	priv->sgmii_plus_link_speed = curr_speed;
+	priv->sgmii_plus_duplex = curr_duplex;
+}
+
+ /* Configure a QSGMII interface */
+static int qca_85xx_sw_init_qsgmii_port(struct qca_85xx_sw_qsgmii_cfg *qcfg)
+{
+	uint32_t val, ch0_val, sd_clk_sel_val;
+	uint32_t ch0_ctrl_addr, ch1_ctrl_addr, ch2_ctrl_addr, ch3_ctrl_addr;
+	bool part_b = false;
+	int group_num;
+
+	if (qcfg->port_base > (priv->chip->max_qsgmii_if * 4))
+		return -EINVAL;
+
+	switch (qcfg->port_base) {
+	case QCA_85XX_SW_PORT_1:
+		group_num = 0;
+		break;
+	case QCA_85XX_SW_PORT_9:
+		group_num = 1;
+		break;
+	case QCA_85XX_SW_PORT_17:
+		group_num = 2;
+		break;
+	case QCA_85XX_SW_PORT_5:
+		group_num = 0;
+		part_b = true;
+		break;
+	case QCA_85XX_SW_PORT_13:
+		group_num = 1;
+		part_b = true;
+		break;
+	case QCA_85XX_SW_PORT_21:
+		group_num = 2;
+		part_b = true;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (part_b) {
+		ch0_ctrl_addr = QSGMII_5_CTRL0(group_num);
+		ch1_ctrl_addr = QSGMII_6_CTRL0(group_num);
+		ch2_ctrl_addr = QSGMII_7_CTRL0(group_num);
+		ch3_ctrl_addr = QSGMII_8_CTRL0(group_num);
+	} else {
+		ch0_ctrl_addr = QSGMII_1_CTRL0(group_num);
+		ch1_ctrl_addr = QSGMII_2_CTRL0(group_num);
+		ch2_ctrl_addr = QSGMII_3_CTRL0(group_num);
+		ch3_ctrl_addr = QSGMII_4_CTRL0(group_num);
+	}
+
+	val = priv->read(ch0_ctrl_addr);
+	if (qcfg->is_speed_forced == false)
+		val &= ~(QSGMII_CTRL_FORCE_SPEED | QSGMII_CTRL_FORCE_LINK_UP);
+	else {
+		val |= QSGMII_CTRL_FORCE_SPEED | QSGMII_CTRL_FORCE_LINK_UP;
+		if (qcfg->forced_speed == SPEED_1000)
+			val |= QSGMII_CTRL_FORCE_SPEED_1000
+				| QSGMII_CTRL_FORCE_DUPLEX_FULL;
+		else if (qcfg->forced_speed == SPEED_100)
+			val |= QSGMII_CTRL_FORCE_SPEED_100;
+		else if (qcfg->forced_speed == SPEED_10)
+			val |= QSGMII_CTRL_FORCE_SPEED_10;
+		else
+			return -EINVAL;
+
+		if (qcfg->forced_speed != SPEED_1000) {
+			if (qcfg->forced_duplex == DUPLEX_FULL)
+				val |= QSGMII_CTRL_FORCE_DUPLEX_FULL;
+			else
+				val &= ~QSGMII_CTRL_FORCE_DUPLEX_FULL;
+		}
+	}
+
+	/* Force the speed if necessary, set the SGMII mode, link up bit */
+	val = val & (~(QSGMII_CTRL_QSGMII_MODE_MAC
+		| QSGMII_CTRL_QSGMII_MODE_PHY));
+	ch0_val = val | QSGMII_CTRL_QSGMII_MODE_MAC;
+
+	priv->write(ch0_ctrl_addr, ch0_val);
+	priv->write(ch1_ctrl_addr, val);
+	priv->write(ch2_ctrl_addr, val);
+	priv->write(ch3_ctrl_addr, val);
+
+	/* Turn off auto-neg in port_status_cfg */
+	val = priv->read(port_status_cfg(qcfg->port_base + 1));
+
+	if (qcfg->is_speed_forced == false) {
+		/* Enable  Auto-negotiation */
+		val |= PORT_STATUS_AUTONEG_EN;
+	} else {
+		/* Disable Auto-negotiation */
+		val &= ~(PORT_STATUS_AUTONEG_EN
+				| PORT_STATUS_AUTO_FLOW_CTRL_EN
+				| PORT_STATUS_TX_HALF_FLOW_EN
+				| PORT_STATUS_RX_FLOW_EN
+				| PORT_STATUS_TX_FLOW_EN);
+		val |= (PORT_STATUS_RXMAC_EN | PORT_STATUS_TXMAC_EN);
+
+		/* Force the speed and duplex as configured */
+		if (qcfg->forced_speed == SPEED_1000)
+			val |= PORT_STATUS_FORCE_SPEED_1000 | PORT_STATUS_FORCE_DUPLEX_FULL;
+		else if (qcfg->forced_speed == SPEED_100)
+			val |= PORT_STATUS_FORCE_SPEED_100;
+		else if (qcfg->forced_speed == SPEED_10)
+			val |= PORT_STATUS_FORCE_SPEED_10;
+		else
+			return -EINVAL;
+
+		if (qcfg->forced_speed != SPEED_1000) {
+			if (qcfg->forced_duplex == DUPLEX_FULL)
+				val |= PORT_STATUS_FORCE_DUPLEX_FULL;
+			else
+				val &= ~PORT_STATUS_FORCE_DUPLEX_FULL;
+		}
+	}
+
+	priv->write(port_status_cfg(qcfg->port_base + 1), val);
+	priv->write(port_status_cfg(qcfg->port_base + 2), val);
+	priv->write(port_status_cfg(qcfg->port_base + 3), val);
+	priv->write(port_status_cfg(qcfg->port_base + 4), val);
+
+	/* Set QSGMII mode in GLOBAL_CTRL_1 */
+	val = priv->read(GLOBAL_CTRL_1);
+	val &= ~(GLOBAL_CTRL_1_MAC1_SGMII_EN << (qcfg->port_base/4));
+	priv->write(GLOBAL_CTRL_1, val);
+
+	 /* Enable SD clock selects for the QSGMII port */
+	sd_clk_sel_val = priv->read(SD_CLK_SEL);
+	sd_clk_sel_val |= (SD_CLK_SEL_QSGMII_1_RX << (qcfg->port_base/4));
+	priv->write(SD_CLK_SEL, sd_clk_sel_val);
+
+	return 0;
+}
+
+/* Configure a SGMII/SGMII+ interface */
+static int qca_85xx_sw_init_sgmii_port(enum qca_85xx_sw_gmac_port port,
+					struct qca_85xx_sw_sgmii_cfg *sgmii_cfg)
+{
+	uint32_t val, sgmii_ctrl0_reg, sgmii_ctrl0_val, sd_clk_sel_val;
+
+	/* Set the port to either SGMII or SGMII+ mode in GLOBAL_CTRL_1 */
+	val = priv->read(GLOBAL_CTRL_1);
+
+	sd_clk_sel_val = priv->read(SD_CLK_SEL);
+	switch (port) {
+	case QCA_85XX_SW_PORT_26:
+		sgmii_ctrl0_reg = SGMII_CTRL0_PORT26;
+		sd_clk_sel_val |= SD_CLK_SEL_SGMII_PORT26_RX;
+		if (sgmii_cfg->port_mode == QCA_85XX_SW_PORT_MODE_SGMII_PLUS) {
+			val |= GLOBAL_CTRL_1_PORT_26_SGMII_PLUS_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_26_SGMII_EN);
+		} else {
+			val |= GLOBAL_CTRL_1_PORT_26_SGMII_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_26_SGMII_PLUS_EN);
+		}
+		break;
+	case QCA_85XX_SW_PORT_27:
+		sd_clk_sel_val |= SD_CLK_SEL_SGMII_PORT27_RX;
+		sgmii_ctrl0_reg = SGMII_CTRL0_PORT27;
+		if (sgmii_cfg->port_mode == QCA_85XX_SW_PORT_MODE_SGMII_PLUS) {
+			val |= GLOBAL_CTRL_1_PORT_27_SGMII_PLUS_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_27_SGMII_EN);
+		} else {
+			val |= GLOBAL_CTRL_1_PORT_27_SGMII_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_27_SGMII_PLUS_EN);
+		}
+		break;
+	case QCA_85XX_SW_PORT_28:
+		sd_clk_sel_val |= SD_CLK_SEL_SGMII_PORT28_RX;
+		sgmii_ctrl0_reg = SGMII_CTRL0_PORT28;
+		if (sgmii_cfg->port_mode == QCA_85XX_SW_PORT_MODE_SGMII_PLUS) {
+			val |= GLOBAL_CTRL_1_PORT_28_SGMII_PLUS_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_28_SGMII_EN);
+		} else {
+			val |= GLOBAL_CTRL_1_PORT_28_SGMII_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_28_SGMII_PLUS_EN);
+		}
+		break;
+	case QCA_85XX_SW_PORT_29:
+		sd_clk_sel_val |= SD_CLK_SEL_SGMII_PORT29_RX;
+		sgmii_ctrl0_reg = SGMII_CTRL0_PORT29;
+		if (sgmii_cfg->port_mode == QCA_85XX_SW_PORT_MODE_SGMII_PLUS) {
+			val |= GLOBAL_CTRL_1_PORT_29_SGMII_PLUS_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_29_SGMII_EN);
+		} else {
+			val |= GLOBAL_CTRL_1_PORT_29_SGMII_EN;
+			val &= ~(GLOBAL_CTRL_1_PORT_29_SGMII_PLUS_EN);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	priv->write(GLOBAL_CTRL_1, val);
+
+	/* Enable SGMII Rx clock select */
+	priv->write(SD_CLK_SEL, sd_clk_sel_val);
+
+	/* Set the MAC-mode settings in SGMII_CTRL0 register */
+	sgmii_ctrl0_val = priv->read(sgmii_ctrl0_reg);
+
+	/* Place the SGMII mode into MAC mode */
+	/* for SGMII ports and 1000Base-X for SGMII+ */
+	if (sgmii_cfg->port_mode != QCA_85XX_SW_PORT_MODE_SGMII_PLUS)
+		sgmii_ctrl0_val |= SGMII_CTRL0_SGMII_MODE_MAC;
+	else
+		sgmii_ctrl0_val &= ~(SGMII_CTRL0_SGMII_MODE_PHY
+				| SGMII_CTRL0_SGMII_MODE_MAC);
+
+	val = priv->read(port_status_cfg(port));
+
+	/* Settings to force speed if configured */
+	if (sgmii_cfg->is_speed_forced == false)
+		val |= PORT_STATUS_AUTONEG_EN;
+	else {
+		/* Disable Auto-negotiation */
+		val &= ~(PORT_STATUS_AUTONEG_EN
+				| PORT_STATUS_AUTO_FLOW_CTRL_EN
+				| PORT_STATUS_TX_HALF_FLOW_EN
+				| PORT_STATUS_RX_FLOW_EN
+				| PORT_STATUS_TX_FLOW_EN);
+		val |= (PORT_STATUS_RXMAC_EN | PORT_STATUS_TXMAC_EN);
+
+		if (sgmii_cfg->port_mode != QCA_85XX_SW_PORT_MODE_SGMII_PLUS)
+			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_MODE_EN;
+
+		/* Force the speed and duplex as configured */
+		switch (sgmii_cfg->forced_speed) {
+		case SPEED_1000:
+		case SPEED_2500:
+			val |= PORT_STATUS_FORCE_SPEED_1000
+				| PORT_STATUS_FORCE_DUPLEX_FULL;
+			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_SPEED_1000
+					| SGMII_CTRL0_FORCE_DUPLEX_FULL;
+			break;
+		case SPEED_100:
+			val |= PORT_STATUS_FORCE_SPEED_100;
+			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_SPEED_100;
+			break;
+		case SPEED_10:
+			val |= PORT_STATUS_FORCE_SPEED_10;
+			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_SPEED_10;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if ((sgmii_cfg->forced_speed != SPEED_1000)
+			&& (sgmii_cfg->forced_speed != SPEED_2500)) {
+			if (sgmii_cfg->forced_duplex == DUPLEX_FULL)
+				val |= PORT_STATUS_FORCE_DUPLEX_FULL;
+			else {
+				val &= ~PORT_STATUS_FORCE_DUPLEX_FULL;
+				sgmii_ctrl0_val &= ~SGMII_CTRL0_FORCE_DUPLEX_FULL;
+			}
+		}
+	}
+
+	priv->write(port_status_cfg(port), val);
+	priv->write(sgmii_ctrl0_reg, sgmii_ctrl0_val);
+
+	/* Serdes control settings */
+	if (sgmii_cfg->port_mode == QCA_85XX_SW_PORT_MODE_SGMII_PLUS) {
+		priv->write(XAUI_SGMII_SERDES13_CTRL0, 0x01e2023e);
+		priv->write(XAUI_SGMII_SERDES13_CTRL1, 0x4c93ff0);
+		priv->sgmii_plus_port_num = port;
+	}
+
+	return 0;
+}
+
+/* Configure a trunk (Link-Aggregated) interface */
+static int qca_85xx_sw_trunk_enable(struct qca_85xx_sw_trunk_cfg *trunk_cfg)
+{
+	uint32_t val = 0, i = 0, shift_val = 0;
+	uint32_t trunk_table_entry_no = 0;
+	uint32_t trunk_table_entry_addr, table_entry_val = 0;
+	uint32_t port_bit_map = 0;
+	uint32_t next_port_num = 0;
+
+	if (trunk_cfg->trunk_id > (QCA_85XX_MAX_TRUNKS - 1))
+		return -EINVAL;
+
+	/* Enable trunk failover */
+	val = priv->read(L2_MISC_CTRL);
+	priv->write(L2_MISC_CTRL, val | FAILOVER_EN);
+
+	/* Set the trunk hash key selection method */
+	priv->write(TRUNK_HASH_KEY_SEL, trunk_cfg->trunk_hash_policy);
+
+	/* Enable the trunk slave ports */
+	for (i = QCA_85XX_SW_PORT_1; i <= QCA_85XX_SW_PORT_29; i++) {
+
+		if ((i > priv->chip->max_ge_if) && (i < QCA_85XX_SW_PORT_26))
+			continue;
+
+		if (trunk_cfg->trunk_ports_bit_map & (1 << i))
+			priv->write(port_trunk_cfg(i), (PORT_TRUNK_EN | trunk_cfg->trunk_id));
+	}
+
+	/* Set the trunk member ports in the TRUNK_GROUP_MEM table */
+	port_bit_map = trunk_cfg->trunk_ports_bit_map;
+
+	/* The TRUNK_GROUP_MEM table has 8 member slots all of which need to be
+	 * filled. So, cycle through the trunk port members list until we have
+	 * filled all the 8 port entries of the table entry.
+	 */
+	while (trunk_table_entry_no < QCA_85XX_MAX_TRUNKS) {
+		/* Get the next port number */
+		next_port_num = ffs(port_bit_map) - 1;
+		port_bit_map &= ~(1 << next_port_num);
+		shift_val = (trunk_table_entry_no
+			* TRUNK_MEM_PORT_ID_SHIFT_LEN) % 32;
+
+		/* Configure the table entries */
+		switch (trunk_table_entry_no) {
+		case 0:
+		case 1:
+		case 2:
+			trunk_table_entry_addr = trunk_group_mem_0(trunk_cfg->trunk_id);
+			table_entry_val = priv->read(trunk_table_entry_addr);
+			priv->write(trunk_table_entry_addr,
+			table_entry_val
+			| (next_port_num << shift_val));
+			break;
+		case 3:
+		case 4:
+			trunk_table_entry_addr = trunk_group_mem_1(trunk_cfg->trunk_id);
+			table_entry_val = priv->read(trunk_table_entry_addr);
+			priv->write(trunk_table_entry_addr,
+			table_entry_val
+			| (next_port_num << shift_val));
+			break;
+		case 5:
+			trunk_table_entry_addr = trunk_group_mem_1(trunk_cfg->trunk_id);
+			table_entry_val = priv->read(trunk_table_entry_addr);
+			priv->write(trunk_table_entry_addr,
+			table_entry_val
+			| ((next_port_num & 0xF) << shift_val));
+
+			if (next_port_num > 0xF) {
+				trunk_table_entry_addr = trunk_group_mem_2(trunk_cfg->trunk_id);
+				table_entry_val = priv->read(trunk_table_entry_addr);
+				priv->write(trunk_table_entry_addr,
+				table_entry_val
+				| ((next_port_num & 0x30) >> 4));
+			}
+
+			break;
+		case 6:
+		case 7:
+			trunk_table_entry_addr = trunk_group_mem_2(trunk_cfg->trunk_id);
+			table_entry_val = priv->read(trunk_table_entry_addr);
+			priv->write(trunk_table_entry_addr,
+			table_entry_val
+			| (next_port_num << shift_val));
+			break;
+		}
+
+		trunk_table_entry_no++;
+
+		if (port_bit_map == 0)
+			port_bit_map = trunk_cfg->trunk_ports_bit_map;
+	}
+
+	/* Enable the trunk slave ports bit map */
+	priv->write(trunk_local_port_mem(trunk_cfg->trunk_id),
+		trunk_cfg->trunk_ports_bit_map);
+
+	return 0;
+}
+
+/* Enable VLAN filters and STP forwarding */
+void qca_85xx_sw_enable_port_defaults(void)
+{
+	uint32_t stp_grp_reg_val_0 = 0, stp_grp_reg_val_1 = 0;
+	uint32_t port_vlan_fltr = 0;
+	int i;
+
+	/* Enable STP forwarding, and enable VLAN filters */
+	for (i = QCA_85XX_SW_PORT_1; i <= QCA_85XX_SW_PORT_29; i++) {
+		if (i < 16)
+			stp_grp_reg_val_0 |= (PORT_FORWARDING << (i*2));
+		else
+			stp_grp_reg_val_1 |= (PORT_FORWARDING << ((i-16) * 2));
+
+		port_vlan_fltr &=  ~(1 << i);
+	}
+
+	priv->write(spanning_tree_group_reg_0(0), stp_grp_reg_val_0);
+	priv->write(spanning_tree_group_reg_1(0), stp_grp_reg_val_1);
+	priv->write(PORT_VLAN_FLTR, port_vlan_fltr);
+}
+
+/* Configure a Port VLAN group */
+int qca_85xx_port_vlan_group_enable(uint16_t vlan_id, uint32_t port_bit_map)
+{
+	int next_port_num = 0, pbm;
+	uint16_t in_vlan_entry_num;
+	uint32_t in_vlan_w0_addr, in_vlan_w1_addr, in_vlan_w2_addr;
+	uint32_t in_vlan_w0_val = 0, in_vlan_w1_val = 0, in_vlan_w2_val = 0;
+	uint32_t vlan_op_val = 0, vlan_op_data_0_val = 0, vlan_op_data_1_val = 0;
+	uint32_t port_eg_vlan_ctrl_addr, port_eg_vlan_ctrl_val = 0;
+	uint32_t eg_vlan_tag_addr, eg_vlan_tag_val = 0;
+
+	pr_debug("qca_85xx_sw: VLAN enable for vlan_id = %d, port-map = 0x%x, vlan-tagged-ports map = 0x%x\n",
+			vlan_id, port_bit_map, priv->vlan_tagged_ports_bm);
+
+	if (vlan_id > QCA_85XX_VLAN_ID_MAX)
+		return -EINVAL;
+
+	/* Program IN_VLAN_TRANSLATION table */
+	in_vlan_entry_num = IN_VLAN_ENTRY_LOWEST_PRIO;
+
+	/* If the VLAN is not a tagged VLAN group, then we assign
+	 * a default ingress port VLAN translation for all the ports
+	 * in the VLAN
+	 */
+	if ((port_bit_map & priv->vlan_tagged_ports_bm) == port_bit_map) {
+		pr_debug("qca_85xx_sw: No ingress VLAN translation for vlan-id %d, port-map = 0x%x\n",
+				vlan_id, port_bit_map);
+		goto post_ingress;
+	}
+
+	pbm = port_bit_map;
+
+	/* Cycle through the port members list and update the IN_VLAN_TRANSLATION
+	 * table entry for each port
+	 */
+	while (pbm) {
+		next_port_num = ffs(pbm) - 1;
+		pbm &= ~(1 << next_port_num);
+
+		in_vlan_w0_addr = in_vlan_table_word_0(next_port_num, in_vlan_entry_num);
+		in_vlan_w1_addr = in_vlan_table_word_1(next_port_num, in_vlan_entry_num);
+		in_vlan_w2_addr = in_vlan_table_word_2(next_port_num, in_vlan_entry_num);
+
+		/* Write table entry word 0 */
+		in_vlan_w0_val |= (CVID_SEARCH_KEY_VALUE_UNTAGGED << CKEY_VID_SHIFT_LEN);
+		priv->write(in_vlan_w0_addr, in_vlan_w0_val);
+
+		/* Write table entry word 1 */
+		in_vlan_w1_val |= (vlan_id << XLT_CVID_SHIFT_LEN);
+		in_vlan_w1_val |= (XLT_CVID_EN | CKEY_VID_INCL);
+		priv->write(in_vlan_w1_addr, in_vlan_w1_val);
+
+		/* Write table entry word 2 */
+		in_vlan_w2_val |= (IN_VLAN_TABLE_ENTRY_VALID | SA_LRN_EN | (CVLAN_ASSIGN_ALL_FRAMES << CKEY_FMT_SHIFT_LEN));
+		priv->write(in_vlan_w2_addr, in_vlan_w2_val);
+	}
+
+post_ingress:
+	/* Program VLAN table entry */
+	vlan_op_data_0_val = port_bit_map;
+	priv->write(VLAN_OP_DATA_0, vlan_op_data_0_val);
+
+	vlan_op_data_1_val |= (LRN_EN | VLAN_TABLE_ENTRY_VALID);
+	priv->write(VLAN_OP_DATA_1, vlan_op_data_1_val);
+
+	vlan_op_val |= (vlan_id | (VLAN_OP_TYPE_ADD_ONE << VLAN_OP_SHIFT_VAL));
+	priv->write(VLAN_OPERATION, vlan_op_val);
+	vlan_op_val |= VLAN_OP_START;
+	priv->write(VLAN_OPERATION, vlan_op_val);
+
+	usleep_range(1000, 10000);
+
+	if (priv->read(VLAN_OPERATION) & VLAN_BUSY) {
+		pr_debug(KERN_ERR "qca_85xx_sw: VLAN entry add operation timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	/* Program Egress VLAN table */
+	eg_vlan_tag_addr = eg_vlan_tag(vlan_id);
+	eg_vlan_tag_val |= EG_VLAN_TAG_TABLE_ENTRY_VALID;
+
+	pbm = port_bit_map;
+	while (pbm) {
+		next_port_num = ffs(pbm) - 1;
+		if (priv->vlan_tagged_ports_bm & (1 << next_port_num))
+			eg_vlan_tag_val |= (1 << next_port_num);
+		pbm &= ~(1 << next_port_num);
+	}
+
+	priv->write(eg_vlan_tag_addr, eg_vlan_tag_val);
+
+	port_eg_vlan_ctrl_val |= (PORT_TAG_CONTROL_VID_LOOKUP_VID
+				  | PORT_EG_VLAN_CTRL_RESERVED
+				  | (PORT_EG_VLAN_TYPE_MODE_UNMODIFIED
+					  << PORT_EG_VLAN_TYPE_MODE_SHIFT_LEN));
+	pbm = port_bit_map;
+	while (pbm) {
+		next_port_num = ffs(pbm) - 1;
+		pbm &= ~(1 << next_port_num);
+		port_eg_vlan_ctrl_addr = port_eg_vlan_ctrl(next_port_num);
+		priv->write(port_eg_vlan_ctrl_addr, port_eg_vlan_ctrl_val);
+	}
+
+	return 0;
+}
+
+/* Initialize VLAN information tables */
+static void qca_85xx_sw_init_vlan_tables(void)
+{
+	int i;
+
+	priv->vlan_tagged_ports_bm = 0;
+
+	for (i = 0; i < QCA_85XX_MAX_PORTS; i++)
+		priv->port_vlan_id[i] = 0;
+
+	for (i = 0; i < QCA_85XX_MAX_VLANS; i++) {
+		priv->vlan_port_map[i] = 0;
+		priv->vlan_tag_id[i] = 0;
+	}
+}
+
+/* Initialize the 8511 chipset */
+static int qca8511_hw_init(struct qca_85xx_sw_platform_data *pdata)
+{
+	uint32_t val = 0;
+	int ret = 0;
+
+	/* Issue software reset and restore registers to default values */
+	val = priv->read(GLOBAL_CTRL_0);
+	val |= (GLOBAL_CTRL_0_REG_RST_EN | GLOBAL_CTRL_0_SOFT_RST);
+	priv->write(GLOBAL_CTRL_0, val);
+
+	usleep_range(1000, 10000);
+
+	/* Is the reset complete? */
+	if (priv->read(GLOBAL_CTRL_0) & GLOBAL_CTRL_0_SOFT_RST) {
+		printk(KERN_ERR "qca_85xx_sw: software reset timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	/* Configuring QSGMII interface */
+	if (pdata->qsgmii_cfg.port_mode == QCA_85XX_SW_PORT_MODE_QSGMII) {
+		ret = qca_85xx_sw_init_qsgmii_port(&pdata->qsgmii_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	/* Configure SGMII/SGMII+ interfaces */
+	if (pdata->port_24_cfg.port_mode != QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED) {
+		ret = qca_85xx_sw_init_sgmii_port(QCA_85XX_SW_PORT_24,
+			&pdata->port_24_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	if (pdata->port_25_cfg.port_mode != QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED) {
+		ret = qca_85xx_sw_init_sgmii_port(QCA_85XX_SW_PORT_25,
+			&pdata->port_25_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	if (pdata->port_26_cfg.port_mode != QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED) {
+		ret = qca_85xx_sw_init_sgmii_port(QCA_85XX_SW_PORT_26,
+			&pdata->port_26_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	if (pdata->port_27_cfg.port_mode != QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED) {
+		ret = qca_85xx_sw_init_sgmii_port(QCA_85XX_SW_PORT_27,
+			&pdata->port_27_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	if (pdata->port_28_cfg.port_mode != QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED) {
+		ret = qca_85xx_sw_init_sgmii_port(QCA_85XX_SW_PORT_28,
+			&pdata->port_28_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	if (pdata->port_29_cfg.port_mode != QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED) {
+		ret = qca_85xx_sw_init_sgmii_port(QCA_85XX_SW_PORT_29,
+			&pdata->port_29_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	/* Configure trunk (Link aggregated) interfaces */
+	if (pdata->trunk_cfg.is_trunk_enabled == true) {
+		ret = qca_85xx_sw_trunk_enable(&pdata->trunk_cfg);
+		if (ret != 0)
+			return ret;
+	}
+
+	/* Configure port VLANs */
+	qca_85xx_sw_enable_port_defaults();
+
+	printk(KERN_INFO "qca_85xx_sw: 8511 switch initialized\n");
+
+	return ret;
+}
+
+struct qca_85xx_sw_chip qca8511_chip = {
+	.hw_init = qca8511_hw_init,
+	.max_qsgmii_if = 2,
+	.max_sgmii_plus_if = 4,
+	.max_ge_if = 8,
+};
+
+/* Netdev notifier callback to inform the change of state of a netdevice */
+static int qca_85xx_sw_netdev_notifier_callback(struct notifier_block *this,
+						unsigned long event, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+
+	if (dev != priv->eth_dev)
+		return NOTIFY_DONE;
+
+	if (!netif_carrier_ok(dev))
+		return NOTIFY_DONE;
+
+	switch (event) {
+	case NETDEV_UP:
+	case NETDEV_CHANGE:
+		qca_85xx_sw_sgmii_plus_if_change_speed(dev);
+		break;
+	case NETDEV_DOWN:
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+/* Switch register read routine */
+static uint32_t qca_85xx_sw_mii_read(uint32_t reg_addr)
+{
+	struct mii_bus *bus = priv->mdio_bus;
+	uint32_t reg_word_addr;
+	uint32_t phy_addr, tmp_val, reg_val;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* Change reg_addr to 32-bit aligned */
+	reg_word_addr = (reg_addr & 0xfffffffc);
+
+	/* Configure register high address */
+	phy_addr = 0x18 | (reg_word_addr >> 29);
+	phy_reg = (reg_word_addr & 0x1f000000) >> 24;
+
+	/* Bit 23-8 of reg address */
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0xffff);
+	mdiobus_write(bus, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as MIBs, since it is read/clear,
+	 * we should read the lower 16-bit register then the higher one
+	 */
+
+	/* Read register in lower address
+	 * Bit 7-5 of reg address
+	 */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);
+
+	/*  Bit 4-0 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);
+	reg_val = (uint32_t) mdiobus_read(bus, phy_addr, phy_reg);
+
+	/* Read register in higher address
+	 * Bit 7-5 of reg address
+	 */
+
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);
+
+	/* Bit4-0 of reg address */
+	phy_reg = (uint8_t) ((reg_word_addr & 0x1f) | 0x2);
+	tmp_val = (uint32_t) mdiobus_read(bus, phy_addr, phy_reg);
+	reg_val |= (tmp_val << 16);
+
+	return reg_val;
+}
+
+/* Switch register write routine */
+static void qca_85xx_sw_mii_write(uint32_t reg_addr, uint32_t reg_val)
+{
+	struct mii_bus *bus = priv->mdio_bus;
+	uint32_t reg_word_addr;
+	uint32_t phy_addr;
+	uint16_t phy_val;
+	uint8_t phy_reg;
+
+	/* Change reg_addr to 16-bit word address,
+	 * 32-bit aligned
+	 */
+	reg_word_addr = (reg_addr & 0xfffffffc);
+
+	/* configure register high address */
+	phy_addr = 0x18 | (reg_word_addr >> 29);
+	phy_reg = (reg_word_addr & 0x1f000000) >> 24;
+
+	/* Bit23-8 of reg address */
+	phy_val = (uint16_t) ((reg_word_addr >> 8) & 0xffff);
+	mdiobus_write(bus, phy_addr, phy_reg, phy_val);
+
+	/* For some registers such as ARL and VLAN, since they include BUSY bit
+	 * in lower address, we should write the higher 16-bit register then the
+	 * lower one
+	 */
+
+	/* write register in higher address
+	 *  bit7-5 of reg address
+	 */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);
+
+	/* bit4-0 of reg address */
+	phy_reg = (uint8_t) (reg_word_addr & 0x1f);
+
+	/* lowest 16bit data */
+	phy_val = (uint16_t) (reg_val & 0xffff);
+	mdiobus_write(bus, phy_addr, phy_reg, phy_val);
+
+	/* write register in lower address
+	 * bit7-5 of reg address
+	 */
+	phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7);
+
+	/* Bit4-0 of reg address */
+	phy_reg = (uint8_t) ((reg_word_addr & 0x1f) | 0x2);
+
+	/* Highest 16bit data */
+	phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+	mdiobus_write(bus, phy_addr, phy_reg, phy_val);
+}
+
+/* Check for a valid range of switch register */
+static bool qca_85xx_sw_check_valid_reg(uint32_t reg_addr)
+{
+	return true;
+}
+
+/* read from debug-fs file */
+static ssize_t qca_85xx_sw_read_reg_get(struct file *fp, char __user *ubuf,
+					size_t sz, loff_t *ppos)
+{
+	char lbuf[40];
+	int bytes_read;
+
+	if (!priv)
+		return -EFAULT;
+
+	snprintf(lbuf, sizeof(lbuf),
+		"0x%x: 0x%x\n",
+		priv->reg_addr,
+		priv->reg_val);
+
+	bytes_read = simple_read_from_buffer(ubuf,
+			sz, ppos,
+			lbuf,
+			strlen(lbuf));
+
+	return bytes_read;
+}
+
+/* Write into the file and read back the switch register */
+static ssize_t qca_85xx_sw_read_reg_set(struct file *fp, const char __user *ubuf,
+					size_t sz, loff_t *ppos)
+{
+	char lbuf[32];
+	size_t lbuf_size;
+	char *curr_ptr = lbuf;
+	unsigned long reg_addr = 0;
+	uint32_t reg_val = 0;
+	bool is_reabable = false;
+
+	if (!priv)
+		return -EFAULT;
+
+	lbuf_size = min(sz, (sizeof(lbuf) - 1));
+
+	if (copy_from_user(lbuf, ubuf, lbuf_size)) {
+		pr_debug("Failed in copy_from_user\n");
+		return -EFAULT;
+	}
+
+	lbuf[lbuf_size] = 0;
+
+	while ((*curr_ptr == ' ') && (curr_ptr < &lbuf[lbuf_size]))
+		curr_ptr++;
+
+	if (curr_ptr == &lbuf[lbuf_size])
+		return -EINVAL;
+
+	if (kstrtoul(curr_ptr, 16, &reg_addr)) {
+		pr_debug("Invalid register address input\n");
+		return -EINVAL;
+	}
+
+	/* Read into PHY reg and store value in previous reg read */
+	is_reabable = qca_85xx_sw_check_valid_reg(reg_addr);
+	if (is_reabable) {
+		priv->reg_addr = reg_addr;
+		reg_val = qca_85xx_sw_mii_read(reg_addr);
+		priv->reg_val = reg_val;
+		return lbuf_size;
+	}
+
+	pr_debug("Non-readable register address input\n");
+	return -EINVAL;
+}
+
+/* Debug-fs function to write a switch register */
+static ssize_t qca_85xx_sw_write_reg_set(struct file *fp, const char __user *ubuf,
+					 size_t sz, loff_t *ppos)
+{
+	char lbuf[32];
+	size_t lbuf_size;
+	char *curr_ptr = lbuf;
+	unsigned long reg_addr = 0;
+	unsigned long reg_val = 0;
+	bool is_writeable = false;
+
+	if (!priv)
+		return -EFAULT;
+
+	lbuf_size = min(sz, (sizeof(lbuf) - 1));
+
+	if (copy_from_user(lbuf, ubuf, lbuf_size)) {
+		pr_debug("Failed in copy_from_user\n");
+		return -EFAULT;
+	}
+
+	lbuf[lbuf_size] = 0;
+
+	while ((*curr_ptr == ' ') && (curr_ptr < &lbuf[lbuf_size]))
+		curr_ptr++;
+
+	if (curr_ptr == &lbuf[lbuf_size])
+		return -EINVAL;
+
+	kstrtoul(curr_ptr, 16, &reg_addr);
+
+	while ((*curr_ptr == ' ') && (curr_ptr < &lbuf[lbuf_size]))
+		curr_ptr++;
+
+	if (curr_ptr == &lbuf[lbuf_size])
+		return -EINVAL;
+
+	if (kstrtoul(curr_ptr, 16, &reg_val)) {
+		pr_debug("Invalid register address input\n");
+		return -EINVAL;
+	}
+
+	/* Check for a valid range of register before writing */
+	is_writeable = qca_85xx_sw_check_valid_reg(reg_addr);
+	if (is_writeable) {
+		qca_85xx_sw_mii_write(reg_addr, reg_val);
+		return lbuf_size;
+	}
+
+	pr_debug("Non-writable register address input\n");
+	return -EINVAL;
+}
+
+static const struct file_operations qca_85xx_sw_read_reg_ops = {
+	.open = simple_open,
+	.read = qca_85xx_sw_read_reg_get,
+	.write = qca_85xx_sw_read_reg_set,
+	.llseek = no_llseek,
+};
+
+static const struct file_operations qca_85xx_sw_write_reg_ops = {
+	.open = simple_open,
+	.write = qca_85xx_sw_write_reg_set,
+	.llseek = no_llseek,
+};
+
+/* Init Netdev notifier event callback to notify any change in netdevice
+ * attached with an external PHY
+ */
+static struct notifier_block qca_85xx_netdev_notifier __read_mostly = {
+	.notifier_call		= qca_85xx_sw_netdev_notifier_callback,
+};
+
+/* Create debug-fs qca_85xx_sw dir and files */
+static int qca_85xx_sw_init_debugfs_entries(void)
+{
+	priv->top_dentry = debugfs_create_dir("qca-85xx-sw", NULL);
+	if (priv->top_dentry == NULL) {
+		printk(KERN_ERR "qca_85xx_sw: Failed to create qca-85xx-sw directory in debugfs\n");
+		return -1;
+	}
+
+	priv->write_dentry = debugfs_create_file("write-reg", 0400,
+						priv->top_dentry,
+						priv, &qca_85xx_sw_write_reg_ops);
+
+	if (unlikely(priv->write_dentry == NULL)) {
+		printk(KERN_ERR "qca_85xx_sw: Failed to create qca-85xx-sw/write-reg file in debugfs\n");
+		debugfs_remove_recursive(priv->top_dentry);
+		return -1;
+	}
+
+	priv->read_dentry = debugfs_create_file("read-reg", 0400,
+						priv->top_dentry,
+						priv, &qca_85xx_sw_read_reg_ops);
+
+	if (unlikely(priv->read_dentry == NULL)) {
+		printk(KERN_ERR "qca_85xx_sw: Failed to create qca-85xx-sw/read-reg file in debugfs\n");
+		debugfs_remove_recursive(priv->top_dentry);
+		return -1;
+	}
+
+	priv->reg_val = 0;
+	priv->reg_addr = 0;
+
+	return 0;
+}
+
+/* Find the ethernet netdevice attached to the SGMII+ Interface */
+static struct net_device *qca_85xx_sw_get_eth_dev(
+		struct platform_device *pdev, struct qca_85xx_sw_platform_data *pdata)
+{
+	struct mii_bus *miibus;
+	struct phy_device *phydev;
+	struct device *dev;
+	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
+	struct device_node *np = NULL;
+	struct device_node *mdio_node = NULL;
+	struct platform_device *mdio_plat = NULL;
+	const __be32 *prop = NULL;
+
+	np = of_node_get(pdev->dev.of_node);
+
+	/* Get MDIO BUS pointer */
+	prop = of_get_property(np, "sgmii-plus-if-phy-mdiobus", NULL);
+	if (!prop) {
+		dev_dbg(&pdev->dev, "cannot get 'mdiobus' property\n", __func__);
+		return NULL;
+	}
+
+	mdio_node = of_find_node_by_phandle(be32_to_cpup(prop));
+	if (!mdio_node) {
+		dev_dbg(&pdev->dev, "cannot find mdio node by phandle\n", __func__);
+		return NULL;
+	}
+
+	mdio_plat = of_find_device_by_node(mdio_node);
+	if (!mdio_plat) {
+		dev_dbg(&pdev->dev, "cannot find platform device from mdio node\n", __func__);
+		return NULL;
+	}
+
+	miibus = dev_get_drvdata(&mdio_plat->dev);
+	if (!miibus) {
+		dev_dbg(&pdev->dev, "cannot get mdio bus reference from device data\n", __func__);
+		return NULL;
+	}
+
+	of_node_put(np);
+
+	 /* create a phyid using MDIO bus id and MDIO bus address of phy */
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3,
+				PHY_ID_FMT,
+				miibus->id,
+				pdata->sgmii_plus_if_phy_addr);
+
+	dev = bus_find_device_by_name(&mdio_bus_type, NULL, phy_id);
+	if (!dev)
+		return NULL;
+
+	phydev = to_phy_device(dev);
+	if (!phydev)
+		return NULL;
+
+	return phydev->attached_dev;
+}
+
+/* Set VLAN enable flag */
+static int qca_85xx_sw_set_vlan(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	if (val->value.i)
+		priv->vlan_enable = true;
+	else
+		priv->vlan_enable = false;
+
+	return 0;
+}
+
+/* Get VLAN enable flag */
+static int qca_85xx_sw_get_vlan(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	if (priv->vlan_enable == true)
+		val->value.i = 1;
+	else
+		val->value.i = 0;
+
+	return 0;
+}
+
+/* Issue MIB operation on a port */
+static int qca_85xx_sw_issue_mib_op(int port, enum qca_85xx_sw_mib_op mib_op)
+{
+	uint32_t op, val;
+
+	switch (mib_op) {
+	case MIB_CAPTURE:
+		op = MIB_OP_TYPE_CAPTURE;
+		break;
+	case MIB_CAPTURE_AND_CLEAR:
+		op = MIB_OP_TYPE_CAPTURE_AND_CLEAR;
+		break;
+	case MIB_FLUSH:
+		op = MIB_OP_TYPE_FLUSH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	val = port;
+	priv->write(MIB_OPERATION, val);
+	val |= (op | MIB_BUSY);
+	priv->write(MIB_OPERATION, val);
+
+	usleep_range(1000, 10000);
+
+	if (priv->read(MIB_OPERATION) & MIB_BUSY) {
+		pr_debug(KERN_ERR "qca_85xx_sw: MIB flush operation timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+/* Reset MIB counters for all ports */
+static int qca_85xx_sw_set_reset_mibs(struct switch_dev *dev,
+				      const struct switch_attr *attr,
+				      struct switch_val *val)
+{
+	int ret = 0, i;
+
+	for (i = 0; i < QCA_85XX_MAX_PORTS; i++) {
+		ret = qca_85xx_sw_issue_mib_op(i, MIB_FLUSH);
+		if (ret != 0)
+			return ret;
+	}
+
+	return ret;
+}
+
+/* Reset MIB counters for a port */
+static int qca_85xx_sw_set_port_reset_mib(struct switch_dev *dev,
+					  const struct switch_attr *attr,
+					  struct switch_val *val)
+{
+	int port = val->port_vlan;
+
+	if (port > dev->ports)
+		return -EINVAL;
+
+	return qca_85xx_sw_issue_mib_op(port, MIB_FLUSH);
+}
+
+/* Read MIB counters for a port */
+static int qca_85xx_sw_get_port_mib(struct switch_dev *dev,
+				    const struct switch_attr *attr,
+				    struct switch_val *val)
+{
+	int port;
+	int i, len = 0, ret = 0;
+	char *buf = priv->port_mib;
+	uint64_t counter_val, counter_high;
+	uint32_t counter_addr = 0;
+
+	port = val->port_vlan;
+
+	if (port > dev->ports)
+		return -EINVAL;
+
+	len += snprintf(buf + len, sizeof(priv->port_mib) - len,
+			"Port %d MIB counters:\n\n",
+			port);
+
+	ret = qca_85xx_sw_issue_mib_op(port, MIB_CAPTURE);
+	if (ret != 0)
+		return ret;
+
+	for (i = 0; i < priv->num_mib_counters; i++) {
+		counter_val = priv->read(MIB_RX_DATA + priv->mib[i].offset);
+		if (priv->mib[i].size > 1) {
+			counter_addr = MIB_RX_DATA + priv->mib[i].offset + 4;
+			counter_high = priv->read(counter_addr);
+			counter_val |= (counter_high << 32);
+		}
+
+		len += snprintf(buf + len, sizeof(priv->port_mib) - len,
+				"%-25s: %llu\n",
+				priv->mib[i].name,
+				counter_val);
+	}
+
+	val->value.s = buf;
+	val->len = len;
+
+	return 0;
+}
+
+/* Set VLAN Tag ID for a VLAN */
+static int qca_85xx_sw_set_vid(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	if (val->port_vlan > dev->vlans)
+		return -EINVAL;
+
+	if (val->value.i > dev->vlans)
+		return -EINVAL;
+
+	priv->vlan_tag_id[val->port_vlan] = val->value.i;
+
+	return 0;
+}
+
+/* Get the VLAN Tag ID for a VLAN */
+static int qca_85xx_sw_get_vid(struct switch_dev *dev,
+				const struct switch_attr *attr,
+				struct switch_val *val)
+{
+	if (val->port_vlan > dev->vlans)
+		return -EINVAL;
+
+	val->value.i = priv->vlan_tag_id[val->port_vlan];
+
+	return 0;
+}
+
+/* Switch device global attributes */
+static struct switch_attr qca_85xx_sw_globals[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = qca_85xx_sw_set_vlan,
+		.get = qca_85xx_sw_get_vlan,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mibs",
+		.description = "Reset all MIB counters",
+		.set = qca_85xx_sw_set_reset_mibs,
+		.get = NULL,
+	},
+};
+
+/* Switch device per-port attributes */
+static struct switch_attr qca_85xx_sw_port[] = {
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mib",
+		.description = "Reset single port MIB counters",
+		.set = qca_85xx_sw_set_port_reset_mib,
+		.get = NULL,
+	},
+	{
+		.type = SWITCH_TYPE_STRING,
+		.name = "mib",
+		.description = "Get port's MIB counters",
+		.set = NULL,
+		.get = qca_85xx_sw_get_port_mib,
+	},
+};
+
+/* Switch device per-vlan attributes */
+static struct switch_attr qca_85xx_sw_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID (0-4094)",
+		.set = qca_85xx_sw_set_vid,
+		.get = qca_85xx_sw_get_vid,
+		.max = 4094,
+	},
+};
+
+/* Set Port VLAN ID for a port */
+static int qca_85xx_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	int i;
+
+	if (vlan >= dev->vlans)
+		return -EINVAL;
+
+	if (port >= QCA_85XX_MAX_PORTS)
+		return -EINVAL;
+
+	priv->port_vlan_id[port] = vlan;
+
+	/* Make sure that this port does not
+	 * appear in other vlans
+	 */
+	for (i = 0; i < QCA_85XX_MAX_VLANS; i++) {
+		if (i == vlan)
+			continue;
+		priv->vlan_port_map[i] &= ~(1 << port);
+	}
+
+	return 0;
+}
+
+/* Get Port VLAN ID for a port */
+static int qca_85xx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	if (port >= QCA_85XX_MAX_PORTS)
+		return -EINVAL;
+
+	*vlan = priv->port_vlan_id[port];
+
+	return 0;
+}
+
+/* Get the member ports for a port VLAN ID */
+static int qca_85xx_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	uint32_t ports = priv->vlan_port_map[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 1; i <= dev->ports; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (priv->vlan_tagged_ports_bm & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+/* Set the member ports for a port-VLAN */
+static int qca_85xx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	uint32_t *vt = &priv->vlan_port_map[val->port_vlan];
+	uint32_t *vt_tagged, vid;
+	int i, j;
+
+	vid = priv->vlan_tag_id[val->port_vlan];
+	vt_tagged = &priv->vlan_port_map[vid];
+
+	*vt = 0;
+	*vt_tagged = 0;
+
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
+			*vt_tagged |= 1 << p->id;
+			priv->vlan_tagged_ports_bm |= (1 << p->id);
+		} else {
+			priv->vlan_tagged_ports_bm &= ~(1 << p->id);
+			priv->port_vlan_id[p->id] = val->port_vlan;
+
+			/* Make sure that an untagged port does not
+			 * appear in other vlans
+			 */
+			for (j = 0; j < QCA_85XX_MAX_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				priv->vlan_port_map[j] &= ~(1 << p->id);
+			}
+
+			*vt |= 1 << p->id;
+		}
+	}
+
+	return 0;
+}
+
+/* Apply the configured settings */
+static int qca_85xx_sw_hw_apply(struct switch_dev *dev)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < QCA_85XX_MAX_VLANS; i++) {
+		if (priv->vlan_port_map[i] == 0)
+			continue;
+		ret = qca_85xx_port_vlan_group_enable(i,
+							priv->vlan_port_map[i]);
+		if (ret != 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* Switch software reset */
+static int qca_85xx_sw_reset_switch(struct switch_dev *dev)
+{
+	/* Initialize VLAN tables */
+	qca_85xx_sw_init_vlan_tables();
+
+	return 0;
+}
+
+/* switch device operations */
+static const struct switch_dev_ops qca_85xx_sw_ops = {
+	.attr_global = {
+		.attr = qca_85xx_sw_globals,
+		.n_attr = ARRAY_SIZE(qca_85xx_sw_globals),
+	},
+	.attr_port = {
+		.attr = qca_85xx_sw_port,
+		.n_attr = ARRAY_SIZE(qca_85xx_sw_port),
+	},
+	.attr_vlan = {
+		.attr = qca_85xx_sw_vlan,
+		.n_attr = ARRAY_SIZE(qca_85xx_sw_vlan),
+	},
+	.get_port_pvid = qca_85xx_sw_get_pvid,
+	.set_port_pvid = qca_85xx_sw_set_pvid,
+	.get_vlan_ports = qca_85xx_sw_get_ports,
+	.set_vlan_ports = qca_85xx_sw_set_ports,
+	.apply_config = qca_85xx_sw_hw_apply,
+	.reset_switch = qca_85xx_sw_reset_switch,
+	.get_port_link = NULL,
+	.get_reg_val = NULL,
+	.set_reg_val = NULL,
+};
+
+static void qca_85xx_sw_of_get_pdata(struct device_node *np,
+				     struct qca_85xx_sw_platform_data *pdata)
+{
+
+	uint32_t is_config_set = 0;
+
+	of_property_read_u32(np,
+		"qcom,sgmii-plus-if-phy-addr",
+		&pdata->sgmii_plus_if_phy_addr);
+	of_property_read_u32(np,
+		"qcom,chip-id",
+		&pdata->chip_id);
+	of_property_read_u32(np,
+		"qcom,qsgmii-cfg-port-mode",
+		&pdata->qsgmii_cfg.port_mode);
+	of_property_read_u32(np,
+		"qcom,qsgmii-cfg-port-base",
+		&pdata->qsgmii_cfg.port_base);
+
+	of_property_read_u32(np,
+		"qcom,qsgmii-cfg-is-speed-forced",
+		&is_config_set);
+	if (is_config_set == 1)
+		pdata->qsgmii_cfg.is_speed_forced = true;
+	else
+		pdata->qsgmii_cfg.is_speed_forced = false;
+
+	is_config_set = 0;
+	of_property_read_u32(np,
+		"qcom,qsgmii-cfg-forced-speed",
+		&pdata->qsgmii_cfg.forced_speed);
+	of_property_read_u32(np,
+		"qcom,qsgmii-cfg-forced-duplex",
+		&pdata->qsgmii_cfg.forced_duplex);
+	of_property_read_u32(np,
+		"qcom,port-26-cfg-port-mode",
+		&pdata->port_26_cfg.port_mode);
+
+	of_property_read_u32(np,
+		"qcom,port-26-cfg-is-speed-forced",
+		&is_config_set);
+	if (is_config_set == 1)
+		pdata->port_26_cfg.is_speed_forced = true;
+	else
+		pdata->port_26_cfg.is_speed_forced = false;
+
+	is_config_set = 0;
+	of_property_read_u32(np,
+		"qcom,port-27-cfg-port-mode",
+		&pdata->port_27_cfg.port_mode);
+
+	of_property_read_u32(np,
+		"qcom,port-27-cfg-is-speed-forced",
+		&is_config_set);
+	if (is_config_set == 1)
+		pdata->port_27_cfg.is_speed_forced = true;
+	else
+		pdata->port_27_cfg.is_speed_forced = false;
+
+	is_config_set = 0;
+	of_property_read_u32(np,
+		"qcom,port-27-cfg-forced-speed",
+		&pdata->port_27_cfg.forced_speed);
+	of_property_read_u32(np,
+		"qcom,port-27-cfg-forced-duplex",
+		&pdata->port_27_cfg.forced_duplex);
+
+	of_property_read_u32(np,
+		"qcom,trunk-cfg-is-trunk-enabled",
+		&is_config_set);
+	if (is_config_set == 1)
+		pdata->trunk_cfg.is_trunk_enabled = true;
+	else
+		pdata->trunk_cfg.is_trunk_enabled = false;
+
+	of_property_read_u32(np,
+		"qcom,trunk-cfg-trunk-id",
+		&pdata->trunk_cfg.trunk_id);
+	of_property_read_u32(np,
+		"qcom,trunk-cfg-trunk-hash-policy",
+		&pdata->trunk_cfg.trunk_hash_policy);
+	of_property_read_u32(np,
+		"qcom,trunk-cfg-trunk-ports-bit-map",
+		&pdata->trunk_cfg.trunk_ports_bit_map);
+}
+
+static int qca_85xx_sw_probe(struct platform_device *pdev)
+{
+	struct mii_bus *mdio_bus;
+	bool sgmii_plus_link_state_notifier_registered = false;
+	bool qca_85xx_sw_dev_registered = false;
+	struct switch_dev *swdev;
+	struct device_node *np = NULL;
+	struct qca_85xx_sw_platform_data *pdata = NULL;
+	struct device_node *mdio_node = NULL;
+	struct platform_device *mdio_plat = NULL;
+	const __be32 *prop = NULL;
+	int ret = -1;
+
+	pdata = vzalloc(sizeof(struct qca_85xx_sw_platform_data));
+	if (pdata == NULL) {
+		printk(KERN_ERR "qca_85xx_sw: Could not allocate memory for qca_85xx_sw platform data\n");
+		return ret;
+	}
+
+	np = of_node_get(pdev->dev.of_node);
+	qca_85xx_sw_of_get_pdata(np, pdata);
+
+	priv = vzalloc(sizeof(struct qca_85xx_sw_priv));
+	if (priv == NULL) {
+		printk(KERN_ERR "qca_85xx_sw: Could not allocate private memory for 85xx driver\n");
+		vfree(pdata);
+		return ret;
+	}
+
+	if (pdata->chip_id == QCA_85XX_SW_ID_QCA8511) {
+		priv->chip = &qca8511_chip;
+		priv->read = qca_85xx_sw_mii_read;
+		priv->write = qca_85xx_sw_mii_write;
+	} else {
+		printk(KERN_ERR "qca_85xx_sw: Unsupported 85xx switch chipset\n");
+		goto err;
+	}
+
+	/* Get MDIO BUS pointer */
+	prop = of_get_property(np, "mdiobus", NULL);
+	if (!prop) {
+		dev_dbg(&pdev->dev, "cannot get 'mdiobus' property\n", __func__);
+		goto err;
+	}
+
+	mdio_node = of_find_node_by_phandle(be32_to_cpup(prop));
+	if (!mdio_node) {
+		dev_dbg(&pdev->dev, "cannot find mdio node by phandle\n", __func__);
+		goto err;
+	}
+
+	mdio_plat = of_find_device_by_node(mdio_node);
+	if (!mdio_plat) {
+		dev_dbg(&pdev->dev, "cannot find platform device from mdio node\n", __func__);
+		goto err;
+	}
+
+	mdio_bus = dev_get_drvdata(&mdio_plat->dev);
+	if (!mdio_bus) {
+		dev_dbg(&pdev->dev, "cannot get mdio bus reference from device data\n", __func__);
+		goto err;
+	}
+	of_node_put(np);
+
+	priv->mdio_bus = mdio_bus;
+
+	/* Find the ethernet device we are bound to */
+	priv->eth_dev = qca_85xx_sw_get_eth_dev(pdev, pdata);
+	if (!priv->eth_dev) {
+		printk(KERN_ERR "qca_85xx_sw: Could not find ethernet device\n");
+		goto err;
+	}
+
+	/* Initialize the debug-fs entries */
+	ret = qca_85xx_sw_init_debugfs_entries();
+	if (ret < 0) {
+		printk(KERN_ERR "qca_85xx_sw: Could not initialize debugfs entries\n");
+		goto err;
+	}
+
+	ret = register_netdevice_notifier(&qca_85xx_netdev_notifier);
+	if (ret != 0) {
+		printk(KERN_ERR "qca_85xx_sw: Failed to register netdevice notifier %d\n", ret);
+		goto err;
+	}
+
+	sgmii_plus_link_state_notifier_registered = true;
+
+	/* Initialize VLAN tables */
+	qca_85xx_sw_init_vlan_tables();
+
+	/* Initialize MIB */
+	priv->mib = qca_85xx_mib;
+	priv->num_mib_counters = ARRAY_SIZE(qca_85xx_mib);
+	priv->vlan_enable = true;
+
+	swdev = &priv->dev;
+	swdev->cpu_port = 0;
+	swdev->ops = &qca_85xx_sw_ops;
+	swdev->ports = QCA_85XX_MAX_PORTS;
+	swdev->vlans = QCA_85XX_MAX_VLANS;
+	if (pdata->chip_id == QCA_85XX_SW_ID_QCA8511)
+		swdev->name = "QCA8511 Switch";
+
+	ret = register_switch(&priv->dev, priv->eth_dev);
+	if (ret) {
+		printk(KERN_ERR "qca_85xx_sw: Error registering 85xx switch chipset\n");
+		goto err;
+	}
+
+	qca_85xx_sw_dev_registered = true;
+
+	ret = priv->chip->hw_init(pdata);
+	if (ret != 0) {
+		printk(KERN_ERR "qca_85xx_sw: Error initializing 85xx chipset\n");
+		goto err;
+	}
+
+	priv->sgmii_plus_link_speed = SPEED_UNKNOWN;
+
+	return 0;
+
+err:
+	if (qca_85xx_sw_dev_registered)
+		unregister_switch(&priv->dev);
+
+	if (sgmii_plus_link_state_notifier_registered)
+		unregister_netdevice_notifier(&qca_85xx_netdev_notifier);
+
+	if (priv->top_dentry != NULL)
+		debugfs_remove_recursive(priv->top_dentry);
+
+	if (priv->eth_dev)
+		dev_put(priv->eth_dev);
+
+	if (priv)
+		vfree(priv);
+
+	if (pdata)
+		vfree(pdata);
+
+	return ret;
+}
+static int qca_85xx_sw_remove(struct platform_device *pdev)
+{
+	unregister_switch(&priv->dev);
+
+	/* Remove debugfs tree */
+	if (likely(priv->top_dentry != NULL))
+		debugfs_remove_recursive(priv->top_dentry);
+
+	dev_put(priv->eth_dev);
+
+	vfree(priv);
+
+	unregister_netdevice_notifier(&qca_85xx_netdev_notifier);
+
+	return 0;
+}
+
+static struct platform_driver qca_85xx_sw_driver = {
+	.driver = {
+		.name = "qca-85xx-sw",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(dt_qca_85xx_sw),
+	},
+	.probe = qca_85xx_sw_probe,
+	.remove = qca_85xx_sw_remove,
+};
+
+int __init qca_85xx_sw_init(void)
+{
+	platform_driver_register(&qca_85xx_sw_driver);
+
+	return 0;
+}
+
+void __exit qca_85xx_sw_exit(void)
+{
+	platform_driver_unregister(&qca_85xx_sw_driver);
+}
+
+module_init(qca_85xx_sw_init);
+module_exit(qca_85xx_sw_exit);
+MODULE_LICENSE("GPL");
diff -Naur -x .git linux-3.14.43.org/drivers/net/phy/qca_85xx_sw_regdef.h linux-3.14.43/drivers/net/phy/qca_85xx_sw_regdef.h
--- linux-3.14.43.org/drivers/net/phy/qca_85xx_sw_regdef.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/drivers/net/phy/qca_85xx_sw_regdef.h	2016-02-02 11:43:20.328577438 +0800
@@ -0,0 +1,293 @@
+/*
+ * QCA 85xx switch register definitions
+ *
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef QCA_85XX_SW_REG_H
+#define QCA_85XX_SW_REG_H
+
+/* Register definitions */
+#define GLOBAL_CTRL_0				0x0
+#define GLOBAL_CTRL_1				0x8
+#define SD_CLK_SEL				0x20
+#define PORT_STATUS_CFG_PORT0			0x100
+#define PORT_VLAN_FLTR				0x4054
+#define VLAN_OPERATION				0x4060
+#define VLAN_OP_DATA_0				0x4064
+#define VLAN_OP_DATA_1				0x4068
+#define PORT_EG_VLAN_CTRL			0x4600
+#define L2_MISC_CTRL				0x6000
+#define TRUNK_HASH_KEY_SEL			0x600c
+#define PORT_TRUNK_CFG_PORT0			0x6800
+#define MIB_OPERATION				0xe000
+#define MIB_RX_DATA				0xe010
+#define MIB_TX_DATA				0xe080
+#define QSGMII_CTRL_GRP0_BASE			0x13000
+#define SGMII_CTRL0_PORT26			0x13200	/* Control for SGMII ports  - Port 26 */
+#define SGMII_CTRL0_PORT27			0x13220	/* Control for SGMII ports  - Port 27 */
+#define SGMII_CTRL0_PORT28			0x13240	/* Control for SGMII ports  - Port 28 */
+#define SGMII_CTRL0_PORT29			0x13260	/* Control for SGMII ports  - Port 29 */
+#define XAUI_SGMII_SERDES13_CTRL0		0x1341c	/* Serdes controls for SGMII/SGMII+ Port 26 to 29 */
+#define XAUI_SGMII_SERDES13_CTRL1		0x13420	/* Serdes controls for SGMII/SGMII+ Port 26 to 29 */
+#define IN_VLAN_TRANSLATION_BASE_WORD_0		0xb0000
+#define IN_VLAN_TRANSLATION_BASE_WORD_1		0xb0004
+#define IN_VLAN_TRANSLATION_BASE_WORD_2		0xb0008
+#define SPANNING_TREE_GROUP_REG_0_GROUP_0	0xd0000
+#define SPANNING_TREE_GROUP_REG_1_GROUP_0	0xd0004
+#define EG_VLAN_TAG_ENTRY_0			0x110000
+#define TRUNK_GROUP_MEM_REG_0_TRUNK_ID_0	0x2e0000
+#define TRUNK_GROUP_MEM_REG_1_TRUNK_ID_0	0x2e0004
+#define TRUNK_GROUP_MEM_REG_2_TRUNK_ID_0	0x2e0008
+#define TRUNK_LOCAL_PORT_MEM_TRUNK_ID_0		0x2b0000
+
+/* Bit Definitions for GLOBAL_CTRL_0 */
+#define GLOBAL_CTRL_0_SOFT_RST			0x80000000
+#define GLOBAL_CTRL_0_REG_RST_EN		0x40000
+
+/* Bit definitions for GLOBAL_CTRL_1 */
+#define GLOBAL_CTRL_1_MAC1_SGMII_EN		0x4
+#define GLOBAL_CTRL_1_PORT_26_SGMII_PLUS_EN	0x4000
+#define GLOBAL_CTRL_1_PORT_26_SGMII_EN		0x8000
+#define GLOBAL_CTRL_1_PORT_27_SGMII_PLUS_EN	0x10000
+#define GLOBAL_CTRL_1_PORT_27_SGMII_EN		0x20000
+#define GLOBAL_CTRL_1_PORT_28_SGMII_PLUS_EN	0x40000
+#define GLOBAL_CTRL_1_PORT_28_SGMII_EN		0x80000
+#define GLOBAL_CTRL_1_PORT_29_SGMII_PLUS_EN	0x100000
+#define GLOBAL_CTRL_1_PORT_29_SGMII_EN		0x200000
+
+/* Bit definitions for SD_CLK_SEL */
+#define SD_CLK_SEL_QSGMII_1_RX			0x1
+#define SD_CLK_SEL_SGMII_PORT26_RX		0x1000
+#define SD_CLK_SEL_SGMII_PORT27_RX		0x2000
+#define SD_CLK_SEL_SGMII_PORT28_RX		0x4000
+#define SD_CLK_SEL_SGMII_PORT29_RX		0x8000
+
+/* Bit definitions for PORT_STATUS_CFG */
+#define port_status_cfg(n)	(PORT_STATUS_CFG_PORT0 + (n * 0x100))
+#define PORT_STATUS_FORCE_SPEED_10	0x0
+#define PORT_STATUS_FORCE_SPEED_100	0x1
+#define PORT_STATUS_FORCE_SPEED_1000	0x2
+#define PORT_STATUS_TXMAC_EN		0x4
+#define PORT_STATUS_RXMAC_EN		0x8
+#define PORT_STATUS_TX_FLOW_EN		0x10
+#define PORT_STATUS_RX_FLOW_EN		0x20
+#define PORT_STATUS_FORCE_DUPLEX_FULL	0x40
+#define PORT_STATUS_TX_HALF_FLOW_EN	0x80
+#define PORT_STATUS_AUTONEG_EN		0x200
+#define PORT_STATUS_AUTO_FLOW_CTRL_EN	0x1000
+
+/* Bit definitions for VLAN_OPERATION */
+#define VLAN_OP_TYPE_ADD_ONE	0x0
+#define VLAN_OP_SHIFT_VAL	27
+#define VLAN_BUSY		0x80000000
+#define VLAN_OP_START		VLAN_BUSY
+
+/* Bit definitions for VLAN_OP_DATA_1 */
+#define LRN_EN			0x800
+#define SVL_ON			0x20000
+#define VLAN_TABLE_ENTRY_VALID	0x40000
+
+/* Bit definitions for PORT_EG_VLAN_CTRL */
+#define port_eg_vlan_ctrl(n)	(PORT_EG_VLAN_CTRL + (n * 0x10))
+#define PORT_EG_VLAN_TYPE_MODE_UNTAGGED		0x0
+#define PORT_EG_VLAN_TYPE_MODE_UNMODIFIED	0x2
+#define PORT_EG_VLAN_TYPE_MODE_SHIFT_LEN	0
+#define PORT_TAG_CONTROL_VID_LOOKUP_VID		0x8
+#define PORT_EG_VLAN_CTRL_RESERVED		0x30000
+
+/* Bit definitions for PORT_VLAN_FLTR */
+#define PORT_VLAN_FLTR_ALL_PORTS_FLTR_EN 0x0
+
+/* Bit definitions for L2_MISC_CTRL */
+#define FAILOVER_EN 0x40000
+
+/* Bit definitions for IN_VLAN_TRANSLATION table entries */
+#define in_vlan_table_word_0(m, n)	(IN_VLAN_TRANSLATION_BASE_WORD_0 + (m * 0x100) + (n * 0x10))
+#define in_vlan_table_word_1(m, n)	(IN_VLAN_TRANSLATION_BASE_WORD_1 + (m * 0x100) + (n * 0x10))
+#define in_vlan_table_word_2(m, n)	(IN_VLAN_TRANSLATION_BASE_WORD_2 + (m * 0x100) + (n * 0x10))
+#define IN_VLAN_ENTRY_LOWEST_PRIO	0xF
+
+/* Bit description for in_vlan_table word 0 */
+#define CKEY_VID_SHIFT_LEN		0
+#define CVID_SEARCH_KEY_VALUE_UNTAGGED	0x0
+
+/* Bit description for in_vlan_table word 1 */
+#define XLT_CVID_SHIFT_LEN		0
+#define XLT_CVID_EN			0x1000
+#define CKEY_VID_INCL			0x8000
+
+/* Bit description for in_vlan_table word 2 */
+#define CKEY_FMT_SHIFT_LEN		0
+#define CVLAN_ASSIGN_ALL_FRAMES		0x3
+#define SA_LRN_EN			0x20
+#define IN_VLAN_TABLE_ENTRY_VALID	0x80
+
+/* Bit Description for SPANNING_TREE_GROUP */
+#define spanning_tree_group_reg_0(n) (SPANNING_TREE_GROUP_REG_0_GROUP_0 + (n * 0x10))
+#define spanning_tree_group_reg_1(n) (SPANNING_TREE_GROUP_REG_1_GROUP_0 + (n * 0x10))
+#define PORT_DISABLE	0x0
+#define PORT_BLOCKING	0x1
+#define PORT_LEARNING	0x2
+#define PORT_FORWARDING	0x3
+
+/* Bit description for EG_VLAN_TAG table entries */
+#define eg_vlan_tag(n)	(EG_VLAN_TAG_ENTRY_0 + (n * 0x10))
+#define EG_VLAN_TAG_TABLE_ENTRY_VALID	0x40000000
+
+/* Bit definitions for TRUNK_GROUP_MEM table */
+#define trunk_group_mem_0(n) (TRUNK_GROUP_MEM_REG_0_TRUNK_ID_0 + (n * 0x10))
+#define trunk_group_mem_1(n) (TRUNK_GROUP_MEM_REG_1_TRUNK_ID_0 + (n * 0x10))
+#define trunk_group_mem_2(n) (TRUNK_GROUP_MEM_REG_2_TRUNK_ID_0 + (n * 0x10))
+#define TRUNK_MEM_PORT_ID_SHIFT_LEN	12
+
+/* Bit definitions for TRUNK_LOCAL_PORT_MEM table entries */
+#define trunk_local_port_mem(n) (TRUNK_LOCAL_PORT_MEM_TRUNK_ID_0 + (n * 0x10))
+
+/* Bit definitions for PORT_TRUNK_CFG */
+#define port_trunk_cfg(n)	(PORT_TRUNK_CFG_PORT0 + (n * 0x10))
+#define PORT_TRUNK_ID_MASK	0x7
+#define PORT_TRUNK_EN		0x20
+
+/* Bit definitions for MIB_OPERATION */
+#define MIB_OP_TYPE_SHIFT_LEN	29
+#define MIB_OP_TYPE_CAPTURE		(0x0 << MIB_OP_TYPE_SHIFT_LEN)
+#define MIB_OP_TYPE_CAPTURE_AND_CLEAR	(0x1 << MIB_OP_TYPE_SHIFT_LEN)
+#define MIB_OP_TYPE_FLUSH		(0x2 << MIB_OP_TYPE_SHIFT_LEN)
+#define MIB_BUSY			0x80000000
+
+/* MIB Statistic Rx counters offsets from MIB_RX_DATA */
+#define MIB_STATS_RX_BROAD		0x0
+#define MIB_STATS_RX_PAUSE		0x4
+#define MIB_STATS_RX_MULTI		0x8
+#define MIB_STATS_RX_FCS_ERR		0xc
+#define MIB_STATS_RX_ALIGN_ERR		0x10
+#define MIB_STATS_RX_RESERVED0		0x14
+#define MIB_STATS_RX_RESERVED1		0x18
+#define MIB_STATS_RX_JUMBO_FCS_ERR	0x1c
+#define MIB_STATS_RX_JUMBO_ALIGN_ERR	0x20
+#define MIB_STATS_RX_PKT_64B		0x24
+#define MIB_STATS_RX_PKT_65_127B	0x28
+#define MIB_STATS_RX_PKT_128_255B	0x2c
+#define MIB_STATS_RX_PKT_256_511B	0x30
+#define MIB_STATS_RX_PKT_512_1023B	0x34
+#define MIB_STATS_RX_PKT_1024_1518B	0x38
+#define MIB_STATS_RX_PKT_1519_XB	0x3c
+#define MIB_STATS_RX_TOO_LONG		0x40
+#define MIB_STATS_RX_GOOD_BYTE		0x44
+#define MIB_STATS_RX_BAD_BYTE		0x4c
+#define MIB_STATS_RX_OVER_FLOW		0x54
+#define MIB_STATS_RX_RUNT_NUM		0x170
+#define MIB_STATS_RX_RUNT_BYTE		0x174
+#define MIB_STATS_RX_FRAG_NUM		0x178
+#define MIB_STATS_RX_FRAG_BYTE		0x17c
+
+/* MIB Statistic Tx counters offsets from MIB_RX_DATA */
+#define MIB_STATS_TX_BROAD		0x70
+#define MIB_STATS_TX_PAUSE		0x74
+#define MIB_STATS_TX_MULTI		0x78
+#define MIB_STATS_TX_UNDER_RUN		0x7c
+#define MIB_STATS_TX_PKT_64B		0x80
+#define MIB_STATS_TX_PKT_65_127B	0x84
+#define MIB_STATS_TX_PKT_128_255B	0x88
+#define MIB_STATS_TX_PKT_256_511B	0x8c
+#define MIB_STATS_TX_PKT_512_1023B	0x90
+#define MIB_STATS_TX_PKT_1024_1518B	0x94
+#define MIB_STATS_TX_PKT_1519_XB	0x98
+#define MIB_STATS_TX_RESERVED0		0x9c
+#define MIB_STATS_TX_BYTE		0xa0
+#define MIB_STATS_TX_COLLISION		0xa8
+#define MIB_STATS_TX_ABORTCOL		0xac
+#define MIB_STATS_TX_MULTICOL		0xb0
+#define MIB_STATS_TX_SINGLECOL		0xb4
+#define MIB_STATS_TX_EXCESSIVE_DEFER	0xb8
+#define MIB_STATS_TX_DEFER		0xbc
+#define MIB_STATS_TX_LATE_COL		0xc0
+
+/* CH0 Control for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_1_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x0)
+
+/* QSGMII settings for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_1_CTRL1(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x4)
+
+/* QSGMII settings for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_1_CTRL2(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x8)
+
+/* CH1 Control for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_2_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0xc)
+
+/* CH2 Control for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_3_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x10)
+
+/* CH3 Control for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_4_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x14)
+
+/* CH0 Control for QSGMII1/QSGMII3/QSGMII5 */
+#define QSGMII_5_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x18)
+
+/* QSGMII settings for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_5_CTRL1(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x1c)
+
+/* QSGMII settings for QSGMII0/QSGMII2/QSGMII4 */
+#define QSGMII_5_CTRL2(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x20)
+
+/* Register not defined */
+#define QSGMII_RESERVED	0x24
+
+/* CH1 Control for QSGMII1/QSGMII3/QSGMII5 */
+#define QSGMII_6_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x28)
+
+/* CH2 Control for QSGMII1/QSGMII3/QSGMII5 */
+#define QSGMII_7_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x2c)
+
+/* CH3 Control for QSGMII1/QSGMII3/QSGMII5 */
+#define QSGMII_8_CTRL0(group)	(QSGMII_CTRL_GRP0_BASE + (0x50*group) + 0x30)
+
+/* Bit definitions for QSGMII_1_CTRL0 */
+#define QSGMII_CTRL_FORCE_DUPLEX_FULL	0x1
+#define QSGMII_CTRL_FORCE_LINK_UP	0x2
+#define QSGMII_CTRL_FORCE_SPEED_10	0x0
+#define QSGMII_CTRL_FORCE_SPEED_100	0x4
+#define QSGMII_CTRL_FORCE_SPEED_1000	0x8
+#define QSGMII_CTRL_FORCE_SPEED		0x00200000
+#define QSGMII_CTRL_QSGMII_MODE_PHY	0x00400000
+#define QSGMII_CTRL_QSGMII_MODE_MAC	0x00800000
+
+/* Bit definitions for SGMII_CTRL0 */
+#define SGMII_CTRL0_FORCE_DUPLEX_FULL	0x1
+#define SGMII_CTRL0_FORCE_SPEED_10	0x0
+#define SGMII_CTRL0_FORCE_SPEED_100	0x4
+#define SGMII_CTRL0_FORCE_SPEED_1000	0x8
+#define SGMII_CTRL0_FORCE_MODE_EN	0x200000
+
+#define SGMII_CTRL0_SGMII_MODE_1000BASE_X	0x0
+#define SGMII_CTRL0_SGMII_MODE_PHY		0x400000
+#define SGMII_CTRL0_SGMII_MODE_MAC		0x800000
+
+/* MIB Operations */
+enum qca_85xx_sw_mib_op {
+	MIB_CAPTURE = 0,
+	MIB_CAPTURE_AND_CLEAR = 1,
+	MIB_FLUSH = 2,
+};
+
+#define MIB_DESC(_s , _o, _n)	\
+	{			\
+		.size = (_s),	\
+		.offset = (_o),	\
+		.name = (_n),	\
+	}
+
+#endif
diff -Naur -x .git linux-3.14.43.org/drivers/net/ppp/pptp.c linux-3.14.43/drivers/net/ppp/pptp.c
--- linux-3.14.43.org/drivers/net/ppp/pptp.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/net/ppp/pptp.c	2016-02-02 11:43:20.332577398 +0800
@@ -147,6 +147,33 @@
 	return i < MAX_CALLID;
 }
 
+/*
+ * Search a pptp session based on peer call id and peer ip address
+ */
+static int lookup_session_dst(struct pptp_opt *opt, u16 call_id, __be32 d_addr)
+{
+	struct pppox_sock *sock;
+	int i = 1;
+
+	rcu_read_lock();
+	for_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {
+		sock = rcu_dereference(callid_sock[i]);
+		if (!sock)
+			continue;
+
+		if (sock->proto.pptp.dst_addr.call_id == call_id &&
+			  sock->proto.pptp.dst_addr.sin_addr.s_addr == d_addr) {
+			sock_hold(sk_pppox(sock));
+			memcpy(opt, &sock->proto.pptp, sizeof(struct pptp_opt));
+			sock_put(sk_pppox(sock));
+			rcu_read_unlock();
+			return 0;
+		}
+	}
+	rcu_read_unlock();
+	return -EINVAL;
+}
+
 static int add_chan(struct pppox_sock *sock)
 {
 	static int call_id;
@@ -300,6 +327,10 @@
 	ip_select_ident(skb, NULL);
 	ip_send_check(iph);
 
+	/* set incoming interface as the ppp interface */
+	if (skb->skb_iif)
+		skb->skb_iif = ppp_dev_index(chan);
+
 	ip_local_out(skb);
 	return 1;
 
@@ -420,6 +451,7 @@
 	if (po) {
 		skb_dst_drop(skb);
 		nf_reset(skb);
+		skb->skb_iif = ppp_dev_index(&po->chan);
 		return sk_receive_skb(sk_pppox(po), skb, 0);
 	}
 drop:
@@ -643,6 +675,49 @@
 }
 
 /*
+ * pptp_channel_addressing_get()
+ *	Return PPTP channel specific addressing information.
+ */
+void pptp_channel_addressing_get(struct pptp_opt *opt, struct ppp_channel *chan)
+{
+	struct sock *sk;
+	struct pppox_sock *po;
+
+	if (!opt)
+		return;
+
+	sk = (struct sock *)chan->private;
+	if (!sk)
+		return;
+
+	sock_hold(sk);
+
+	/* This is very unlikely, but check the socket is connected state */
+	if (unlikely(sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))) {
+		sock_put(sk);
+		return;
+	}
+
+	po = pppox_sk(sk);
+	memcpy(opt, &po->proto.pptp, sizeof(struct pptp_opt));
+	sock_put(sk);
+}
+EXPORT_SYMBOL(pptp_channel_addressing_get);
+
+/*
+ * pptp_session_find()
+ *	Search and return a PPTP session info based on peer callid and IP address.
+ *	The function accepts the parameters in network byte order
+ */
+int pptp_session_find(struct pptp_opt *opt, __be16 peer_call_id, __be32 peer_ip_addr)
+{
+	if (!opt)
+		return -EINVAL;
+	return lookup_session_dst(opt, ntohs(peer_call_id), peer_ip_addr);
+}
+EXPORT_SYMBOL(pptp_session_find);
+
+/*
  * pptp_hold_chan()
  */
 static void pptp_hold_chan(struct ppp_channel *chan)
diff -Naur -x .git linux-3.14.43.org/drivers/pci/host/pci-qcom.c linux-3.14.43/drivers/pci/host/pci-qcom.c
--- linux-3.14.43.org/drivers/pci/host/pci-qcom.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/pci/host/pci-qcom.c	2016-02-02 11:43:20.540575297 +0800
@@ -972,4 +972,4 @@
 	if (err)
 		pr_err("pcie config write failed %d\n", err);
 }
-DECLARE_PCI_FIXUP_FINAL(PCIE_VENDOR_ID_RCP, PCIE_DEVICE_ID_RCP, msm_pcie_fixup_final);
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, msm_pcie_fixup_final);
diff -Naur -x .git linux-3.14.43.org/drivers/platform/msm/bootconfig.c linux-3.14.43/drivers/platform/msm/bootconfig.c
--- linux-3.14.43.org/drivers/platform/msm/bootconfig.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/drivers/platform/msm/bootconfig.c	2016-02-02 11:43:20.588574814 +0800
@@ -0,0 +1,370 @@
+/*
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+#include <asm/setup.h>
+#include <linux/mtd/partitions.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/genhd.h>
+#include <linux/major.h>
+#include <linux/mtd/blktrans.h>
+#include <linux/mtd/mtd.h>
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include "bootconfig.h"
+
+static struct proc_dir_entry *boot_info_dir;
+static struct proc_dir_entry *partname_dir[NUM_ALT_PARTITION];
+
+static unsigned int num_parts;
+static unsigned int flash_type;
+
+struct sbl_if_dualboot_info_type_v2 *bootconfig1;
+struct sbl_if_dualboot_info_type_v2 *bootconfig2;
+
+static int getbinary_show(struct seq_file *m, void *v)
+{
+	struct sbl_if_dualboot_info_type_v2 *sbl_info_v2;
+
+	sbl_info_v2 = m->private;
+	sbl_info_v2->age++;
+	memcpy(m->buf + m->count, sbl_info_v2,
+		sizeof(struct sbl_if_dualboot_info_type_v2));
+	m->count += sizeof(struct sbl_if_dualboot_info_type_v2);
+
+	return 0;
+}
+
+static int getbinary_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, getbinary_show, PDE_DATA(inode));
+}
+
+static const struct file_operations getbinary_ops = {
+	.open		= getbinary_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int part_upgradepartition_show(struct seq_file *m, void *v)
+{
+	struct per_part_info *part_info_t = m->private;
+
+	/*
+	 * In case of NOR\NAND, SBLs change the names of paritions in
+	 * such a way that the partition to upgrade is always suffixed
+	 * by _1. This is not the case in eMMC as paritions are read
+	 * from GPT and we have no control on it. So for eMMC we need
+	 * to check and generate the name wheres for NOR\NAND it is
+	 * always _1 SBLs should be modified not to change partition
+	 * names so that it is consistent with GPT. Till that is done
+	 * we will take care of it here.
+	 */
+
+	if (flash_type && (part_info_t->primaryboot))
+		seq_printf(m, "%s\n", part_info_t->name);
+	else
+		seq_printf(m, "%s_1\n", part_info_t->name);
+
+	return 0;
+
+}
+
+static int part_upgradepartition_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, part_upgradepartition_show, PDE_DATA(inode));
+}
+
+static const struct file_operations upgradepartition_ops = {
+	.open		= part_upgradepartition_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+static ssize_t part_primaryboot_write(struct file *file,
+				       const char __user *user,
+				       size_t count, loff_t *data)
+{
+	int ret;
+	char optstr[64];
+	struct per_part_info *part_entry;
+	unsigned long val;
+
+	part_entry = PDE_DATA(file_inode(file));
+
+	if (count == 0 || count > sizeof(optstr))
+		return -EINVAL;
+
+	ret = copy_from_user(optstr, user, count);
+	if (ret)
+		return ret;
+
+	optstr[count - 1] = '\0';
+
+	ret = kstrtoul(optstr, 0, &val);
+	if (ret)
+		return ret;
+
+	part_entry->primaryboot = val;
+
+	return count;
+
+}
+
+static int part_primaryboot_show(struct seq_file *m, void *v)
+{
+	struct per_part_info *part_entry;
+
+	part_entry = m->private;
+	seq_printf(m, "%x\n", part_entry->primaryboot);
+	return 0;
+}
+
+static int part_primaryboot_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, part_primaryboot_show, PDE_DATA(inode));
+}
+
+static const struct file_operations primaryboot_ops = {
+	.open		= part_primaryboot_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.write		= part_primaryboot_write,
+};
+
+
+struct sbl_if_dualboot_info_type_v2 *read_bootconfig_mtd(
+						struct mtd_info *master,
+						uint64_t offset)
+{
+
+	size_t retlen = 0;
+	struct sbl_if_dualboot_info_type_v2 *bootconfig_mtd;
+	int ret;
+
+	bootconfig_mtd = kmalloc(sizeof(struct sbl_if_dualboot_info_type_v2),
+				   GFP_ATOMIC);
+
+	if (!bootconfig_mtd)
+		return NULL;
+
+	ret = mtd_read(master, offset,
+			sizeof(struct sbl_if_dualboot_info_type_v2),
+			&retlen, (void *)bootconfig_mtd);
+	if (ret < 0) {
+		pr_alert("error occured while reading from \"%s\"\n",
+				master->name);
+		bootconfig_mtd = NULL;
+		kfree(bootconfig_mtd);
+		return NULL;
+	}
+
+	if (bootconfig_mtd->magic_start != SMEM_DUAL_BOOTINFO_MAGIC_START) {
+		pr_alert("Magic not found in \"%s\"\n", master->name);
+		kfree(bootconfig_mtd);
+		return NULL;
+	}
+
+	return bootconfig_mtd;
+}
+
+struct sbl_if_dualboot_info_type_v2 *read_bootconfig_emmc(struct gendisk *disk,
+						struct hd_struct *part)
+{
+	sector_t n;
+	Sector sect;
+	int ret;
+	unsigned char *data;
+	struct sbl_if_dualboot_info_type_v2 *bootconfig_emmc;
+	unsigned ssz;
+	struct block_device *bdev = NULL;
+
+	bdev = bdget_disk(disk, 0);
+	if (!bdev)
+		return NULL;
+
+	bdev->bd_invalidated = 1;
+	ret = blkdev_get(bdev, FMODE_READ , NULL);
+	if (ret)
+		return NULL;
+
+	ssz = bdev_logical_block_size(bdev);
+	bootconfig_emmc = kmalloc(ssz, GFP_ATOMIC);
+	if (!bootconfig_emmc)
+		return NULL;
+
+	n =  part->start_sect * (bdev_logical_block_size(bdev) / 512);
+	data = read_dev_sector(bdev, n, &sect);
+	put_dev_sector(sect);
+	blkdev_put(bdev, FMODE_READ);
+	if (!data) {
+		kfree(bootconfig_emmc);
+		return NULL;
+	}
+
+	memcpy(bootconfig_emmc, data, 512);
+
+	return bootconfig_emmc;
+}
+
+#define BOOTCONFIG_PARTITION	"0:BOOTCONFIG"
+#define BOOTCONFIG_PARTITION1	"0:BOOTCONFIG1"
+
+static int __init bootconfig_partition_init(void)
+{
+	struct per_part_info *part_info;
+	int i;
+	struct gendisk *disk = NULL;
+	struct disk_part_iter piter;
+	struct hd_struct *part;
+	struct mtd_info *mtd;
+	int partno;
+
+	mtd = get_mtd_device_nm(BOOTCONFIG_PARTITION);
+	if (!IS_ERR(mtd)) {
+
+		bootconfig1 = read_bootconfig_mtd(mtd, 0);
+		mtd = get_mtd_device_nm(BOOTCONFIG_PARTITION1);
+		if (IS_ERR(mtd)) {
+			pr_alert("%s: " BOOTCONFIG_PARTITION1 " not found\n",
+				__func__);
+			return 0;
+		}
+
+		bootconfig2 = read_bootconfig_mtd(mtd, 0);
+	} else {
+		disk = get_gendisk(MKDEV(MMC_BLOCK_MAJOR, 0), &partno);
+		if (!disk)
+			return 0;
+
+		disk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);
+		while ((part = disk_part_iter_next(&piter))) {
+
+			if (part->info) {
+				if (!strcmp((char *)part->info->volname,
+						BOOTCONFIG_PARTITION)) {
+					bootconfig1 = read_bootconfig_emmc(disk,
+									part);
+				}
+
+				if (!strcmp((char *)part->info->volname,
+						BOOTCONFIG_PARTITION1)) {
+					bootconfig2 = read_bootconfig_emmc(disk,
+									 part);
+					flash_type = 1;
+				}
+			}
+		}
+		disk_part_iter_exit(&piter);
+
+	}
+
+	if (!bootconfig1)
+		return 0;
+
+	if (!bootconfig2)
+		return 0;
+
+	if (bootconfig1->age > bootconfig2->age) {
+		part_info = (struct per_part_info *)bootconfig1->per_part_entry;
+		bootconfig2->age ^= bootconfig1->age;
+		bootconfig1->age ^= bootconfig2->age;
+		bootconfig2->age ^= bootconfig1->age;
+		num_parts = bootconfig1->numaltpart;
+	} else {
+		part_info = (struct per_part_info *)bootconfig2->per_part_entry;
+		bootconfig1->age ^= bootconfig2->age;
+		bootconfig2->age ^= bootconfig1->age;
+		bootconfig1->age ^= bootconfig2->age;
+		num_parts = bootconfig2->numaltpart;
+	}
+
+	boot_info_dir = proc_mkdir("boot_info", NULL);
+	if (!boot_info_dir)
+		return 0;
+
+	for (i = 0; i < num_parts; i++) {
+		if (!flash_type &&
+				(strncmp(part_info[i].name, "kernel",
+					ALT_PART_NAME_LENGTH) == 0))
+			continue;
+
+		partname_dir[i] = proc_mkdir(part_info[i].name, boot_info_dir);
+		if (partname_dir != NULL) {
+			proc_create_data("primaryboot", S_IRUGO,
+					   partname_dir[i],
+					   &primaryboot_ops,
+					   part_info + i);
+			proc_create_data("upgradepartition", S_IRUGO,
+					   partname_dir[i],
+					   &upgradepartition_ops,
+					   part_info + i);
+		}
+	}
+
+	proc_create_data("getbinary_bootconfig", S_IRUGO, boot_info_dir,
+			&getbinary_ops, bootconfig1);
+	proc_create_data("getbinary_bootconfig1", S_IRUGO, boot_info_dir,
+			&getbinary_ops, bootconfig2);
+
+	return 0;
+}
+module_init(bootconfig_partition_init);
+
+static void __exit bootconfig_partition_exit(void)
+{
+	struct per_part_info *part_info;
+	int i;
+
+	if (!bootconfig1)
+		return;
+
+	if (!bootconfig2)
+		return;
+
+	part_info = (struct per_part_info *)bootconfig1->per_part_entry;
+	for (i = 0; i < num_parts; i++) {
+		if (!flash_type &&
+				(strncmp(part_info[i].name, "kernel",
+					ALT_PART_NAME_LENGTH) == 0))
+			continue;
+
+		remove_proc_entry("primaryboot", partname_dir[i]);
+		remove_proc_entry("upgradepartition", partname_dir[i]);
+		remove_proc_entry(part_info[i].name, boot_info_dir);
+	}
+	remove_proc_entry("getbinary_bootconfig", boot_info_dir);
+	remove_proc_entry("getbinary_bootconfig1", boot_info_dir);
+	remove_proc_entry("boot_info", NULL);
+	kfree(bootconfig1);
+	kfree(bootconfig2);
+}
+
+module_exit(bootconfig_partition_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
diff -Naur -x .git linux-3.14.43.org/drivers/platform/msm/bootconfig.h linux-3.14.43/drivers/platform/msm/bootconfig.h
--- linux-3.14.43.org/drivers/platform/msm/bootconfig.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/drivers/platform/msm/bootconfig.h	2016-02-02 11:43:20.588574814 +0800
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BOOTCONFIG_H_
+#define _BOOTCONFIG_H_
+
+#define BOOTCONFIG_PART_IDX_MAX 21
+
+#define ALT_PART_NAME_LENGTH 16
+struct per_part_info {
+	char name[ALT_PART_NAME_LENGTH];
+	uint32_t primaryboot;
+};
+
+#define NUM_ALT_PARTITION 8
+
+/* version 2 */
+#define SMEM_DUAL_BOOTINFO_MAGIC_START 0xA3A2A1A0
+#define SMEM_DUAL_BOOTINFO_MAGIC_END 0xB3B2B1B0
+
+struct sbl_if_dualboot_info_type_v2 {
+	uint32_t magic_start;
+	uint32_t age;
+	uint32_t numaltpart;
+	struct per_part_info per_part_entry[NUM_ALT_PARTITION];
+	uint32_t magic_end;
+} __packed;
+
+#endif /* _BOOTCONFIG_H_ */
+
diff -Naur -x .git linux-3.14.43.org/drivers/platform/msm/Kconfig linux-3.14.43/drivers/platform/msm/Kconfig
--- linux-3.14.43.org/drivers/platform/msm/Kconfig	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/platform/msm/Kconfig	2016-02-02 11:43:20.584574853 +0800
@@ -55,5 +55,12 @@
 	  directionality of connections by explicitly listing device connections
 	  thus avoiding illegal routes.
 
+config BOOTCONFIG_PARTITION
+	tristate "BOOTCONFIG Partition support"
+	help
+	  Say Y here if you would like to use hard disks under Linux which
+	  were partitioned using MTD/EFI.
+
+
 endmenu
 
diff -Naur -x .git linux-3.14.43.org/drivers/platform/msm/Makefile linux-3.14.43/drivers/platform/msm/Makefile
--- linux-3.14.43.org/drivers/platform/msm/Makefile	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/platform/msm/Makefile	2016-02-02 11:43:20.584574853 +0800
@@ -5,3 +5,4 @@
 obj-$(CONFIG_SPS) += sps/
 obj-$(CONFIG_MSM_BUS_SCALING) += msm_bus/
 obj-$(CONFIG_BUS_TOPOLOGY_ADHOC) += msm_bus/
+obj-$(CONFIG_BOOTCONFIG_PARTITION) += bootconfig.o
diff -Naur -x .git linux-3.14.43.org/drivers/soc/qcom/Kconfig linux-3.14.43/drivers/soc/qcom/Kconfig
--- linux-3.14.43.org/drivers/soc/qcom/Kconfig	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/soc/qcom/Kconfig	2016-02-02 11:43:20.816572511 +0800
@@ -76,3 +76,11 @@
           look at them in a RAM dump will give useless data. Select this if you
           want to dump the L1 and L2 caches on panic before any flush occurs.
           If unsure, say N
+
+config QCOM_TZ_LOG
+	tristate "Trust Zone (TZ) Log Driver"
+	depends on DEBUG_FS
+	help
+	  This option enables a driver with a debugfs interface for messages
+	  produced by the Secure code (Trust zone). These messages provide
+	  diagnostic information about TZ operation.
diff -Naur -x .git linux-3.14.43.org/drivers/soc/qcom/Makefile linux-3.14.43/drivers/soc/qcom/Makefile
--- linux-3.14.43.org/drivers/soc/qcom/Makefile	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/soc/qcom/Makefile	2016-02-02 11:43:20.816572511 +0800
@@ -5,3 +5,4 @@
 obj-$(CONFIG_QCOM_RESTART_REASON) += restart_reason.o
 obj-$(CONFIG_QCA_SCM_RESTART_REASON) += scm_restart_reason.o
 obj-$(CONFIG_QCOM_CACHE_DUMP) += cache_dump.o
+obj-$(CONFIG_QCOM_TZ_LOG) += tz_log.o
diff -Naur -x .git linux-3.14.43.org/drivers/soc/qcom/tz_log.c linux-3.14.43/drivers/soc/qcom/tz_log.c
--- linux-3.14.43.org/drivers/soc/qcom/tz_log.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/drivers/soc/qcom/tz_log.c	2016-02-02 11:43:20.816572511 +0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/debugfs.h> /* this is for DebugFS libraries */
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <soc/qcom/scm.h>
+#include <linux/slab.h>
+
+#define BUF_LEN 0x1000
+#define TZ_INFO_GET_DIAG_ID 0x2
+
+struct dentry *dirret, *fileret;
+
+static char ker_buf[BUF_LEN] __aligned(4096), tmp_buf[BUF_LEN];
+
+struct tzbsp_log_pos_t {
+	uint16_t wrap;		/* Ring buffer wrap-around ctr */
+	uint16_t offset;	/* Ring buffer current position */
+};
+
+struct tzbsp_diag_log_t {
+	struct tzbsp_log_pos_t log_pos;	/* Ring buffer position mgmt */
+	uint8_t log_buf[1];		/* Open ended array to the end
+					 * of the 4K IMEM buffer
+					 */
+};
+
+struct tzbsp_diag_t {
+	uint32_t unused[7];	/* Unused variable is to support the
+				 * corresponding structure in trustzone
+				 */
+	uint32_t ring_off;
+	uint32_t unused1[514];
+	struct tzbsp_diag_log_t log;
+};
+
+struct log_read {
+	uint32_t log_buf;
+	uint32_t buf_size;
+};
+
+/* Read file operation */
+static ssize_t tz_log_read(struct file *fp, char __user *user_buffer,
+				size_t count, loff_t *position)
+{
+	int ret;
+	struct log_read rdip;
+	struct tzbsp_diag_t *tz_diag;
+	uint16_t offset;
+	uint16_t ring;
+
+	rdip.buf_size = BUF_LEN;
+	rdip.log_buf = dma_map_single(NULL, ker_buf, BUF_LEN, DMA_FROM_DEVICE);
+	ret = dma_mapping_error(NULL, rdip.log_buf);
+	if (ret != 0) {
+		pr_err("DMA Mapping Error : %d\n", ret);
+		return -EINVAL;
+	}
+
+	/* SCM call to TZ to get the tz log */
+	ret = scm_call(SCM_SVC_INFO, TZ_INFO_GET_DIAG_ID,
+		&rdip, sizeof(struct log_read),  NULL, 0);
+	dma_unmap_single(NULL, rdip.log_buf, BUF_LEN, DMA_FROM_DEVICE);
+	if (ret != 0) {
+		pr_err("Error in getting tz log : %d\n", ret);
+		return -EINVAL;
+	}
+
+	tz_diag = (struct tzbsp_diag_t *)ker_buf;
+	offset = tz_diag->log.log_pos.offset;
+	ring = tz_diag->ring_off;
+
+	if (tz_diag->log.log_pos.wrap != 0) {
+		memcpy(tmp_buf, (ker_buf + offset + ring),
+					(BUF_LEN - offset - ring));
+		memcpy(tmp_buf + (BUF_LEN - offset - ring), (ker_buf + ring),
+					offset);
+	} else {
+		memcpy(tmp_buf, (ker_buf + ring), offset);
+	}
+
+	return simple_read_from_buffer(user_buffer, count,
+					position, tmp_buf, BUF_LEN);
+}
+
+static const struct file_operations fops_tz_log = {
+	.read = tz_log_read,
+};
+
+static int __init init_tz_log(void)
+{
+	int filevalue;
+	dirret = debugfs_create_dir("qcom_debug_logs", NULL);
+	fileret = debugfs_create_file("tz_log", 0444, dirret,
+					&filevalue, &fops_tz_log);
+	return 0;
+}
+
+static void __exit exit_tz_log(void)
+{
+	/* removing the directory recursively which
+	in turn cleans all the file */
+	debugfs_remove_recursive(dirret);
+}
+
+module_init(init_tz_log);
+module_exit(exit_tz_log);
diff -Naur -x .git linux-3.14.43.org/drivers/spi/spi-qup.c linux-3.14.43/drivers/spi/spi-qup.c
--- linux-3.14.43.org/drivers/spi/spi-qup.c	2015-12-02 04:03:06.000000000 +0800
+++ linux-3.14.43/drivers/spi/spi-qup.c	2016-02-02 11:43:20.824572429 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2014, The Linux foundation. All rights reserved.
+ * Copyright (c) 2008-2015, The Linux foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License rev 2 and
@@ -850,6 +850,9 @@
 
 	dev = &pdev->dev;
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -EINVAL;
+
 	base = devm_ioremap_resource(dev, res);
 	if (IS_ERR(base))
 		return PTR_ERR(base);
@@ -971,14 +974,10 @@
 
 	/* allocate dma resources, if available */
 	controller->rx_chan = dma_request_slave_channel(&pdev->dev, "rx");
-	if (controller->rx_chan) {
-		controller->tx_chan =
-			dma_request_slave_channel(&pdev->dev, "tx");
+	controller->tx_chan = dma_request_slave_channel(&pdev->dev, "tx");
+
+	if (controller->rx_chan && controller->tx_chan) {
 
-		if (!controller->tx_chan) {
-			dev_err(&pdev->dev, "Failed to allocate dma tx chan");
-			dma_release_channel(controller->rx_chan);
-		}
 
 		/* set DMA parameters */
 		controller->rx_conf.device_fc = 1;
@@ -1005,17 +1004,34 @@
 			dma_release_channel(controller->tx_chan);
 			controller->tx_chan = NULL;
 			controller->rx_chan = NULL;
-		}
-
-		controller->dummy = dma_alloc_writecombine(controller->dev,
+		} else {
+			controller->dummy = dma_alloc_writecombine(
+				controller->dev,
 				controller->in_blk_sz + controller->out_blk_sz,
 				&controller->dummy_phys, GFP_KERNEL);
 
-		if (!controller->dummy) {
+			if (!controller->dummy) {
+				dev_err(&pdev->dev,
+					"failed to allocate DMA memory\n");
+
+				dma_release_channel(controller->rx_chan);
+				dma_release_channel(controller->tx_chan);
+				controller->tx_chan = NULL;
+				controller->rx_chan = NULL;
+			}
+		}
+	} else {
+		if (controller->rx_chan) {
 			dma_release_channel(controller->rx_chan);
+			controller->rx_chan = NULL;
+		} else {
+			dev_err(&pdev->dev, "Failed to allocate dma rx chan");
+		}
+		if (controller->tx_chan) {
 			dma_release_channel(controller->tx_chan);
 			controller->tx_chan = NULL;
-			controller->rx_chan = NULL;
+		} else {
+			dev_err(&pdev->dev, "Failed to allocate dma tx chan");
 		}
 	}
 
diff -Naur -x .git linux-3.14.43.org/drivers/staging/mt29f_spinand/mt29f_spinand.c linux-3.14.43/drivers/staging/mt29f_spinand/mt29f_spinand.c
--- linux-3.14.43.org/drivers/staging/mt29f_spinand/mt29f_spinand.c	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/drivers/staging/mt29f_spinand/mt29f_spinand.c	2016-02-02 11:43:20.976570896 +0800
@@ -81,7 +81,7 @@
 	},
 	{
 		NAND_MFR_WINBOND,
-		0xaa21,
+		0xaa,
 		gigadevice_set_defaults,
 		gigadevice_read_cmd,
 		winbond_read_data,
@@ -280,11 +280,11 @@
 static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 {
 	int retval;
-	u8 nand_id[4];
+	u8 nand_id[3];
 	struct spinand_cmd cmd = {0};
 
 	cmd.cmd = CMD_READ_ID;
-	cmd.n_rx = 4;
+	cmd.n_rx = 3;
 	cmd.rx_buf = &nand_id[0];
 
 	retval = spinand_cmd(spi_nand, &cmd);
@@ -294,7 +294,6 @@
 	}
 	id[0] = nand_id[1];
 	id[1] = nand_id[2];
-	id[2] = nand_id[3];
 	spinand_parse_id(spi_nand, nand_id, id);
 	return retval;
 }
diff -Naur -x .git linux-3.14.43.org/drivers/thermal/thermal_core.c linux-3.14.43/drivers/thermal/thermal_core.c
--- linux-3.14.43.org/drivers/thermal/thermal_core.c	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/drivers/thermal/thermal_core.c	2016-02-02 11:43:21.140569241 +0800
@@ -1107,7 +1107,7 @@
 release_idr:
 	release_idr(&tz->idr, &tz->lock, dev->id);
 free_mem:
-	kfree(dev);
+	devm_kfree(&cdev->device, dev);
 	return result;
 }
 EXPORT_SYMBOL_GPL(thermal_zone_bind_cooling_device);
@@ -1368,7 +1368,6 @@
 
 	release_idr(&thermal_cdev_idr, &thermal_idr_lock, cdev->id);
 	device_unregister(&cdev->device);
-	kfree(cdev);
 
 	return;
 }
diff -Naur -x .git linux-3.14.43.org/drivers/thermal/thermal_hwmon.c linux-3.14.43/drivers/thermal/thermal_hwmon.c
--- linux-3.14.43.org/drivers/thermal/thermal_hwmon.c	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/drivers/thermal/thermal_hwmon.c	2016-02-02 11:43:21.140569241 +0800
@@ -62,7 +62,7 @@
 name_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct thermal_hwmon_device *hwmon = dev_get_drvdata(dev);
-	return sprintf(buf, "%s\n", hwmon->type);
+	return snprintf(buf, PAGE_SIZE, "%s\n", hwmon->type);
 }
 static DEVICE_ATTR(name, 0444, name_show, NULL);
 
@@ -83,7 +83,7 @@
 	if (ret)
 		return ret;
 
-	return sprintf(buf, "%ld\n", temperature);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", temperature);
 }
 
 static ssize_t
@@ -102,7 +102,7 @@
 	if (ret)
 		return ret;
 
-	return sprintf(buf, "%ld\n", temperature);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", temperature);
 }
 
 
diff -Naur -x .git linux-3.14.43.org/drivers/tty/serial/msm_serial_hs.c linux-3.14.43/drivers/tty/serial/msm_serial_hs.c
--- linux-3.14.43.org/drivers/tty/serial/msm_serial_hs.c	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/drivers/tty/serial/msm_serial_hs.c	2016-02-02 11:43:21.156569080 +0800
@@ -2981,7 +2981,7 @@
 	match = of_match_device(msm_hs_match_table, &pdev->dev);
 	if (!match) {
 		pr_err("Plaform device ID mismatch = %d\n", pdev->id);
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata) {
@@ -3461,11 +3461,11 @@
 			return -ENXIO;
 		/* adm crci mux cfg*/
 		if (of_property_read_u32(node, "qcom,tcsr_adm_mux_sel_reg",
-					&msm_uport->tcsr_adm_mux_sel_reg) ||
+					(u32 *)&msm_uport->tcsr_adm_mux_sel_reg) ||
 		   of_property_read_u32(node, "qcom,tcsr_adm_mux_sel_reg_mask",
 					&msm_uport->tcsr_adm_mux_sel_reg_mask) ||
 		   of_property_read_u32(node, "qcom,tcsr_adm_mux_sel_reg_value",
-					&msm_uport->tcsr_adm_mux_sel_reg_value)) {
+					(u32 *)&msm_uport->tcsr_adm_mux_sel_reg_value)) {
 			dev_err(msm_uport->uport.dev,
 				"adm crici mux configuration not done\n");
 		} else {
diff -Naur -x .git linux-3.14.43.org/include/linux/aq_phy.h linux-3.14.43/include/linux/aq_phy.h
--- linux-3.14.43.org/include/linux/aq_phy.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/include/linux/aq_phy.h	2016-02-02 11:43:21.628564323 +0800
@@ -0,0 +1,118 @@
+/*
+ * AQ105 PHY driver header file
+ *
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef AQ_PHY_H
+#define AQ_PHY_H
+
+/* AQ PHY stats register format structure */
+struct aq_stats_reg {
+	uint32_t regaddr_lsw;	/* Stats reg address, lower 16-Bit */
+	uint32_t regaddr_msw;	/* Stats reg address, Upper 16-Bit */
+	uint32_t regval;	/* Register Value */
+};
+
+/* AQ PHY stats structure */
+struct aq_stats {
+	struct aq_stats_reg line_tx_good; /* Line side good packets TXed */
+	struct aq_stats_reg line_tx_bad;  /* Line side bad packets TXed */
+	struct aq_stats_reg line_rx_good; /* Line side good packets RXed */
+	struct aq_stats_reg line_rx_bad;  /* Line side bad packets RXed */
+	struct aq_stats_reg sys_tx_good;  /* Sys side good packets TXed */
+	struct aq_stats_reg sys_tx_bad;   /* Sys side bad packets TXed */
+	struct aq_stats_reg sys_rx_good;  /* Sys side good packets RXed */
+	struct aq_stats_reg sys_rx_bad;   /* Sys side bad packets RXed */
+};
+
+/* Board specific data structure */
+struct aq_phy_platform_data {
+	uint16_t phy_addr;		/* AQ PHY Address */
+	uint32_t mdio_bus_id;		/* MDIO Bus number where AQ
+					   PHY is connected */
+	char *mdio_bus_name;		/* MDIO bus name */
+};
+
+/* AQ Phy Stats Registers addresses */
+#define AQ_LINE_SIDE_TX_GOOD_REG_LSW  0X3C820
+#define AQ_LINE_SIDE_TX_GOOD_REG_MSW  0X3C821
+#define AQ_LINE_SIDE_TX_BAD_REG_LSW  0X3C822
+#define AQ_LINE_SIDE_TX_BAD_REG_MSW  0X3C823
+
+#define AQ_LINE_SIDE_RX_GOOD_REG_LSW  0X3E812
+#define AQ_LINE_SIDE_RX_GOOD_REG_MSW  0X3E813
+#define AQ_LINE_SIDE_RX_BAD_REG_LSW  0X3E814
+#define AQ_LINE_SIDE_RX_BAD_REG_MSW  0X3E815
+
+#define AQ_SYS_SIDE_TX_GOOD_REG_LSW  0X1DD303
+#define AQ_SYS_SIDE_TX_GOOD_REG_MSW  0X1DD304
+#define AQ_SYS_SIDE_TX_BAD_REG_LSW  0X1DD305
+#define AQ_SYS_SIDE_TX_BAD_REG_MSW  0X1DD306
+
+#define AQ_SYS_SIDE_RX_GOOD_REG_LSW  0X1DD282
+#define AQ_SYS_SIDE_RX_GOOD_REG_MSW  0X1DD283
+#define AQ_SYS_SIDE_RX_BAD_REG_LSW  0X1DD284
+#define AQ_SYS_SIDE_RX_BAD_REG_MSW  0X1DD285
+
+/*
+ * The AQ device mask and ID. The last four bits comprise
+ * the revision ID, while the rest of the bits comprise
+ * the organization ID and the model ID
+ */
+#define AQ_DEVICE_ID_MASK 0xFFFFFFF0
+#define AQ_DEVICE_ID 0x03a1b4a0
+
+/* PMD Line side Rx signal detect register */
+#define AQ_PHY_PMD_SIGNAL_DETECT_REG	0xa
+
+/* Mask and Bit definition for AQ_PHY_PMD_SIGNAL_DETECT_REG */
+#define AQ_PHY_PMD_SIGNAL_DETECT_MASK	0x1
+
+/* Autonegotiation Vendor Status register */
+#define AQ_PHY_LINK_REG		0xC800
+
+/* Mask and Bit definition for AQ_PHY_LINK_REG */
+#define AQ_PHY_LINK_DUPLEX_MASK	0x1
+#define AQ_PHY_LINK_SPEED_10000	0x3
+#define AQ_PHY_LINK_SPEED_5000	0x5
+#define AQ_PHY_LINK_SPEED_2500	0x4
+#define AQ_PHY_LINK_SPEED_1000	0x2
+#define AQ_PHY_LINK_SPEED_100	0x1
+#define AQ_PHY_LINK_SPEED_10	0x0
+
+/* Line side link status register */
+#define AQ_PHY_PMA_RX_LINK_CURRENT_STATUS_REG	0xE800
+
+/* Mask and Bit definition for AQ_PHY_PMA_RX_LINK_CURRENT_STATUS_REG */
+#define AQ_PHY_PMA_RX_LINK_CURRENT_STATUS_MASK	0x1
+
+/* PMA reg to check FW is loaded properly and PHY is out of reset */
+#define AQ_PHY_PMA_STANDARD_CTRL_1_REG	0
+
+/* Mask and Bit definition for AQ_PHY_PMA_STANDARD_CTRL_1_REG */
+#define AQ_PHY_PMA_STANDARD_CTRL_1_MASK	0x8000
+
+/*
+ * Maximum string length:
+ * This should be equal to maximum string size of any stats
+ * inclusive of stats value
+ */
+#define AQ_PHY_STATS_MAX_STR_LENGTH 50
+
+/* Maximum number of lines to be printed at console device */
+#define AQ_PHY_STATS_MAX_OUTPUT_LINE 10
+
+#endif /*AQ_PHY_H */
diff -Naur -x .git linux-3.14.43.org/include/linux/if_bridge.h linux-3.14.43/include/linux/if_bridge.h
--- linux-3.14.43.org/include/linux/if_bridge.h	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/include/linux/if_bridge.h	2016-02-02 11:43:21.656564041 +0800
@@ -33,7 +33,8 @@
 struct net_bridge_port;
 
 extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
-extern struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr);
+extern struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
+		struct sk_buff *skb);
 extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
 extern void br_dev_update_stats(struct net_device *dev, struct rtnl_link_stats64 *nlstats);
 extern bool br_fdb_has_entry(struct net_device *dev, const char *addr, __u16 vid);
@@ -62,6 +63,10 @@
 		struct sk_buff **skb);
 extern br_get_dst_hook_t __rcu *br_get_dst_hook;
 
+typedef struct net_bridge_port *br_port_dev_get_hook_t(struct net_device *dev,
+		struct sk_buff *skb);
+extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
+
 typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
 extern br_notify_hook_t __rcu *br_notify_hook;
 #endif
diff -Naur -x .git linux-3.14.43.org/include/linux/if_pppox.h linux-3.14.43/include/linux/if_pppox.h
--- linux-3.14.43.org/include/linux/if_pppox.h	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/include/linux/if_pppox.h	2016-02-02 11:43:21.656564041 +0800
@@ -125,5 +125,10 @@
 /* Return netdevice associated with the session id and remote mac address */
 extern struct net_device *pppoe_get_and_hold_netdev_from_session_info(uint16_t sid, uint8_t *mac);
 
+/* Lookup PPTP session info and return PPTP session */
+extern int pptp_session_find(struct pptp_opt *opt, __be16 peer_call_id, __be32 peer_ip_addr);
+
+/* Return PPTP session information given the channel */
+extern void pptp_channel_addressing_get(struct pptp_opt *opt, struct ppp_channel *chan);
 
 #endif /* !(__LINUX_IF_PPPOX_H) */
diff -Naur -x .git linux-3.14.43.org/include/linux/mmc/sdhci.h linux-3.14.43/include/linux/mmc/sdhci.h
--- linux-3.14.43.org/include/linux/mmc/sdhci.h	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/include/linux/mmc/sdhci.h	2016-02-02 11:43:21.688563718 +0800
@@ -100,6 +100,12 @@
 #define SDHCI_QUIRK2_BROKEN_HOST_CONTROL		(1<<5)
 /* Controller does not support HS200 */
 #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
+/*
+ * Dont use the max_discard_to in sdhci driver so that the maximum discard
+ * unit gets picked by the mmc queue. Otherwise, it takes a long time for
+ * secure discard kind of operations to complete.
+ */
+#define SDHCI_QUIRK2_USE_MAX_DISCARD_SIZE		(1<<7)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
diff -Naur -x .git linux-3.14.43.org/include/linux/qca_85xx_sw.h linux-3.14.43/include/linux/qca_85xx_sw.h
--- linux-3.14.43.org/include/linux/qca_85xx_sw.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.43/include/linux/qca_85xx_sw.h	2016-02-02 11:43:21.716563436 +0800
@@ -0,0 +1,114 @@
+/*
+ * QCA 85xx switch driver platform data
+ *
+ * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef QCA_85XX_SW_H
+#define QCA_85XX_SW_H
+
+#define QCA_85XX_MAX_TRUNKS	8
+#define QCA_85XX_MAX_PORTS	30
+#define QCA_85XX_VLAN_ID_MAX	4094
+#define QCA_85XX_MAX_VLANS	4095
+
+/* Device IDS for the 85xx switch family */
+enum {
+	QCA_85XX_SW_ID_QCA8511 = 0x01,
+	QCA_85XX_SW_ID_QCA8512 = 0x02,
+	QCA_85XX_SW_ID_QCA8513 = 0x03,
+	QCA_85XX_SW_ID_QCA8519 = 0x04,
+};
+
+/* GMAC port modes */
+enum qca_85xx_sw_port_mode {
+	QCA_85XX_SW_PORT_MODE_NOT_CONFIGURED = 0,
+	QCA_85XX_SW_PORT_MODE_QSGMII = 1,
+	QCA_85XX_SW_PORT_MODE_SGMII = 2,
+	QCA_85XX_SW_PORT_MODE_SGMII_PLUS = 3,
+	QCA_85XX_SW_PORT_MODE_XAUI = 4,
+};
+
+/* QSGMII port platform configuration data */
+struct qca_85xx_sw_qsgmii_cfg {
+	enum qca_85xx_sw_port_mode port_mode;
+	uint32_t port_base;
+	bool is_speed_forced;
+	uint32_t forced_speed;
+	uint32_t forced_duplex;
+};
+
+/* SGMII port platform configuration data */
+struct qca_85xx_sw_sgmii_cfg {
+	enum qca_85xx_sw_port_mode port_mode;
+	bool is_speed_forced;
+	uint32_t forced_speed;
+	uint32_t forced_duplex;
+};
+
+/* Platform configuration data for LAG trunk */
+struct qca_85xx_sw_trunk_cfg {
+	bool is_trunk_enabled;
+	uint32_t trunk_id;
+	uint32_t trunk_hash_policy;
+	uint32_t trunk_ports_bit_map;
+};
+
+/* 85xx Switch platform configuration */
+struct qca_85xx_sw_platform_data {
+	const char	*mdio_bus_name;
+	const char	*sgmii_plus_if_mdio_bus_name;
+	int		mdio_bus_id;
+	int		sgmii_plus_if_phy_mdio_bus_id;
+	uint32_t	sgmii_plus_if_phy_addr;
+	uint32_t	chip_id;
+	struct qca_85xx_sw_qsgmii_cfg qsgmii_cfg;
+	struct qca_85xx_sw_sgmii_cfg port_24_cfg;
+	struct qca_85xx_sw_sgmii_cfg port_25_cfg;
+	struct qca_85xx_sw_sgmii_cfg port_26_cfg;
+	struct qca_85xx_sw_sgmii_cfg port_27_cfg;
+	struct qca_85xx_sw_sgmii_cfg port_28_cfg;
+	struct qca_85xx_sw_sgmii_cfg port_29_cfg;
+	struct qca_85xx_sw_trunk_cfg trunk_cfg;
+};
+
+/* 85xx Switch GMAC port IDs */
+enum qca_85xx_sw_gmac_port {
+	QCA_85XX_SW_PORT_1 = 1,
+	QCA_85XX_SW_PORT_5 = 5,
+	QCA_85XX_SW_PORT_9 = 9,
+	QCA_85XX_SW_PORT_13 = 13,
+	QCA_85XX_SW_PORT_17 = 17,
+	QCA_85XX_SW_PORT_21 = 21,
+	QCA_85XX_SW_PORT_23 = 23,
+	QCA_85XX_SW_PORT_24 = 24,
+	QCA_85XX_SW_PORT_25 = 25,
+	QCA_85XX_SW_PORT_26 = 26,
+	QCA_85XX_SW_PORT_27 = 27,
+	QCA_85XX_SW_PORT_28 = 28,
+	QCA_85XX_SW_PORT_29 = 29,
+};
+
+/* Bit definitions for TRUNK_HASH_KEY_SEL register */
+#define TRUNK_L4_DST_PORT_INCL	0x1	/* Include L4 dst port for trunk hash */
+#define TRUNK_L4_SRC_PORT_INCL	0x2	/* Include L4 src port for trunk hash */
+#define TRUNK_DST_IP_INCL	0x4	/* Include dst IP address for trunk hash */
+#define TRUNK_SRC_IP_INCL	0x8	/* Include src IP address for trunk hash */
+#define TRUNK_L2_PROT_INCL	0x10	/* Include L2 protocol for trunk hash */
+#define TRUNK_MAC_DA_INCL	0x20	/* Include dst MAC address for trunk hash */
+#define TRUNK_MAC_SA_INCL	0x40	/* Include src MAC address for trunk hash */
+#define TRUNK_SRC_PORT_INCL	0x80	/* Include GMAC src port ID for trunk hash */
+
+#endif /* QCA_85XX_SW_H */
diff -Naur -x .git linux-3.14.43.org/include/net/ip6_route.h linux-3.14.43/include/net/ip6_route.h
--- linux-3.14.43.org/include/net/ip6_route.h	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/include/net/ip6_route.h	2016-02-02 11:43:21.760562993 +0800
@@ -123,6 +123,8 @@
 void rt6_mtu_change(struct net_device *dev, unsigned int mtu);
 void rt6_remove_prefsrc(struct inet6_ifaddr *ifp);
 
+int rt6_register_notifier(struct notifier_block *nb);
+int rt6_unregister_notifier(struct notifier_block *nb);
 
 /*
  *	Store a destination cache entry in a socket
diff -Naur -x .git linux-3.14.43.org/include/net/route.h linux-3.14.43/include/net/route.h
--- linux-3.14.43.org/include/net/route.h	2015-12-02 04:03:07.000000000 +0800
+++ linux-3.14.43/include/net/route.h	2016-02-02 11:43:21.772562872 +0800
@@ -193,6 +193,9 @@
 void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
 int ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
+int ip_rt_register_notifier(struct notifier_block *nb);
+int ip_rt_unregister_notifier(struct notifier_block *nb);
+
 struct in_ifaddr;
 void fib_add_ifaddr(struct in_ifaddr *);
 void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
diff -Naur -x .git linux-3.14.43.org/net/bridge/br_if.c linux-3.14.43/net/bridge/br_if.c
--- linux-3.14.43.org/net/bridge/br_if.c	2015-12-02 04:03:08.000000000 +0800
+++ linux-3.14.43/net/bridge/br_if.c	2016-02-02 11:43:21.952561058 +0800
@@ -1,16 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  **************************************************************************
  */
 
@@ -43,6 +33,10 @@
 
 #include "br_private.h"
 
+/* Hook for external forwarding logic */
+br_port_dev_get_hook_t __rcu *br_port_dev_get_hook __read_mostly;
+EXPORT_SYMBOL_GPL(br_port_dev_get_hook);
+
 /*
  * Determine initial path cost based on speed.
  * using recommendations from 802.1d standard
@@ -476,12 +470,16 @@
 
 /*
  * br_port_dev_get()
- *	Using the given addr, identify the port to which it is reachable,
+ *      If a skb is provided, and the br_port_dev_get_hook_t hook exists,
+ *      use that to try and determine the egress port for that skb.
+ *      If not, or no egress port could be determined, use the given addr
+ *      to identify the port to which it is reachable,
  *	returing a reference to the net device associated with that port.
  *
  * NOTE: Return NULL if given dev is not a bridge or the mac has no associated port
  */
-struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr)
+struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
+	struct sk_buff *skb)
 {
 	struct net_bridge_fdb_entry *fdbe;
 	struct net_bridge *br;
@@ -493,17 +491,41 @@
 	if (!(dev->priv_flags & IFF_EBRIDGE))
 		return NULL;
 
+	rcu_read_lock();
+
+	/*
+	 * If the hook exists and the skb isn't NULL, try and get the port
+	 */
+	if (skb) {
+		br_port_dev_get_hook_t *port_dev_get_hook;
+		port_dev_get_hook = rcu_dereference(br_port_dev_get_hook);
+		if (port_dev_get_hook) {
+			struct net_bridge_port *pdst =
+				__br_get(port_dev_get_hook, NULL, dev, skb);
+			if (pdst) {
+				dev_hold(pdst->dev);
+				netdev = pdst->dev;
+				goto out;
+			}
+		}
+	}
+
+	/*
+	 * Either there is no hook, or can't
+	 * determine the port to use - fall back to using FDB
+	 */
+
 	br = netdev_priv(dev);
 
 	/*
 	 * Lookup the fdb entry and get reference to the port dev
 	 */
-	rcu_read_lock();
 	fdbe = __br_fdb_get(br, addr, 0);
 	if (fdbe && fdbe->dst) {
 		netdev = fdbe->dst->dev; /* port device */
 		dev_hold(netdev);
 	}
+out:
 	rcu_read_unlock();
 	return netdev;
 }
diff -Naur -x .git linux-3.14.43.org/net/core/flow.c linux-3.14.43/net/core/flow.c
--- linux-3.14.43.org/net/core/flow.c	2015-12-02 04:03:08.000000000 +0800
+++ linux-3.14.43/net/core/flow.c	2016-02-02 11:43:21.964560937 +0800
@@ -204,6 +204,27 @@
 	return 0;
 }
 
+/* Take one entry back from the flow cache garbage, it will
+ * avoid that the flow cache become every large in some
+ * situation, e.g: heavy load delay the collect of the garbage
+ */
+static struct flow_cache_entry *flow_cache_reuse_entry(void)
+{
+	struct flow_cache_entry *fce = NULL;
+
+	spin_lock_bh(&flow_cache_gc_lock);
+	if (!list_empty(&flow_cache_gc_list)) {
+		fce = list_last_entry(&flow_cache_gc_list,
+				struct flow_cache_entry, u.gc_list);
+		list_del(&fce->u.gc_list);
+	}
+	spin_unlock_bh(&flow_cache_gc_lock);
+	if (fce && fce->object)
+		fce->object->ops->delete(fce->object);
+
+	return fce;
+}
+
 struct flow_cache_object *
 flow_cache_lookup(struct net *net, const struct flowi *key, u16 family, u8 dir,
 		  flow_resolve_t resolver, void *ctx)
@@ -248,7 +269,9 @@
 		if (fcp->hash_count > fc->high_watermark)
 			flow_cache_shrink(fc, fcp);
 
-		fle = kmem_cache_alloc(flow_cachep, GFP_ATOMIC);
+		fle = flow_cache_reuse_entry();
+		if (!fle)
+			fle = kmem_cache_alloc(flow_cachep, GFP_ATOMIC);
 		if (fle) {
 			fle->net = net;
 			fle->family = family;
@@ -448,7 +471,7 @@
 {
 	int i;
 
-	fc->hash_shift = 10;
+	fc->hash_shift = 12;
 	fc->low_watermark = 2 * flow_cache_hash_size(fc);
 	fc->high_watermark = 4 * flow_cache_hash_size(fc);
 
diff -Naur -x .git linux-3.14.43.org/net/ipv4/fib_trie.c linux-3.14.43/net/ipv4/fib_trie.c
--- linux-3.14.43.org/net/ipv4/fib_trie.c	2015-12-02 04:03:08.000000000 +0800
+++ linux-3.14.43/net/ipv4/fib_trie.c	2016-02-02 11:43:21.984560736 +0800
@@ -1158,6 +1158,9 @@
 	return fa_head;
 }
 
+/* Define route change notification chain. */
+static BLOCKING_NOTIFIER_HEAD(iproute_chain);
+
 /*
  * Caller must hold RTNL.
  */
@@ -1318,6 +1321,8 @@
 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, tb->tb_id,
 		  &cfg->fc_nlinfo, 0);
 succeeded:
+	blocking_notifier_call_chain(&iproute_chain,
+					RTM_NEWROUTE, fi);
 	return 0;
 
 out_free_new_fa:
@@ -1693,6 +1698,8 @@
 	if (fa->fa_state & FA_S_ACCESSED)
 		rt_cache_flush(cfg->fc_nlinfo.nl_net);
 
+	blocking_notifier_call_chain(&iproute_chain,
+					RTM_DELROUTE, fa->fa_info);
 	fib_release_info(fa->fa_info);
 	alias_free_mem_rcu(fa);
 	return 0;
@@ -1957,6 +1964,18 @@
 }
 
 
+int ip_rt_register_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&iproute_chain, nb);
+}
+EXPORT_SYMBOL(ip_rt_register_notifier);
+
+int ip_rt_unregister_notifier(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&iproute_chain, nb);
+}
+EXPORT_SYMBOL(ip_rt_unregister_notifier);
+
 struct fib_table *fib_trie_table(u32 id)
 {
 	struct fib_table *tb;
diff -Naur -x .git linux-3.14.43.org/net/ipv6/route.c linux-3.14.43/net/ipv6/route.c
--- linux-3.14.43.org/net/ipv6/route.c	2015-12-02 04:03:08.000000000 +0800
+++ linux-3.14.43/net/ipv6/route.c	2016-02-02 11:43:22.008560494 +0800
@@ -136,6 +136,9 @@
 	return __rt6_get_peer(rt, 1);
 }
 
+/* Define route change notification chain. */
+ATOMIC_NOTIFIER_HEAD(ip6route_chain);
+
 static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
 {
 	struct rt6_info *rt = (struct rt6_info *) dst;
@@ -884,6 +887,9 @@
 	err = fib6_add(&table->tb6_root, rt, info);
 	write_unlock_bh(&table->tb6_lock);
 
+	if (!err)
+		atomic_notifier_call_chain(&ip6route_chain,
+						RTM_NEWROUTE, rt);
 	return err;
 }
 
@@ -1744,6 +1750,9 @@
 	err = fib6_del(rt, info);
 	write_unlock_bh(&table->tb6_lock);
 
+	if (!err)
+		atomic_notifier_call_chain(&ip6route_chain,
+						RTM_DELROUTE, rt);
 out:
 	ip6_rt_put(rt);
 	return err;
@@ -2872,6 +2881,18 @@
 	return NOTIFY_OK;
 }
 
+int rt6_register_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&ip6route_chain, nb);
+}
+EXPORT_SYMBOL(rt6_register_notifier);
+
+int rt6_unregister_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&ip6route_chain, nb);
+}
+EXPORT_SYMBOL(rt6_unregister_notifier);
+
 /*
  *	/proc
  */
diff -Naur -x .git linux-3.14.43.org/net/l2tp/l2tp_ppp.c linux-3.14.43/net/l2tp/l2tp_ppp.c
--- linux-3.14.43.org/net/l2tp/l2tp_ppp.c	2015-12-02 04:03:08.000000000 +0800
+++ linux-3.14.43/net/l2tp/l2tp_ppp.c	2016-02-02 11:43:22.020560373 +0800
@@ -463,6 +463,8 @@
 	addr->local_addr.sin_addr.s_addr = isk->inet_saddr;
 	addr->remote_addr.sin_addr.s_addr = isk->inet_daddr;
 
+	addr->tunnel_version = tunnel->version;
+
 	sock_put(sk_tun);
 	sock_put(sk);
 	return 0;
