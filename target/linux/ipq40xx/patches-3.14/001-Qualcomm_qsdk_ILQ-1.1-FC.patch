Index: linux-3.14.43/Documentation/devicetree/bindings/clock/qcom,fab-scaling.txt
===================================================================
--- /dev/null
+++ linux-3.14.43/Documentation/devicetree/bindings/clock/qcom,fab-scaling.txt
@@ -0,0 +1,19 @@
+Qualcomm Atheros DDR and APPS FABRICS scaling
+------------------------------------------------
+
+Required properties :
+- compatible : "qcom,fab-scaling"
+- clocks : defines each clock needed
+- clock-names : contains clock names
+- fab_freq_high : Turbo FABRIC frequency
+- fab_freq_nominal : Nominal FABRIC frequency
+
+Example:
+
+fab-scaling {
+	compatible = "qcom,fab-scaling";
+	clocks = <&apps_fabric_clk>, <&ebi1_clk>;
+	clock-names = "apps-fab-clk", "ddr-fab-clk";
+	fab_freq_high = <533000000>;
+	fab_freq_nominal = <400000000>;
+};
Index: linux-3.14.43/Documentation/devicetree/bindings/input/touchscreen/gsl1680.txt
===================================================================
--- /dev/null
+++ linux-3.14.43/Documentation/devicetree/bindings/input/touchscreen/gsl1680.txt
@@ -0,0 +1,13 @@
+* GSL1680, 1680 Capacitive Touchscreen Controller
+
+Required properties:
+- compatible: must be "gsl1680_ts"
+- reg: slave address of touch screen controller.
+- status : enabled or disabled.
+
+Example:
+	lcd_ts: lcd_ts@40 {
+		compatible = "qca,gsl1680_ts"
+		reg = <0x40;
+		status = "disabled"
+	};
Index: linux-3.14.43/Documentation/devicetree/bindings/net/qcom-nss-crypto.txt
===================================================================
--- /dev/null
+++ linux-3.14.43/Documentation/devicetree/bindings/net/qcom-nss-crypto.txt
@@ -0,0 +1,21 @@
+* Qualcomm Technologies Inc. Crypto Platform Driver.
+
+This driver configures the crypto engine for IPSec traffic in UBI32.
+
+Required properties:
+- compatible: Should be qcom,nss-crypto
+- reg: Physical address and length of the register set for the device.
+- resets: physical address for crypto reset register
+- qcom,ee: Number of interrupt lines(Execution Environments) supported by BAM.
+
+Example:
+
+crypto0: crypto@e8000000 {
+	 compatible = "qcom,nss-crypto";
+	 reg-names = "crypto_pbase", "bam_base";
+	 reg = <0xe8000000 0x20000>,
+	     <0xe8004000 0x22000>;
+	 resets = <&gcc CRYPTO_ENG2_RESET>;
+	 reset-names = "rst_eng";
+	 qcom,ee = <0>;
+};
Index: linux-3.14.43/Documentation/devicetree/bindings/net/qcom-nss-drv.txt
===================================================================
--- /dev/null
+++ linux-3.14.43/Documentation/devicetree/bindings/net/qcom-nss-drv.txt
@@ -0,0 +1,113 @@
+* Qualcomm Technologies Inc. NSS HLOS Platform Driver.
+
+This driver communicates with the NSS Firmware, and provides empty buffers for packet-processing to the UBI32 processor.
+It also keeps track of sync packets from NSS Firmware.
+This driver has 2 sections listed below, one common to all the UBI32 cores and other specific to each UBI32 core.
+
+1. Driver access details specific to each UBI32/NSS core.
+
+Required properties:
+- compatible: "qcom,nss0"
+- compatible: "qcom,nss1"
+- interrupts: UBI32 to Apps interrupts for Sync/Data Packets and Empty Buffers.
+- reg-names: Indicates various resources passed to driver by name.
+		"nphys","vphys"
+		Refers to TCM and CSM Base Addresses of UBI32 Memory map.
+- reg: physical address and length of the register set for the device.
+- qcom,id: Unique Identifier for the HLOS block.This field is unique identifier for the core, which is also used as an index for global nss context.
+- clocks: physical address for NSS source clock, TCM clock and fabric clock.
+- resets: physical address for core clock reset, AHB and AXI reset.
+- qcom,rst_addr: Reset vector for NSS core.
+- qcom,load_addr: physical address to load NSS firmware.
+- qcom,turbo_frequency = turbo freq supported or not.
+- qcom,low_frequency = lowest supported operating frequency.
+- qcom,mid_frequency = nominal supported operating frequency.
+- qcom,max_frequency = maximum supported operating frequency.
+
+Optional properties:
+- qcom,ipv4-enabled: Enables registeration of N2H/PPPoE/ETH handlers, to receive stat sync
+	             IPV4 packets from UBI32.
+- qcom,ipv6-enabled: Enables registeration of IPV6 packet handlers, to receive stat sync
+                     IPV6 packets from UBI32.
+- qcom,crypto-enabled: Enables the cryptography feature for the platform.
+- qcom,gmac0-enabled: Enables GMAC0 port.
+- qcom,gmac1-enabled: Enables GMAC1 port.
+- qcom,gmac2-enabled: Enables GMAC2 port.
+- qcom,gmac3-enabled: Enables GMAC3 port.
+- qcom,wlan_dataplane_offload_enabled: Enables wifi dataplane offload in NSS.
+
+example:
+nss0: nss@40000000 {
+	compatible = "qcom,nss0";
+	pinctrl-0 = <&nss_spi_pins>;
+	pinctrl-names = "default";
+	interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+		GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+	reg = <0x36000000 0x1000 0x39000000 0x10000>;
+	reg-names = "nphys", "vphys";
+	clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+	clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+	resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+		<&gcc UBI32_CORE1_CLAMP_RESET>,
+		<&gcc UBI32_CORE1_AHB_RESET>,
+		<&gcc UBI32_CORE1_AXI_RESET>;
+	reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+	qcom,id = <0>;
+	qcom,num_irq = <2>;
+	qcom,rst_addr = <0x40000000>;
+	qcom,load_addr = <0x40000000>;
+	qcom,turbo_frequency = <1>;
+	qcom,low_frequency = <110000000>;
+	qcom,mid_frequency = <550000000>;
+	qcom,max_frequency = <733000000>;
+	qcom,ipv4_enabled = <1>;
+	qcom,ipv6_enabled = <1>;
+	qcom,l2switch_enabled = <1>;
+	qcom,crypto_enabled = <0>;
+	qcom,ipsec_enabled = <0>;
+	qcom,wlanredirect_enabled = <1>;
+	qcom,tun6rd_enabled = <1>;
+	qcom,tunipip6_enabled = <1>;
+	qcom,shaping_enabled = <1>;
+	qcom,gmac0_enabled = <1>;
+	qcom,gmac1_enabled = <1>;
+	qcom,gmac2_enabled = <1>;
+	qcom,gmac3_enabled = <1>;
+	qcom,wlan_dataplane_offload_enabled = <1>;
+};
+
+nss1: nss@40800000 {
+	compatible = "qcom,nss1";
+	interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+			  GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+	reg = <0x36400000 0x1000 0x39010000 0x10000>;
+	reg-names = "nphys", "vphys";
+	resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+		 <&gcc UBI32_CORE2_CLAMP_RESET>,
+		 <&gcc UBI32_CORE2_AHB_RESET>,
+		 <&gcc UBI32_CORE2_AXI_RESET>;
+	reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+	qcom,id = <1>;
+	qcom,num_irq = <2>;
+	qcom,rst_addr = <0x40800000>;
+	qcom,load_addr = <0x40800000>;
+	qcom,turbo_frequency = <1>;
+	qcom,low_frequency = <110000000>;
+	qcom,mid_frequency = <550000000>;
+	qcom,max_frequency = <733000000>;
+	qcom,ipv4_enabled = <0>;
+	qcom,ipv6_enabled = <0>;
+	qcom,l2switch_enabled = <0>;
+	qcom,crypto_enabled = <1>;
+	qcom,ipsec_enabled = <1>;
+	qcom,wlanredirect_enabled = <0>;
+	qcom,tun6rd_enabled = <0>;
+	qcom,tunipip6_enabled = <0>;
+	qcom,shaping_enabled = <0>;
+	qcom,gmac0_enabled = <0>;
+	qcom,gmac1_enabled = <0>;
+	qcom,gmac2_enabled = <0>;
+	qcom,gmac3_enabled = <0>;
+	qcom,wlan_dataplane_offload_enabled = <0>;
+};
+
Index: linux-3.14.43/arch/arm/boot/dts/Makefile
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/Makefile
+++ linux-3.14.43/arch/arm/boot/dts/Makefile
@@ -236,11 +236,14 @@ dtb-$(CONFIG_ARCH_QCOM) += \
 	qcom-apq8074-dragonboard.dtb \
 	qcom-apq8084-mtp.dtb \
 	qcom-ipq8064-ap148.dtb \
+	qcom-ipq8064-ap148_1xx.dtb \
 	qcom-ipq8064-db149.dtb \
 	qcom-ipq8064-v2.0-db149.dtb \
 	qcom-ipq8064-v3.0-db149.dtb \
 	qcom-ipq8064-v2.0-ap148.dtb \
 	qcom-ipq8064-v3.0-ap148.dtb \
+	qcom-ipq8064-v2.0-ap148_1xx.dtb \
+	qcom-ipq8064-v3.0-ap148_1xx.dtb \
 	qcom-ipq8064-storm.dtb \
 	qcom-ipq8064-whirlwind.dtb \
 	qcom-msm8660-surf.dtb \
@@ -252,6 +255,7 @@ dtb-$(CONFIG_ARCH_QCOM) += \
 	qcom-ipq40xx-ap.dk04.1-c1.dtb \
 	qcom-ipq40xx-ap.dk04.1-c2.dtb \
 	qcom-ipq40xx-ap.dk04.1-c3.dtb \
+	qcom-ipq40xx-ap.dk04.1-c4.dtb \
 	qcom-ipq40xx-db.dk01.1-c1.dtb \
 	qcom-ipq40xx-db.dk02.1-c1.dtb \
 	qcom-ipq8064-ap145.dtb \
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts
@@ -140,5 +140,14 @@
 		pcm_lb: pcm_lb@0 {
 			status = "ok";
 		};
+
+		serial@78b0000 {
+			status = "disabled";
+		};
+
+		uart1:uart@78b0000 {
+			status = "ok";
+		};
+
 	};
 };
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c4.dts
===================================================================
--- /dev/null
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c4.dts
@@ -0,0 +1,120 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq40xx-ap.dk04.1.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK04.1-C4";
+
+	soc {
+		pinctrl@0x01000000 {
+			audio_pins: audio_pinmux {
+				status = "disabled";
+			};
+
+			nhost_int {
+				pins = "gpio6";
+				bias-pull,up;
+			};
+
+			nwake {
+				pins = "gpio7";
+				bias-pull,up;
+			};
+
+			mcu_int_pins: mcu_pin_mux {
+				mux {
+					pins = "gpio18", "gpio41";
+					bias-pull,down;
+				};
+			};
+
+			emmc_reset {
+				pins = "gpio34";
+				bias-pull,up;
+			};
+
+			tpm_davint {
+				pins = "gpio39";
+				bias-pull,up;
+			};
+
+			zb_reset { /* Zigbee reset */
+				pins = "gpio40";
+				bias-pull,up;
+			};
+
+			rx_active {
+				pins = "gpio43";
+				bias-pull,down;
+			};
+
+			spi_1_pins: spi_1_pinmux { /* mapped to Zigbee */
+				mux {
+					pins = "gpio44", "gpio45",
+							 "gpio46", "gpio47";
+					function = "blsp_spi1";
+					bias-pull,down;
+				};
+			};
+
+			host_wake {
+				pins = "gpio48";
+				bias-pull,down;
+			};
+
+			bt_pins: bt_mux {
+				bt_wake {
+					pins = "gpio49";
+					bias-pull,down;
+				};
+
+				bt_disable {
+					pins = "gpio50";
+					bias-pull,up;
+				};
+
+				bt_reset {
+					pins = "gpio62";
+					bias-pull,down;
+				};
+			};
+
+			wlan_active {
+				pins = "gpio57";
+				bias-pull,down;
+			};
+
+			i2c_0_pins: i2c_0_pinmux {
+				mux {
+					pins = "gpio58", "gpio59";
+					function = "blsp_i2c0";
+					bias-disable;
+				};
+			};
+
+			sys_rst_out {
+				pins = "gpio60";
+				bias-pull,down;
+			};
+
+			nssel_int {
+				pins = "gpio61";
+				bias-pull,down;
+			};
+		};
+	};
+};
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi
@@ -15,6 +15,7 @@
  */
 
 #include "qcom-ipq40xx.dtsi"
+#include "qcom-ipq40xx-hsuart.dtsi"
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/gpio/gpio.h>
 
@@ -74,6 +75,14 @@
 				};
 			};
 
+			uart1_pins: uart1_pinmux {
+				mux {
+					pins = "gpio8", "gpio9", "gpio10", "gpio11";
+					function = "blsp_uart1";
+					bias-disable;
+				};
+			};
+
 			spi_0_pins: spi_0_pinmux {
 				mux {
 					pins = "gpio12", "gpio13", "gpio14", "gpio15";
@@ -142,6 +151,17 @@
 					bias-disable;
 				};
 			};
+			ts_0_pins: ts_0_pinmux {
+				mux_1 {
+					pins = "gpio34";
+					output-high;
+				};
+				mux_2 {
+					pins= "gpio35";
+					input-enable;
+					bias-pull-up;
+				};
+			};
 		};
 
 		serial@78af000 {
@@ -156,6 +176,13 @@
 			status = "ok";
 		};
 
+		uart1:uart@78b0000 {
+			pinctrl-0 = <&uart1_pins>;
+			pinctrl-1 = <&uart1_pins>;
+			pinctrl-names = "default", "sleep";
+			status = "disabled";
+		};
+
 		spi_0: spi@78b5000 { /* BLSP1 QUP1 */
 			pinctrl-0 = <&spi_0_pins>;
 			pinctrl-names = "default";
@@ -211,6 +238,12 @@
 				reg = <0x12>;
 				status = "disabled";
 			};
+
+			lcd_ts: lcd_ts@40 {
+				compatible = "qca,gsl1680_ts";
+				reg = <0x40>;
+				status = "disabled";
+			};
 		};
 
 		qcom_crypto: qcrypto@8e20000 {
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-hsuart.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq40xx-hsuart.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx-hsuart.dtsi
@@ -14,7 +14,7 @@
  *
  */
 
-/ {
+&soc {
 	uart1:uart@78b0000 {
 		compatible = "qcom,msm-hsuart-v14";
 		reg = <0x78b0000 0x200>,
@@ -31,8 +31,8 @@
 		qcom,bam-tx-ep-pipe-index = <2>;
 		qcom,bam-rx-ep-pipe-index = <3>;
 		qcom,master-id = <86>;
-		clocks = <&gcc 0>,
-			<&gcc 0>;
+		clocks = <&gcc GCC_BLSP1_AHB_CLK>,
+			<&gcc GCC_BLSP1_UART2_APPS_CLK>;
 		clock-names = "iface_clk", "core_clk";
 		status = "disabled";
 		};
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq40xx.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq40xx.dtsi
@@ -292,14 +292,10 @@
 			reg-names = "qscratch_base";
 			clocks = <&gcc GCC_USB3_MASTER_CLK>,
 				<&gcc GCC_USB3_SLEEP_CLK>,
-				<&gcc GCC_USB3_MOCK_UTMI_CLK>,
-				<&gcc 0>,
-				<&gcc 0>;
+				<&gcc GCC_USB3_MOCK_UTMI_CLK>;
 			clock-names = "master",
 				"sleep",
-				"mock_utmi",
-				"srif_ahb",
-				"srif_25m";
+				"mock_utmi";
 			qca,host = <1>;
 			status = "disabled";
 
@@ -327,14 +323,10 @@
 			reg-names = "qscratch_base";
 			clocks = <&gcc GCC_USB2_MASTER_CLK>,
 				<&gcc GCC_USB2_SLEEP_CLK>,
-				<&gcc GCC_USB2_MOCK_UTMI_CLK>,
-				<&gcc 0>,
-				<&gcc 0>;
+				<&gcc GCC_USB2_MOCK_UTMI_CLK>;
 			clock-names = "master",
 				"sleep",
-				"mock_utmi",
-				"srif_ahb",
-				"srif_25m";
+				"mock_utmi";
 			qca,host = <1>;
 			status = "disabled";
 
@@ -373,7 +365,7 @@
 				<&gcc GCC_BLSP1_QUP1_I2C_APPS_CLK>;
 			clock-names = "iface_clk", "core_clk";
 			qcom,clk-freq-out = <100000>;
-			qcom,clk-freq-in  = <19200000>;
+			qcom,clk-freq-in  = <19050000>;
 			qcom,noise-rjct-scl = <0>;
 			qcom,noise-rjct-sda = <0>;
 			qcom,bam-pipe-idx-cons = <8>;
@@ -420,6 +412,18 @@
 			status = "disabled";
 		};
 
+		wifi_glb_tcsr: tcsr@1949000 {
+			compatible = "qcom,tcsr";
+			reg = <0x1949000 0x100>;
+			qcom,wifi_glb_cfg = <TCSR_WIFI_GLB_CFG>;
+		};
+
+		wifi_noc_memtype_m0_m2_tcsr: tcsr@1957000 {
+			compatible = "qcom,tcsr";
+			reg = <0x1957000 0x100>;
+			qcom,wifi_noc_memtype_m0_m2 = <TCSR_WIFI_NOC_MEMTYPE_M0_M2>;
+		};
+
 		wifi0: wifi@a000000 {
 			compatible = "qca,wifi-ipq40xx";
 			reg = <0xa000000 0x200000>;
@@ -604,21 +608,13 @@
 
 			clocks = <&gcc GCC_PCIE_AHB_CLK>,
 				<&gcc GCC_PCIE_AXI_M_CLK>,
-				<&gcc GCC_PCIE_AXI_S_CLK>,
-				<&gcc 0>,
-				<&gcc 0>,
-				<&gcc 0>,
-				<&gcc 0>;
+				<&gcc GCC_PCIE_AXI_S_CLK>;
 
 			clock-names =	"pcie_0_cfg_ahb_clk",
 					"pcie_0_mstr_axi_clk",
-					"pcie_0_slv_axi_clk",
-					"pcie_0_pipe_clk",
-					"pcie_0_ref_clk_src",
-					"pcie_0_aux_clk",
-					"pcie_0_ldo";
+					"pcie_0_slv_axi_clk";
 
-			max-clock-frequency-hz = <100000000>, <200000000>, <200000000>, <0>, <0>, <0>, <0>;
+			max-clock-frequency-hz = <0>, <0>, <0>;
 
 			resets = <&gcc PCIE_AXI_M_ARES>,
 				<&gcc PCIE_AXI_S_ARES>,
@@ -723,5 +719,10 @@
 		cpu_freq_ipq40xx {
 			compatible = "qca,ipq40xx_freq";
 			clock-latency = <0x100>;
+			qcom,cpufreq-table =
+			< 48000 >,
+			< 200000 >,
+			< 500000 >,
+			< 710000 >;
 		};
 	};
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi
@@ -16,9 +16,11 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
-	model = "QCA IPQ8064/AK01";
+	model = "QCA IPQ8064/AK01-1XX";
 	compatible = "qcom,ipq8064-ak01", "qcom,ipq8064";
 
 	reserved-memory {
@@ -31,9 +33,18 @@
 		};
 	};
 
+	aliases {
+		mdio-gpio0 = &mdio0;
+		/*
+		 * U-Boot searches for these entries and patches
+		 * 'local-mac-address'
+		 */
+		ethernet0 = &gmac3;
+	};
+
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&rgmii2_pins_default>;
+			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -96,6 +107,20 @@
 				};
 			};
 
+			mdio0_pins_default: mdio0_pins_default {
+				mux {
+					pins = "gpio0", "gpio1";
+					function = "mdio";
+					drive-strength = <8>;
+					bias-disable;
+				};
+
+				clk {
+					pins = "gpio1";
+					input-disable;
+				};
+			};
+
 			rgmii2_pins_default: rgmii2_pins_default {
 				mux {
 					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
@@ -229,6 +254,100 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&qcom_pinmux 54 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+			button@2 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 62 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
+		mdio0: mdio {
+			compatible = "virtual,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+
+			phy5: ethernet-phy@5 {
+				device_type = "ethernet-phy";
+				reg = <5>;
+			};
+		};
+
+		nss0: nss@40000000 {
+			compatible = "qcom,nss0";
+			pinctrl-names = "default";
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+				GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x10000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				<&gcc UBI32_CORE1_CLAMP_RESET>,
+				<&gcc UBI32_CORE1_AHB_RESET>,
+				<&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <1>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <1>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <1>;
+		};
+
+		nss-gmac-common@03000000 {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+		};
+
+		gmac3: ethernet@37600000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37600000 0x200000>;
+			interrupts = <GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "sgmii";
+			qcom,id = <3>;
+			qcom,pcs-chanid = <3>;
+			qcom,phy-mdio-addr = <5>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <0>;
+			qcom,forced-duplex = <0xFF>;
+			qcom,mmds-mask = <0>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
 		rpm@108000 {
 			pinctrl-0 = <&rpm_i2c_pinmux>;
 			pinctrl-names = "default";
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi
@@ -16,6 +16,8 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "QCA IPQ8062/AP145";
@@ -141,7 +143,7 @@
 	soc {
 
 		pinmux@800000 {
-			pinctrl-0 = <&rgmii2_pins_default>;
+			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default>;
 			pinctrl-names = "default";
 
 			i2c4_pins: i2c4_pinmux {
@@ -200,7 +202,19 @@
 					bias-bus-hold;
 				};
 			};
+			mdio0_pins_default: mdio0_pins_default {
+				mux {
+					pins = "gpio0", "gpio1";
+					function = "mdio";
+					drive-strength = <8>;
+					bias-disable;
+				};
 
+				clk {
+					pins = "gpio1";
+					input-disable;
+				};
+			};
 			rgmii2_pins_default: rgmii2_pins_default {
 				mux {
 					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
@@ -365,6 +379,18 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 22 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
 		amba {
 			/* eMMC */
 			sdcc1: sdcc@12400000 {
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi
@@ -16,9 +16,11 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
-	model = "Qualcomm Atheros IPQ8062/AP145_1XX";
+	model = "Qualcomm Atheros IPQ8062/AP145-1XX";
 	compatible = "qcom,ipq8062-ap145_1xx", "qcom,ipq8062";
 
 	reserved-memory {
@@ -359,6 +361,18 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 22 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
 		amba {
 			/* eMMC */
 			sdcc1: sdcc@12400000 {
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi
@@ -178,15 +178,6 @@
 					reg = <0>;
 					m25p,fast-read;
 
-					partition@0 {
-						label = "rootfs";
-						reg = <0x0 0x1000000>;
-					};
-
-					partition@1 {
-						label = "scratch";
-						reg = <0x1000000 0x1000000>;
-					};
 				};
 			};
 		};
@@ -315,7 +306,7 @@
 			pinctrl-names = "default";
 			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
 				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
-			reg = <0x36000000 0x1000 0x39000000 0x20000>;
+			reg = <0x36000000 0x1000 0x39000000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
 			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
@@ -339,12 +330,49 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
 			qcom,tunipip6_enabled = <1>;
 			qcom,shaping_enabled = <1>;
-			qcom,gmac0_enabled = <1>;
+			qcom,gmac0_enabled = <0>;
 			qcom,gmac1_enabled = <1>;
 			qcom,gmac2_enabled = <1>;
-			qcom,gmac3_enabled = <1>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			compatible = "qcom,nss1";
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <1>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
 		};
 
 		nss-gmac-common@03000000 {
@@ -389,6 +417,47 @@
 			mdiobus = <&mdio0>;
 		};
 
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
 		rpm@108000 {
 			pinctrl-0 = <&rpm_i2c_pinmux>;
 			pinctrl-names = "default";
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dts
===================================================================
--- /dev/null
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dts
@@ -0,0 +1,18 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq8064-v1.0.dtsi"
+#include "qcom-ipq8064-ap148_1xx.dtsi"
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi
===================================================================
--- /dev/null
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi
@@ -0,0 +1,499 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "QCA IPQ8064/AP148-1XX";
+	compatible = "qcom,ipq8064-ap148_1xx", "qcom,ipq8064";
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		rsvd@41200000 {
+			reg = <0x41200000 0x300000>;
+			no-map;
+		};
+	};
+
+	aliases {
+		mdio-gpio0 = &mdio0;
+		/*
+		 * U-Boot searches for these entries and patches
+		 * 'local-mac-address'
+		 */
+		ethernet0 = &gmac1;
+		ethernet1 = &gmac2;
+		serial0 = &uart0;
+		serial1 = &uart1;
+	};
+
+	soc {
+		pinmux@800000 {
+			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default &uart2_pins>;
+			pinctrl-names = "default";
+
+			rpm_i2c_pinmux: rpm_i2c_pinmux {
+				mux {
+					pins = "gpio12", "gpio13";
+					function = "gsbi4";
+					drive-strength = <12>;
+					bias-disable;
+				};
+			};
+
+			pcie1_pins: pcie1_pinmux {
+				mux {
+					pins = "gpio3";
+					drive-strength = <2>;
+					bias-disable;
+				};
+			};
+
+			pcie2_pins: pcie2_pinmux {
+				mux {
+					pins = "gpio48";
+					drive-strength = <2>;
+					bias-disable;
+				};
+			};
+
+			nss_spi_pins: nss_spi_pins {
+				mux {
+					pins = "gpio14", "gpio15", "gpio16", "gpio17",
+					       "gpio55", "gpio56", "gpio57", "gpio58";
+					function = "nss_spi";
+					drive-strengh = <10>;
+				};
+				data {
+					pins = "gpio14", "gpio15", "gpio55", "gpio56";
+					bias-none;
+				};
+				cs {
+					pins = "gpio16", "gpio17", "gpio57", "gpio58";
+					bias-pull-up;
+				};
+			};
+
+			spi_pins: spi_pins {
+				mux {
+					pins = "gpio18", "gpio19", "gpio21";
+					function = "gsbi5";
+					drive-strength = <10>;
+					bias-none;
+				};
+				cs {
+					pins = "gpio20";
+					drive-strength = <12>;
+				};
+			};
+			nand_pins: nand_pins {
+				mux {
+					pins = "gpio34", "gpio35", "gpio36",
+						"gpio37", "gpio38", "gpio39",
+						"gpio40", "gpio41", "gpio42",
+						"gpio43", "gpio44", "gpio45",
+						"gpio46", "gpio47";
+					function = "nand";
+					drive-strength = <10>;
+					bias-disable;
+				};
+				pullups {
+					pins = "gpio39";
+					bias-pull-up;
+				};
+				hold {
+					pins = "gpio40", "gpio41", "gpio42",
+						"gpio43", "gpio44", "gpio45",
+						"gpio46", "gpio47";
+					bias-bus-hold;
+				};
+			};
+			buttons_pins: buttons_pins {
+				mux {
+					pins = "gpio54";
+					drive-strength = <2>;
+					bias-pull-up;
+				};
+			};
+			mdio0_pins_default: mdio0_pins_default {
+				mux {
+					pins = "gpio0", "gpio1";
+					function = "mdio";
+					drive-strength = <8>;
+					bias-disable;
+				};
+
+				clk {
+					pins = "gpio1";
+					input-disable;
+				};
+			};
+
+			rgmii2_pins_default: rgmii2_pins_default {
+				mux {
+					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
+					       "gpio51", "gpio52", "gpio59", "gpio60", "gpio61", "gpio62" ;
+					function = "rgmii2";
+					drive-strength = <8>;
+					bias-disable;
+				};
+
+				tx {
+					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
+					input-disable;
+				};
+			};
+
+			uart2_pins: uart2_pins {
+				mux {
+					pins = "gpio22", "gpio23", "gpio24", "gpio25";
+					function = "gsbi2";
+					drive-strength = <12>;
+					bias-none;
+				};
+			};
+		};
+
+		gsbi@16300000 {
+			qcom,mode = <GSBI_PROT_I2C_UART>;
+			status = "ok";
+			uart0: serial@16340000 {
+				status = "ok";
+			};
+		};
+
+		gsbi2: gsbi@12480000 {
+			qcom,mode = <GSBI_PROT_I2C_UART>;
+			status = "ok";
+			uart1: serial@12490000 {
+				status = "ok";
+			};
+		};
+
+		gsbi5: gsbi@1a200000 {
+			qcom,mode = <GSBI_PROT_SPI>;
+			status = "ok";
+
+			spi4: spi@1a280000 {
+				status = "ok";
+				spi-max-frequency = <50000000>;
+
+				pinctrl-0 = <&spi_pins>;
+				pinctrl-names = "default";
+
+				cs-gpios = <&qcom_pinmux 20 0>;
+
+				dmas = <&adm_dma 6 9>,
+					<&adm_dma 5 10>;
+				dma-names = "rx", "tx";
+
+				flash: m25p80@0 {
+					compatible = "s25fl256s1";
+					#address-cells = <1>;
+					#size-cells = <1>;
+					spi-max-frequency = <50000000>;
+					reg = <0>;
+					m25p,fast-read;
+
+				};
+			};
+		};
+
+		sata-phy@1b400000 {
+			status = "ok";
+		};
+
+		pci@1b500000 {
+			status = "ok";
+			reset-gpio = <&qcom_pinmux 3 0>;
+			pinctrl-0 = <&pcie1_pins>;
+			pinctrl-names = "default";
+
+			ranges = <0x00000000 0 0x00000000 0x0ff00000 0 0x00100000   /* configuration space */
+				  0x81000000 0 0	  0x0fe00000 0 0x00100000   /* downstream I/O */
+				  0x82000000 0 0x00000000 0x08000000 0 0x07e00000>; /* non-prefetchable memory */
+		};
+
+		pci@1b700000 {
+			status = "ok";
+			reset-gpio = <&qcom_pinmux 48 0>;
+			pinctrl-0 = <&pcie2_pins>;
+			pinctrl-names = "default";
+
+			ranges = <0x00000000 0 0x00000000 0x31f00000 0 0x00100000   /* configuration space */
+				  0x81000000 0 0	  0x31e00000 0 0x00100000   /* downstream I/O */
+				  0x82000000 0 0x00000000 0x2e000000 0 0x03e00000>; /* non-prefetchable memory */
+
+			force_gen1 = <1>;
+		};
+
+		sata@29000000 {
+			status = "ok";
+		};
+
+		dma@18300000 {
+			status = "ok";
+		};
+
+		nand@0x1ac00000 {
+			status = "ok";
+
+			pinctrl-0 = <&nand_pins>;
+			pinctrl-names = "default";
+		};
+
+		tcsr@1a400000 {
+			status = "ok";
+			qcom,usb-ctrl-select = <TCSR_USB_SELECT_USB3_DUAL>;
+		};
+
+		phy@100f8800 {		/* USB3 port 1 HS phy */
+			status = "ok";
+		};
+
+		phy@100f8830 {		/* USB3 port 1 SS phy */
+			status = "ok";
+		};
+
+		phy@110f8800 {		/* USB3 port 0 HS phy */
+			status = "ok";
+		};
+
+		phy@110f8830 {		/* USB3 port 0 SS phy */
+			status = "ok";
+		};
+
+		usb30@0 {
+			status = "ok";
+		};
+
+		usb30@1 {
+			status = "ok";
+		};
+		gpio_keys {
+			compatible = "gpio-keys";
+			pinctrl-0 = <&buttons_pins>;
+			pinctrl-names = "default";
+
+			button@1 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&qcom_pinmux 54 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+			button@2 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 65 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
+		mdio0: mdio {
+			compatible = "virtual,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+
+			phy0: ethernet-phy@0 {
+				device_type = "ethernet-phy";
+				reg = <0>;
+				qca,ar8327-initvals = <
+					0x00004 0x7600000   /* PAD0_MODE */
+					0x00008 0x1000000   /* PAD5_MODE */
+					0x0000c 0x80        /* PAD6_MODE */
+					0x000e4 0xaa545     /* MAC_POWER_SEL */
+					0x000e0 0xc74164de  /* SGMII_CTRL */
+					0x0007c 0x4e        /* PORT0_STATUS */
+					0x00094 0x4e        /* PORT6_STATUS */
+				>;
+			};
+
+			phy4: ethernet-phy@4 {
+				device_type = "ethernet-phy";
+				reg = <4>;
+			};
+		};
+
+		nss0: nss@40000000 {
+			compatible = "qcom,nss0";
+			pinctrl-0 = <&nss_spi_pins>;
+			pinctrl-names = "default";
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x10000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_AHB_RESET>,
+				 <&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <1>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			qcom,l2tpv2_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <1>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			compatible = "qcom,nss1";
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <1>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+		};
+
+		nss-gmac-common@03000000 {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+		};
+
+		gmac1: ethernet@37200000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37200000 0x200000>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <1>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <4>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <1>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac2: ethernet@37400000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37400000 0x200000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "sgmii";
+			qcom,id = <2>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <0>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		rpm@108000 {
+			pinctrl-0 = <&rpm_i2c_pinmux>;
+			pinctrl-names = "default";
+		};
+	};
+};
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi
@@ -16,6 +16,8 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "QCA IPQ8064/AP160";
@@ -31,9 +33,20 @@
 		};
 	};
 
+	aliases {
+		mdio-gpio0 = &mdio0;
+		/*
+		 * U-Boot searches for these entries and patches
+		 * 'local-mac-address'
+		 */
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		ethernet3 = &gmac2;
+	};
+
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&rgmii2_pins_default>;
+			pinctrl-0 = <&rgmii2_pins_default &pcie_2g_pwrdwn_default &pcie_5g_pwrdwn_default>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -61,6 +74,32 @@
 				};
 			};
 
+			pcie3_pins: pcie3_pinmux {
+				mux {
+					pins = "gpio63";
+					drive-strength = <2>;
+					bias-disable;
+				};
+			};
+
+			pcie_2g_pwrdwn_default: pcie_2g_pwrdwn_default {
+				mux {
+					pins = "gpio9";
+					drive-strength = <12>;
+					bias-pull-up;
+					output-high;
+				};
+			};
+
+			pcie_5g_pwrdwn_default: pcie_5g_pwrdwn_default {
+				mux {
+					pins = "gpio26";
+					drive-strength = <12>;
+					bias-pull-up;
+					output-high;
+				};
+			};
+
 			spi_pins: spi_pins {
 				mux {
 					pins = "gpio18", "gpio19", "gpio21";
@@ -95,19 +134,30 @@
 					bias-bus-hold;
 				};
 			};
-
 			rgmii2_pins_default: rgmii2_pins_default {
 				mux {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
-					       "gpio51", "gpio52", "gpio59", "gpio60", "gpio61", "gpio62" ;
+					pins ="gpio2", "gpio27", "gpio28",
+						"gpio29", "gpio30", "gpio31",
+						"gpio32", "gpio51", "gpio52",
+						"gpio59", "gpio60", "gpio61",
+						"gpio62", "gpio66" ;
 					function = "rgmii2";
 					drive-strength = <8>;
 					bias-disable;
 				};
 
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
+			};
+
+			sdcc3_pins: sdcc3_pinmux {
+				mux {
+					pins = "gpio6";
+					drive-strength = <2>;
+					bias-pull-down;
+				};
+				card_det {
+					pins = "gpio8";
+					drive-strength = <16>;
+					bias-pull-none;
 				};
 			};
 		};
@@ -185,6 +235,18 @@
 
 		};
 
+		pci@1b900000 {
+			status = "ok";
+			reset-gpio = <&qcom_pinmux 63 0>;
+			pinctrl-0 = <&pcie3_pins>;
+			pinctrl-names = "default";
+
+			ranges = <0x00000000 0 0x00000000 0x35f00000 0 0x00100000   /* configuration space */
+				  0x81000000 0 0          0x35e00000 0 0x00100000   /* downstream I/O */
+				  0x82000000 0 0x00000000 0x32000000 0 0x03e00000>; /* non-prefetchable memory */
+
+		};
+
 		sata@29000000 {
 			status = "ok";
 		};
@@ -229,6 +291,260 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&qcom_pinmux 54 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+			button@2 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 22 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
+		vcc_sdc3: regulator@0 {
+			compatible = "regulator-gpio";
+			regulator-name = "SDC3 GPIO Regulator";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3000000>;
+
+			gpios = <&qcom_pinmux 8 0>;
+			states = <3000000 0
+				1800000 1>;
+			enable-active-high;
+		};
+
+		amba {
+		/* External micro SD card */
+			sdcc3: sdcc@12180000 {
+				status = "ok";
+				pinctrl-0 = <&sdcc3_pins>;
+				pinctrl-names = "default";
+				vmmc-supply = <&vcc_sdc3>;
+				cd-gpios  = <&qcom_pinmux 6 0>;
+				cd-inverted;
+				qcom-uhs-gpio = <8>;
+			};
+		};
+
+		mdio0: mdio {
+			compatible = "virtual,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+
+			phy0: ethernet-phy@0 {
+				device_type = "ethernet-phy";
+				reg = <0>;
+				qca,ar8327-initvals = <
+				0x00004 0x7600000   /* PAD0_MODE */
+				0x00008 0x1000000   /* PAD5_MODE */
+				0x0000c 0x20080        /* PAD6_MODE */
+				0x000e4 0x6a545     /* MAC_POWER_SEL */
+				0x000e0 0xc74164de  /* SGMII_CTRL */
+				0x0007c 0x4e        /* PORT0_STATUS */
+				0x00094 0x4e        /* PORT6_STATUS */
+				>;
+			};
+
+			phy4: ethernet-phy@4 {
+				device_type = "ethernet-phy";
+				reg = <4>;
+				phy_rgmii_en = <1>;
+				txclk_delay_en = <1>;
+				rxclk_delay_en = <1>;
+			};
+
+			phy3: ethernet-phy@3 {
+				device_type = "ethernet-phy";
+				reg = <3>;
+			};
+		};
+
+		nss0: nss@40000000 {
+			compatible = "qcom,nss0";
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x20000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>,  <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				<&gcc UBI32_CORE1_CLAMP_RESET>,
+				<&gcc UBI32_CORE1_AHB_RESET>,
+				<&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			qcom,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <1>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			compatible = "qcom,nss1";
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <1>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
+		};
+
+		nss-gmac-common {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+		};
+
+		gmac0: ethernet@37000000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37000000 0x200000>;
+			interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <0>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <4>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <1>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <0>;
+			qcom,forced-duplex = <0xFF>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac1: ethernet@37200000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37200000 0x200000>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <1>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <0>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac2: ethernet@37400000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37400000 0x200000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "sgmii";
+			qcom,id = <2>;
+			qcom,pcs-chanid = <2>;
+			qcom,phy-mdio-addr = <3>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
 		rpm@108000 {
 			pinctrl-0 = <&rpm_i2c_pinmux>;
 			pinctrl-names = "default";
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi
@@ -16,9 +16,11 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
-	model = "QCA IPQ8064/AP160_2XX";
+	model = "QCA IPQ8064/AP160-2XX";
 	compatible = "qcom,ipq8064-ap160_2xx", "qcom,ipq8064";
 
 	reserved-memory {
@@ -33,7 +35,7 @@
 
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&rgmii2_pins_default>;
+			pinctrl-0 = <&mdio0_pins_default &mdio1_pins_default &rgmii2_pins_default>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -95,6 +97,32 @@
 					bias-bus-hold;
 				};
 			};
+			mdio0_pins_default: mdio0_pins_default {
+				mux {
+					pins = "gpio0", "gpio1";
+					function = "mdio";
+					drive-strength = <8>;
+					bias-disable;
+				};
+
+				clk {
+					pins = "gpio1";
+					input-disable;
+				};
+			};
+			mdio1_pins_default: mdio1_pins_default {
+				mux {
+					pins = "gpio2", "gpio66";
+					function = "mdio";
+					drive-strength = <8>;
+					bias-disable;
+				};
+
+				clk {
+					pins = "gpio66";
+					input-disable;
+				};
+			};
 
 			rgmii2_pins_default: rgmii2_pins_default {
 				mux {
@@ -229,6 +257,25 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&qcom_pinmux 54 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+			button@2 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 22 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
 		rpm@108000 {
 			pinctrl-0 = <&rpm_i2c_pinmux>;
 			pinctrl-names = "default";
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi
@@ -16,6 +16,8 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "QCA IPQ8064/AP161";
@@ -31,6 +33,17 @@
 		};
 	};
 
+	aliases {
+		mdio-gpio0 = &mdio0;
+		/*
+		 * U-Boot searches for these entries and patches
+		 * 'local-mac-address'
+		 */
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		ethernet3 = &gmac2;
+	};
+
 	soc {
 		pinmux@800000 {
 			pinctrl-0 = <&rgmii2_pins_default>;
@@ -61,6 +74,14 @@
 				};
 			};
 
+			pcie3_pins: pcie3_pinmux {
+				mux {
+					pins = "gpio63";
+					drive-strength = <2>;
+					bias-disable;
+				};
+			};
+
 			spi_pins: spi_pins {
 				mux {
 					pins = "gpio18", "gpio19", "gpio21";
@@ -95,20 +116,18 @@
 					bias-bus-hold;
 				};
 			};
-
 			rgmii2_pins_default: rgmii2_pins_default {
 				mux {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
-					       "gpio51", "gpio52", "gpio59", "gpio60", "gpio61", "gpio62" ;
+					pins = "gpio2", "gpio27", "gpio28",
+						"gpio29", "gpio30", "gpio31",
+						"gpio32", "gpio51", "gpio52",
+						"gpio59", "gpio60", "gpio61",
+						 "gpio62", "gpio66" ;
 					function = "rgmii2";
 					drive-strength = <8>;
 					bias-disable;
 				};
 
-				tx {
-					pins = "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32" ;
-					input-disable;
-				};
 			};
 
 			hs_uart_pins: hs_uart_pins {
@@ -158,6 +177,9 @@
 				qcom,tx-chan = <7>;
 				qcom,rx-crci = <14>;
 				qcom,tx-crci = <4>;
+				qcom,tcsr_adm_mux_sel_reg = <IPQ806X_TCSR_REG_A_ADM_CRCI_MUX_SEL>;
+				qcom,tcsr_adm_mux_sel_reg_mask = <IPQ806X_GSBI2_ADM_CRCI_MUX_SEL_MASK>;
+				qcom,tcsr_adm_mux_sel_reg_value = <GSBI_CRCI_UART>;
 				pinctrl-0 = <&hs_uart_pins>;
 				pinctrl-names = "default";
 
@@ -230,6 +252,17 @@
 
 		};
 
+		pci@1b900000 {
+			status = "ok";
+			reset-gpio = <&qcom_pinmux 63 0>;
+			pinctrl-0 = <&pcie3_pins>;
+			pinctrl-names = "default";
+
+			ranges = <0x00000000 0 0x00000000 0x35f00000 0 0x00100000   /* configuration space */
+				  0x81000000 0 0          0x35e00000 0 0x00100000   /* downstream I/O */
+				  0x82000000 0 0x00000000 0x32000000 0 0x03e00000>; /* non-prefetchable memory */
+		};
+
 		sata@29000000 {
 			status = "ok";
 		};
@@ -274,6 +307,228 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 54 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
+		mdio0: mdio {
+			compatible = "virtual,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			gpios = <&qcom_pinmux 1 0 &qcom_pinmux 0 0>;
+
+			phy0: ethernet-phy@0 {
+				device_type = "ethernet-phy";
+				reg = <0>;
+				qca,ar8327-initvals = <
+					0x00004 0x7600000   /* PAD0_MODE */
+					0x00008 0x1000000   /* PAD5_MODE */
+					0x0000c 0x20080        /* PAD6_MODE */
+					0x000e4 0x6a545     /* MAC_POWER_SEL */
+					0x000e0 0xc74164de  /* SGMII_CTRL */
+					0x0007c 0x4e        /* PORT0_STATUS */
+					0x00094 0x4e        /* PORT6_STATUS */
+				>;
+			};
+
+			phy4: ethernet-phy@4 {
+				device_type = "ethernet-phy";
+				reg = <4>;
+				phy_rgmii_en = <1>;
+				txclk_delay_en = <1>;
+				rxclk_delay_en = <1>;
+			};
+
+			phy3: ethernet-phy@3 {
+				device_type = "ethernet-phy";
+				reg = <3>;
+			};
+		};
+
+		nss0: nss@40000000 {
+			compatible = "qcom,nss0";
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36000000 0x1000 0x39000000 0x20000>;
+			reg-names = "nphys", "vphys";
+			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
+			clock-names = "nss_core_clk", "nss_tcm_src", "nss_tcm_clk", "nss-fab0-clk", "nss-fab1-clk";
+			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_CLAMP_RESET>,
+				 <&gcc UBI32_CORE1_AHB_RESET>,
+				 <&gcc UBI32_CORE1_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <0>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40000000>;
+			qcom,load_addr = <0x40000000>;
+			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <1>;
+			qcom,ipv6_enabled = <1>;
+			qcom,l2switch_enabled = <1>;
+			qcom,crypto_enabled = <0>;
+			qcom,ipsec_enabled = <0>;
+			qcom,wlanredirect_enabled = <1>;
+			qcom,tun6rd_enabled = <1>;
+			com,tunipip6_enabled = <1>;
+			qcom,shaping_enabled = <1>;
+			qcom,gmac0_enabled = <1>;
+			qcom,gmac1_enabled = <1>;
+			qcom,gmac2_enabled = <1>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <1>;
+		};
+
+		nss1: nss@40800000 {
+			compatible = "qcom,nss1";
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
+				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x36400000 0x1000 0x39010000 0x10000>;
+			reg-names = "nphys", "vphys";
+			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_CLAMP_RESET>,
+				 <&gcc UBI32_CORE2_AHB_RESET>,
+				 <&gcc UBI32_CORE2_AXI_RESET>;
+			reset-names = "clkrst_clamp", "clamp", "ahb", "axi";
+			qcom,id = <1>;
+			qcom,num_irq = <2>;
+			qcom,rst_addr = <0x40800000>;
+			qcom,load_addr = <0x40800000>;
+			qcom,turbo_frequency = <1>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <550000000>;
+			qcom,max_frequency = <733000000>;
+			qcom,ipv4_enabled = <0>;
+			qcom,ipv6_enabled = <0>;
+			qcom,l2switch_enabled = <0>;
+			qcom,crypto_enabled = <1>;
+			qcom,ipsec_enabled = <1>;
+			qcom,wlanredirect_enabled = <0>;
+			qcom,tun6rd_enabled = <0>;
+			qcom,tunipip6_enabled = <0>;
+			qcom,shaping_enabled = <0>;
+			qcom,gmac0_enabled = <0>;
+			qcom,gmac1_enabled = <0>;
+			qcom,gmac2_enabled = <0>;
+			qcom,gmac3_enabled = <0>;
+			qcom,wlan_dataplane_offload_enabled = <0>;
+		};
+
+		nss-gmac-common {
+			compatible = "qcom,nss-gmac-common";
+			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
+			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
+		};
+
+		gmac0: ethernet@37000000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37000000 0x200000>;
+			interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <0>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <4>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <1>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <0>;
+			qcom,forced-duplex = <0xFF>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac1: ethernet@37200000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37200000 0x200000>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "rgmii";
+			qcom,id = <1>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <0>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		gmac2: ethernet@37400000 {
+			device_type = "network";
+			compatible = "qcom,nss-gmac";
+			reg = <0x37400000 0x200000>;
+			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+			phy-mode = "sgmii";
+			qcom,id = <2>;
+			qcom,pcs-chanid = <2>;
+			qcom,phy-mdio-addr = <3>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
+			qcom,emulation = <0>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,socver = <0>;
+			local-mac-address = [000000000000];
+			mdiobus = <&mdio0>;
+		};
+
+		crypto1: crypto@38000000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38000000 0x20000>,
+			    <0x38004000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG1_RESET>,
+                                 <&gcc CRYPTO_AHB_RESET>;
+                        reset-names = "rst_eng", "rst_ahb";
+			qcom,ee = <0>;
+		};
+
+		crypto2: crypto@38400000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38400000 0x20000>,
+			    <0x38404000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG2_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto3: crypto@38800000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38800000 0x20000>,
+			    <0x38804000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG3_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
+		crypto4: crypto@38C00000 {
+			compatible = "qcom,nss-crypto";
+			reg-names = "crypto_pbase", "bam_base";
+			reg = <0x38C00000 0x20000>,
+			    <0x38C04000 0x22000>;
+                        resets = <&gcc CRYPTO_ENG4_RESET>;
+                        reset-names = "rst_eng";
+			qcom,ee = <0>;
+		};
+
 		rpm@108000 {
 			pinctrl-0 = <&rpm_i2c_pinmux>;
 			pinctrl-names = "default";
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi
@@ -16,6 +16,8 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "Qualcomm Atheros IPQ8064/DB149";
@@ -37,8 +39,10 @@
 		 * U-Boot searches for these entries and patches
 		 * 'local-mac-address'
 		 */
-		ethernet0 = &gmac1;
-		ethernet1 = &gmac2;
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		ethernet3 = &gmac2;
+		ethernet4 = &gmac3;
 	};
 
 	soc {
@@ -313,6 +317,18 @@
 			status = "ok";
 		};
 
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&qcom_pinmux 26 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+		};
+
 		vcc_sdc3: regulator@0 {
 			compatible = "regulator-gpio";
 			regulator-name = "SDC3 GPIO Regulator";
@@ -369,6 +385,16 @@
 				device_type = "ethernet-phy";
 				reg = <4>;
 			};
+
+			phy6: ethernet-phy@6 {
+				device_type = "ethernet-phy";
+				reg = <6>;
+			};
+
+			phy7: ethernet-phy@7 {
+				device_type = "ethernet-phy";
+				reg = <7>;
+			};
 		};
 
 		nss0: nss@40000000 {
@@ -408,6 +434,7 @@
 		};
 
 		nss-gmac-common {
+			compatible = "qcom,nss-gmac-common";
 			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
 			reg-names = "nss_reg_base" , "qsgmii_reg_base", "clk_ctl_base";
 		};
@@ -433,12 +460,14 @@
 			interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>;
 			phy-mode = "rgmii";
 			qcom,id = <0>;
-			qcom,phy_mdio_addr = <4>;
-			qcom,poll_required = <1>;
-			qcom,rgmii_delay = <1>;
+			qcom,pcs-chanid = <0>;
+			qcom,phy-mdio-addr = <4>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <1>;
 			qcom,emulation = <0>;
-			qcom,forced_speed = <1000>;
-			qcom,forced_duplex = <1>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,mmds-mask = <0>;
 			qcom,socver = <0>;
 			local-mac-address = [000000000000];
 			mdiobus = <&mdio0>;
@@ -451,12 +480,14 @@
 			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 			phy-mode = "sgmii";
 			qcom,id = <1>;
-			qcom,phy_mdio_addr = <4>;
-			qcom,poll_required = <1>;
-			qcom,rgmii_delay = <1>;
+			qcom,pcs-chanid = <1>;
+			qcom,phy-mdio-addr = <0>;
+			qcom,poll-required = <0>;
+			qcom,rgmii-delay = <0>;
 			qcom,emulation = <0>;
-			qcom,forced_speed = <1000>;
-			qcom,forced_duplex = <1>;
+			qcom,forced-speed = <1000>;
+			qcom,forced-duplex = <1>;
+			qcom,mmds-mask = <0>;
 			qcom,socver = <0>;
 			local-mac-address = [000000000000];
 			mdiobus = <&mdio0>;
@@ -469,10 +500,14 @@
 			interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 			phy-mode = "sgmii";
 			qcom,id = <2>;
-			qcom,phy_mdio_addr = <0>;
-			qcom,poll_required = <0>;
-			qcom,rgmii_delay = <0>;
+			qcom,pcs-chanid = <2>;
+			qcom,phy-mdio-addr = <6>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
 			qcom,emulation = <0>;
+			qcom,forced-speed = <0>;
+			qcom,forced-duplex = <0xFF>;
+			qcom,mmds-mask = <0>;
 			qcom,socver = <0>;
 			local-mac-address = [000000000000];
 			mdiobus = <&mdio0>;
@@ -485,10 +520,14 @@
 			interrupts = <GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>;
 			phy-mode = "sgmii";
 			qcom,id = <3>;
-			qcom,phy_mdio_addr = <0>;
-			qcom,poll_required = <0>;
-			qcom,rgmii_delay = <0>;
+			qcom,pcs-chanid = <3>;
+			qcom,phy-mdio-addr = <7>;
+			qcom,poll-required = <1>;
+			qcom,rgmii-delay = <0>;
 			qcom,emulation = <0>;
+			qcom,forced-speed = <0>;
+			qcom,forced-duplex = <0xFF>;
+			qcom,mmds-mask = <0>;
 			qcom,socver = <0>;
 			local-mac-address = [000000000000];
 			mdiobus = <&mdio0>;
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v2.0-ap148_1xx.dts
===================================================================
--- /dev/null
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v2.0-ap148_1xx.dts
@@ -0,0 +1,18 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq8064-v2.0.dtsi"
+#include "qcom-ipq8064-ap148_1xx.dtsi"
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v2.0.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064-v2.0.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v2.0.dtsi
@@ -2,13 +2,13 @@
 
 &soc {
 	pci@1b500000 {
-		compatible = "qcom,pcie-ipq8064-v2", "qcom,pcie-ipq8064";
+		compatible = "qcom,pcie-ipq8064-v2";
 	};
 	pci@1b700000 {
-		compatible = "qcom,pcie-ipq8064-v2", "qcom,pcie-ipq8064";
+		compatible = "qcom,pcie-ipq8064-v2";
 	};
 	pci@1b900000 {
-		compatible = "qcom,pcie-ipq8064-v2", "qcom,pcie-ipq8064";
+		compatible = "qcom,pcie-ipq8064-v2";
 	};
 	ss_phy_0: phy@110f8830 {
 		rx_eq = <2>;
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v3.0-ap148_1xx.dts
===================================================================
--- /dev/null
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064-v3.0-ap148_1xx.dts
@@ -0,0 +1,18 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq8064-v3.0.dtsi"
+#include "qcom-ipq8064-ap148_1xx.dtsi"
Index: linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064.dtsi
===================================================================
--- linux-3.14.43.orig/arch/arm/boot/dts/qcom-ipq8064.dtsi
+++ linux-3.14.43/arch/arm/boot/dts/qcom-ipq8064.dtsi
@@ -69,6 +69,7 @@
 
 			clock-latency = <100000>;
 			voltage-tolerance = <5>;
+			cpu_freq_idle = <800000000>;
 
 			cooling-min-state = <0>;
 			cooling-max-state = <10>;
@@ -126,6 +127,7 @@
 			>;
 
 			clock-latency = <100000>;
+			cpu_freq_idle = <800000000>;
 
 			cooling-min-state = <0>;
 			cooling-max-state = <10>;
@@ -198,6 +200,14 @@
 		nss_core_threshold_freq = <733000000>;
 	};
 
+	fab-scaling {
+		compatible = "qcom,fab-scaling";
+		clocks = <&apps_fabric_clk>, <&ebi1_clk>;
+		clock-names = "apps-fab-clk", "ddr-fab-clk";
+		fab_freq_high = <533000000>;
+		fab_freq_nominal = <400000000>;
+        };
+
 	soc: soc {
 		#address-cells = <1>;
 		#size-cells = <1>;
@@ -562,7 +572,7 @@
 		};
 
 		sata@29000000 {
-			compatible = "qcom,ipq806x-ahci", "generic-ahci";
+			compatible = "qcom,ipq806x-ahci";
 			reg = <0x29000000 0x180>;
 
 			interrupts = <0 209 0x0>;
@@ -570,9 +580,10 @@
 			clocks = <&gcc SFAB_SATA_S_H_CLK>,
 				 <&gcc SATA_H_CLK>,
 				 <&gcc SATA_A_CLK>,
+				 <&gcc SATA_CLK_SRC>,
 				 <&gcc SATA_RXOOB_CLK>,
 				 <&gcc SATA_PMALIVE_CLK>;
-			clock-names = "slave_face", "iface", "core",
+			clock-names = "slave_face", "iface", "core", "src",
 					"rxoob", "pmalive";
 
 			assigned-clocks = <&gcc SATA_RXOOB_CLK>, <&gcc SATA_PMALIVE_CLK>;
@@ -638,13 +649,17 @@
 				 <&gcc PCIE_HCLK_RESET>,
 				 <&gcc PCIE_POR_RESET>,
 				 <&gcc PCIE_PCI_RESET>,
-				 <&gcc PCIE_PHY_RESET>;
-			reset-names = "axi", "ahb", "por", "pci", "phy";
+				 <&gcc PCIE_PHY_RESET>,
+				 <&gcc PCIE_EXT_RESET>;
+			reset-names = "axi", "ahb", "por", "pci", "phy", "ext";
 
 			clocks = <&gcc PCIE_A_CLK>,
 				 <&gcc PCIE_H_CLK>,
-				 <&gcc PCIE_PHY_CLK>;
-			clock-names = "core", "iface", "phy";
+				 <&gcc PCIE_PHY_CLK>,
+				 <&gcc PCIE_ALT_REF_SRC>,
+				 <&gcc PCIE_ALT_REF_CLK>,
+				 <&gcc PCIE_AUX_CLK>;
+			clock-names = "core", "iface", "phy", "alt_src", "alt_clk", "aux";
 			status = "disabled";
 			force_gen1 = <0>;
 		};
@@ -670,13 +685,17 @@
 				 <&gcc PCIE_1_HCLK_RESET>,
 				 <&gcc PCIE_1_POR_RESET>,
 				 <&gcc PCIE_1_PCI_RESET>,
-				 <&gcc PCIE_1_PHY_RESET>;
-			reset-names = "axi", "ahb", "por", "pci", "phy";
+				 <&gcc PCIE_1_PHY_RESET>,
+				 <&gcc PCIE_1_EXT_RESET>;
+			reset-names = "axi", "ahb", "por", "pci", "phy", "ext";
 
 			clocks = <&gcc PCIE_1_A_CLK>,
 				 <&gcc PCIE_1_H_CLK>,
-				 <&gcc PCIE_1_PHY_CLK>;
-			clock-names = "core", "iface", "phy";
+				 <&gcc PCIE_1_PHY_CLK>,
+				 <&gcc PCIE_1_ALT_REF_SRC>,
+				 <&gcc PCIE_1_ALT_REF_CLK>,
+				 <&gcc PCIE_1_AUX_CLK>;
+			clock-names = "core", "iface", "phy", "alt_src", "alt_clk", "aux";
 			status = "disabled";
 			force_gen1 = <0>;
 		};
@@ -702,13 +721,17 @@
 				 <&gcc PCIE_2_HCLK_RESET>,
 				 <&gcc PCIE_2_POR_RESET>,
 				 <&gcc PCIE_2_PCI_RESET>,
-				 <&gcc PCIE_2_PHY_RESET>;
-			reset-names = "axi", "ahb", "por", "pci", "phy";
+				 <&gcc PCIE_2_PHY_RESET>,
+				 <&gcc PCIE_2_EXT_RESET>;
+			reset-names = "axi", "ahb", "por", "pci", "phy", "ext";
 
 			clocks = <&gcc PCIE_2_A_CLK>,
 				 <&gcc PCIE_2_H_CLK>,
-				 <&gcc PCIE_2_PHY_CLK>;
-			clock-names = "core", "iface", "phy";
+				 <&gcc PCIE_2_PHY_CLK>,
+				 <&gcc PCIE_2_ALT_REF_SRC>,
+				 <&gcc PCIE_2_ALT_REF_CLK>,
+				 <&gcc PCIE_2_AUX_CLK>;
+			clock-names = "core", "iface", "phy", "alt_src", "alt_clk", "aux";
 			status = "disabled";
 			force_gen1 = <0>;
 		};
@@ -813,6 +836,7 @@
 				phy-names = "usb2-phy", "usb3-phy";
 				tx-fifo-resize;
 				dr_mode = "host";
+				dis_u3_susphy_quirk;
 			};
 		};
 
@@ -835,6 +859,7 @@
 				phy-names = "usb2-phy", "usb3-phy";
 				tx-fifo-resize;
 				dr_mode = "host";
+				dis_u3_susphy_quirk;
 			};
 		};
 
@@ -944,7 +969,8 @@
 				cap-mmc-highspeed;
 				max-frequency   = <192000000>;
 				#mmc-ddr-1_8v;
-				sd-uhs-sdr50;
+				sd-uhs-sdr104;
+				sd-uhs-ddr50;
 				vmmc-supply = <&vsdcc_fixed>;
 				#dmas = <&sdcc3bam 2>, <&sdcc3bam 1>;
 				#dma-names = "tx", "rx";
Index: linux-3.14.43/arch/arm/mach-qcom/pcie.c
===================================================================
--- linux-3.14.43.orig/arch/arm/mach-qcom/pcie.c
+++ linux-3.14.43/arch/arm/mach-qcom/pcie.c
@@ -162,32 +162,10 @@ static struct msm_pcie_gpio_info_t msm_p
 static struct msm_pcie_clk_info_t
 	msm_pcie_clk_info[MAX_RC_NUM][MSM_PCIE_MAX_CLK] = {
 	{
-	{NULL, "pcie_0_ref_clk_src", 0, false},
-	{NULL, "pcie_0_aux_clk", 1010000, true},
 	{NULL, "pcie_0_cfg_ahb_clk", 0, true},
 	{NULL, "pcie_0_mstr_axi_clk", 0, true},
 	{NULL, "pcie_0_slv_axi_clk", 0, true},
-	{NULL, "pcie_0_ldo", 0, true}
 	},
-	{
-	{NULL, "pcie_1_ref_clk_src", 0, false},
-	{NULL, "pcie_1_aux_clk", 1010000, true},
-	{NULL, "pcie_1_cfg_ahb_clk", 0, true},
-	{NULL, "pcie_1_mstr_axi_clk", 0, true},
-	{NULL, "pcie_1_slv_axi_clk", 0, true},
-	{NULL, "pcie_1_ldo", 0, true}
-	}
-};
-
-/* Pipe Clocks */
-static struct msm_pcie_clk_info_t
-	msm_pcie_pipe_clk_info[MAX_RC_NUM][MSM_PCIE_MAX_PIPE_CLK] = {
-	{
-	{NULL, "pcie_0_pipe_clk", 125000000, true},
-	},
-	{
-	{NULL, "pcie_1_pipe_clk", 125000000, true},
-	}
 };
 
 /* RESETs */
@@ -695,67 +673,6 @@ static void msm_pcie_clk_deinit(struct m
 	regulator_disable(dev->gdsc);
 }
 
-static int msm_pcie_pipe_clk_init(struct msm_pcie_dev_t *dev)
-{
-	int i, rc = 0;
-	struct msm_pcie_clk_info_t *info;
-
-	PCIE_DBG(dev, "RC%d\n", dev->rc_idx);
-
-	for (i = 0; i < MSM_PCIE_MAX_PIPE_CLK; i++) {
-		info = &dev->pipeclk[i];
-
-		if (!info->hdl)
-			continue;
-
-
-		if (info->freq) {
-			rc = clk_set_rate(info->hdl, info->freq);
-			if (rc) {
-				PCIE_ERR(dev,
-					"PCIe: RC%d can't set rate for clk %s: %d.\n",
-					dev->rc_idx, info->name, rc);
-				break;
-			} else {
-				PCIE_DBG2(dev,
-					"PCIe: RC%d set rate for clk %s: %d.\n",
-					dev->rc_idx, info->name, rc);
-			}
-		}
-
-		rc = clk_prepare_enable(info->hdl);
-
-		if (rc)
-			PCIE_ERR(dev, "PCIe: RC%d failed to enable clk %s.\n",
-				dev->rc_idx, info->name);
-		else
-			PCIE_DBG2(dev, "RC%d enabled pipe clk %s.\n",
-				dev->rc_idx, info->name);
-	}
-
-	if (rc) {
-		PCIE_DBG(dev, "RC%d disable pipe clocks for error handling.\n",
-			dev->rc_idx);
-		while (i--)
-			if (dev->pipeclk[i].hdl)
-				clk_disable_unprepare(dev->pipeclk[i].hdl);
-	}
-
-	return rc;
-}
-
-static void msm_pcie_pipe_clk_deinit(struct msm_pcie_dev_t *dev)
-{
-	int i;
-
-	PCIE_DBG(dev, "RC%d\n", dev->rc_idx);
-
-	for (i = 0; i < MSM_PCIE_MAX_PIPE_CLK; i++)
-		if (dev->pipeclk[i].hdl)
-			clk_disable_unprepare(
-				dev->pipeclk[i].hdl);
-}
-
 static void msm_pcie_controller_reset(struct msm_pcie_dev_t *dev)
 {
 	/* Assert pcie_pipe_ares */
@@ -1076,32 +993,6 @@ static int msm_pcie_get_resources(struct
 		}
 	}
 
-	for (i = 0; i < MSM_PCIE_MAX_PIPE_CLK; i++) {
-		clk_info = &dev->pipeclk[i];
-
-		clk_info->hdl = devm_clk_get(&pdev->dev, clk_info->name);
-
-		if (IS_ERR(clk_info->hdl)) {
-			if (clk_info->required) {
-				PCIE_DBG(dev, "Clock %s isn't available:%ld\n",
-				clk_info->name, PTR_ERR(clk_info->hdl));
-				ret = PTR_ERR(clk_info->hdl);
-				goto out;
-			} else {
-				PCIE_DBG(dev, "Ignoring Clock %s\n",
-					clk_info->name);
-				clk_info->hdl = NULL;
-			}
-		} else {
-			if (clkfreq != NULL) {
-				clk_info->freq = clkfreq[i];
-				PCIE_DBG(dev, "Freq of Clock %s is:%d\n",
-					clk_info->name, clk_info->freq);
-			}
-		}
-	}
-
-
 	for (i = 0; i < MSM_PCIE_MAX_RESET; i++) {
 		rst_info = &dev->rst[i];
 
@@ -1294,16 +1185,6 @@ int msm_pcie_enable(struct msm_pcie_dev_
 			 dev->dm_core + PCIE20_DEVICE_CONTROL2_STATUS2);
 	writel_relaxed(LTSSM_EN, dev->parf + PCIE20_PARF_LTSSM);
 
-	if (options & PM_PIPE_CLK) {
-		usleep_range(PHY_STABILIZATION_DELAY_US_MIN,
-					 PHY_STABILIZATION_DELAY_US_MAX);
-		/* Enable the pipe clock */
-		ret = msm_pcie_pipe_clk_init(dev);
-		wmb();
-		if (ret)
-			goto link_fail;
-	}
-
 	PCIE_DBG(dev, "RC%d: waiting for phy ready...\n", dev->rc_idx);
 
 	do {
@@ -1422,7 +1303,6 @@ link_fail:
 	msm_pcie_clk_deinit(dev);
 clk_fail:
 	msm_pcie_vreg_deinit(dev);
-	msm_pcie_pipe_clk_deinit(dev);
 out:
 	mutex_unlock(&dev->setup_lock);
 
@@ -1462,9 +1342,6 @@ void msm_pcie_disable(struct msm_pcie_de
 	if (options & PM_VREG)
 		msm_pcie_vreg_deinit(dev);
 
-	if (options & PM_PIPE_CLK)
-		msm_pcie_pipe_clk_deinit(dev);
-
 	mutex_unlock(&dev->setup_lock);
 }
 
@@ -1576,15 +1453,6 @@ static struct hw_pci msm_pci[MAX_RC_NUM]
 	.map_irq	= msm_pcie_map_irq,
 	.add_bus	= msm_pcie_add_bus,
 	},
-	{
-	.domain = 1,
-	.nr_controllers	= 1,
-	.swizzle	= pci_common_swizzle,
-	.setup		= msm_pcie_setup,
-	.scan		= msm_pcie_scan_bus,
-	.map_irq	= msm_pcie_map_irq,
-	.add_bus	= msm_pcie_add_bus,
-	},
 };
 
 int msm_pcie_rescan(void)
@@ -1595,7 +1463,7 @@ int msm_pcie_rescan(void)
 		return 0;
 
 	for (i = 0; i < pcie_drv.rc_num; i++) {
-		/* s/w reset of pcie */
+		/* reset the RC and enumurate devices */
 		msm_pcie_controller_reset(&msm_pcie_dev[i]);
 		msm_pcie_enumerate(i);
 	}
@@ -1663,6 +1531,40 @@ int msm_pcie_enumerate(u32 rc_idx)
 	return ret;
 }
 
+static ssize_t msm_bus_rescan_store(struct bus_type *bus, const char *buf,
+					size_t count)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		pci_lock_rescan_remove();
+		msm_pcie_rescan();
+		pci_unlock_rescan_remove();
+	}
+	return count;
+}
+static BUS_ATTR(rcrescan, (S_IWUSR|S_IWGRP), NULL, msm_bus_rescan_store);
+
+static ssize_t msm_bus_remove_store(struct bus_type *bus, const char *buf,
+					size_t count)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		pci_lock_rescan_remove();
+		msm_pcie_remove_bus();
+		pci_unlock_rescan_remove();
+	}
+	return count;
+}
+static BUS_ATTR(rcremove, (S_IWUSR|S_IWGRP), NULL, msm_bus_remove_store);
+
 static int msm_pcie_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -1812,8 +1714,6 @@ static int msm_pcie_probe(struct platfor
 				sizeof(msm_pcie_gpio_info));
 	memcpy(msm_pcie_dev[rc_idx].clk, msm_pcie_clk_info[rc_idx],
 				sizeof(msm_pcie_clk_info));
-	memcpy(msm_pcie_dev[rc_idx].pipeclk, msm_pcie_pipe_clk_info[rc_idx],
-				sizeof(msm_pcie_pipe_clk_info));
 
 	memcpy(msm_pcie_dev[rc_idx].rst, msm_pcie_rst_info,
 				sizeof(msm_pcie_rst_info));
@@ -1867,16 +1767,36 @@ static int msm_pcie_probe(struct platfor
 
 	ret = msm_pcie_enumerate(rc_idx);
 
-	if (ret)
+	if (ret) {
 		PCIE_ERR(&msm_pcie_dev[rc_idx],
 			"PCIe: RC%d is not enabled during bootup; it will be enumerated upon WAKE signal.\n",
 			rc_idx);
-	else
+		goto decrease_rc_num;
+	} else {
 		PCIE_ERR(&msm_pcie_dev[rc_idx], "RC%d is enabled in bootup\n",
 			rc_idx);
+	}
 
 	PCIE_DBG(&msm_pcie_dev[rc_idx], "PCIE probed %s\n",
 		dev_name(&(pdev->dev)));
+
+	/* create sysfs files to support power save mode */
+	if (!rc_idx) {
+		ret = bus_create_file(&pci_bus_type, &bus_attr_rcrescan);
+		if (ret != 0) {
+			PCIE_ERR(&msm_pcie_dev[rc_idx],
+				"RC%d failed to create sysfs rcrescan file\n",
+				rc_idx);
+		}
+
+		ret = bus_create_file(&pci_bus_type, &bus_attr_rcremove);
+		if (ret != 0) {
+			PCIE_ERR(&msm_pcie_dev[rc_idx],
+				"RC%d failed to create sysfs rcremove file\n",
+				rc_idx);
+		}
+	}
+
 	mutex_unlock(&pcie_drv.drv_lock);
 	return 0;
 
Index: linux-3.14.43/arch/arm/mach-qcom/pcie.h
===================================================================
--- linux-3.14.43.orig/arch/arm/mach-qcom/pcie.h
+++ linux-3.14.43/arch/arm/mach-qcom/pcie.h
@@ -23,10 +23,10 @@
 #include <mach/msm_pcie.h>
 
 #define MSM_PCIE_MAX_VREG 3
-#define MSM_PCIE_MAX_CLK 6
+#define MSM_PCIE_MAX_CLK 3
 #define MSM_PCIE_MAX_PIPE_CLK 1
 
-#define MAX_RC_NUM 2
+#define MAX_RC_NUM 1
 
 #ifdef CONFIG_ARM_LPAE
 #define PCIE_UPPER_ADDR(addr) ((u32)((addr) >> 32))
@@ -209,7 +209,6 @@ struct msm_pcie_dev_t {
 	struct msm_pcie_vreg_info_t  vreg[MSM_PCIE_MAX_VREG];
 	struct msm_pcie_gpio_info_t  gpio[MSM_PCIE_MAX_GPIO];
 	struct msm_pcie_clk_info_t   clk[MSM_PCIE_MAX_CLK];
-	struct msm_pcie_clk_info_t   pipeclk[MSM_PCIE_MAX_PIPE_CLK];
 	struct msm_pcie_res_info_t   res[MSM_PCIE_MAX_RES];
 	struct msm_pcie_irq_info_t   irq[MSM_PCIE_MAX_IRQ];
 	struct msm_pcie_rst_info_t   rst[MSM_PCIE_MAX_RESET];
Index: linux-3.14.43/arch/arm/mach-qcom/pcie_irq.c
===================================================================
--- linux-3.14.43.orig/arch/arm/mach-qcom/pcie_irq.c
+++ linux-3.14.43/arch/arm/mach-qcom/pcie_irq.c
@@ -242,10 +242,13 @@ void msm_pcie_destroy_irq(unsigned int i
 	int pos;
 	struct msm_pcie_dev_t *dev;
 
-	if (pcie_dev)
+	if (pcie_dev) {
 		dev = pcie_dev;
-	else
+	} else {
 		dev = irq_get_chip_data(irq);
+		if (!dev)
+			return;
+	}
 
 	if (dev->msi_gicm_addr) {
 		PCIE_DBG(dev, "destroy QGIC based irq %d\n", irq);
Index: linux-3.14.43/arch/arm/mach-qcom/pcie_phy.c
===================================================================
--- linux-3.14.43.orig/arch/arm/mach-qcom/pcie_phy.c
+++ linux-3.14.43/arch/arm/mach-qcom/pcie_phy.c
@@ -227,32 +227,6 @@ static void qca_uni_phy_write(void __iom
 	udelay(100);
 }
 
-/**
- * Write register and read back masked value to confirm it is written
- *
- * @base - PHY base virtual address.
- * @offset - register offset.
- * @mask - register bitmask specifying what should be updated
- * @val - value to write.
- */
-static void qca_uni_phy_write_readback(void __iomem *base, u32 offset,
-		const u32 mask, u32 val)
-{
-	u32 write_val, tmp = readl(base + offset);
-
-	tmp &= ~mask;       /* retain other bits */
-	write_val = tmp | val;
-
-	writel(write_val, base + offset);
-
-	/* Read back to see if val was written */
-	tmp = readl(base + offset);
-	tmp &= mask;        /* clear other bits */
-
-	if (tmp != val)
-		pr_err("write: %x to UNI PHY: %x FAILED\n", val, offset);
-}
-
 static int mdio_wait(void __iomem *base)
 {
 	unsigned int mdio_access;
Index: linux-3.14.43/arch/arm/mach-qcom/rpm_log.c
===================================================================
--- linux-3.14.43.orig/arch/arm/mach-qcom/rpm_log.c
+++ linux-3.14.43/arch/arm/mach-qcom/rpm_log.c
@@ -309,6 +309,7 @@ static int __init msm_rpm_log_probe(stru
 	struct dentry *dent;
 	struct resource *res;
 	struct device_node *of_node = pdev->dev.of_node;
+	int result;
 
 	if (!of_node)
 		return -ENODEV;
@@ -330,9 +331,9 @@ static int __init msm_rpm_log_probe(stru
 		return -EBUSY;
 	}
 
-	res = of_property_read_u32_array(of_node, "reg-offsets",
+	result = of_property_read_u32_array(of_node, "reg-offsets",
 				rpm_log_data.reg_offsets, MSM_RPM_LOG_PAGE_COUNT);
-	if (res) {
+	if (result) {
 		dev_err(&pdev->dev, "Invalid or missing property: reg-offsets\n");
 		iounmap(rpm_log_data.reg_base);
 		return -ENODEV;
Index: linux-3.14.43/drivers/ata/Kconfig
===================================================================
--- linux-3.14.43.orig/drivers/ata/Kconfig
+++ linux-3.14.43/drivers/ata/Kconfig
@@ -97,6 +97,14 @@ config SATA_AHCI_PLATFORM
 
 	  If unsure, say N.
 
+config AHCI_IPQ
+	tristate "Qualcomm Atheros IPQ806X AHCI SATA support"
+	help
+	This option enables support for the IPQ806X SoC's
+	onboard AHCI SATA.
+
+	If unsure, say N.
+
 config AHCI_IMX
 	tristate "Freescale i.MX AHCI SATA support"
 	depends on MFD_SYSCON
Index: linux-3.14.43/drivers/ata/Makefile
===================================================================
--- linux-3.14.43.orig/drivers/ata/Makefile
+++ linux-3.14.43/drivers/ata/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_SATA_SIL24)	+= sata_sil24.o
 obj-$(CONFIG_SATA_DWC)		+= sata_dwc_460ex.o
 obj-$(CONFIG_SATA_HIGHBANK)	+= sata_highbank.o libahci.o
 obj-$(CONFIG_AHCI_IMX)		+= ahci_imx.o libahci.o libahci_platform.o
+obj-$(CONFIG_AHCI_IPQ)		+= ahci_ipq.o libahci.o libahci_platform.o
 
 # SFF w/ custom DMA
 obj-$(CONFIG_PDC_ADMA)		+= pdc_adma.o
Index: linux-3.14.43/drivers/ata/ahci.h
===================================================================
--- linux-3.14.43.orig/drivers/ata/ahci.h
+++ linux-3.14.43/drivers/ata/ahci.h
@@ -53,7 +53,7 @@
 
 enum {
 	AHCI_MAX_PORTS		= 32,
-	AHCI_MAX_CLKS		= 5,
+	AHCI_MAX_CLKS		= 6,
 	AHCI_MAX_SG		= 168, /* hardware max is 64K */
 	AHCI_DMA_BOUNDARY	= 0xffffffff,
 	AHCI_MAX_CMDS		= 32,
Index: linux-3.14.43/drivers/ata/ahci_ipq.c
===================================================================
--- /dev/null
+++ linux-3.14.43/drivers/ata/ahci_ipq.c
@@ -0,0 +1,256 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/libata.h>
+#include <linux/ahci_platform.h>
+#include "libata.h"
+#include "ahci.h"
+
+struct ipq_ahci_priv {
+	struct platform_device *ahci_pdev;
+	struct ahci_host_priv *hpriv;
+	void *preg_reset;
+	int pstate;
+};
+struct ipq_ahci_priv *ipqpriv;
+
+static const struct ata_port_info ipq_ahci_port_info = {
+	.flags		= AHCI_FLAG_COMMON,
+	.pio_mask	= ATA_PIO4,
+	.udma_mask	= ATA_UDMA6,
+	.port_ops	= &ahci_platform_ops,
+};
+
+#define SATA_PWR_STATE_DOWN	0x1
+#define SATA_PWR_STATE_UP	0x2
+#define SATA_RESET		0x00902c1c
+
+static void ipq_ahci_hard_reset(struct device *dev)
+{
+	u32 reg;
+
+	reg = readl_relaxed(ipqpriv->preg_reset);
+	writel_relaxed(reg | BIT(0), ipqpriv->preg_reset);
+	/* To make sure the write is complete before we move on */
+	mb();
+
+	reg = readl_relaxed(ipqpriv->preg_reset);
+	writel_relaxed(reg & (~BIT(0)), ipqpriv->preg_reset);
+	/* To make sure the write is complete before we move on */
+	mb();
+}
+
+static int ipq_ahci_suspend(struct device *dev)
+{
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct device_type *apt = &ata_port_type;
+	const struct dev_pm_ops *pm = apt->pm;
+	struct ata_port *ap;
+	int ret = 0, i;
+
+	if (ipqpriv->pstate == SATA_PWR_STATE_UP) {
+		for (i = 0; i < host->n_ports; i++) {
+			ap = host->ports[i];
+			/* Issue Port PM Suspend */
+			ret = pm->runtime_suspend(&ap->tdev);
+			if (ret) {
+				dev_err(dev, "SATA controller port suspend failed\n");
+				return ret;
+			}
+		}
+
+		/* Issue Contoller PM Suspend */
+		ret = ahci_platform_suspend_host(dev);
+		if (ret) {
+			dev_err(dev, "SATA controller host suspend failed\n");
+			return ret;
+		}
+
+		if (ipqpriv->hpriv->phy) {
+			phy_power_off(ipqpriv->hpriv->phy);
+			phy_exit(ipqpriv->hpriv->phy);
+		}
+
+		ahci_platform_disable_clks(ipqpriv->hpriv);
+		ipqpriv->pstate = SATA_PWR_STATE_DOWN;
+	} else {
+		dev_warn(dev, "SATA device already in suspended state");
+	}
+
+	return ret;
+}
+
+static int ipq_ahci_resume(struct device *dev)
+{
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct device_type *apt = &ata_port_type;
+	const struct dev_pm_ops *pm = apt->pm;
+	struct ata_port *ap;
+	int ret = 0, i;
+
+	if (ipqpriv->pstate == SATA_PWR_STATE_DOWN) {
+
+		ahci_platform_enable_clks(ipqpriv->hpriv);
+
+		/* Issue SATA clock hard reset */
+		ipq_ahci_hard_reset(dev);
+
+		if (ipqpriv->hpriv->phy) {
+			phy_init(ipqpriv->hpriv->phy);
+			phy_power_on(ipqpriv->hpriv->phy);
+		}
+
+		/* Issue Contoller PM Resume */
+		ret = ahci_platform_resume_host(dev);
+		if (ret) {
+			dev_err(dev, "SATA controller resume failed\n");
+			return ret;
+		}
+		for (i = 0; i < host->n_ports; i++) {
+			/* Issue Port PM Resume */
+			ap = host->ports[i];
+			ret = pm->runtime_resume(&ap->tdev);
+			if (ret) {
+				dev_err(dev, "SATA controller port resume failed\n");
+				return ret;
+			}
+		}
+		ipqpriv->pstate = SATA_PWR_STATE_UP;
+	} else {
+		dev_warn(dev, "SATA device already in resume state");
+	}
+
+	return ret;
+}
+
+static ssize_t ipq_ahci_display_power_status(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (ipqpriv->pstate == SATA_PWR_STATE_UP)
+		pr_info("\nSATA interface in full power state\n");
+	else if (ipqpriv->pstate == SATA_PWR_STATE_DOWN)
+		pr_info("\nSATA interface in suspended state\n");
+
+	return 0;
+}
+
+static ssize_t ipq_ahci_process_power_request(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (buf[0] == '1')
+		ipq_ahci_suspend(dev);
+	else if (buf[0] == '0')
+		ipq_ahci_resume(dev);
+
+	return count;
+}
+
+static DEVICE_ATTR(ipq_ahci_suspend, S_IRUGO | S_IWUSR,
+	ipq_ahci_display_power_status, ipq_ahci_process_power_request);
+
+static int ipq_ahci_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
+	struct ahci_host_priv *hpriv;
+	int rc;
+
+	hpriv = ahci_platform_get_resources(pdev);
+	if (IS_ERR(hpriv))
+		return PTR_ERR(hpriv);
+
+	rc = ahci_platform_enable_resources(hpriv);
+	if (rc)
+		return rc;
+
+	if (pdata && pdata->init) {
+		rc = pdata->init(dev, hpriv->mmio);
+		if (rc)
+			goto disable_resources;
+	}
+
+	rc = ahci_platform_init_host(pdev, hpriv, &ipq_ahci_port_info, 0, 0);
+	if (rc)
+		goto pdata_exit;
+
+	ipqpriv = devm_kzalloc(dev, sizeof(*ipqpriv), GFP_KERNEL);
+	if (!ipqpriv) {
+		dev_err(dev, "can't alloc ahci_host_priv\n");
+		rc =  -ENOMEM;
+		goto pdata_exit;
+	}
+
+	ipqpriv->ahci_pdev = pdev;
+	ipqpriv->hpriv = hpriv;
+	ipqpriv->pstate = SATA_PWR_STATE_UP;
+
+	ipqpriv->preg_reset = devm_ioremap(dev, SATA_RESET,
+						sizeof(*(ipqpriv->preg_reset)));
+	if (IS_ERR(ipqpriv->preg_reset)) {
+		dev_err(dev, "can't ioremap for preg_reset\n");
+		rc =  -ENOMEM;
+		goto pdata_exit;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ipq_ahci_suspend);
+	if (rc < 0) {
+		dev_err(dev, "SATA failed to create suspend /sys endpoint err=%d\n", rc);
+	}
+
+	return 0;
+pdata_exit:
+	if (pdata && pdata->exit)
+		pdata->exit(dev);
+disable_resources:
+	ahci_platform_disable_resources(hpriv);
+	return rc;
+}
+
+int ipq_ahci_remove(struct platform_device *pdev)
+{
+	ata_platform_remove_one(pdev);
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ipq_ahci_pm_ops, ahci_platform_suspend,
+			 ahci_platform_resume);
+
+static const struct of_device_id ipq_ahci_of_match[] = {
+	{ .compatible = "qcom,ipq806x-ahci", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ipq_ahci_of_match);
+
+static struct platform_driver ipq_ahci_driver = {
+	.probe = ipq_ahci_probe,
+	.remove = ipq_ahci_remove,
+	.driver = {
+		.name = "ahci-ipq",
+		.owner = THIS_MODULE,
+		.of_match_table = ipq_ahci_of_match,
+		.pm = &ipq_ahci_pm_ops,
+	},
+};
+module_platform_driver(ipq_ahci_driver);
+
+MODULE_DESCRIPTION("IPQ806x AHCI SATA platform driver");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_ALIAS("platform:ahci-ipq");
Index: linux-3.14.43/drivers/clk/qcom/Makefile
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/Makefile
+++ linux-3.14.43/drivers/clk/qcom/Makefile
@@ -12,6 +12,7 @@ clk-qcom-$(CONFIG_KRAIT_CLOCKS) += clk-k
 clk-qcom-y += clk-hfpll.o
 clk-qcom-y += clk-qcapll.o
 clk-qcom-y += reset.o
+clk-qcom-y += fab_scaling.o
 
 obj-$(CONFIG_APQ_GCC_8084) += gcc-apq8084.o
 obj-$(CONFIG_APQ_MMCC_8084) += mmcc-apq8084.o
Index: linux-3.14.43/drivers/clk/qcom/adcc-ipq40xx.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/adcc-ipq40xx.c
+++ linux-3.14.43/drivers/clk/qcom/adcc-ipq40xx.c
@@ -171,7 +171,7 @@ static struct clk_cdiv_rcg2 rxm_clk_src
 		.parent_names = adcc_xo_adpll_padmclk,
 		.num_parents = 3,
 		.ops = &clk_cdiv_rcg2_ops,
-		.flags = CLK_SET_RATE_PARENT | CLK_RCG2_NO_WAIT,
+		.flags = CLK_SET_RATE_PARENT,
 	},
 };
 
@@ -203,7 +203,7 @@ static struct clk_cdiv_rcg2 txm_clk_src
 		.parent_names = adcc_xo_adpll_padmclk,
 		.num_parents = 3,
 		.ops = &clk_cdiv_rcg2_ops,
-		.flags = CLK_SET_RATE_PARENT | CLK_RCG2_NO_WAIT,
+		.flags = CLK_SET_RATE_PARENT,
 	},
 };
 
@@ -346,7 +346,7 @@ static struct clk_cdiv_rcg2 pcm_clk_src
 		.parent_names = adcc_xo_adpll,
 		.num_parents = 2,
 		.ops = &clk_cdiv_rcg2_ops,
-		.flags = CLK_SET_RATE_PARENT | CLK_RCG2_NO_WAIT,
+		.flags = CLK_SET_RATE_PARENT,
 	},
 };
 
@@ -386,7 +386,7 @@ static struct clk_rcg2 spdifinfast_src =
 		.parent_names = adcc_xo_adpll,
 		.num_parents = 2,
 		.ops = &clk_rcg2_ops,
-		.flags = CLK_SET_RATE_PARENT | CLK_RCG2_NO_WAIT,
+		.flags = CLK_SET_RATE_PARENT,
 	},
 };
 
Index: linux-3.14.43/drivers/clk/qcom/clk-qcapll.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/clk-qcapll.c
+++ linux-3.14.43/drivers/clk/qcom/clk-qcapll.c
@@ -30,6 +30,8 @@
 
 #define PLL_POSTDIV_MASK	0x380
 #define PLL_POSTDIV_SHFT	7
+#define PLL_PLLPWD_MASK         0x20
+#define PLL_PLLPWD_SHFT         5
 #define PLL_REFDIV_MASK		0x7
 #define PLL_REFDIV_SHFT		0
 #define PLL_TGT_INT_SHFT	1
@@ -43,7 +45,7 @@ static int clk_qcapll_enable(struct clk_
 	struct clk_qcapll *pll = to_clk_qcapll(hw);
 	int ret;
 
-	/* Disable PLL bypass mode. */
+	/* Enable PLL bypass mode. */
 	ret = regmap_update_bits(pll->clkr.regmap, pll->config_reg,
 				 PLL_CONFIG_PLLPWD, 0);
 	if (ret)
@@ -56,17 +58,26 @@ static void clk_qcapll_disable(struct cl
 {
 	struct clk_qcapll *pll = to_clk_qcapll(hw);
 
-	/* Enable PLL bypass mode. */
+	/* Disable PLL bypass mode. */
 	regmap_update_bits(pll->clkr.regmap, pll->config_reg, PLL_CONFIG_PLLPWD,
 			   0x1);
 }
 
+static int clk_qcapll_is_enabled(struct clk_hw *hw)
+{
+	u32 config;
+
+	struct clk_qcapll *pll = to_clk_qcapll(hw);
+	regmap_read(pll->clkr.regmap, pll->config_reg, &config);
+	return config & PLL_PLLPWD_MASK;
+}
+
 static unsigned long
 clk_qcapll_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
 {
 	struct clk_qcapll *pll = to_clk_qcapll(hw);
 	u32 ref_div, post_plldiv, tgt_div_frac, tgt_div_int;
-	u32 rate, config, mod_reg;
+	u32 config, mod_reg;
 
 	regmap_read(pll->clkr.regmap, pll->config_reg, &config);
 	regmap_read(pll->clkr.regmap, pll->mod_reg, &mod_reg);
@@ -137,6 +148,9 @@ clk_qcapll_set_rate(struct clk_hw *hw, u
 	if (!f)
 		return -EINVAL;
 
+	if (clk_qcapll_is_enabled(hw))
+		clk_qcapll_disable(hw);
+
 	regmap_write(pll->clkr.regmap, pll->config1_reg, 0xc);
 	udelay(2);
 	regmap_write(pll->clkr.regmap, pll->config1_reg, 0xd);
@@ -149,6 +163,8 @@ clk_qcapll_set_rate(struct clk_hw *hw, u
 	if (ret)
 		return ret;
 
+	clk_qcapll_enable(hw);
+
 	val = f->tgt_div_int << PLL_TGT_INT_SHFT;
 	val |= f->tgt_div_frac << PLL_TGT_FRAC_SHFT;
 
@@ -172,6 +188,7 @@ clk_qcapll_set_rate(struct clk_hw *hw, u
 const struct clk_ops clk_qcapll_ops = {
 	.enable = clk_qcapll_enable,
 	.disable = clk_qcapll_disable,
+	.is_enabled = clk_qcapll_is_enabled,
 	.recalc_rate = clk_qcapll_recalc_rate,
 	.determine_rate = clk_qcapll_determine_rate,
 	.set_rate = clk_qcapll_set_rate,
Index: linux-3.14.43/drivers/clk/qcom/clk-rcg.h
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/clk-rcg.h
+++ linux-3.14.43/drivers/clk/qcom/clk-rcg.h
@@ -225,5 +225,5 @@ extern const struct clk_ops clk_byte_ops
 extern const struct clk_ops clk_pixel_ops;
 extern const struct clk_ops clk_cdiv_rcg2_ops;
 extern const struct clk_ops clk_muxr_misc_ops;
-
+extern const struct clk_ops clk_cpu_rcg2_ops;
 #endif
Index: linux-3.14.43/drivers/clk/qcom/clk-rcg2.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/clk-rcg2.c
+++ linux-3.14.43/drivers/clk/qcom/clk-rcg2.c
@@ -46,6 +46,7 @@
 #define M_REG			0x8
 #define N_REG			0xc
 #define D_REG			0x10
+#define FEPLL_500_SRC		0x2
 
 static int clk_rcg2_is_enabled(struct clk_hw *hw)
 {
@@ -740,7 +741,13 @@ static int clk_cdiv_rcg2_configure(struc
 
 
 	if ((rcg->cdiv.mask) && (f->pre_div > 16)) {
-		for (i = 2; i <= 32; i++) {
+
+		/* The division is handled by two dividers. Both of which can
+		 * divide by a maximum value of 16. To achieve a division of
+		 * 256 = 16 * 16, we use a divider of 16 in the RCGR and the
+		 * other divider of 16 in the MISC Register.
+		 */
+		for (i = 2; i <= 16; i++) {
 			if (f->pre_div % i == 0)
 				cfg = i;
 		}
@@ -868,6 +875,9 @@ static long clk_muxr_determine_rate(stru
 	unsigned long clk_flags;
 
 	f = qcom_find_freq(rcg->freq_tbl, rate);
+	if (!f)
+		return -EINVAL;
+
 	clk_flags = __clk_get_flags(hw->clk);
 	*p = clk_get_parent_by_index(hw->clk, f->src);
 	if (clk_flags & CLK_SET_RATE_PARENT) {
@@ -929,3 +939,262 @@ const struct clk_ops clk_muxr_misc_ops =
 	.set_rate_and_parent	=	clk_muxr_set_rate_and_parent,
 };
 EXPORT_SYMBOL_GPL(clk_muxr_misc_ops);
+
+static int clk_cpu_rcg2_is_enabled(struct clk_hw *hw)
+{
+	struct clk_cdiv_rcg2 *rcg = to_clk_cdiv_rcg2(hw);
+	u32 cmd;
+	int ret;
+
+	ret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG, &cmd);
+	if (ret)
+		return ret;
+
+	return (cmd & CMD_ROOT_OFF) == 0;
+
+}
+
+static u8 clk_cpu_rcg2_get_parent(struct clk_hw *hw)
+{
+	struct clk_cdiv_rcg2 *rcg = to_clk_cdiv_rcg2(hw);
+	int num_parents = __clk_get_num_parents(hw->clk);
+	u32 cfg;
+	int i, ret;
+
+	ret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);
+	if (ret)
+		return ret;
+
+	cfg &= CFG_SRC_SEL_MASK;
+	cfg >>= CFG_SRC_SEL_SHIFT;
+
+	for (i = 0; i < num_parents; i++)
+		if (cfg == rcg->parent_map[i])
+			return i;
+
+	return -EINVAL;
+}
+
+static int cpu_rcg2_update_config(struct clk_cdiv_rcg2 *rcg)
+{
+	int count, ret;
+	u32 cmd;
+	struct clk_hw *hw = &rcg->clkr.hw;
+	const char *name = __clk_get_name(hw->clk);
+
+	ret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG,
+				 CMD_UPDATE, CMD_UPDATE);
+	if (ret)
+		return ret;
+
+	/* Wait for update to take effect */
+	for (count = 500; count > 0; count--) {
+		ret = regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CMD_REG,
+									&cmd);
+		if (ret)
+			return ret;
+		if (!(cmd & CMD_UPDATE))
+			return 0;
+		udelay(1);
+	}
+
+	WARN(1, "%s: rcg didn't update its configuration.", name);
+	return 0;
+}
+static int clk_cpu_rcg2_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_cdiv_rcg2 *rcg = to_clk_cdiv_rcg2(hw);
+	int ret;
+
+	ret = regmap_update_bits(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG,
+				 CFG_SRC_SEL_MASK,
+				 rcg->parent_map[index] << CFG_SRC_SEL_SHIFT);
+	if (ret)
+		return ret;
+
+	return cpu_rcg2_update_config(rcg);
+}
+
+
+/*
+ * These are used for looking up the actual divider ratios
+ * the divider used for DDR PLL Post divider is not linear,
+ * hence we need this look up table
+ */
+static const unsigned char ddrpll_div[] = {
+		12,
+		13,
+		14,
+		15,
+		16,
+		17,
+		18,
+		19,
+		20,
+		21,
+		22,
+		24,
+		26,
+		28
+};
+
+static unsigned long
+clk_cpu_rcg2_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct clk_cdiv_rcg2 *rcg = to_clk_cdiv_rcg2(hw);
+	u32 cfg, hid_div , m = 0 , n = 0 , mode = 0 , mask , cdiv;
+	unsigned long rate;
+	u32 src;
+
+	regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + CFG_REG, &cfg);
+
+	if (rcg->mnd_width) {
+		mask = BIT(rcg->mnd_width) - 1;
+		regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + M_REG, &m);
+		m &= mask;
+		regmap_read(rcg->clkr.regmap, rcg->cmd_rcgr + N_REG, &n);
+		n =  ~n;
+		n &= mask;
+		n += m;
+		mode = cfg & CFG_MODE_MASK;
+		mode >>= CFG_MODE_SHIFT;
+	}
+
+	mask = BIT(rcg->hid_width) - 1;
+	hid_div = cfg >> CFG_SRC_DIV_SHIFT;
+	hid_div &= mask;
+	rate = calc_rate(parent_rate, m, n, mode, hid_div);
+	src = (cfg >> CFG_SRC_SEL_SHIFT) & 0xf;
+	if (src == 0x1) {
+		regmap_read(rcg->clkr.regmap, rcg->cdiv.offset, &cdiv);
+		cdiv &= (rcg->cdiv.mask << rcg->cdiv.shift);
+		cdiv = cdiv >> rcg->cdiv.shift;
+		do_div(rate , ddrpll_div[cdiv]);
+		rate *= 16;
+		do_div(rate , 1000000);
+		rate = rate * 1000000;
+	}
+	return rate;
+}
+
+static long _cpu_rcg2_freq_tbl_determine_rate(struct clk_hw *hw,
+		const struct freq_tbl *f, unsigned long rate,
+		unsigned long *p_rate, struct clk **p)
+{
+	unsigned long clk_flags;
+
+	f = qcom_find_freq(f, rate);
+	if (!f)
+		return -EINVAL;
+
+	clk_flags = __clk_get_flags(hw->clk);
+	*p = clk_get_parent_by_index(hw->clk, f->src);
+	rate = __clk_get_rate(*p);
+	*p_rate = rate;
+
+	return f->freq;
+}
+
+static long clk_cpu_rcg2_determine_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *p_rate, struct clk **p)
+{
+	struct clk_cdiv_rcg2 *rcg = to_clk_cdiv_rcg2(hw);
+
+	return _cpu_rcg2_freq_tbl_determine_rate(hw, rcg->freq_tbl,
+							rate, p_rate, p);
+}
+
+
+static int clk_cpu_rcg2_configure(struct clk_cdiv_rcg2 *rcg,
+						const struct freq_tbl *f)
+{
+	u32 cfg, mask;
+	int ret;
+
+	if (rcg->mnd_width && f->n) {
+		mask = BIT(rcg->mnd_width) - 1;
+		ret = regmap_update_bits(rcg->clkr.regmap,
+				rcg->cmd_rcgr + M_REG, mask, f->m);
+		if (ret)
+			return ret;
+
+		ret = regmap_update_bits(rcg->clkr.regmap,
+				rcg->cmd_rcgr + N_REG, mask, ~(f->n - f->m));
+		if (ret)
+			return ret;
+
+		ret = regmap_update_bits(rcg->clkr.regmap,
+				rcg->cmd_rcgr + D_REG, mask, ~f->n);
+		if (ret)
+			return ret;
+	}
+
+	if ((rcg->parent_map[f->src] == 0x01)) {
+		mask = (BIT(rcg->hid_width) - 1);
+		mask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;
+		cfg = FEPLL_500_SRC << CFG_SRC_SEL_SHIFT;
+		cfg |= (1 << CFG_SRC_DIV_SHIFT);
+		ret = regmap_update_bits(rcg->clkr.regmap,
+					rcg->cmd_rcgr + CFG_REG, mask, cfg);
+		if (ret)
+			return ret;
+		cpu_rcg2_update_config(rcg);
+		mask = (rcg->cdiv.mask)<<rcg->cdiv.shift;
+		ret = regmap_update_bits(rcg->clkr.regmap,
+					rcg->cdiv.offset, mask,
+				(f->pre_div << rcg->cdiv.shift) & mask);
+		udelay(1);
+		mask = BIT(rcg->hid_width) - 1;
+		mask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;
+		cfg = 1 << CFG_SRC_DIV_SHIFT;
+	} else {
+		mask = BIT(rcg->hid_width) - 1;
+		mask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;
+		cfg = f->pre_div << CFG_SRC_DIV_SHIFT;
+	}
+
+	cfg |= rcg->parent_map[f->src] << CFG_SRC_SEL_SHIFT;
+	if (rcg->mnd_width && f->n)
+		cfg |= CFG_MODE_DUAL_EDGE;
+	ret = regmap_update_bits(rcg->clkr.regmap,
+					rcg->cmd_rcgr + CFG_REG, mask, cfg);
+	if (ret)
+		return ret;
+
+	return cpu_rcg2_update_config(rcg);
+}
+
+static long __clk_cpu_rcg2_set_rate(struct clk_hw *hw, unsigned long rate)
+{
+	struct clk_cdiv_rcg2 *rcg = to_clk_cdiv_rcg2(hw);
+	const struct freq_tbl *f;
+
+	f = qcom_find_freq(rcg->freq_tbl, rate);
+	if (!f)
+		return -EINVAL;
+
+	return clk_cpu_rcg2_configure(rcg, f);
+}
+
+static int clk_cpu_rcg2_set_rate(struct clk_hw *hw, unsigned long rate,
+			    unsigned long parent_rate)
+{
+	return __clk_cpu_rcg2_set_rate(hw, rate);
+}
+
+static int clk_cpu_rcg2_set_rate_and_parent(struct clk_hw *hw,
+		unsigned long rate, unsigned long parent_rate, u8 index)
+{
+	return __clk_cpu_rcg2_set_rate(hw, rate);
+}
+
+const struct clk_ops clk_cpu_rcg2_ops = {
+	.is_enabled	=	clk_cpu_rcg2_is_enabled,
+	.get_parent	=	clk_cpu_rcg2_get_parent,
+	.set_parent	=	clk_cpu_rcg2_set_parent,
+	.recalc_rate	=	clk_cpu_rcg2_recalc_rate,
+	.determine_rate	=	clk_cpu_rcg2_determine_rate,
+	.set_rate	=	clk_cpu_rcg2_set_rate,
+	.set_rate_and_parent	=	clk_cpu_rcg2_set_rate_and_parent,
+};
+EXPORT_SYMBOL_GPL(clk_cpu_rcg2_ops);
Index: linux-3.14.43/drivers/clk/qcom/fab_scaling.c
===================================================================
--- /dev/null
+++ linux-3.14.43/drivers/clk/qcom/fab_scaling.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clk-private.h>
+#include <linux/fab_scaling.h>
+
+#define MAX_CLK_COUNT	5
+
+#define APPS_FAB_CLK	"apps-fab-clk"
+#define DDR_FAB_CLK	"ddr-fab-clk"
+
+static u32 fab_freq_high;
+static u32 fab_freq_nominal;
+
+static struct clk *apps_fab_clk;
+static struct clk *ddr_fab_clk;
+
+static struct fab_scaling_info arr_monitor_clk[MAX_CLK_COUNT];
+
+int scale_fabrics(void)
+{
+	int i, clk_cnt = 0, scale_down = 1;
+	unsigned long curr_freq, new_freq;
+
+	if (!apps_fab_clk || !ddr_fab_clk)
+		return -1;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (!arr_monitor_clk[i].clk || !arr_monitor_clk[i].idle_freq)
+			continue;
+
+		clk_cnt++;
+		curr_freq = clk_get_rate(arr_monitor_clk[i].clk);
+		if (curr_freq > arr_monitor_clk[i].idle_freq) {
+			scale_down = 0;
+			break;
+		}
+	}
+
+	if (clk_cnt) {
+		if (scale_down)
+			new_freq = fab_freq_nominal;
+		else
+			new_freq = fab_freq_high;
+
+		clk_set_rate(apps_fab_clk, new_freq);
+		clk_set_rate(ddr_fab_clk, new_freq);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scale_fabrics);
+
+int fab_scaling_register(struct fab_scaling_info *data)
+{
+	int i, ret = -1;
+
+	if (!data)
+		return ret;
+
+	if (!data->clk)
+		return ret;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (arr_monitor_clk[i].clk == data->clk) {
+			pr_err("Clk already registered!!!\n");
+			return -1;
+		}
+	}
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (!arr_monitor_clk[i].clk) {
+			arr_monitor_clk[i].clk = data->clk;
+			arr_monitor_clk[i].idle_freq = data->idle_freq;
+			ret = 0;
+			break;
+		}
+	}
+
+	if (ret)
+		pr_err("FABRIC scaling registration failed.\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(fab_scaling_register);
+
+int fab_scaling_unregister(struct clk *clk)
+{
+	int i;
+
+	if (!clk)
+		return -1;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		if (arr_monitor_clk[i].clk == clk) {
+			arr_monitor_clk[i].clk = 0;
+			arr_monitor_clk[i].idle_freq = 0;
+			break;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(fab_scaling_unregister);
+
+
+static int ipq806x_fab_scaling_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return -ENODEV;
+
+	if (of_property_read_u32(np, "fab_freq_high", &fab_freq_high)) {
+		pr_err("FABRICS turbo freq not found. Using defaults...\n");
+		fab_freq_high = 533000000;
+	}
+
+	if (of_property_read_u32(np, "fab_freq_nominal", &fab_freq_nominal)) {
+		pr_err("FABRICS nominal freq not found. Using defaults...\n");
+		fab_freq_nominal = 400000000;
+	}
+
+	apps_fab_clk = devm_clk_get(&pdev->dev, APPS_FAB_CLK);
+	if (IS_ERR(apps_fab_clk)) {
+		pr_err("Failed to get APPS FABRIC clock\n");
+		apps_fab_clk = 0;
+		return -ENODEV;
+	}
+
+	ddr_fab_clk = devm_clk_get(&pdev->dev, DDR_FAB_CLK);
+	if (IS_ERR(ddr_fab_clk)) {
+		pr_err("Failed to get DDR FABRIC clock\n");
+		ddr_fab_clk = 0;
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int ipq806x_fab_scaling_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < MAX_CLK_COUNT; i++) {
+		arr_monitor_clk[i].clk = 0;
+		arr_monitor_clk[i].idle_freq = 0;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id fab_scaling_ipq806x_match_table[] = {
+	{ .compatible = "qcom,fab-scaling" },
+	{ }
+};
+
+static struct platform_driver fab_scaling_ipq806x_driver = {
+	.probe		= ipq806x_fab_scaling_probe,
+	.remove		= ipq806x_fab_scaling_remove,
+	.driver		= {
+		.name   = "fab-scaling",
+		.owner  = THIS_MODULE,
+		.of_match_table = fab_scaling_ipq806x_match_table,
+	},
+};
+
+static int __init fab_scaling_ipq806x_init(void)
+{
+	return platform_driver_register(&fab_scaling_ipq806x_driver);
+}
+late_initcall(fab_scaling_ipq806x_init);
+
+static void __exit fab_scaling_ipq806x_exit(void)
+{
+	platform_driver_unregister(&fab_scaling_ipq806x_driver);
+}
+module_exit(fab_scaling_ipq806x_exit);
Index: linux-3.14.43/drivers/clk/qcom/gcc-ipq40xx.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/gcc-ipq40xx.c
+++ linux-3.14.43/drivers/clk/qcom/gcc-ipq40xx.c
@@ -246,6 +246,7 @@
 #define MPM_SLEEP_CBCR				0x2400C
 #define SPDM_BCR				0x25000
 #define MDIO_AHB_CBCR				0x26000
+#define GCC_DDRC_PLL_DIV			0x2E020
 
 
 static const u8 gcc_xo_200_500_map[] = {
@@ -470,8 +471,7 @@ static struct clk_branch gcc_audio_pwm_c
 
 
 static const struct freq_tbl ftbl_gcc_blsp1_qup1_2_i2c_apps_clk[] = {
-	F(19200000, P_XO, 1, 2, 5),
-	F(24000000, P_XO, 1, 1, 2),
+	{19050000, FE_PLL_200, 20, 0, 0},
 	{ }
 };
 
@@ -811,19 +811,32 @@ static struct clk_cdiv_rcg2  sdcc1_apps_
 	},
 };
 
-
-
-
 /*APPS CLOCKS*/
 static const struct freq_tbl ftbl_gcc_apps_clk[] = {
-	F(48000000 , P_XO,	   1, 0, 0),
-	F(200000000, FE_PLL_200,   1, 0, 0),
-	F(500000000, FE_PLL_500,   1, 0, 0),
-	F(626000000, DDRC_PLL_666, 1, 0, 0),
-	{ }
-};
-
-static struct clk_rcg2 apps_clk_src = {
+	{48000000, P_XO,          1, 0, 0},
+	{200000000, FE_PLL_200,   1, 0, 0},
+	{380000000, DDRC_PLL_666, 0xD, 0},
+	{409000000, DDRC_PLL_666, 0xC, 0, 0},
+	{444000000, DDRC_PLL_666, 0xB, 0, 0},
+	{484000000, DDRC_PLL_666, 0xA, 0, 0},
+	{500000000, FE_PLL_500,   1, 0, 0},
+	{507000000, DDRC_PLL_666, 0x9, 0, 0},
+	{532000000, DDRC_PLL_666, 0x8, 0, 0},
+	{560000000, DDRC_PLL_666, 0x7, 0, 0},
+	{592000000, DDRC_PLL_666, 0x6, 0, 0},
+	{626000000, DDRC_PLL_666, 0x5, 0, 0},
+	{666000000, DDRC_PLL_666, 0x4, 0, 0},
+	{710000000, DDRC_PLL_666, 0x3, 0, 0},
+	{761000000, DDRC_PLL_666, 0x2, 0, 0},
+	{819000000, DDRC_PLL_666, 0x1, 0, 0},
+	{888000000, DDRC_PLL_666, 0x0, 0, 0},
+	{}
+};
+
+static struct clk_cdiv_rcg2 apps_clk_src = {
+	.cdiv.offset = GCC_DDRC_PLL_DIV,
+	.cdiv.shift = 4,
+	.cdiv.mask = 0xf,
 	.cmd_rcgr = APSS_CMD_RCGR,
 	.hid_width = 5,
 	.freq_tbl = ftbl_gcc_apps_clk,
@@ -832,7 +845,7 @@ static struct clk_rcg2 apps_clk_src = {
 		.name = "apps_clk_src",
 		.parent_names = gcc_xo_ddr_500_200,
 		.num_parents = 4,
-		.ops = &clk_rcg2_ops,
+		.ops = &clk_cpu_rcg2_ops,
 	},
 };
 
@@ -1640,7 +1653,7 @@ static const struct regmap_config gcc_ip
 	.reg_bits	= 32,
 	.reg_stride	= 4,
 	.val_bits	= 32,
-	.max_register	= 0x2DFFF,
+	.max_register	= 0x2FFFF,
 	.fast_io	= true,
 };
 
@@ -1689,7 +1702,7 @@ static int gcc_ipq40xx_probe(struct plat
 	clk_register_fixed_rate(dev, "ddrpllsdcc1", NULL, CLK_IS_ROOT,
 				      409800000);
 	clk_register_fixed_rate(dev, "ddrpllapss", NULL, CLK_IS_ROOT,
-				      626000000);
+				      666000000);
 	clk_register_fixed_rate(dev, "pcnoc_clk_src", NULL, CLK_IS_ROOT,
 				      100000000);
 
Index: linux-3.14.43/drivers/clk/qcom/gcc-ipq806x.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/gcc-ipq806x.c
+++ linux-3.14.43/drivers/clk/qcom/gcc-ipq806x.c
@@ -3133,6 +3133,11 @@ static const struct qcom_reset_map gcc_i
 	[GMAC_CORE3_RESET] = { 0x3cfc, 0 },
 	[GMAC_CORE4_RESET] = { 0x3d1c, 0 },
 	[GMAC_AHB_RESET] = { 0x3e24, 0 },
+	[CRYPTO_ENG1_RESET] = { 0x3e00, 0},
+	[CRYPTO_ENG2_RESET] = { 0x3e04, 0},
+	[CRYPTO_ENG3_RESET] = { 0x3e08, 0},
+	[CRYPTO_ENG4_RESET] = { 0x3e0c, 0},
+	[CRYPTO_AHB_RESET] = { 0x3e10, 0},
 	[NSS_CH0_RST_RX_CLK_N_RESET] = { 0x3b60, 0 },
 	[NSS_CH0_RST_TX_CLK_N_RESET] = { 0x3b60, 1 },
 	[NSS_CH0_RST_RX_125M_N_RESET] = { 0x3b60, 2 },
Index: linux-3.14.43/drivers/clk/qcom/mmcc-apq8084.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/mmcc-apq8084.c
+++ linux-3.14.43/drivers/clk/qcom/mmcc-apq8084.c
@@ -3324,6 +3324,9 @@ static int mmcc_apq8084_probe(struct pla
 		return ret;
 
 	regmap = dev_get_regmap(&pdev->dev, NULL);
+	if (!regmap)
+		return -ENODEV;
+
 	clk_pll_configure_sr_hpm_lp(&mmpll1, regmap, &mmpll1_config, true);
 	clk_pll_configure_sr_hpm_lp(&mmpll3, regmap, &mmpll3_config, false);
 
Index: linux-3.14.43/drivers/clk/qcom/nss-volt-ipq806x.c
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/nss-volt-ipq806x.c
+++ linux-3.14.43/drivers/clk/qcom/nss-volt-ipq806x.c
@@ -22,6 +22,11 @@
 #include <linux/of_device.h>
 #include "nss-volt-ipq806x.h"
 
+static struct regulator *nss_reg;
+static u32 nss_core_vdd_nominal;
+static u32 nss_core_vdd_high;
+static u32 nss_core_threshold_freq;
+
 static int get_required_vdd_nss_core(unsigned long rate)
 {
 	if (rate >= nss_core_threshold_freq)
@@ -73,7 +78,7 @@ static int nss_ipq806x_probe(struct plat
 	if (!np)
 		return -ENODEV;
 
-	vdd = of_parse_phandle(np, "nss_core-supply", NULL);
+	vdd = of_parse_phandle(np, "nss_core-supply", 0);
 	if (vdd)
 		nss_reg = regulator_get(NULL, vdd->name);
 	else
Index: linux-3.14.43/drivers/clk/qcom/nss-volt-ipq806x.h
===================================================================
--- linux-3.14.43.orig/drivers/clk/qcom/nss-volt-ipq806x.h
+++ linux-3.14.43/drivers/clk/qcom/nss-volt-ipq806x.h
@@ -19,11 +19,6 @@
 
 #include <linux/regulator/consumer.h>
 
-static struct regulator *nss_reg;
-static u32 nss_core_vdd_nominal;
-static u32 nss_core_vdd_high;
-static u32 nss_core_threshold_freq;
-
 int nss_ramp_voltage(unsigned long rate, bool ramp_up);
 
 #endif
Index: linux-3.14.43/drivers/cpufreq/cpufreq-krait.c
===================================================================
--- linux-3.14.43.orig/drivers/cpufreq/cpufreq-krait.c
+++ linux-3.14.43/drivers/cpufreq/cpufreq-krait.c
@@ -25,6 +25,7 @@
 #include <linux/thermal.h>
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
+#include <linux/fab_scaling.h>
 #include <soc/qcom/socinfo.h>
 
 static unsigned int transition_latency;
@@ -38,6 +39,8 @@ static struct regulator *l2_reg;
 static struct cpufreq_frequency_table *freq_table;
 static struct thermal_cooling_device *cdev;
 
+#define OPERATING_PT_FMT	"operating-points-%x-%x"
+
 struct cache_points {
 	unsigned long cache_freq;
 	unsigned long cpu_freq;
@@ -178,6 +181,8 @@ static int krait_set_target(struct cpufr
 			pr_err("failed to scale l2 clk: %d\n", ret);
 	}
 
+	scale_fabrics();
+
 	return ret;
 }
 
@@ -264,17 +269,18 @@ static int krait_cpufreq_get_speed_pvs(s
 
 static int krait_cpufreq_probe(struct platform_device *pdev)
 {
-	char opp_name[sizeof("operating-points-N-M")];
+	char opp_name[strlen(OPERATING_PT_FMT) + 1];
 	struct device_node *np, *cache;
 	int ret, i;
 	unsigned int cpu;
 	struct device *dev;
 	struct clk *clk;
 	struct regulator *core;
-	unsigned long freq_Hz, freq, max_cpu_freq;
+	unsigned long freq_Hz, max_cpu_freq = 0;
 	struct dev_pm_opp *opp;
 	unsigned long volt, tol;
 	u8 speed = 0, pvs = 0;
+	struct fab_scaling_info fab_data;
 
 	cpu_dev = get_cpu_device(0);
 	if (!cpu_dev) {
@@ -294,7 +300,8 @@ static int krait_cpufreq_probe(struct pl
 		goto out_put_node;
 	}
 
-	sprintf(opp_name, "operating-points-%x-%x", speed & 0xF, pvs & 0xF);
+	snprintf(opp_name, strlen(OPERATING_PT_FMT), OPERATING_PT_FMT,
+						speed & 0xF, pvs & 0xF);
 
 	if (dev_pm_opp_get_opp_count(cpu_dev) <= 0) {
 		ret = of_init_opp_table_named(cpu_dev, opp_name);
@@ -383,7 +390,13 @@ static int krait_cpufreq_probe(struct pl
 			pr_err("failed to enable regulator: %d\n", ret);
 			goto out_free_table;
 		}
-		max_cpu_freq = max(max_cpu_freq, freq);
+		max_cpu_freq = max(max_cpu_freq, freq_Hz);
+
+		if (!of_property_read_u32(np, "cpu_freq_idle",
+						&fab_data.idle_freq)) {
+			fab_data.clk = clk;
+			fab_scaling_register(&fab_data);
+		}
 	}
 
 	for (i = 0; i < nr_krait_l2_points; i++) {
@@ -418,6 +431,12 @@ static int krait_cpufreq_probe(struct pl
 	 */
 	for_each_possible_cpu(cpu) {
 		dev = get_cpu_device(cpu);
+		if (!dev) {
+			pr_err("failed to get krait device\n");
+			ret = -ENOENT;
+			goto out_free_table;
+		}
+
 		np = of_node_get(dev->of_node);
 		if (of_find_property(np, "#cooling-cells", NULL)) {
 			cdev = of_cpufreq_cooling_register(np, cpumask_of(cpu));
@@ -441,6 +460,13 @@ out_put_node:
 
 static int krait_cpufreq_remove(struct platform_device *pdev)
 {
+	unsigned int cpu;
+	struct clk *clk;
+
+	for_each_possible_cpu(cpu) {
+		clk = per_cpu(krait_cpu_clks, cpu);
+		fab_scaling_unregister(clk);
+	}
 	cpufreq_cooling_unregister(cdev);
 	cpufreq_unregister_driver(&krait_cpufreq_driver);
 	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);
Index: linux-3.14.43/drivers/cpufreq/qca-ipq40xx-cpufreq.c
===================================================================
--- linux-3.14.43.orig/drivers/cpufreq/qca-ipq40xx-cpufreq.c
+++ linux-3.14.43/drivers/cpufreq/qca-ipq40xx-cpufreq.c
@@ -25,21 +25,79 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
-enum efreq_lvl {
-	L0, L1, L2, L3, L_INVALID
-};
-
-static struct cpufreq_frequency_table qca_ipq40xx_freq_table[] = {
-	{L0, 626000},
-	{L1, 500000},
-	{L2, 200000},
-	{L3, 48000},
-	{L_INVALID, CPUFREQ_TABLE_END},
-};
+#define CPUFREQ_TABLE_END ~1
 
 static unsigned int transition_latency;
 static DEFINE_PER_CPU(struct clk *, cpu_clks);
-static struct cpufreq_frequency_table *freq_table;
+struct cpufreq_frequency_table *ftbl;
+
+
+static struct cpufreq_frequency_table *cpufreq_parse_dt(struct device *dev,
+						char *tbl_name, int cpu)
+{
+	u32 ret, nf, i;
+	u32 *data;
+
+	/* Parse list of usable CPU frequencies. */
+	if (!of_find_property(dev->of_node, tbl_name, &nf))
+		return ERR_PTR(-EINVAL);
+	nf /= sizeof(*data);
+
+	if (nf == 0)
+		return ERR_PTR(-EINVAL);
+
+	data = devm_kzalloc(dev, nf * sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return ERR_PTR(-ENOMEM);
+
+	ret = of_property_read_u32_array(dev->of_node, tbl_name, data, nf);
+	if (ret)
+		return ERR_PTR(ret);
+
+	ftbl = devm_kzalloc(dev, (nf + 1) * sizeof(*ftbl), GFP_KERNEL);
+	if (!ftbl)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < nf; i++) {
+		unsigned long f;
+		struct clk *cpu_clk;
+
+		cpu_clk = per_cpu(cpu_clks, cpu);
+
+		f = clk_round_rate(cpu_clk, data[i] * 1000);
+		if (IS_ERR_VALUE(f))
+			break;
+		f /= 1000;
+
+		/*
+		 * Check if this is the last feasible frequency in the table.
+		 *
+		 * The table listing frequencies higher than what the HW can
+		 * support is not an error since the table might be shared
+		 * across CPUs in different speed bins. It's also not
+		 * sufficient to check if the rounded rate is lower than the
+		 * requested rate as it doesn't cover the following example:
+		 *
+		 * Table lists: 2.2 GHz and 2.5 GHz.
+		 * Rounded rate returns: 2.2 GHz and 2.3 GHz.
+		 *
+		 * In this case, we can CPUfreq to use 2.2 GHz and 2.3 GHz
+		 * instead of rejecting the 2.5 GHz table entry.
+		 */
+		if (i > 0 && f <= ftbl[i-1].frequency)
+			break;
+
+		ftbl[i].driver_data = i;
+		ftbl[i].frequency = f;
+	}
+
+	ftbl[i].driver_data = i;
+	ftbl[i].frequency = CPUFREQ_TABLE_END;
+
+	devm_kfree(dev, data);
+
+	return ftbl;
+}
 
 static int ipq40xx_set_target(struct cpufreq_policy *policy, unsigned int index)
 {
@@ -49,9 +107,9 @@ static int ipq40xx_set_target(struct cpu
 	struct clk *cpu_clk;
 
 	cpu_clk = per_cpu(cpu_clks, policy->cpu);
-	freq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);
+	freq_Hz = clk_round_rate(cpu_clk, ftbl[index].frequency * 1000);
 	if (freq_Hz <= 0)
-		freq_Hz = freq_table[index].frequency * 1000;
+		freq_Hz = ftbl[index].frequency * 1000;
 
 	freq_exact = freq_Hz;
 	new_freq = freq_Hz;
@@ -79,12 +137,12 @@ static int ipq40xx_cpufreq_init(struct c
 {
 	policy->clk = per_cpu(cpu_clks, policy->cpu);
 
-	if (!freq_table) {
+	if (!ftbl) {
 		pr_err("Freq table not initialized.\n");
 		return -ENODEV;
 	}
-	cpufreq_frequency_table_get_attr(freq_table, 0);
-	return cpufreq_generic_init(policy, freq_table, transition_latency);
+	cpufreq_frequency_table_get_attr(ftbl, 0);
+	return cpufreq_generic_init(policy, ftbl, transition_latency);
 }
 
 static struct cpufreq_driver qca_ipq40xx_cpufreq_driver = {
@@ -99,10 +157,10 @@ static struct cpufreq_driver qca_ipq40xx
 
 static int __init ipq40xx_cpufreq_probe(struct platform_device *pdev)
 {
-	struct device_node *np;
+	struct device_node *np = NULL;
+	struct device *dev;
 	struct clk *clk;
 	unsigned int cpu;
-	struct device *dev;
 	int ret;
 
 	for_each_possible_cpu(cpu) {
@@ -120,9 +178,12 @@ static int __init ipq40xx_cpufreq_probe(
 		}
 	}
 
-	freq_table = qca_ipq40xx_freq_table;
+	ftbl = cpufreq_parse_dt(&pdev->dev, "qcom,cpufreq-table", 0);
+
+	np = of_node_get(pdev->dev.of_node);
+	of_property_read_u32(np, "clock-latency", &transition_latency);
 
-	if (!of_property_read_u32(np, "clock-latency", &transition_latency)) {
+	if (!transition_latency) {
 		pr_info("%s: Clock latency not found. Defaults...\n"
 			, __func__);
 		transition_latency = CPUFREQ_ETERNAL;
Index: linux-3.14.43/drivers/crypto/msm/qce50.c
===================================================================
--- linux-3.14.43.orig/drivers/crypto/msm/qce50.c
+++ linux-3.14.43/drivers/crypto/msm/qce50.c
@@ -168,8 +168,10 @@ static int count_sg(struct scatterlist *
 {
 	int i;
 
-	for (i = 0; nbytes > 0; i++, sg = scatterwalk_sg_next(sg))
+	for (i = 0; nbytes > 0 && sg != NULL; i++,
+		sg = scatterwalk_sg_next(sg)) {
 		nbytes -= sg->length;
+	}
 	return i;
 }
 
@@ -178,7 +180,7 @@ static int qce_dma_map_sg(struct device
 {
 	int i;
 
-	for (i = 0; i < nents; ++i) {
+	for (i = 0; ((i < nents) && (sg != NULL)); ++i) {
 		dma_map_sg(dev, sg, 1, direction);
 		sg = scatterwalk_sg_next(sg);
 	}
@@ -191,7 +193,7 @@ static int qce_dma_unmap_sg(struct devic
 {
 	int i;
 
-	for (i = 0; i < nents; ++i) {
+	for (i = 0; ((i < nents) && (sg != NULL)); ++i) {
 		dma_unmap_sg(dev, sg, 1, direction);
 		sg = scatterwalk_sg_next(sg);
 	}
@@ -2332,7 +2334,7 @@ static int _qce_sps_add_sg_data(struct q
 	struct sps_iovec *iovec = sps_bam_pipe->iovec +
 						sps_bam_pipe->iovec_count;
 
-	while (nbytes > 0) {
+	while ((nbytes > 0) && (sg_src != NULL)) {
 		len = min(nbytes, sg_dma_len(sg_src));
 		nbytes -= len;
 		addr = sg_dma_address(sg_src);
Index: linux-3.14.43/drivers/crypto/msm/qcrypto.c
===================================================================
--- linux-3.14.43.orig/drivers/crypto/msm/qcrypto.c
+++ linux-3.14.43/drivers/crypto/msm/qcrypto.c
@@ -613,7 +613,7 @@ static size_t qcrypto_sg_copy_from_buffe
 	int i;
 	size_t offset, len;
 
-	for (i = 0, offset = 0; i < nents; ++i) {
+	for (i = 0, offset = 0; ((i < nents) && (sgl != NULL)); ++i) {
 		len = sg_copy_from_buffer(sgl, 1, buf, buflen);
 		buf += len;
 		buflen -= len;
@@ -630,7 +630,7 @@ static size_t qcrypto_sg_copy_to_buffer(
 	int i;
 	size_t offset, len;
 
-	for (i = 0, offset = 0; i < nents; ++i) {
+	for (i = 0, offset = 0; ((i < nents) && (sgl != NULL)); ++i) {
 		len = sg_copy_to_buffer(sgl, 1, buf, buflen);
 		buf += len;
 		buflen -= len;
@@ -3773,6 +3773,7 @@ static int _qcrypto_prefix_alg_cra_name(
  * Fill up fips_selftest_data structure
  */
 
+#ifdef CONFIG_FIPS_ENABLE
 static void _qcrypto_fips_selftest_d(struct fips_selftest_data *selftest_d,
 					struct ce_hw_support *ce_support,
 					char *prefix)
@@ -3786,6 +3787,7 @@ static void _qcrypto_fips_selftest_d(str
 	selftest_d->prefix_aead_algo = ce_support->use_sw_aead_algo;
 	selftest_d->ce_device = ce_support->ce_device;
 }
+#endif
 
 int qcrypto_cipher_set_device(struct ablkcipher_request *req, unsigned int dev)
 {
@@ -4466,10 +4468,11 @@ static int  _qcrypto_probe(struct platfo
 	struct crypto_engine *pengine;
 	unsigned long flags;
 
+#ifdef CONFIG_FIPS_ENABLE
 	/* For FIPS140-2 Power on self tests */
 	struct fips_selftest_data selftest_d;
 	char prefix[10] = "";
-
+#endif
 	pengine = kzalloc(sizeof(*pengine), GFP_KERNEL);
 	if (!pengine) {
 		pr_err("qcrypto Memory allocation of q_alg FAIL, error %ld\n",
Index: linux-3.14.43/drivers/dma/qcom_adm_dma.c
===================================================================
--- linux-3.14.43.orig/drivers/dma/qcom_adm_dma.c
+++ linux-3.14.43/drivers/dma/qcom_adm_dma.c
@@ -280,6 +280,11 @@ static void msm_dmov_enqueue_cmd_ext_wor
 		PRINT_IO("msm_dmov_enqueue_cmd(%d), start command, status %x\n",
 			id, status);
 		cmd = start_ready_cmd(ch, adm);
+		if (cmd == NULL) {
+			spin_unlock_irqrestore(&dmov_conf[adm].list_lock,
+									flags);
+			goto error;
+		}
 		/*
 		 * We added something to the ready list, and still hold the
 		 * list lock. Thus, no need to check for cmd == NULL
@@ -390,6 +395,7 @@ int msm_dmov_exec_cmd(unsigned id, unsig
 	cmd.dmov_cmd.exec_func = NULL;
 	cmd.id = id;
 	cmd.result = 0;
+	memset(cmd.err.flush, 0, sizeof(cmd.err.flush));
 	INIT_WORK_ONSTACK(&cmd.dmov_cmd.work, msm_dmov_enqueue_cmd_ext_work);
 	init_completion(&cmd.complete);
 
@@ -678,6 +684,9 @@ static int msm_dmov_probe(struct platfor
 	struct resource *mres =
 		platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
+	if (!irqres || !mres)
+		return -ENODEV;
+
         dmov_conf[adm].sd=0;
         dmov_conf[adm].sd_size=0x800;
 	   
Index: linux-3.14.43/drivers/i2c/busses/i2c-msm-v2.h
===================================================================
--- linux-3.14.43.orig/drivers/i2c/busses/i2c-msm-v2.h
+++ linux-3.14.43/drivers/i2c/busses/i2c-msm-v2.h
@@ -370,7 +370,7 @@ struct i2c_msm_xfer_mode_bam {
 	struct resource         *mem;
 	void __iomem            *base;
 	ulong                    handle;
-	u32                      irq;
+	int                      irq;
 	struct i2c_msm_bam_pipe  pipe[2];
 };
 
Index: linux-3.14.43/drivers/input/touchscreen/Kconfig
===================================================================
--- linux-3.14.43.orig/drivers/input/touchscreen/Kconfig
+++ linux-3.14.43/drivers/input/touchscreen/Kconfig
@@ -943,4 +943,16 @@ config TOUCHSCREEN_ZFORCE
 	  To compile this driver as a module, choose M here: the
 	  module will be called zforce_ts.
 
+config TOUCHSCREEN_GSL1680
+	tristate "Silead's GSL1680 capacitive touch screens"
+	depends on I2C
+	help
+	  Say Y here if you have a touchscreen using the Silead's
+	  GSL1680 capacitive touch screen driver.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gsl1680.
+
 endif
Index: linux-3.14.43/drivers/input/touchscreen/Makefile
===================================================================
--- linux-3.14.43.orig/drivers/input/touchscreen/Makefile
+++ linux-3.14.43/drivers/input/touchscreen/Makefile
@@ -77,3 +77,4 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GSL1680)	+= gsl1680_ts.o
Index: linux-3.14.43/drivers/input/touchscreen/gsl1680_ts.c
===================================================================
--- /dev/null
+++ linux-3.14.43/drivers/input/touchscreen/gsl1680_ts.c
@@ -0,0 +1,564 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include "gsl1680_ts.h"
+
+#define ANDROID_KEY_MENU		59
+#define ANDROID_KEY_HOME		102
+#define ANDROID_KEY_BACK		158
+
+#define GSL1680_CLIENT_ADDR		0x40
+#define DMA_TRANS_LEN			0x10
+
+#define GSL_DEV_NAME			"gsl1680_ts"
+
+#define GSL_IRQ_GPIO		35
+#define GSL_RST_GPIO		34
+
+
+static unsigned int gsl1680_key_map[] = {ANDROID_KEY_MENU, ANDROID_KEY_HOME,
+					ANDROID_KEY_BACK};
+
+static int pre_delta;
+static int pre_x;
+static int pre_y;
+static int move_flag;
+
+
+static u32 gsl_read_interface(struct i2c_client *client,
+						u8 reg, u8 *buf, u32 num)
+{
+	struct i2c_msg xfer_msg[2];
+	xfer_msg[0].addr = client->addr;
+	xfer_msg[0].flags = client->flags & I2C_M_TEN;
+	xfer_msg[0].len = 1;
+	xfer_msg[0].buf = &reg;
+
+	xfer_msg[1].addr = client->addr;
+	xfer_msg[1].flags = client->flags & I2C_M_TEN;
+	xfer_msg[1].flags |= I2C_M_RD;
+	xfer_msg[1].len = num;
+	xfer_msg[1].buf = buf;
+
+	if (reg < 0x80)
+		i2c_transfer(client->adapter, xfer_msg, 2);
+
+	return i2c_transfer(client->adapter, xfer_msg, 2);
+}
+
+static u32 gsl_write_interface(struct i2c_client *client,
+					const u8 reg, u8 *buf, u32 num)
+{
+	struct i2c_msg xfer_msg[1];
+
+	buf[0] = reg;
+
+	xfer_msg[0].addr = client->addr;
+	xfer_msg[0].len = num + 1;
+	xfer_msg[0].flags = client->flags & I2C_M_TEN;
+	xfer_msg[0].buf = buf;
+
+	return i2c_transfer(client->adapter, xfer_msg, 1);
+}
+
+static inline void fw2buf(u8 *buf, const u32 *fw)
+{
+	u32 *u32_buf = (int *)buf;
+	*u32_buf = *fw;
+}
+
+static void gsl_start_core(struct i2c_client *client)
+{
+	u8 buf[5] = {0};
+	u8 reg = GSL_START_REG;
+
+	gsl_write_interface(client, reg, buf, 1);
+}
+
+static void gsl_reset_core(struct i2c_client *client)
+{
+	u8 buf[5] = {0};
+
+	buf[1] = 0x88;
+	gsl_write_interface(client, GSL_START_REG, buf, 1);
+	msleep(500);
+
+	buf[1] = 0x04;
+	gsl_write_interface(client, GSL_CLOCK_REG, buf, 1);
+	msleep(500);
+
+	buf[4] = 0x00;
+	buf[3] = 0x00;
+	buf[2] = 0x00;
+	buf[1] = 0x00;
+	gsl_write_interface(client, POWE_FAIL_REG, buf, 4);
+	msleep(500);
+}
+
+static void gsl_load_fw(struct i2c_client *client)
+{
+	u8 buf[129] = {0};
+	u8 send_flag = 1;
+	u8 *cur = buf + 1;
+	u32 source_line = 0;
+	u32 source_len = ARRAY_SIZE(GSL1680_D0_FW);
+
+	for (; source_line < source_len; source_line++) {
+		/* init page trans, set the page val */
+		if (GSL_PAGE_REG == GSL1680_D0_FW[source_line].offset) {
+			fw2buf(cur, &GSL1680_D0_FW[source_line].val);
+			gsl_write_interface(client, GSL_PAGE_REG, buf, 4);
+			send_flag = 1;
+		} else {
+			if (1 == send_flag % DMA_TRANS_LEN)
+				buf[0] = (u8)GSL1680_D0_FW[source_line].offset;
+
+			fw2buf(cur, &GSL1680_D0_FW[source_line].val);
+			cur += 4;
+
+			if (0 == send_flag % DMA_TRANS_LEN) {
+				gsl_write_interface(client, buf[0], buf,
+							cur - buf - 1);
+				cur = buf + 1;
+			}
+			send_flag++;
+		}
+	}
+}
+
+
+static int check_mem_data(struct i2c_client *client)
+{
+	char buf[4] = {0};
+
+	msleep(500);
+	gsl_read_interface(client, 0xb0, buf, 4);
+
+	if (buf[3] != 0x5a || buf[2] != 0x5a || buf[1] != 0x5a
+						|| buf[0] != 0x5a) {
+		pr_info("first attempt failed. firmware retry\n");
+		gsl_reset_core(client);
+		gsl_load_fw(client);
+		gsl_start_core(client);
+		gsl_reset_core(client);
+		gsl_start_core(client);
+
+		gsl_read_interface(client, 0xb0, buf, 4);
+		if (buf[3] != 0x5a || buf[2] != 0x5a || buf[1] != 0x5a
+						 || buf[0] != 0x5a) {
+			pr_info("GSL: Firmware Upgrade Failed !!\n");
+			return 1;
+		}
+	}
+
+	pr_info("GSL: Firmware Upgarde Success !!\n");
+	return 0;
+}
+
+static void gsl1680_touch_up(struct gsl_ts_data *ddata)
+{
+	int i;
+	struct input_dev *ts_input = ddata->idev;
+
+	for (i = 0; i < ARRAY_SIZE(gsl1680_key_map); i++)
+		input_event(ts_input, EV_KEY, gsl1680_key_map[i], 0);
+}
+
+static void gsl_report_point(struct gsl_ts_data *ddata, u8 num)
+{
+	input_report_abs(ddata->idev, ABS_MT_TOUCH_MAJOR, MAX_TOUCH);
+	input_report_abs(ddata->idev, ABS_MT_POSITION_X,
+					ddata->ti->point[num].x);
+	input_report_abs(ddata->idev, ABS_MT_POSITION_Y,
+					ddata->ti->point[num].y);
+	input_report_abs(ddata->idev, ABS_MT_WIDTH_MAJOR, MAX_WIDTH);
+	input_mt_sync(ddata->idev);
+}
+
+static void gsl_report_work(struct work_struct *work)
+{
+	int tmp;
+	struct gsl_ts_data *ddata =
+				container_of(work, struct gsl_ts_data, work);
+
+	gsl_read_interface(ddata->client, TOUCH_INFO_REG,
+			(u8 *)(ddata->ti), sizeof(union gsl_touch_info));
+	pre_delta = abs(pre_x - ddata->ti->point[0].x) +
+			abs(pre_y - ddata->ti->point[0].y);
+	pre_x = ddata->ti->point[0].x;
+	pre_y = ddata->ti->point[0].y;
+	move_flag++;
+	if (pre_delta < 5 && (move_flag % 2) != 0 &&
+				ddata->ti->finger_num != 0) {
+		pre_delta = 0;
+		return;
+	}
+	if (0 == ddata->ti->finger_num) {
+		pr_info("gsl_report_work,finger_num==0\n");
+		move_flag = 0;
+		gsl1680_touch_up(ddata);
+		input_mt_sync(ddata->idev);
+	} else {
+		pr_info("gsl_report_work,finger_num==multi finger ,gsl_report_point\n");
+		for (tmp = 0; tmp < ddata->ti->finger_num; tmp++)
+			gsl_report_point(ddata, tmp);
+	}
+
+	input_report_key(ddata->idev, BTN_TOUCH, !!ddata->ti->finger_num);
+	input_sync(ddata->idev);
+}
+
+static irqreturn_t gsl_irq_handle(int irq, void *dev_id)
+{
+	struct gsl_ts_data *ddata = dev_id;
+
+	disable_irq_nosync(irq);
+
+	queue_work(ddata->wq, &ddata->work);
+	enable_irq(ddata->irq);
+	return IRQ_HANDLED;
+}
+
+static int gsl_request_input(struct gsl_ts_data *ddata)
+{
+	int ret = 0;
+	int i;
+
+	ddata->idev = input_allocate_device();
+	if (!ddata->idev) {
+		pr_info("could not allocate device");
+		return -ENODEV;
+	}
+
+	ddata->idev->name = GSL_DEV_NAME;
+	ddata->idev->id.bustype = BUS_I2C;
+	ddata->idev->dev.parent = &ddata->client->dev;
+	input_set_drvdata(ddata->idev, ddata);
+
+	__set_bit(EV_ABS, ddata->idev->evbit);
+	__set_bit(EV_KEY, ddata->idev->evbit);
+	__set_bit(BTN_TOUCH, ddata->idev->keybit);
+	__set_bit(INPUT_PROP_DIRECT, ddata->idev->propbit);
+
+	for (i = 0; i < ARRAY_SIZE(gsl1680_key_map); i++)
+		__set_bit(gsl1680_key_map[i], ddata->idev->keybit);
+
+	input_set_abs_params(ddata->idev, ABS_MT_POSITION_X,
+						DIS_MIN_X, DIS_MAX_X, 0, 0);
+	input_set_abs_params(ddata->idev, ABS_MT_POSITION_Y,
+						DIS_MIN_Y, DIS_MAX_Y, 0, 0);
+	input_set_abs_params(ddata->idev, ABS_MT_TOUCH_MAJOR,
+						MIN_TOUCH, MAX_TOUCH, 0, 0);
+	input_set_abs_params(ddata->idev, ABS_MT_WIDTH_MAJOR,
+						MIN_WIDTH, MAX_WIDTH, 0, 0);
+	input_set_abs_params(ddata->idev, ABS_MT_TRACKING_ID,
+						MIN_TRCKID, MAX_TRCKID, 0, 0);
+
+	INIT_WORK(&ddata->work, gsl_report_work);
+
+	ddata->wq = create_singlethread_workqueue(GSL_DEV_NAME);
+	if (!ddata->wq) {
+		ret = -ENOMEM;
+		goto error_wq_create;
+	}
+
+	ret = input_register_device(ddata->idev);
+	if (ret) {
+		pr_info("ret = %d : could not register input device", ret);
+		goto error_unreg_device;
+	}
+	return 0;
+
+error_unreg_device:
+	destroy_workqueue(ddata->wq);
+error_wq_create:
+	input_free_device(ddata->idev);
+	return ret;
+}
+
+static int gsl1680_pin_config(void)
+{
+	gpio_request(GSL_IRQ_GPIO, "ts_irq");
+	gpio_direction_input(GSL_IRQ_GPIO);
+
+	gpio_request(GSL_RST_GPIO, "ts_rst");
+	gpio_direction_output(GSL_RST_GPIO, 1);
+	msleep(500);
+	gpio_direction_output(GSL_RST_GPIO, 0);
+	msleep(500);
+	gpio_direction_output(GSL_RST_GPIO, 1);
+	msleep(500);
+	return gpio_to_irq(GSL_IRQ_GPIO);
+}
+
+static int gsl_hw_init(struct gsl_ts_data *ddata)
+{
+	int ret;
+
+	ddata->irq = gsl1680_pin_config();
+	if (ddata->irq < 0) {
+		ret = ddata->irq;
+		goto error_pin_config;
+	}
+
+	ret = request_irq(ddata->irq, gsl_irq_handle, IRQF_TRIGGER_RISING,
+							GSL_DEV_NAME, ddata);
+	if (ret)
+		goto error_req_irq;
+
+	return 0;
+
+error_req_irq:
+	free_irq(ddata->irq, ddata);
+error_pin_config:
+	gpio_free(GSL_IRQ_GPIO);
+#ifdef GPIO_RST_USE
+	gpio_free(GSL_RST_GPIO);
+#endif
+	return ret;
+}
+
+static int gsl_sw_init(struct gsl_ts_data *ddata)
+{
+	i2c_set_clientdata(ddata->client, ddata);
+
+	if (!i2c_check_functionality(ddata->client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&ddata->client->dev, "I2C functionality not support!\n");
+		return -EIO;
+	}
+	gsl_reset_core(ddata->client);
+	msleep(500);
+	gsl_load_fw(ddata->client);
+	msleep(500);
+	gsl_start_core(ddata->client);
+	msleep(500);
+	gsl_reset_core(ddata->client);
+	msleep(500);
+	gsl_start_core(ddata->client);
+	msleep(500);
+
+	if (check_mem_data(ddata->client))
+		return 1;
+
+	return 0;
+}
+
+
+#ifdef USE_IOCTL
+#define GSL_PR_DIFVALUE         1
+#define GSL_UPDATE_FIRMWARE     2
+
+static int gsl_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static void gsl_release(struct inode *inode, struct file *filp)
+{
+}
+
+static ssize_t gsl_write(struct file *filp, const char __user *buf,
+						size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static ssize_t gsl_read(struct file *filp, const char *buf,
+					size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static int gsl_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static const struct file_operations gsl_fops = {
+	.owner      = THIS_MODULE,
+	.write      = gsl_write,
+	.read       = gsl_read,
+	.unlocked_ioctl = gsl_ioctl
+};
+#endif
+
+static int gsl1680_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct gsl_ts_data *ddata;
+	int ret = 0;
+#ifdef USE_IOCTL
+	struct class *i2c_dev_class;
+	struct device *dev;
+#endif
+
+	ddata = kzalloc(sizeof(struct gsl_ts_data), GFP_KERNEL);
+	if (!ddata) {
+		pr_info("failed to alloc ddata memoryi!");
+		return -ENOMEM;
+	}
+
+	ddata->ti = kzalloc(sizeof(union gsl_touch_info), GFP_KERNEL);
+	if (!ddata->ti) {
+		pr_info("failed to alloc ddata->ti memoryi!");
+		ret = -ENOMEM;
+		goto error_alloc_mem;
+	}
+
+	ddata->client = client;
+
+#ifdef USE_IOCTL
+#define I2C_MAJOR   125
+
+	ret = register_chrdev(I2C_MAJOR, "gsl", &gsl_fops);
+	if (ret) {
+		pr_info("regist chrdev error...\n");
+		goto error_regist_input;
+	}
+
+	i2c_dev_class = class_create(THIS_MODULE, "gsl");
+	if (IS_ERR(i2c_dev_class)) {
+		ret = PTR_ERR(i2c_dev_class);
+		goto error_regist_input;
+	}
+
+	dev = device_create(i2c_dev_class, &client->adapter->dev,
+		MKDEV(I2C_MAJOR, client->adapter->nr), NULL,
+		"gsl%d", client->adapter->nr);
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+		goto error_regist_input;
+	}
+#endif
+
+	/* regist a input dev */
+	ret = gsl_request_input(ddata);
+	if (ret) {
+		pr_info("failed to regist input dev!");
+		goto error_regist_input;
+	}
+
+	/* setup the gpio -- irq & rst */
+	ret = gsl_hw_init(ddata);
+	if (ret) {
+		pr_info("failed to init hw!");
+		goto error_init_hw;
+	}
+
+	/* setup client data & download fw */
+	ret = gsl_sw_init(ddata);
+	if (ret) {
+		pr_info("failed to init sw!\n");
+		goto error_init_sw;
+	}
+
+	pr_info("abcd,gsl1680_probe,exit\n");
+
+	return 0;
+
+error_init_sw:
+	free_irq(ddata->irq, ddata);
+	gpio_free(GSL_IRQ_GPIO);
+#ifdef GPIO_RST_USE
+	gpio_free(GSL_RST_GPIO);
+#endif
+error_init_hw:
+	input_unregister_device(ddata->idev);
+	destroy_workqueue(ddata->wq);
+	input_free_device(ddata->idev);
+error_regist_input:
+	kfree(ddata->ti);
+error_alloc_mem:
+	kfree(ddata);
+
+	return ret;
+}
+
+static int gsl1680_remove(struct i2c_client *client)
+{
+	struct gsl_ts_data *ddata = i2c_get_clientdata(client);
+
+	free_irq(ddata->irq, ddata);
+	gpio_free(GSL_IRQ_GPIO);
+#ifdef GPIO_RST_USE
+	gpio_free(GSL_RST_GPIO);
+#endif
+	input_unregister_device(ddata->idev);
+	destroy_workqueue(ddata->wq);
+	input_free_device(ddata->idev);
+	kfree(ddata->ti);
+	kfree(ddata);
+
+	return 0;
+}
+
+static const struct i2c_device_id gsl1680_idtable[] = {
+	[0] = {
+		.name = GSL_DEV_NAME,
+		.driver_data = 0,
+	},
+	[1] = {},
+};
+
+static struct i2c_driver gsl1680_driver = {
+	.driver = {
+		.name	= GSL_DEV_NAME,
+		.owner	= THIS_MODULE,
+	},
+
+	.id_table	= gsl1680_idtable,
+	.probe		= gsl1680_probe,
+	.remove		= gsl1680_remove,
+};
+
+static struct i2c_board_info gsl1680_info = {
+	.type = GSL_DEV_NAME,
+	.addr = GSL1680_CLIENT_ADDR,
+};
+
+static int __init gsl1680_driver_init(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&gsl1680_driver);
+	if (ret < 0)
+		pr_info("i2c_add_driver failed");
+
+	return ret;
+}
+
+static void __exit gsl1680_driver_exit(void)
+{
+	i2c_del_driver(&gsl1680_driver);
+}
+
+module_init(gsl1680_driver_init);
+module_exit(gsl1680_driver_exit);
Index: linux-3.14.43/drivers/input/touchscreen/gsl1680_ts.h
===================================================================
--- /dev/null
+++ linux-3.14.43/drivers/input/touchscreen/gsl1680_ts.h
@@ -0,0 +1,5577 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* touch coordinate range */
+#define TP_WIDTH		480
+#define TP_LENTH		800
+
+/* coordinate direction */
+#define TP_DIREC		1
+
+/* touch threshold */
+#define MAI_TRSD		200
+#define SUB_TRSD		40
+#define SUM_TRSD		(MAI_TRSD + SUB_TRSD + 20)
+
+/* touch tigger condition */
+#define TRIG_MOD		1
+#define VOLT_LEV		0
+/* touch sensitivity */
+#define TP_DACG			0x00100010
+
+#define GSL_PAGE_REG		0xf0
+#define GSL_CLOCK_REG		0xe4
+#define GSL_START_REG		0xe0
+#define GSL_CLOCK_REG		0xe4
+#define POWE_FAIL_REG		0xbc
+#define TOUCH_INFO_REG		0x80
+
+#define DIS_MIN_X		0
+#define DIS_MAX_X		TP_WIDTH
+#define DIS_MIN_Y		0
+#define DIS_MAX_Y		TP_LENTH
+
+#define MIN_TOUCH		0
+#define MAX_TOUCH		1
+#define MIN_WIDTH		0
+#define MAX_WIDTH		1
+#define MIN_TRCKID		0
+#define MAX_TRCKID		5
+
+/* the data format of one point */
+union gsl_point_data {
+	struct {
+		u16 y;
+		u16 x:12;
+		u16 id:4;
+	};
+	u8 all[4];
+};
+
+/* the 24-byte data of read once */
+union gsl_touch_info {
+	struct {
+		u32 finger_num:8;
+		u32 :0;
+		union gsl_point_data point[5];
+	};
+	u8 all[24];
+};
+
+struct gsl_ts_data {
+	union gsl_touch_info *ti;
+	struct i2c_client *client;
+	struct input_dev *idev;
+	struct workqueue_struct *wq;
+	struct work_struct work;
+	unsigned int irq;
+};
+
+struct gsl_avoid_jit {
+	union gsl_point_data pre;
+	union gsl_point_data base;
+	u32 delta;
+};
+
+/* Fixme mem Alig */
+struct fw_data {
+	u32 offset:8;
+	u32 :0;
+	u32 val;
+};
+
+static const struct fw_data GSL1680_D0_FW[] = {
+{0xf0, 0x3},
+{0x00, 0xa5a5ffc0},
+{0x04, 0x00000000},
+{0x08, 0xe810c4e1},
+{0x0c, 0xd3dd7f4d},
+{0x10, 0xd7c56634},
+{0x14, 0xe3505a2a},
+{0x18, 0x514d494f},
+{0x1c, 0xafebf471},
+{0x20, 0x00000000},
+{0x24, 0x00000000},
+{0x28, 0x00000000},
+{0x2c, 0x00000000},
+{0x30, 0x00001000},
+{0x34, 0x00000000},
+{0x38, 0x00000000},
+{0x3c, 0x00000000},
+{0x40, 0x00000001},
+{0x44, 0x00000000},
+{0x48, 0x00000000},
+{0x4c, 0x00000000},
+{0x50, 0x00000000},
+{0x54, 0x01020304},
+{0x58, 0x05060708},
+{0x5c, 0x090a0b0c},
+{0x60, 0x0d0e0e0f},
+{0x64, 0x10111213},
+{0x68, 0x14151617},
+{0x6c, 0x18191a1b},
+{0x70, 0x1b1c1e1f},
+{0x74, 0x00000000},
+{0x78, 0x00010000},
+{0x7c, 0x8c846af3},
+{0xf0, 0x4},
+{0x00, 0x00000000},
+{0x04, 0x00000000},
+{0x08, 0x00000000},
+{0x0c, 0x00000000},
+{0x10, 0xffffff38},
+{0x14, 0x00000000},
+{0x18, 0x00000000},
+{0x1c, 0x00000000},
+{0x20, 0x00000000},
+{0x24, 0x00000000},
+{0x28, 0x00000000},
+{0x2c, 0x00000000},
+{0x30, 0x00002400},
+{0x34, 0x00000000},
+{0x38, 0x00000000},
+{0x3c, 0x00000000},
+{0x40, 0x00000000},
+{0x44, 0x00000000},
+{0x48, 0x00000000},
+{0x4c, 0x00000000},
+{0x50, 0x00000000},
+{0x54, 0x00010203},
+{0x58, 0x03040506},
+{0x5c, 0x06070808},
+{0x60, 0x090a0b0c},
+{0x64, 0x0d0e0f10},
+{0x68, 0x10111314},
+{0x6c, 0x15161819},
+{0x70, 0x1a1b1d1f},
+{0x74, 0x00000000},
+{0x78, 0x8080a680},
+{0x7c, 0x8c846af3},
+{0xf0, 0x5},
+{0x00, 0xf3b18989},
+{0x04, 0x00000005},
+{0x08, 0x0000012c},
+{0x0c, 0x80808080},
+{0x10, 0x00000000},
+{0x14, 0x00000000},
+{0x18, 0x00010fff},
+{0x1c, 0x10000000},
+{0x20, 0x10000000},
+{0x24, 0x00000000},
+{0x28, 0x00000000},
+{0x2c, 0x00000400},
+{0x30, 0x00808080},
+{0x34, 0x80808080},
+{0x38, 0x80808080},
+{0x3c, 0x80808080},
+{0x40, 0x80808080},
+{0x44, 0x80808080},
+{0x48, 0x80808080},
+{0x4c, 0x80808080},
+{0x50, 0x00000000},
+{0x54, 0x00010202},
+{0x58, 0x03040505},
+{0x5c, 0x06070808},
+{0x60, 0x090a0b0c},
+{0x64, 0x0d0e0f10},
+{0x68, 0x11121314},
+{0x6c, 0x15161819},
+{0x70, 0x1a1b1d1e},
+{0x74, 0x00000001},
+{0x78, 0x0000000f},
+{0x7c, 0x0000000a},
+{0xf0, 0x6},
+{0x00, 0x0000000f},
+{0x04, 0x00000000},
+{0x08, 0x0000000a},
+{0x0c, 0x00000000},
+{0x10, 0x00000032},
+{0x14, 0x00000014},
+{0x18, 0x00000000},
+{0x1c, 0x00000001},
+{0x20, 0x00002904},
+{0x24, 0x000001e0},
+{0x28, 0x00000320},
+{0x2c, 0xf8010009},
+{0x30, 0xf8010009},
+{0x34, 0x00000004},
+{0x38, 0x00000003},
+{0x3c, 0x00010fff},
+{0x40, 0x80000000},
+{0x44, 0x00160016},
+{0x48, 0x00000fff},
+{0x4c, 0x00000003},
+{0x50, 0x00020001},
+{0x54, 0x00000064},
+{0x58, 0x00001000},
+{0x5c, 0x09249248},
+{0x60, 0x00000000},
+{0x64, 0x000007d0},
+{0x68, 0x00000000},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x000001c2},
+{0x78, 0x00000064},
+{0x7c, 0x00000000},
+{0xf0, 0x7},
+{0x00, 0x04010700},
+{0x04, 0x06030902},
+{0x08, 0x0805040a},
+{0x0c, 0x07110610},
+{0x10, 0x09130812},
+{0x14, 0x00543216},
+{0x18, 0x007890ab},
+{0x1c, 0x00321094},
+{0x20, 0x005678ab},
+{0x24, 0xff080010},
+{0x28, 0xff080120},
+{0x2c, 0xff080140},
+{0x30, 0xff080160},
+{0x34, 0x000000fa},
+{0x38, 0x000000d8},
+{0x3c, 0x000000b7},
+{0x40, 0x00000014},
+{0x44, 0x00000100},
+{0x48, 0x00000000},
+{0x4c, 0x00000004},
+{0x50, 0x00000000},
+{0x54, 0x00000001},
+{0x58, 0x000e0000},
+{0x5c, 0x00000000},
+{0x60, 0x00000000},
+{0x64, 0x00000000},
+{0x68, 0x00080002},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x00000000},
+{0x78, 0x00432105},
+{0x7c, 0x006789ab},
+{0xf0, 0x8},
+{0x00, 0x026f028f},
+{0x04, 0x02af02cf},
+{0x08, 0x02ef030f},
+{0x0c, 0x032f034f},
+{0x10, 0x01f301f4},
+{0x14, 0x01f501f6},
+{0x18, 0x01f701f8},
+{0x1c, 0x11f901fa},
+{0x20, 0x022f024f},
+{0x24, 0x036f01f0},
+{0x28, 0x01f101f2},
+{0x2c, 0x020f0000},
+{0x30, 0x00000000},
+{0x34, 0x00000000},
+{0x38, 0x00000000},
+{0x3c, 0x000043ef},
+{0x40, 0x02040608},
+{0x44, 0x0a000000},
+{0x48, 0x00000000},
+{0x4c, 0x01030507},
+{0x50, 0x09000000},
+{0x54, 0x00000000},
+{0x58, 0x00c800aa},
+{0x5c, 0x00000008},
+{0x60, 0x00000118},
+{0x64, 0x00000201},
+{0x68, 0x00000804},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x00000000},
+{0x78, 0x00000000},
+{0x7c, 0x0000000a},
+{0xf0, 0x9},
+{0x00, 0xff080094},
+{0x04, 0x00070011},
+{0x08, 0xff080090},
+{0x0c, 0x00040000},
+{0x10, 0xfffffff0},
+{0x14, 0x00000000},
+{0x18, 0xfffffff0},
+{0x1c, 0x00000000},
+{0x20, 0xfffffff0},
+{0x24, 0x00000000},
+{0x28, 0xfffffff0},
+{0x2c, 0x00000000},
+{0x30, 0xfffffff0},
+{0x34, 0x00000000},
+{0x38, 0xfffffff0},
+{0x3c, 0x00000000},
+{0x40, 0xfffffff0},
+{0x44, 0x00000000},
+{0x48, 0xfffffff0},
+{0x4c, 0x00000000},
+{0x50, 0xfffffff0},
+{0x54, 0x00000000},
+{0x58, 0xfffffff0},
+{0x5c, 0x00000000},
+{0x60, 0xfffffff0},
+{0x64, 0x00000000},
+{0x68, 0xfffffff0},
+{0x6c, 0x00000000},
+{0x70, 0xfffffff0},
+{0x74, 0x00000000},
+{0x78, 0xfffffff0},
+{0x7c, 0x00000000},
+
+{0xf0, 0xe0},
+{0x00, 0x006e002b},
+{0x04, 0x00000075},
+{0x08, 0x005c0088},
+{0x0c, 0x009a0011},
+{0x10, 0x00ad0007},
+{0x14, 0x0024000c},
+{0x18, 0x001500e9},
+{0x1c, 0x003f0084},
+{0x20, 0x00bc0021},
+{0x24, 0x003c0079},
+{0x28, 0x007d0064},
+{0x2c, 0x006200b6},
+{0x30, 0x00d30001},
+{0x34, 0x0000011e},
+{0x38, 0x0135003c},
+{0x3c, 0x00730086},
+{0x40, 0x006401f4},
+{0x44, 0x00640064},
+{0x48, 0x01900064},
+{0x4c, 0x00500190},
+{0x50, 0x00500050},
+{0x54, 0x012c0050},
+{0x58, 0x012c012c},
+{0x5c, 0x0032012c},
+{0x60, 0x00640000},
+{0x64, 0x00640064},
+{0x68, 0x00000032},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x00000000},
+{0x78, 0x00000000},
+{0x7c, 0x00000000},
+{0xf0, 0xe1},
+{0x00, 0x00810028},
+{0x04, 0x00000068},
+{0x08, 0x00590071},
+{0x0c, 0x00a80014},
+{0x10, 0x00aa0000},
+{0x14, 0x0029000a},
+{0x18, 0x002000bc},
+{0x1c, 0x003e0079},
+{0x20, 0x00a70025},
+{0x24, 0x00330071},
+{0x28, 0x00720062},
+{0x2c, 0x008300ae},
+{0x30, 0x00b50000},
+{0x34, 0x00000110},
+{0x38, 0x012c0034},
+{0x3c, 0x005d0090},
+{0x40, 0x00000000},
+{0x44, 0x00000000},
+{0x48, 0x00000000},
+{0x4c, 0x00000000},
+{0x50, 0x00000000},
+{0x54, 0x00000000},
+{0x58, 0x00000000},
+{0x5c, 0x00000000},
+{0x60, 0x00000000},
+{0x64, 0x00000000},
+{0x68, 0x00000000},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x00000000},
+{0x78, 0x00000000},
+{0x7c, 0x00000000},
+
+{0xf0, 0x0},
+{0x00, 0x01000000},
+{0x04, 0x01000000},
+{0x08, 0x01000000},
+{0x0c, 0x233fc0c0},
+{0x10, 0xa2146004},
+{0x14, 0xa4102000},
+{0x18, 0xe4244000},
+{0x1c, 0x233fc0c0},
+{0x20, 0xa2146010},
+{0x24, 0x2500003f},
+{0x28, 0xa414a3ff},
+{0x2c, 0xe4244000},
+{0x30, 0x01000000},
+{0x34, 0x821020e0},
+{0x38, 0x81880001},
+{0x3c, 0x01000000},
+{0x40, 0x01000000},
+{0x44, 0x01000000},
+{0x48, 0x270010c0},
+{0x4c, 0xa614e00f},
+{0x50, 0xe6a00040},
+{0x54, 0x01000000},
+{0x58, 0xa410200f},
+{0x5c, 0xe4a00040},
+{0x60, 0x01000000},
+{0x64, 0xa0100000},
+{0x68, 0xa2100000},
+{0x6c, 0xa4100000},
+{0x70, 0xa6100000},
+{0x74, 0xa8100000},
+{0x78, 0xaa100000},
+{0x7c, 0xac100000},
+{0xf0, 0x1},
+{0x00, 0xae100000},
+{0x04, 0x90100000},
+{0x08, 0x92100000},
+{0x0c, 0x94100000},
+{0x10, 0x96100000},
+{0x14, 0x98100000},
+{0x18, 0x9a100000},
+{0x1c, 0x9c100000},
+{0x20, 0x9e100000},
+{0x24, 0x84100000},
+{0x28, 0x86100000},
+{0x2c, 0x88100000},
+{0x30, 0x8a100000},
+{0x34, 0x8c100000},
+{0x38, 0x8e100000},
+{0x3c, 0x01000000},
+{0x40, 0x01000000},
+{0x44, 0x01000000},
+{0x48, 0x82100000},
+{0x4c, 0x81900001},
+{0x50, 0x82100000},
+{0x54, 0x81980001},
+{0x58, 0x81800000},
+{0x5c, 0x01000000},
+{0x60, 0x01000000},
+{0x64, 0x01000000},
+{0x68, 0xbc102cf8},
+{0x6c, 0x9c102c78},
+{0x70, 0x01000000},
+{0x74, 0x01000000},
+{0x78, 0x01000000},
+{0x7c, 0x01000000},
+{0xf0, 0x2},
+{0x00, 0x270010c0},
+{0x04, 0xa614e00f},
+{0x08, 0xe6a00040},
+{0x0c, 0x01000000},
+{0x10, 0x40000451},
+{0x14, 0x01000000},
+{0x18, 0x01000000},
+{0x1c, 0x10bfffff},
+{0x20, 0x01000000},
+{0x24, 0x00000000},
+{0x28, 0x00000000},
+{0x2c, 0x00000000},
+{0x30, 0x00000000},
+{0x34, 0x00000000},
+{0x38, 0x00000000},
+{0x3c, 0x00000000},
+{0x40, 0x00000000},
+{0x44, 0x00000000},
+{0x48, 0x00000000},
+{0x4c, 0x00000000},
+{0x50, 0x00000000},
+{0x54, 0x00000000},
+{0x58, 0x00000000},
+{0x5c, 0x00000000},
+{0x60, 0x00000000},
+{0x64, 0x00000000},
+{0x68, 0x00000000},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x00000000},
+{0x78, 0x00000000},
+{0x7c, 0x00000000},
+{0xf0, 0x1a},
+{0x00, 0x0000000e},
+{0x04, 0xfffffe65},
+{0x08, 0x000003fc},
+{0x0c, 0x00000af6},
+{0x10, 0x000003d4},
+{0x14, 0xfffffe64},
+{0x18, 0x00000008},
+{0x1c, 0xfffffe66},
+{0x20, 0x00000425},
+{0x24, 0x00000af5},
+{0x28, 0x000003ac},
+{0x2c, 0xfffffe65},
+{0x30, 0x00000003},
+{0x34, 0xfffffe67},
+{0x38, 0x0000044e},
+{0x3c, 0x00000af3},
+{0x40, 0x00000384},
+{0x44, 0xfffffe65},
+{0x48, 0xfffffffd},
+{0x4c, 0xfffffe69},
+{0x50, 0x00000476},
+{0x54, 0x00000aef},
+{0x58, 0x0000035c},
+{0x5c, 0xfffffe67},
+{0x60, 0xfffffff7},
+{0x64, 0xfffffe6c},
+{0x68, 0x0000049f},
+{0x6c, 0x00000aea},
+{0x70, 0x00000335},
+{0x74, 0xfffffe68},
+{0x78, 0xfffffff1},
+{0x7c, 0xfffffe6f},
+{0xf0, 0x1b},
+{0x00, 0x000004c9},
+{0x04, 0x00000ae5},
+{0x08, 0x0000030e},
+{0x0c, 0xfffffe6a},
+{0x10, 0xffffffeb},
+{0x14, 0xfffffe73},
+{0x18, 0x000004f2},
+{0x1c, 0x00000ade},
+{0x20, 0x000002e7},
+{0x24, 0xfffffe6d},
+{0x28, 0xffffffe4},
+{0x2c, 0xfffffe78},
+{0x30, 0x0000051b},
+{0x34, 0x00000ad5},
+{0x38, 0x000002c1},
+{0x3c, 0xfffffe70},
+{0x40, 0xffffffde},
+{0x44, 0xfffffe7d},
+{0x48, 0x00000544},
+{0x4c, 0x00000acc},
+{0x50, 0x0000029c},
+{0x54, 0xfffffe74},
+{0x58, 0xffffffd7},
+{0x5c, 0xfffffe83},
+{0x60, 0x0000056d},
+{0x64, 0x00000ac2},
+{0x68, 0x00000276},
+{0x6c, 0xfffffe78},
+{0x70, 0xffffffd0},
+{0x74, 0xfffffe89},
+{0x78, 0x00000597},
+{0x7c, 0x00000ab6},
+{0xf0, 0x1c},
+{0x00, 0x00000251},
+{0x04, 0xfffffe7c},
+{0x08, 0xffffffc8},
+{0x0c, 0xfffffe91},
+{0x10, 0x000005c0},
+{0x14, 0x00000aa9},
+{0x18, 0x0000022d},
+{0x1c, 0xfffffe81},
+{0x20, 0xffffffc1},
+{0x24, 0xfffffe99},
+{0x28, 0x000005e9},
+{0x2c, 0x00000a9b},
+{0x30, 0x00000209},
+{0x34, 0xfffffe86},
+{0x38, 0xffffffb9},
+{0x3c, 0xfffffea1},
+{0x40, 0x00000611},
+{0x44, 0x00000a8d},
+{0x48, 0x000001e5},
+{0x4c, 0xfffffe8b},
+{0x50, 0xffffffb2},
+{0x54, 0xfffffeab},
+{0x58, 0x0000063a},
+{0x5c, 0x00000a7d},
+{0x60, 0x000001c3},
+{0x64, 0xfffffe91},
+{0x68, 0xffffffaa},
+{0x6c, 0xfffffeb5},
+{0x70, 0x00000663},
+{0x74, 0x00000a6b},
+{0x78, 0x000001a0},
+{0x7c, 0xfffffe97},
+{0xf0, 0x1d},
+{0x00, 0xffffffa2},
+{0x04, 0xfffffebf},
+{0x08, 0x0000068b},
+{0x0c, 0x00000a59},
+{0x10, 0x0000017e},
+{0x14, 0xfffffe9d},
+{0x18, 0xffffff9a},
+{0x1c, 0xfffffecb},
+{0x20, 0x000006b3},
+{0x24, 0x00000a46},
+{0x28, 0x0000015d},
+{0x2c, 0xfffffea4},
+{0x30, 0xffffff91},
+{0x34, 0xfffffed7},
+{0x38, 0x000006da},
+{0x3c, 0x00000a32},
+{0x40, 0x0000013d},
+{0x44, 0xfffffeab},
+{0x48, 0xffffff89},
+{0x4c, 0xfffffee4},
+{0x50, 0x00000702},
+{0x54, 0x00000a1d},
+{0x58, 0x0000011d},
+{0x5c, 0xfffffeb2},
+{0x60, 0xffffff80},
+{0x64, 0xfffffef2},
+{0x68, 0x00000729},
+{0x6c, 0x00000a06},
+{0x70, 0x000000fd},
+{0x74, 0xfffffeba},
+{0x78, 0xffffff78},
+{0x7c, 0xffffff00},
+{0xf0, 0x1e},
+{0x00, 0x0000074f},
+{0x04, 0x000009ef},
+{0x08, 0x000000df},
+{0x0c, 0xfffffec1},
+{0x10, 0xffffff6f},
+{0x14, 0xffffff10},
+{0x18, 0x00000776},
+{0x1c, 0x000009d7},
+{0x20, 0x000000c1},
+{0x24, 0xfffffec9},
+{0x28, 0xffffff66},
+{0x2c, 0xffffff20},
+{0x30, 0x0000079b},
+{0x34, 0x000009be},
+{0x38, 0x000000a3},
+{0x3c, 0xfffffed1},
+{0x40, 0xffffff5e},
+{0x44, 0xffffff30},
+{0x48, 0x000007c1},
+{0x4c, 0x000009a4},
+{0x50, 0x00000087},
+{0x54, 0xfffffed9},
+{0x58, 0xffffff55},
+{0x5c, 0xffffff42},
+{0x60, 0x000007e5},
+{0x64, 0x00000989},
+{0x68, 0x0000006b},
+{0x6c, 0xfffffee2},
+{0x70, 0xffffff4c},
+{0x74, 0xffffff54},
+{0x78, 0x0000080a},
+{0x7c, 0x0000096d},
+{0xf0, 0x1f},
+{0x00, 0x0000004f},
+{0x04, 0xfffffeea},
+{0x08, 0xffffff43},
+{0x0c, 0xffffff67},
+{0x10, 0x0000082d},
+{0x14, 0x00000951},
+{0x18, 0x00000035},
+{0x1c, 0xfffffef3},
+{0x20, 0xffffff3a},
+{0x24, 0xffffff7b},
+{0x28, 0x00000850},
+{0x2c, 0x00000933},
+{0x30, 0x0000001b},
+{0x34, 0xfffffefb},
+{0x38, 0xffffff31},
+{0x3c, 0xffffff90},
+{0x40, 0x00000873},
+{0x44, 0x00000915},
+{0x48, 0x00000002},
+{0x4c, 0xffffff04},
+{0x50, 0xffffff28},
+{0x54, 0xffffffa5},
+{0x58, 0x00000895},
+{0x5c, 0x000008f6},
+{0x60, 0xffffffea},
+{0x64, 0xffffff0d},
+{0x68, 0xffffff1f},
+{0x6c, 0xffffffbb},
+{0x70, 0x000008b6},
+{0x74, 0x000008d6},
+{0x78, 0xffffffd2},
+{0x7c, 0xffffff16},
+{0xf0, 0x20},
+{0x00, 0x83580000},
+{0x04, 0x82086ff0},
+{0x08, 0x83306004},
+{0x0c, 0x80a06005},
+{0x10, 0x02800024},
+{0x14, 0x01000000},
+{0x18, 0x80a06006},
+{0x1c, 0x02800039},
+{0x20, 0x01000000},
+{0x24, 0x80a06015},
+{0x28, 0x02800051},
+{0x2c, 0x01000000},
+{0x30, 0x80a0602a},
+{0x34, 0x02800085},
+{0x38, 0x01000000},
+{0x3c, 0x073fc180},
+{0x40, 0x8610e03c},
+{0x44, 0x05169680},
+{0x48, 0x84004002},
+{0x4c, 0xc420c000},
+{0x50, 0x073fc000},
+{0x54, 0x8610e020},
+{0x58, 0x84102001},
+{0x5c, 0xc420c000},
+{0x60, 0x0500000c},
+{0x64, 0x01000000},
+{0x68, 0x01000000},
+{0x6c, 0x8480bfff},
+{0x70, 0x12bffffe},
+{0x74, 0x01000000},
+{0x78, 0x01000000},
+{0x7c, 0x073fc000},
+{0xf0, 0x21},
+{0x00, 0x8610e020},
+{0x04, 0x84102000},
+{0x08, 0xc420c000},
+{0x0c, 0x01000000},
+{0x10, 0x01000000},
+{0x14, 0x81c44000},
+{0x18, 0x81cc8000},
+{0x1c, 0x01000000},
+{0x20, 0xa7500000},
+{0x24, 0xa92ce002},
+{0x28, 0xa734e001},
+{0x2c, 0xa614c014},
+{0x30, 0xa60ce007},
+{0x34, 0x81900000},
+{0x38, 0x01000000},
+{0x3c, 0x01000000},
+{0x40, 0x81e00000},
+{0x44, 0xe03ba000},
+{0x48, 0xe43ba008},
+{0x4c, 0xe83ba010},
+{0x50, 0xec3ba018},
+{0x54, 0xf03ba020},
+{0x58, 0xf43ba028},
+{0x5c, 0xf83ba030},
+{0x60, 0xfc3ba038},
+{0x64, 0x81e80000},
+{0x68, 0x8194c000},
+{0x6c, 0x01000000},
+{0x70, 0x01000000},
+{0x74, 0x81c44000},
+{0x78, 0x81cc8000},
+{0x7c, 0x01000000},
+{0xf0, 0x22},
+{0x00, 0xa7500000},
+{0x04, 0xa934e002},
+{0x08, 0xa72ce001},
+{0x0c, 0xa614c014},
+{0x10, 0xa60ce007},
+{0x14, 0x81900000},
+{0x18, 0x01000000},
+{0x1c, 0x01000000},
+{0x20, 0x81e80000},
+{0x24, 0x81e80000},
+{0x28, 0xe01ba000},
+{0x2c, 0xe41ba008},
+{0x30, 0xe81ba010},
+{0x34, 0xec1ba018},
+{0x38, 0xf01ba020},
+{0x3c, 0xf41ba028},
+{0x40, 0xf81ba030},
+{0x44, 0xfc1ba038},
+{0x48, 0x81e00000},
+{0x4c, 0x81e00000},
+{0x50, 0x8194c000},
+{0x54, 0x01000000},
+{0x58, 0x01000000},
+{0x5c, 0x81c44000},
+{0x60, 0x81cc8000},
+{0x64, 0x01000000},
+{0x68, 0x01000000},
+{0x6c, 0x82102010},
+{0x70, 0x273fc0c0},
+{0x74, 0xa614e010},
+{0x78, 0xc224c000},
+{0x7c, 0x01000000},
+{0xf0, 0x23},
+{0x00, 0x033fc0c0},
+{0x04, 0x82106004},
+{0x08, 0xa6102000},
+{0x0c, 0xe6204000},
+{0x10, 0x01000000},
+{0x14, 0x01000000},
+{0x18, 0x01000000},
+{0x1c, 0xa6102020},
+{0x20, 0x83480000},
+{0x24, 0x82104013},
+{0x28, 0x81884000},
+{0x2c, 0x01000000},
+{0x30, 0x400011a1},
+{0x34, 0x01000000},
+{0x38, 0x01000000},
+{0x3c, 0x01000000},
+{0x40, 0xa7500000},
+{0x44, 0xa934e002},
+{0x48, 0xa72ce001},
+{0x4c, 0xa614c014},
+{0x50, 0xa60ce007},
+{0x54, 0x81900000},
+{0x58, 0x01000000},
+{0x5c, 0x81e80000},
+{0x60, 0xe01ba000},
+{0x64, 0xe41ba008},
+{0x68, 0xe81ba010},
+{0x6c, 0xec1ba018},
+{0x70, 0xf01ba020},
+{0x74, 0xf41ba028},
+{0x78, 0xf81ba030},
+{0x7c, 0xfc1ba038},
+{0xf0, 0x24},
+{0x00, 0x81e00000},
+{0x04, 0x8194c000},
+{0x08, 0x01000000},
+{0x0c, 0xa6102020},
+{0x10, 0x83480000},
+{0x14, 0x82284013},
+{0x18, 0x81884000},
+{0x1c, 0x01000000},
+{0x20, 0x033fc0c0},
+{0x24, 0x82106004},
+{0x28, 0xa6103fff},
+{0x2c, 0xe6204000},
+{0x30, 0x01000000},
+{0x34, 0x01000000},
+{0x38, 0x01000000},
+{0x3c, 0x81c44000},
+{0x40, 0x81cc8000},
+{0x44, 0x01000000},
+{0x48, 0x81c48000},
+{0x4c, 0x81cca004},
+{0x50, 0x01000000},
+{0x54, 0x9de3bf98},
+{0x58, 0x4000001b},
+{0x5c, 0x01000000},
+{0x60, 0x40000012},
+{0x64, 0x01000000},
+{0x68, 0x400000ee},
+{0x6c, 0x01000000},
+{0x70, 0x40000040},
+{0x74, 0x01000000},
+{0x78, 0x400000a4},
+{0x7c, 0x01000000},
+{0xf0, 0x25},
+{0x00, 0x30bffffe},
+{0x04, 0x80a22000},
+{0x08, 0x02800006},
+{0x0c, 0x01000000},
+{0x10, 0x01000000},
+{0x14, 0x90823fff},
+{0x18, 0x12bffffe},
+{0x1c, 0x01000000},
+{0x20, 0x81c3e008},
+{0x24, 0x01000000},
+{0x28, 0x82102001},
+{0x2c, 0x81904000},
+{0x30, 0x01000000},
+{0x34, 0x01000000},
+{0x38, 0x01000000},
+{0x3c, 0x81c3e008},
+{0x40, 0x01000000},
+{0x44, 0x03000008},
+{0x48, 0x82106342},
+{0x4c, 0xa3804000},
+{0x50, 0x03000004},
+{0x54, 0x82106000},
+{0x58, 0x81984000},
+{0x5c, 0x01000000},
+{0x60, 0x01000000},
+{0x64, 0x01000000},
+{0x68, 0x81c3e008},
+{0x6c, 0x01000000},
+{0x70, 0x98102000},
+{0x74, 0x832b2002},
+{0x78, 0xda006480},
+{0x7c, 0x80a37ff0},
+{0xf0, 0x26},
+{0x00, 0x02800006},
+{0x04, 0x98032002},
+{0x08, 0xc2006484},
+{0x0c, 0x80a3201f},
+{0x10, 0x04bffff9},
+{0x14, 0xc2234000},
+{0x18, 0x81c3e008},
+{0x1c, 0x01000000},
+{0x20, 0x03004040},
+{0x24, 0x94106101},
+{0x28, 0x98102000},
+{0x2c, 0x832b2002},
+{0x30, 0xd60063a4},
+{0x34, 0x9a102000},
+{0x38, 0x832b6002},
+{0x3c, 0x9a036001},
+{0x40, 0x80a36004},
+{0x44, 0x04bffffd},
+{0x48, 0xd422c001},
+{0x4c, 0x98032001},
+{0x50, 0x80a32003},
+{0x54, 0x04bffff7},
+{0x58, 0x832b2002},
+{0x5c, 0x033fc200},
+{0x60, 0xda002330},
+{0x64, 0x82106074},
+{0x68, 0x81c3e008},
+{0x6c, 0xda204000},
+{0x70, 0x9de3bf98},
+{0x74, 0x40000f98},
+{0x78, 0x90102000},
+{0x7c, 0x213fc140},
+{0xf0, 0x27},
+{0x00, 0xda00247c},
+{0x04, 0x98142040},
+{0x08, 0xea030000},
+{0x0c, 0xc20022f8},
+{0x10, 0x9b336001},
+{0x14, 0x825b4001},
+{0x18, 0xaa0d7c00},
+{0x1c, 0xaa154001},
+{0x20, 0xea230000},
+{0x24, 0x82142004},
+{0x28, 0xea004000},
+{0x2c, 0xaa0d7ff0},
+{0x30, 0xaa15400d},
+{0x34, 0xea204000},
+{0x38, 0x2d3fc200},
+{0x3c, 0x8215a080},
+{0x40, 0xea004000},
+{0x44, 0xaa0d7ff0},
+{0x48, 0xaa15400d},
+{0x4c, 0xea204000},
+{0x50, 0xc200233c},
+{0x54, 0x9a15a070},
+{0x58, 0xc2234000},
+{0x5c, 0x19000016},
+{0x60, 0x033fc000},
+{0x64, 0xda002338},
+{0x68, 0xa21323a8},
+{0x6c, 0x82106030},
+{0x70, 0xda204000},
+{0x74, 0x98132180},
+{0x78, 0x96142088},
+{0x7c, 0xd822c000},
+{0xf0, 0x28},
+{0x00, 0x9414208c},
+{0x04, 0x0300003f},
+{0x08, 0xe2228000},
+{0x0c, 0x92142058},
+{0x10, 0x821063ff},
+{0x14, 0xc2224000},
+{0x18, 0xc20023f8},
+{0x1c, 0x9015a00c},
+{0x20, 0xc2220000},
+{0x24, 0xc20023fc},
+{0x28, 0x9e15a008},
+{0x2c, 0xc223c000},
+{0x30, 0xa6142080},
+{0x34, 0xd824c000},
+{0x38, 0xa8142084},
+{0x3c, 0xa414205c},
+{0x40, 0xe2250000},
+{0x44, 0x7fffffb7},
+{0x48, 0xc0248000},
+{0x4c, 0x400001fb},
+{0x50, 0xa415a030},
+{0x54, 0x9a15a07c},
+{0x58, 0xea034000},
+{0x5c, 0x033ff000},
+{0x60, 0xd8002374},
+{0x64, 0xaa2d4001},
+{0x68, 0xea234000},
+{0x6c, 0x033fc1c0},
+{0x70, 0xda002340},
+{0x74, 0x82106064},
+{0x78, 0xda204000},
+{0x7c, 0x0300007f},
+{0xf0, 0x29},
+{0x00, 0x92142010},
+{0x04, 0x821063ff},
+{0x08, 0x1507ffc0},
+{0x0c, 0xc2224000},
+{0x10, 0x9e142030},
+{0x14, 0x96032001},
+{0x18, 0xd423c000},
+{0x1c, 0x972ae010},
+{0x20, 0xa0142014},
+{0x24, 0x9602c00c},
+{0x28, 0xa32b2010},
+{0x2c, 0x912b2004},
+{0x30, 0xd4240000},
+{0x34, 0x80a32000},
+{0x38, 0x82044008},
+{0x3c, 0x9602e002},
+{0x40, 0x9a15a084},
+{0x44, 0x9815a088},
+{0x48, 0x02800005},
+{0x4c, 0x9415a08c},
+{0x50, 0xc2234000},
+{0x54, 0xe2230000},
+{0x58, 0xd6228000},
+{0x5c, 0xc2002344},
+{0x60, 0xc2248000},
+{0x64, 0x033fc0c0},
+{0x68, 0x82106004},
+{0x6c, 0x9a103fff},
+{0x70, 0x7fffff80},
+{0x74, 0xda204000},
+{0x78, 0x03200040},
+{0x7c, 0xc2258000},
+{0xf0, 0x2a},
+{0x00, 0x81c7e008},
+{0x04, 0x81e80000},
+{0x08, 0x01000000},
+{0x0c, 0x01000000},
+{0x10, 0x01000000},
+{0x14, 0xa7800000},
+{0x18, 0x01000000},
+{0x1c, 0x01000000},
+{0x20, 0x01000000},
+{0x24, 0x81c3e008},
+{0x28, 0x01000000},
+{0x2c, 0x9de3bf98},
+{0x30, 0xb6102000},
+{0x34, 0xb0102000},
+{0x38, 0xb8102000},
+{0x3c, 0xc2070000},
+{0x40, 0xb8072004},
+{0x44, 0x80a724ff},
+{0x48, 0x08bffffd},
+{0x4c, 0xb606c001},
+{0x50, 0x03000016},
+{0x54, 0x821061e0},
+{0x58, 0x82087f80},
+{0x5c, 0xb8102d00},
+{0x60, 0x80a70001},
+{0x64, 0x3a80001e},
+{0x68, 0xfa002180},
+{0x6c, 0xb4100001},
+{0x70, 0x9a102001},
+{0x74, 0x9e100001},
+{0x78, 0xc2070000},
+{0x7c, 0xb8072004},
+{0xf0, 0x2b},
+{0x00, 0xb21f001a},
+{0x04, 0xbb37200c},
+{0x08, 0x808f2fff},
+{0x0c, 0x02800005},
+{0x10, 0xb606c001},
+{0x14, 0x80a7001a},
+{0x18, 0x1280000e},
+{0x1c, 0x80a7000f},
+{0x20, 0x80a00019},
+{0x24, 0xba677fff},
+{0x28, 0x832f6002},
+{0x2c, 0xc2006180},
+{0x30, 0xb606c001},
+{0x34, 0xba077fff},
+{0x38, 0x80a6e000},
+{0x3c, 0x832b401d},
+{0x40, 0x12800003},
+{0x44, 0xb6102000},
+{0x48, 0xb0160001},
+{0x4c, 0x80a7000f},
+{0x50, 0x2abfffeb},
+{0x54, 0xc2070000},
+{0x58, 0xfa002180},
+{0x5c, 0xb816001d},
+{0x60, 0x821e001d},
+{0x64, 0x80a70001},
+{0x68, 0x32800009},
+{0x6c, 0xba16001d},
+{0x70, 0x0329697f},
+{0x74, 0x821063ff},
+{0x78, 0x80a70001},
+{0x7c, 0x32800004},
+{0xf0, 0x2c},
+{0x00, 0xba16001d},
+{0x04, 0x3b169696},
+{0x08, 0xba17625a},
+{0x0c, 0x033fc180},
+{0x10, 0x82106030},
+{0x14, 0xfa204000},
+{0x18, 0x81c7e008},
+{0x1c, 0x91e82001},
+{0x20, 0x033fc180},
+{0x24, 0xc0204000},
+{0x28, 0x82102500},
+{0x2c, 0xc0204000},
+{0x30, 0x82006004},
+{0x34, 0x80a0687c},
+{0x38, 0x28bffffe},
+{0x3c, 0xc0204000},
+{0x40, 0x033fc200},
+{0x44, 0x82106030},
+{0x48, 0xda004000},
+{0x4c, 0x82102010},
+{0x50, 0xc2202574},
+{0x54, 0x82102001},
+{0x58, 0xc2202540},
+{0x5c, 0x8210200f},
+{0x60, 0xc2202548},
+{0x64, 0x81c3e008},
+{0x68, 0xda20257c},
+{0x6c, 0x9de3bf98},
+{0x70, 0x82102000},
+{0x74, 0x80a04019},
+{0x78, 0x16800015},
+{0x7c, 0x9e100019},
+{0xf0, 0x2d},
+{0x00, 0xb6006001},
+{0x04, 0x80a6c00f},
+{0x08, 0x1680000f},
+{0x0c, 0xba10001b},
+{0x10, 0xb3286002},
+{0x14, 0xb52f6002},
+{0x18, 0xf8060019},
+{0x1c, 0xc206001a},
+{0x20, 0x80a70001},
+{0x24, 0x04800004},
+{0x28, 0xba076001},
+{0x2c, 0xc2260019},
+{0x30, 0xf826001a},
+{0x34, 0x80a7400f},
+{0x38, 0x06bffff8},
+{0x3c, 0xb52f6002},
+{0x40, 0x80a6c00f},
+{0x44, 0x06bfffef},
+{0x48, 0x8210001b},
+{0x4c, 0x81c7e008},
+{0x50, 0x81e80000},
+{0x54, 0x033fc140},
+{0x58, 0x82106048},
+{0x5c, 0xda004000},
+{0x60, 0x03000040},
+{0x64, 0x808b4001},
+{0x68, 0x03000016},
+{0x6c, 0x12800003},
+{0x70, 0x90106180},
+{0x74, 0x901063a8},
+{0x78, 0x81c3e008},
+{0x7c, 0x01000000},
+{0xf0, 0x2e},
+{0x00, 0x9de3bf38},
+{0x04, 0xa12e2002},
+{0x08, 0x1b00003f},
+{0x0c, 0xc20423d8},
+{0x10, 0x9a1363ff},
+{0x14, 0xb008400d},
+{0x18, 0x97306010},
+{0x1c, 0xc200247c},
+{0x20, 0x9a22c018},
+{0x24, 0x825e0001},
+{0x28, 0x92836001},
+{0x2c, 0x0280000c},
+{0x30, 0xb0004019},
+{0x34, 0x9a100009},
+{0x38, 0x9807bf98},
+{0x3c, 0x82060018},
+{0x40, 0xc2168001},
+{0x44, 0xc2230000},
+{0x48, 0xc200247c},
+{0x4c, 0xb0060001},
+{0x50, 0x9a837fff},
+{0x54, 0x12bffffa},
+{0x58, 0x98032004},
+{0x5c, 0x7fffffc4},
+{0x60, 0x9007bf98},
+{0x64, 0x0300003f},
+{0x68, 0xda0423e8},
+{0x6c, 0x821063ff},
+{0x70, 0xb00b4001},
+{0x74, 0x97336010},
+{0x78, 0x80a6000b},
+{0x7c, 0x92102000},
+{0xf0, 0x2f},
+{0x00, 0x1880000b},
+{0x04, 0x9a100018},
+{0x08, 0x832e2002},
+{0x0c, 0x8200401e},
+{0x10, 0x98007f98},
+{0x14, 0xc2030000},
+{0x18, 0x9a036001},
+{0x1c, 0x92024001},
+{0x20, 0x80a3400b},
+{0x24, 0x08bffffc},
+{0x28, 0x98032004},
+{0x2c, 0xb022c018},
+{0x30, 0xb0062001},
+{0x34, 0x81800000},
+{0x38, 0x01000000},
+{0x3c, 0x01000000},
+{0x40, 0x01000000},
+{0x44, 0xb0724018},
+{0x48, 0x81c7e008},
+{0x4c, 0x81e80000},
+{0x50, 0x832a2002},
+{0x54, 0x82004008},
+{0x58, 0x9b326002},
+{0x5c, 0x8200400d},
+{0x60, 0x83286002},
+{0x64, 0x920a6003},
+{0x68, 0x932a6003},
+{0x6c, 0xd00065b0},
+{0x70, 0x91320009},
+{0x74, 0x81c3e008},
+{0x78, 0x900a20ff},
+{0x7c, 0x972a2002},
+{0xf0, 0x30},
+{0x00, 0x99326002},
+{0x04, 0x9002c008},
+{0x08, 0x9002000c},
+{0x0c, 0x920a6003},
+{0x10, 0x932a6003},
+{0x14, 0x912a2002},
+{0x18, 0x821020ff},
+{0x1c, 0xda0225b0},
+{0x20, 0x83284009},
+{0x24, 0x822b4001},
+{0x28, 0x952a8009},
+{0x2c, 0x8210400a},
+{0x30, 0xc22225b0},
+{0x34, 0xda02e3a4},
+{0x38, 0x992b2002},
+{0x3c, 0x81c3e008},
+{0x40, 0xc223400c},
+{0x44, 0x9de3bf98},
+{0x48, 0xda002310},
+{0x4c, 0x80a36000},
+{0x50, 0x02800049},
+{0x54, 0xb0102000},
+{0x58, 0xc2002594},
+{0x5c, 0x82006001},
+{0x60, 0x80a0400d},
+{0x64, 0x0a800044},
+{0x68, 0xc2202594},
+{0x6c, 0xa4102000},
+{0x70, 0xc20023d4},
+{0x74, 0x80a48001},
+{0x78, 0xc0202594},
+{0x7c, 0xa2102000},
+{0xf0, 0x31},
+{0x00, 0x1a800028},
+{0x04, 0xa72c6002},
+{0x08, 0xc204e364},
+{0x0c, 0x80a06000},
+{0x10, 0x02800020},
+{0x14, 0xa0102000},
+{0x18, 0xc20022fc},
+{0x1c, 0x80a40001},
+{0x20, 0x1a80001c},
+{0x24, 0x15000017},
+{0x28, 0xc200255c},
+{0x2c, 0xf00c2380},
+{0x30, 0x9412a1d0},
+{0x34, 0x90100011},
+{0x38, 0x80a06000},
+{0x3c, 0x02800007},
+{0x40, 0x920e20ff},
+{0x44, 0x7fffff84},
+{0x48, 0x01000000},
+{0x4c, 0x94100008},
+{0x50, 0x90100011},
+{0x54, 0x920e20ff},
+{0x58, 0x7fffff8a},
+{0x5c, 0xa0042001},
+{0x60, 0xc204e364},
+{0x64, 0xda002348},
+{0x68, 0x98020001},
+{0x6c, 0x82034001},
+{0x70, 0x80a20001},
+{0x74, 0x38bfffe9},
+{0x78, 0xa404a001},
+{0x7c, 0x80a3000d},
+{0xf0, 0x32},
+{0x00, 0x3abfffe7},
+{0x04, 0xc20022fc},
+{0x08, 0x10bfffe4},
+{0x0c, 0xa404a001},
+{0x10, 0xa2046001},
+{0x14, 0xc20023d4},
+{0x18, 0x10bfffda},
+{0x1c, 0x80a44001},
+{0x20, 0xd800258c},
+{0x24, 0x80a0000c},
+{0x28, 0x9a603fff},
+{0x2c, 0x80a00012},
+{0x30, 0x82603fff},
+{0x34, 0x808b4001},
+{0x38, 0x02800007},
+{0x3c, 0x80a4a000},
+{0x40, 0xc200255c},
+{0x44, 0x80a00001},
+{0x48, 0x82603fff},
+{0x4c, 0xc220255c},
+{0x50, 0x80a4a000},
+{0x54, 0x12800004},
+{0x58, 0x82032001},
+{0x5c, 0x10800003},
+{0x60, 0xc020258c},
+{0x64, 0xc220258c},
+{0x68, 0xc200258c},
+{0x6c, 0x80a06003},
+{0x70, 0xb0603fff},
+{0x74, 0x81c7e008},
+{0x78, 0x81e80000},
+{0x7c, 0x9de3bf98},
+{0xf0, 0x33},
+{0x00, 0xc2002540},
+{0x04, 0x80a06000},
+{0x08, 0x0280002a},
+{0x0c, 0xb0102000},
+{0x10, 0xda002210},
+{0x14, 0x80a36000},
+{0x18, 0x02800026},
+{0x1c, 0xb4102001},
+{0x20, 0xde0022f8},
+{0x24, 0x80a6800f},
+{0x28, 0x18800018},
+{0x2c, 0x03000018},
+{0x30, 0x98106220},
+{0x34, 0xf20022fc},
+{0x38, 0xb6102007},
+{0x3c, 0xb8102001},
+{0x40, 0x80a70019},
+{0x44, 0x1880000d},
+{0x48, 0x832ee003},
+{0x4c, 0x8200400c},
+{0x50, 0xba006004},
+{0x54, 0xc2074000},
+{0x58, 0xb8072001},
+{0x5c, 0x80a0400d},
+{0x60, 0x14800003},
+{0x64, 0xba076004},
+{0x68, 0xb0062001},
+{0x6c, 0x80a70019},
+{0x70, 0x28bffffa},
+{0x74, 0xc2074000},
+{0x78, 0xb406a001},
+{0x7c, 0x80a6800f},
+{0xf0, 0x34},
+{0x00, 0x08bfffef},
+{0x04, 0xb606e007},
+{0x08, 0xc21023ce},
+{0x0c, 0x80a60001},
+{0x10, 0x24800007},
+{0x14, 0xc0202598},
+{0x18, 0xc2002598},
+{0x1c, 0x82006001},
+{0x20, 0xc2202598},
+{0x24, 0x10800003},
+{0x28, 0xb0102001},
+{0x2c, 0xb0102000},
+{0x30, 0x81c7e008},
+{0x34, 0x81e80000},
+{0x38, 0x9a102005},
+{0x3c, 0x8210200b},
+{0x40, 0x9a234008},
+{0x44, 0x82204008},
+{0x48, 0x9b2b6002},
+{0x4c, 0x80a22005},
+{0x50, 0x14800007},
+{0x54, 0x99286002},
+{0x58, 0x033fc200},
+{0x5c, 0x8210600c},
+{0x60, 0xc2004000},
+{0x64, 0x10800006},
+{0x68, 0x8330400d},
+{0x6c, 0x033fc200},
+{0x70, 0x82106008},
+{0x74, 0xc2004000},
+{0x78, 0x8330400c},
+{0x7c, 0x81c3e008},
+{0xf0, 0x35},
+{0x00, 0x9008600f},
+{0x04, 0x9de3bf98},
+{0x08, 0xc200247c},
+{0x0c, 0x83306001},
+{0x10, 0x80a60001},
+{0x14, 0x1a800006},
+{0x18, 0x90100018},
+{0x1c, 0x7fffffe7},
+{0x20, 0x01000000},
+{0x24, 0x10800006},
+{0x28, 0xb0020008},
+{0x2c, 0x7fffffe3},
+{0x30, 0x90260001},
+{0x34, 0x90020008},
+{0x38, 0xb0022001},
+{0x3c, 0x81c7e008},
+{0x40, 0x81e80000},
+{0x44, 0x9de3bf98},
+{0x48, 0xa8102000},
+{0x4c, 0xc20023d4},
+{0x50, 0x80a50001},
+{0x54, 0x1a800057},
+{0x58, 0xe2002348},
+{0x5c, 0xa4102000},
+{0x60, 0xc200247c},
+{0x64, 0x80a48001},
+{0x68, 0x3a80004e},
+{0x6c, 0xa8052001},
+{0x70, 0x7fffffe5},
+{0x74, 0x90100012},
+{0x78, 0x92100008},
+{0x7c, 0x7fffff35},
+{0xf0, 0x36},
+{0x00, 0x90100014},
+{0x04, 0x80a62000},
+{0x08, 0x12800004},
+{0x0c, 0xa0100008},
+{0x10, 0x10800016},
+{0x14, 0xa0102000},
+{0x18, 0x80a62008},
+{0x1c, 0x18800011},
+{0x20, 0x80a62007},
+{0x24, 0x7ffffeec},
+{0x28, 0x01000000},
+{0x2c, 0x94100008},
+{0x30, 0x90100014},
+{0x34, 0x7ffffef3},
+{0x38, 0x921ca001},
+{0x3c, 0x80a20011},
+{0x40, 0x04800007},
+{0x44, 0xa6100008},
+{0x48, 0x9a102008},
+{0x4c, 0x9a234018},
+{0x50, 0x82102001},
+{0x54, 0x8328400d},
+{0x58, 0xa02c0001},
+{0x5c, 0x80a62007},
+{0x60, 0x18800008},
+{0x64, 0x80a62008},
+{0x68, 0x9a102007},
+{0x6c, 0x9a234018},
+{0x70, 0x82102001},
+{0x74, 0x8328400d},
+{0x78, 0x10800022},
+{0x7c, 0xa0140001},
+{0xf0, 0x37},
+{0x00, 0x1280000a},
+{0x04, 0x821e2009},
+{0x08, 0x80a420fe},
+{0x0c, 0x24800002},
+{0x10, 0xa0042001},
+{0x14, 0x03000018},
+{0x18, 0x9b2ca002},
+{0x1c, 0x82106220},
+{0x20, 0x10800018},
+{0x24, 0xe6234001},
+{0x28, 0x80a00001},
+{0x2c, 0x9a603fff},
+{0x30, 0x80a420fe},
+{0x34, 0x04800003},
+{0x38, 0x82102001},
+{0x3c, 0x82102000},
+{0x40, 0x808b4001},
+{0x44, 0x0280000f},
+{0x48, 0x03000018},
+{0x4c, 0x9b2ca002},
+{0x50, 0x82106220},
+{0x54, 0xc2034001},
+{0x58, 0x80a04011},
+{0x5c, 0x18800003},
+{0x60, 0x9a204011},
+{0x64, 0x9a244001},
+{0x68, 0x80a4c011},
+{0x6c, 0x14800003},
+{0x70, 0x8224c011},
+{0x74, 0x82244013},
+{0x78, 0x80a34001},
+{0x7c, 0xa0642000},
+{0xf0, 0x38},
+{0x00, 0x7fffffa1},
+{0x04, 0x90100012},
+{0x08, 0x92100008},
+{0x0c, 0x90100014},
+{0x10, 0x7ffffefb},
+{0x14, 0x94100010},
+{0x18, 0x10bfffb2},
+{0x1c, 0xa404a001},
+{0x20, 0xc20023d4},
+{0x24, 0x80a50001},
+{0x28, 0x0abfffae},
+{0x2c, 0xa4102000},
+{0x30, 0x81c7e008},
+{0x34, 0x81e80000},
+{0x38, 0x033fc200},
+{0x3c, 0x961060a0},
+{0x40, 0x98102000},
+{0x44, 0x832b2002},
+{0x48, 0x9a03000c},
+{0x4c, 0xda136400},
+{0x50, 0x98032001},
+{0x54, 0x80a32016},
+{0x58, 0x04bffffb},
+{0x5c, 0xda20400b},
+{0x60, 0x81c3e008},
+{0x64, 0x01000000},
+{0x68, 0x9de3bf98},
+{0x6c, 0xc2002544},
+{0x70, 0x82006001},
+{0x74, 0xc2202544},
+{0x78, 0x03000017},
+{0x7c, 0xb41063f8},
+{0xf0, 0x39},
+{0x00, 0x9e100018},
+{0x04, 0x031fffdf},
+{0x08, 0xb01063ff},
+{0x0c, 0xba102000},
+{0x10, 0xb72f6002},
+{0x14, 0xc2002544},
+{0x18, 0x80a06009},
+{0x1c, 0xb2076001},
+{0x20, 0x12800007},
+{0x24, 0xb810001b},
+{0x28, 0xc206c01a},
+{0x2c, 0x83306001},
+{0x30, 0x82084018},
+{0x34, 0xc226c01a},
+{0x38, 0xc2002544},
+{0x3c, 0x80a06008},
+{0x40, 0x08800006},
+{0x44, 0xc207001a},
+{0x48, 0xfa03c01c},
+{0x4c, 0xbb376001},
+{0x50, 0x10800003},
+{0x54, 0xba0f4018},
+{0x58, 0xfa03c01c},
+{0x5c, 0x8200401d},
+{0x60, 0xc227001a},
+{0x64, 0x80a66089},
+{0x68, 0x08bfffea},
+{0x6c, 0xba100019},
+{0x70, 0x81c7e008},
+{0x74, 0x81e80000},
+{0x78, 0x9de3bf98},
+{0x7c, 0x9e102001},
+{0xf0, 0x3a},
+{0x00, 0xc20022fc},
+{0x04, 0x80a3c001},
+{0x08, 0x1880002a},
+{0x0c, 0x03000018},
+{0x10, 0x82106220},
+{0x14, 0x9a006004},
+{0x18, 0x19000017},
+{0x1c, 0xc20022f8},
+{0x20, 0xb6102001},
+{0x24, 0x80a6c001},
+{0x28, 0xb21323f8},
+{0x2c, 0xb41321d0},
+{0x30, 0x1880001b},
+{0x34, 0xc20be37f},
+{0x38, 0xb0004001},
+{0x3c, 0xb8036038},
+{0x40, 0xc2002544},
+{0x44, 0xb606e001},
+{0x48, 0x80a06008},
+{0x4c, 0x08800003},
+{0x50, 0xfa164018},
+{0x54, 0xba07401d},
+{0x58, 0x81800000},
+{0x5c, 0xc2002548},
+{0x60, 0x01000000},
+{0x64, 0x01000000},
+{0x68, 0x82774001},
+{0x6c, 0xba100001},
+{0x70, 0xc2168018},
+{0x74, 0xba274001},
+{0x78, 0xfa270000},
+{0x7c, 0xc200247c},
+{0xf0, 0x3b},
+{0x00, 0x82004001},
+{0x04, 0xfa0022f8},
+{0x08, 0xb4068001},
+{0x0c, 0x80a6c01d},
+{0x10, 0xb2064001},
+{0x14, 0x08bfffeb},
+{0x18, 0xb8072038},
+{0x1c, 0x9e03e001},
+{0x20, 0xc20022fc},
+{0x24, 0x80a3c001},
+{0x28, 0x08bfffdd},
+{0x2c, 0x9a036004},
+{0x30, 0x81c7e008},
+{0x34, 0x81e80000},
+{0x38, 0xc2002540},
+{0x3c, 0x80a06000},
+{0x40, 0x0280000f},
+{0x44, 0x1b3fc200},
+{0x48, 0xc2002298},
+{0x4c, 0x9a136070},
+{0x50, 0xc2234000},
+{0x54, 0x03000017},
+{0x58, 0xc0202540},
+{0x5c, 0xc0202544},
+{0x60, 0x981063f8},
+{0x64, 0x9a102000},
+{0x68, 0x832b6002},
+{0x6c, 0x9a036001},
+{0x70, 0x80a36089},
+{0x74, 0x08bffffd},
+{0x78, 0xc020400c},
+{0x7c, 0x81c3e008},
+{0xf0, 0x3c},
+{0x00, 0x01000000},
+{0x04, 0xc200247c},
+{0x08, 0xda0022f8},
+{0x0c, 0x8258400d},
+{0x10, 0x97306001},
+{0x14, 0x98102000},
+{0x18, 0x80a3000b},
+{0x1c, 0x1680000e},
+{0x20, 0x1b000017},
+{0x24, 0x0307ffc7},
+{0x28, 0x901363f8},
+{0x2c, 0x921063ff},
+{0x30, 0x941361d0},
+{0x34, 0x9b2b2002},
+{0x38, 0xc2034008},
+{0x3c, 0x83306003},
+{0x40, 0x82084009},
+{0x44, 0x98032001},
+{0x48, 0x80a3000b},
+{0x4c, 0x06bffffa},
+{0x50, 0xc223400a},
+{0x54, 0x03000018},
+{0x58, 0x9a106220},
+{0x5c, 0x98102000},
+{0x60, 0x832b2002},
+{0x64, 0x98032001},
+{0x68, 0x80a322d5},
+{0x6c, 0x04bffffd},
+{0x70, 0xc020400d},
+{0x74, 0x81c3e008},
+{0x78, 0x01000000},
+{0x7c, 0x00000000},
+{0xf0, 0x3d},
+{0x00, 0x82102020},
+{0x04, 0x82204009},
+{0x08, 0x80a06040},
+{0x0c, 0x04800003},
+{0x10, 0x9a100008},
+{0x14, 0x90023fff},
+{0x18, 0x80a06080},
+{0x1c, 0x34800002},
+{0x20, 0x90037ffe},
+{0x24, 0x80a06000},
+{0x28, 0x24800002},
+{0x2c, 0x90036001},
+{0x30, 0x80a07fc0},
+{0x34, 0x24800002},
+{0x38, 0x90036002},
+{0x3c, 0x81c3e008},
+{0x40, 0x01000000},
+{0x44, 0x900221ff},
+{0x48, 0x833a201f},
+{0x4c, 0x8330601a},
+{0x50, 0x82020001},
+{0x54, 0x82087fc0},
+{0x58, 0x90220001},
+{0x5c, 0x81c3e008},
+{0x60, 0x90022001},
+{0x64, 0x9de3bf80},
+{0x68, 0x90102020},
+{0x6c, 0x7ffffff6},
+{0x70, 0x90220018},
+{0x74, 0x82102041},
+{0x78, 0x82204008},
+{0x7c, 0x9b2ea003},
+{0xf0, 0x3e},
+{0x00, 0x98004001},
+{0x04, 0x9a23401a},
+{0x08, 0x98030001},
+{0x0c, 0x9a03400d},
+{0x10, 0x9a03401b},
+{0x14, 0x03000018},
+{0x18, 0x82106220},
+{0x1c, 0x9b2b6002},
+{0x20, 0x9a034001},
+{0x24, 0xc2002300},
+{0x28, 0x96020008},
+{0x2c, 0x9602c008},
+{0x30, 0xaa006001},
+{0x34, 0xc2002308},
+{0x38, 0xa52ae003},
+{0x3c, 0xa8006001},
+{0x40, 0xa72b2003},
+{0x44, 0x96037ff8},
+{0x48, 0xa0103ffe},
+{0x4c, 0xb0102000},
+{0x50, 0x94103ffe},
+{0x54, 0xa206c010},
+{0x58, 0x9804ecfc},
+{0x5c, 0x9e04ace8},
+{0x60, 0x9202ff90},
+{0x64, 0x8206800a},
+{0x68, 0x80a54001},
+{0x6c, 0x9a603fff},
+{0x70, 0x80a50011},
+{0x74, 0x82603fff},
+{0x78, 0x808b4001},
+{0x7c, 0x02800003},
+{0xf0, 0x3f},
+{0x00, 0x9a102000},
+{0x04, 0xda024000},
+{0x08, 0x80a22020},
+{0x0c, 0x34800003},
+{0x10, 0xc2030000},
+{0x14, 0xc203c000},
+{0x18, 0x825b4001},
+{0x1c, 0x9402a001},
+{0x20, 0xb0060001},
+{0x24, 0x92026038},
+{0x28, 0x9e03e004},
+{0x2c, 0x80a2a003},
+{0x30, 0x04bfffed},
+{0x34, 0x98033ffc},
+{0x38, 0x832c2002},
+{0x3c, 0x8200401e},
+{0x40, 0xa0042001},
+{0x44, 0xf0207fe8},
+{0x48, 0x80a42003},
+{0x4c, 0x04bfffe0},
+{0x50, 0x9602e004},
+{0x54, 0xd207bfe0},
+{0x58, 0xd407bfe4},
+{0x5c, 0xd607bfe8},
+{0x60, 0xd807bfec},
+{0x64, 0xda07bff0},
+{0x68, 0xc207bff4},
+{0x6c, 0x933a6008},
+{0x70, 0x953aa008},
+{0x74, 0x973ae008},
+{0x78, 0x993b2008},
+{0x7c, 0x9b3b6008},
+{0xf0, 0x40},
+{0x00, 0x83386008},
+{0x04, 0x90102020},
+{0x08, 0xd227bfe0},
+{0x0c, 0xd427bfe4},
+{0x10, 0xd627bfe8},
+{0x14, 0xd827bfec},
+{0x18, 0xda27bff0},
+{0x1c, 0xc227bff4},
+{0x20, 0x7fffffa9},
+{0x24, 0x90220019},
+{0x28, 0x80a22020},
+{0x2c, 0x14800011},
+{0x30, 0xb0102000},
+{0x34, 0x82020008},
+{0x38, 0x82004008},
+{0x3c, 0x83286003},
+{0x40, 0x90006ce8},
+{0x44, 0x9807bfe0},
+{0x48, 0x94102005},
+{0x4c, 0xc2030000},
+{0x50, 0xda020000},
+{0x54, 0x8258400d},
+{0x58, 0xb0060001},
+{0x5c, 0x98032004},
+{0x60, 0x9482bfff},
+{0x64, 0x1cbffffa},
+{0x68, 0x90022004},
+{0x6c, 0x30800011},
+{0x70, 0x82102041},
+{0x74, 0x90204008},
+{0x78, 0x82020008},
+{0x7c, 0x82004008},
+{0xf0, 0x41},
+{0x00, 0x83286003},
+{0x04, 0x90006cfc},
+{0x08, 0x9807bfe0},
+{0x0c, 0x94102005},
+{0x10, 0xc2030000},
+{0x14, 0xda020000},
+{0x18, 0x8258400d},
+{0x1c, 0xb0060001},
+{0x20, 0x98032004},
+{0x24, 0x9482bfff},
+{0x28, 0x1cbffffa},
+{0x2c, 0x90023ffc},
+{0x30, 0x81c7e008},
+{0x34, 0x81e80000},
+{0x38, 0x9de3bf98},
+{0x3c, 0x9010001a},
+{0x40, 0x7fffff70},
+{0x44, 0x92100018},
+{0x48, 0xb4100008},
+{0x4c, 0x9010001b},
+{0x50, 0x7fffff6c},
+{0x54, 0x92100019},
+{0x58, 0x7fffff83},
+{0x5c, 0x97e80008},
+{0x60, 0x01000000},
+{0x64, 0x9de3bf90},
+{0x68, 0xa8102000},
+{0x6c, 0xf427a04c},
+{0x70, 0xaa102000},
+{0x74, 0xac102000},
+{0x78, 0xae102010},
+{0x7c, 0xe827bff4},
+{0xf0, 0x42},
+{0x00, 0xb4250017},
+{0x04, 0x9210001a},
+{0x08, 0x94100018},
+{0x0c, 0x96100019},
+{0x10, 0x7fffffea},
+{0x14, 0x90100015},
+{0x18, 0xa6100008},
+{0x1c, 0xb6254017},
+{0x20, 0x92100014},
+{0x24, 0x94100018},
+{0x28, 0x96100019},
+{0x2c, 0x7fffffe3},
+{0x30, 0x9010001b},
+{0x34, 0xa4100008},
+{0x38, 0xb8050017},
+{0x3c, 0x9210001c},
+{0x40, 0x94100018},
+{0x44, 0x96100019},
+{0x48, 0x7fffffdc},
+{0x4c, 0x90100015},
+{0x50, 0xa2100008},
+{0x54, 0xba054017},
+{0x58, 0x92100014},
+{0x5c, 0x94100018},
+{0x60, 0x96100019},
+{0x64, 0x7fffffd5},
+{0x68, 0x9010001d},
+{0x6c, 0xa0100008},
+{0x70, 0x90100015},
+{0x74, 0x92100014},
+{0x78, 0x94100018},
+{0x7c, 0x7fffffcf},
+{0xf0, 0x43},
+{0x00, 0x96100019},
+{0x04, 0xa624c008},
+{0x08, 0xa0240008},
+{0x0c, 0xa4248008},
+{0x10, 0xa2244008},
+{0x14, 0x80a4e000},
+{0x18, 0x04800004},
+{0x1c, 0x82102000},
+{0x20, 0x82100013},
+{0x24, 0xac102001},
+{0x28, 0x80a48001},
+{0x2c, 0x04800005},
+{0x30, 0x80a44001},
+{0x34, 0x82100012},
+{0x38, 0xac102003},
+{0x3c, 0x80a44001},
+{0x40, 0x04800005},
+{0x44, 0x80a40001},
+{0x48, 0x82100011},
+{0x4c, 0xac102005},
+{0x50, 0x80a40001},
+{0x54, 0x04800005},
+{0x58, 0x80a06000},
+{0x5c, 0x82100010},
+{0x60, 0xac102007},
+{0x64, 0x80a06000},
+{0x68, 0x14800017},
+{0x6c, 0x80a5a001},
+{0x70, 0x80a5e020},
+{0x74, 0x12800004},
+{0x78, 0x80a5e010},
+{0x7c, 0x10800020},
+{0xf0, 0x44},
+{0x00, 0xae102010},
+{0x04, 0x12800004},
+{0x08, 0x80a5e008},
+{0x0c, 0x1080001c},
+{0x10, 0xae102008},
+{0x14, 0x12800004},
+{0x18, 0x80a5e004},
+{0x1c, 0x10800018},
+{0x20, 0xae102004},
+{0x24, 0x12800004},
+{0x28, 0x80a5e002},
+{0x2c, 0x10800014},
+{0x30, 0xae102002},
+{0x34, 0x12800018},
+{0x38, 0x832e2006},
+{0x3c, 0x10800010},
+{0x40, 0xae102001},
+{0x44, 0x12800004},
+{0x48, 0x80a5a003},
+{0x4c, 0x1080000c},
+{0x50, 0xa810001a},
+{0x54, 0x12800004},
+{0x58, 0x80a5a005},
+{0x5c, 0x10800008},
+{0x60, 0xaa10001b},
+{0x64, 0x12800004},
+{0x68, 0x80a5a007},
+{0x6c, 0x10800004},
+{0x70, 0xa810001c},
+{0x74, 0x22800002},
+{0x78, 0xaa10001d},
+{0x7c, 0xc207bff4},
+{0xf0, 0x45},
+{0x00, 0x82006001},
+{0x04, 0x80a0607f},
+{0x08, 0x04bfff9e},
+{0x0c, 0xc227bff4},
+{0x10, 0x832e2006},
+{0x14, 0xaa054001},
+{0x18, 0x82380015},
+{0x1c, 0x8338601f},
+{0x20, 0xaa0d4001},
+{0x24, 0x9b2e6006},
+{0x28, 0xc2002308},
+{0x2c, 0xa885000d},
+{0x30, 0x1c800004},
+{0x34, 0x83286006},
+{0x38, 0x10800005},
+{0x3c, 0xa8102000},
+{0x40, 0x80a50001},
+{0x44, 0x38800002},
+{0x48, 0xa8100001},
+{0x4c, 0x9a0d2fff},
+{0x50, 0x832d6010},
+{0x54, 0x8210400d},
+{0x58, 0xd807a04c},
+{0x5c, 0x9b2b2002},
+{0x60, 0xc2236768},
+{0x64, 0x81c7e008},
+{0x68, 0x81e80000},
+{0x6c, 0x9de3bf98},
+{0x70, 0xfa50245a},
+{0x74, 0x80a76000},
+{0x78, 0x0280003d},
+{0x7c, 0x9e102001},
+{0xf0, 0x46},
+{0x00, 0xc20022fc},
+{0x04, 0x80a3c001},
+{0x08, 0x18800039},
+{0x0c, 0x17000018},
+{0x10, 0x8212e220},
+{0x14, 0x9810001d},
+{0x18, 0x9a006004},
+{0x1c, 0xb6102001},
+{0x20, 0xf20022f8},
+{0x24, 0x80a6c019},
+{0x28, 0xb4102000},
+{0x2c, 0x1880002b},
+{0x30, 0x82102000},
+{0x34, 0xf0502458},
+{0x38, 0xba036038},
+{0x3c, 0xf8074000},
+{0x40, 0xb606e001},
+{0x44, 0x80a70018},
+{0x48, 0x06800004},
+{0x4c, 0xba076038},
+{0x50, 0xb406801c},
+{0x54, 0x82006001},
+{0x58, 0x80a6c019},
+{0x5c, 0x28bffff9},
+{0x60, 0xf8074000},
+{0x64, 0x80a06000},
+{0x68, 0x2280001d},
+{0x6c, 0x9e03e001},
+{0x70, 0x953ea01f},
+{0x74, 0x8182a000},
+{0x78, 0x01000000},
+{0x7c, 0x01000000},
+{0xf0, 0x47},
+{0x00, 0x01000000},
+{0x04, 0x827e8001},
+{0x08, 0x8258400c},
+{0x0c, 0xbb38601f},
+{0x10, 0xbb376016},
+{0x14, 0x8200401d},
+{0x18, 0xb6102001},
+{0x1c, 0xfa0022f8},
+{0x20, 0x80a6c01d},
+{0x24, 0x1880000d},
+{0x28, 0xb538600a},
+{0x2c, 0x832be002},
+{0x30, 0xba006038},
+{0x34, 0xb812e220},
+{0x38, 0xc207401c},
+{0x3c, 0x8220401a},
+{0x40, 0xc227401c},
+{0x44, 0xb606e001},
+{0x48, 0xc20022f8},
+{0x4c, 0x80a6c001},
+{0x50, 0x08bffffa},
+{0x54, 0xba076038},
+{0x58, 0x9e03e001},
+{0x5c, 0xc20022fc},
+{0x60, 0x80a3c001},
+{0x64, 0x08bfffce},
+{0x68, 0x9a036004},
+{0x6c, 0x81c7e008},
+{0x70, 0x81e80000},
+{0x74, 0x9de3bf48},
+{0x78, 0x1b00003f},
+{0x7c, 0xc2002350},
+{0xf0, 0x48},
+{0x00, 0x9a1363ff},
+{0x04, 0xba08400d},
+{0x08, 0xa4102001},
+{0x0c, 0xda0022f8},
+{0x10, 0x80a4800d},
+{0x14, 0x18800063},
+{0x18, 0xa3306010},
+{0x1c, 0xae10200e},
+{0x20, 0xac10200e},
+{0x24, 0xaa102000},
+{0x28, 0xa8102000},
+{0x2c, 0xa6102000},
+{0x30, 0x80a46000},
+{0x34, 0x02800033},
+{0x38, 0xa0102000},
+{0x3c, 0x03000018},
+{0x40, 0x96106220},
+{0x44, 0x92102000},
+{0x48, 0x9807bfa8},
+{0x4c, 0x8204c009},
+{0x50, 0xda086440},
+{0x54, 0x8205800d},
+{0x58, 0x80a36000},
+{0x5c, 0x02800007},
+{0x60, 0x83286002},
+{0x64, 0xc200400b},
+{0x68, 0xc2230000},
+{0x6c, 0x92026001},
+{0x70, 0x10bffff7},
+{0x74, 0x98032004},
+{0x78, 0x7ffffc7d},
+{0x7c, 0x9007bfa8},
+{0xf0, 0x49},
+{0x00, 0x80a74011},
+{0x04, 0x1480000b},
+{0x08, 0x9210001d},
+{0x0c, 0x832f6002},
+{0x10, 0x8200401e},
+{0x14, 0x9a007fa8},
+{0x18, 0xc2034000},
+{0x1c, 0x92026001},
+{0x20, 0xa0040001},
+{0x24, 0x80a24011},
+{0x28, 0x04bffffc},
+{0x2c, 0x9a036004},
+{0x30, 0x8224401d},
+{0x34, 0x82006001},
+{0x38, 0x9b3c201f},
+{0x3c, 0x81836000},
+{0x40, 0x01000000},
+{0x44, 0x01000000},
+{0x48, 0x01000000},
+{0x4c, 0xa0fc0001},
+{0x50, 0x36800007},
+{0x54, 0xda0023c4},
+{0x58, 0xc20023c8},
+{0x5c, 0x80886020},
+{0x60, 0x22800026},
+{0x64, 0xaa056001},
+{0x68, 0xda0023c4},
+{0x6c, 0x9a5c000d},
+{0x70, 0x833b601f},
+{0x74, 0x83306018},
+{0x78, 0x9a034001},
+{0x7c, 0xa13b6008},
+{0xf0, 0x4a},
+{0x00, 0x92102000},
+{0x04, 0x11000018},
+{0x08, 0x82050009},
+{0x0c, 0xda086440},
+{0x10, 0x8205c00d},
+{0x14, 0x94122220},
+{0x18, 0x97286002},
+{0x1c, 0x80a36000},
+{0x20, 0x02800015},
+{0x24, 0x92026001},
+{0x28, 0xc202c00a},
+{0x2c, 0x98204010},
+{0x30, 0xda0822b0},
+{0x34, 0x833b201f},
+{0x38, 0x80a0000d},
+{0x3c, 0x8220400c},
+{0x40, 0x9a402000},
+{0x44, 0x8330601f},
+{0x48, 0x808b4001},
+{0x4c, 0x22bfffef},
+{0x50, 0xd822c00a},
+{0x54, 0xda0ca2b0},
+{0x58, 0x9a5b000d},
+{0x5c, 0x833b601f},
+{0x60, 0x83306019},
+{0x64, 0x9a034001},
+{0x68, 0x993b6007},
+{0x6c, 0x10bfffe7},
+{0x70, 0xd822c00a},
+{0x74, 0xaa056001},
+{0x78, 0xa604e00c},
+{0x7c, 0x80a56001},
+{0xf0, 0x4b},
+{0x00, 0x04bfffac},
+{0x04, 0xa805200c},
+{0x08, 0xa404a001},
+{0x0c, 0xc20022f8},
+{0x10, 0x80a48001},
+{0x14, 0xac05a00e},
+{0x18, 0x08bfffa3},
+{0x1c, 0xae05e00e},
+{0x20, 0x81c7e008},
+{0x24, 0x81e80000},
+{0x28, 0x9de3bf98},
+{0x2c, 0xc21023b6},
+{0x30, 0xf81023be},
+{0x34, 0x96102001},
+{0x38, 0xfa0022f8},
+{0x3c, 0x80a2c01d},
+{0x40, 0xa8004001},
+{0x44, 0xa407001c},
+{0x48, 0x18800088},
+{0x4c, 0xe6002214},
+{0x50, 0x90102038},
+{0x54, 0x92102038},
+{0x58, 0x9810200e},
+{0x5c, 0x15000018},
+{0x60, 0xb8102001},
+{0x64, 0xc20022fc},
+{0x68, 0x80a70001},
+{0x6c, 0x38800079},
+{0x70, 0x9602e001},
+{0x74, 0x2f000018},
+{0x78, 0xac12a220},
+{0x7c, 0xaa12a224},
+{0xf0, 0x4c},
+{0x00, 0x8203001c},
+{0x04, 0xb7286002},
+{0x08, 0xfa06c016},
+{0x0c, 0x80a74013},
+{0x10, 0x2480006b},
+{0x14, 0xb8072001},
+{0x18, 0x80a74014},
+{0x1c, 0x16800014},
+{0x20, 0x83286002},
+{0x24, 0x80a74012},
+{0x28, 0x06800007},
+{0x2c, 0x8215e21c},
+{0x30, 0xc206c015},
+{0x34, 0x80a04012},
+{0x38, 0x1680000c},
+{0x3c, 0x8203001c},
+{0x40, 0x8215e21c},
+{0x44, 0xc206c001},
+{0x48, 0x80a74001},
+{0x4c, 0x2680005c},
+{0x50, 0xb8072001},
+{0x54, 0xc206c015},
+{0x58, 0x80a74001},
+{0x5c, 0x24800058},
+{0x60, 0xb8072001},
+{0x64, 0x8203001c},
+{0x68, 0x83286002},
+{0x6c, 0xfa0023c8},
+{0x70, 0x808f6040},
+{0x74, 0xf0004016},
+{0x78, 0x0280000b},
+{0x7c, 0xa2072001},
+{0xf0, 0x4d},
+{0x00, 0xfa0022fc},
+{0x04, 0x83376001},
+{0x08, 0x80a70001},
+{0x0c, 0x28800007},
+{0x10, 0x9a102000},
+{0x14, 0x8227401c},
+{0x18, 0xb8006001},
+{0x1c, 0x10800003},
+{0x20, 0x9a102001},
+{0x24, 0x9a102000},
+{0x28, 0xfa00221c},
+{0x2c, 0xc2002220},
+{0x30, 0xba5f401c},
+{0x34, 0xba074001},
+{0x38, 0xba5e001d},
+{0x3c, 0x833f601f},
+{0x40, 0x83306016},
+{0x44, 0xba074001},
+{0x48, 0xc2002224},
+{0x4c, 0x8258401c},
+{0x50, 0xbb3f600a},
+{0x54, 0xba074001},
+{0x58, 0xc2002240},
+{0x5c, 0xb0074001},
+{0x60, 0xc2002218},
+{0x64, 0xb6070001},
+{0x68, 0xa012a220},
+{0x6c, 0xb92ee002},
+{0x70, 0xba10001c},
+{0x74, 0xb2024010},
+{0x78, 0x9e020010},
+{0x7c, 0xc20023c8},
+{0xf0, 0x4e},
+{0x00, 0x80886040},
+{0x04, 0xb806401c},
+{0x08, 0x02800007},
+{0x0c, 0xb403c01d},
+{0x10, 0xc20022fc},
+{0x14, 0x83306001},
+{0x18, 0x80a6c001},
+{0x1c, 0x38800027},
+{0x20, 0xb8100011},
+{0x24, 0xfa0022fc},
+{0x28, 0x8227401b},
+{0x2c, 0x83286002},
+{0x30, 0x80a6c01d},
+{0x34, 0x18800020},
+{0x38, 0x82064001},
+{0x3c, 0x80a36000},
+{0x40, 0x32800002},
+{0x44, 0xb8006004},
+{0x48, 0xc2070000},
+{0x4c, 0x82204018},
+{0x50, 0xc2270000},
+{0x54, 0xfa002228},
+{0x58, 0x8226c01d},
+{0x5c, 0x80a6c01d},
+{0x60, 0x04800013},
+{0x64, 0xb85e0001},
+{0x68, 0x80a36000},
+{0x6c, 0x22800008},
+{0x70, 0xc200222c},
+{0x74, 0xc20022fc},
+{0x78, 0x8220401b},
+{0x7c, 0x83286002},
+{0xf0, 0x4f},
+{0x00, 0x8203c001},
+{0x04, 0xb4006004},
+{0x08, 0xc200222c},
+{0x0c, 0x825f0001},
+{0x10, 0xbb38601f},
+{0x14, 0xbb376018},
+{0x18, 0x8200401d},
+{0x1c, 0xfa068000},
+{0x20, 0x83386008},
+{0x24, 0xba274001},
+{0x28, 0xfa268000},
+{0x2c, 0x10bfffd0},
+{0x30, 0xb606e001},
+{0x34, 0xb8100011},
+{0x38, 0xb8072001},
+{0x3c, 0xc20022fc},
+{0x40, 0x80a70001},
+{0x44, 0x08bfff90},
+{0x48, 0x8203001c},
+{0x4c, 0x9602e001},
+{0x50, 0xc20022f8},
+{0x54, 0x80a2c001},
+{0x58, 0x9803200e},
+{0x5c, 0x92026038},
+{0x60, 0x08bfff80},
+{0x64, 0x90022038},
+{0x68, 0x81c7e008},
+{0x6c, 0x81e80000},
+{0x70, 0x9de3bf98},
+{0x74, 0xc21023b6},
+{0x78, 0xf81023be},
+{0x7c, 0x96102001},
+{0xf0, 0x50},
+{0x00, 0xfa0022fc},
+{0x04, 0x80a2c01d},
+{0x08, 0xa0004001},
+{0x0c, 0x9207001c},
+{0x10, 0x1880005e},
+{0x14, 0xd0002214},
+{0x18, 0x15000018},
+{0x1c, 0x9a102001},
+{0x20, 0xc20022f8},
+{0x24, 0x80a34001},
+{0x28, 0x18800053},
+{0x2c, 0x832ae002},
+{0x30, 0xb2006038},
+{0x34, 0x27000018},
+{0x38, 0xa412a220},
+{0x3c, 0xa212a258},
+{0x40, 0xfa064012},
+{0x44, 0x80a74008},
+{0x48, 0x24800047},
+{0x4c, 0x9a036001},
+{0x50, 0x80a74010},
+{0x54, 0x36800013},
+{0x58, 0xfa00221c},
+{0x5c, 0x80a74009},
+{0x60, 0x06800007},
+{0x64, 0x8214e1e8},
+{0x68, 0xc2064011},
+{0x6c, 0x80a04009},
+{0x70, 0x3680000c},
+{0x74, 0xfa00221c},
+{0x78, 0x8214e1e8},
+{0x7c, 0xc2064001},
+{0xf0, 0x51},
+{0x00, 0x80a74001},
+{0x04, 0x26800038},
+{0x08, 0x9a036001},
+{0x0c, 0xc2064011},
+{0x10, 0x80a74001},
+{0x14, 0x24800034},
+{0x18, 0x9a036001},
+{0x1c, 0xfa00221c},
+{0x20, 0xc2002220},
+{0x24, 0xba5f400d},
+{0x28, 0xba074001},
+{0x2c, 0xf8064012},
+{0x30, 0xba5f001d},
+{0x34, 0x833f601f},
+{0x38, 0x83306016},
+{0x3c, 0xba074001},
+{0x40, 0xc2002224},
+{0x44, 0x8258400d},
+{0x48, 0xbb3f600a},
+{0x4c, 0xba074001},
+{0x50, 0xc2002218},
+{0x54, 0xb6034001},
+{0x58, 0xc2002240},
+{0x5c, 0xb8074001},
+{0x60, 0xc20022f8},
+{0x64, 0x80a6c001},
+{0x68, 0x1880001c},
+{0x6c, 0x832ee003},
+{0x70, 0x8220401b},
+{0x74, 0x82004001},
+{0x78, 0x8200400b},
+{0x7c, 0xb5286002},
+{0xf0, 0x52},
+{0x00, 0x9812a220},
+{0x04, 0xc206800c},
+{0x08, 0x9e20401c},
+{0x0c, 0xde26800c},
+{0x10, 0xfa002228},
+{0x14, 0x8226c01d},
+{0x18, 0x80a6c01d},
+{0x1c, 0xb05f0001},
+{0x20, 0x0480000a},
+{0x24, 0xb606e001},
+{0x28, 0xc200222c},
+{0x2c, 0x825e0001},
+{0x30, 0xbb38601f},
+{0x34, 0xbb376018},
+{0x38, 0x8200401d},
+{0x3c, 0x83386008},
+{0x40, 0x8223c001},
+{0x44, 0xc226800c},
+{0x48, 0xc20022f8},
+{0x4c, 0x80a6c001},
+{0x50, 0x08bfffed},
+{0x54, 0xb406a038},
+{0x58, 0x9a036001},
+{0x5c, 0xb2066038},
+{0x60, 0x9a036001},
+{0x64, 0xc20022f8},
+{0x68, 0x80a34001},
+{0x6c, 0x08bfffb5},
+{0x70, 0xb2066038},
+{0x74, 0x9602e001},
+{0x78, 0xc20022fc},
+{0x7c, 0x80a2c001},
+{0xf0, 0x53},
+{0x00, 0x08bfffa8},
+{0x04, 0x9a102001},
+{0x08, 0x81c7e008},
+{0x0c, 0x81e80000},
+{0x10, 0xc2002214},
+{0x14, 0x80a06000},
+{0x18, 0x0280000c},
+{0x1c, 0x01000000},
+{0x20, 0xc20023c8},
+{0x24, 0x80886010},
+{0x28, 0x02800005},
+{0x2c, 0x01000000},
+{0x30, 0x03000009},
+{0x34, 0x81c061a8},
+{0x38, 0x01000000},
+{0x3c, 0x03000009},
+{0x40, 0x81c063f0},
+{0x44, 0x01000000},
+{0x48, 0x01000000},
+{0x4c, 0x81c3e008},
+{0x50, 0x01000000},
+{0x54, 0x9de3bf98},
+{0x58, 0xb0102001},
+{0x5c, 0xda002200},
+{0x60, 0x80a6000d},
+{0x64, 0x1880001d},
+{0x68, 0xc0202504},
+{0x6c, 0x03000018},
+{0x70, 0x98106220},
+{0x74, 0xde0022fc},
+{0x78, 0xb2102007},
+{0x7c, 0xb6102001},
+{0xf0, 0x54},
+{0x00, 0x80a6c00f},
+{0x04, 0x18800011},
+{0x08, 0x832e6003},
+{0x0c, 0x8200400c},
+{0x10, 0xba006004},
+{0x14, 0xf4002238},
+{0x18, 0xc2074000},
+{0x1c, 0xb606e001},
+{0x20, 0xba076004},
+{0x24, 0x80a0401a},
+{0x28, 0x08800005},
+{0x2c, 0xb820401a},
+{0x30, 0xc2002504},
+{0x34, 0x8200401c},
+{0x38, 0xc2202504},
+{0x3c, 0x80a6c00f},
+{0x40, 0x28bffff7},
+{0x44, 0xc2074000},
+{0x48, 0xb0062001},
+{0x4c, 0x80a6000d},
+{0x50, 0x08bfffeb},
+{0x54, 0xb2066007},
+{0x58, 0xfa002504},
+{0x5c, 0xc200223c},
+{0x60, 0x80a74001},
+{0x64, 0x28800004},
+{0x68, 0xc0202568},
+{0x6c, 0x82102001},
+{0x70, 0xc2202568},
+{0x74, 0x033fc180},
+{0x78, 0xfa002568},
+{0x7c, 0x8210602c},
+{0xf0, 0x55},
+{0x00, 0xfa204000},
+{0x04, 0xfa202570},
+{0x08, 0x81c7e008},
+{0x0c, 0x81e80000},
+{0x10, 0x9de3bf70},
+{0x14, 0x92102001},
+{0x18, 0xd0002300},
+{0x1c, 0x80a24008},
+{0x20, 0x1880001c},
+{0x24, 0x9e102000},
+{0x28, 0x03000018},
+{0x2c, 0xa2106220},
+{0x30, 0xd4002308},
+{0x34, 0x98102007},
+{0x38, 0x96102001},
+{0x3c, 0x80a2c00a},
+{0x40, 0x38800011},
+{0x44, 0x92026001},
+{0x48, 0x832b2003},
+{0x4c, 0x82004011},
+{0x50, 0x82006004},
+{0x54, 0xda004000},
+{0x58, 0x80a3400f},
+{0x5c, 0x04800005},
+{0x60, 0x82006004},
+{0x64, 0x9e10000d},
+{0x68, 0xa0100009},
+{0x6c, 0xa410000b},
+{0x70, 0x9602e001},
+{0x74, 0x80a2c00a},
+{0x78, 0x28bffff8},
+{0x7c, 0xda004000},
+{0xf0, 0x56},
+{0x00, 0x92026001},
+{0x04, 0x80a24008},
+{0x08, 0x08bfffec},
+{0x0c, 0x98032007},
+{0x10, 0xa2042001},
+{0x14, 0x92043fff},
+{0x18, 0x80a24011},
+{0x1c, 0x1480002e},
+{0x20, 0x9e102000},
+{0x24, 0x832a6003},
+{0x28, 0x90204009},
+{0x2c, 0x03000018},
+{0x30, 0xa6106220},
+{0x34, 0xa004a001},
+{0x38, 0x9604bfff},
+{0x3c, 0x80a2c010},
+{0x40, 0x14800021},
+{0x44, 0x82020008},
+{0x48, 0x8200400b},
+{0x4c, 0x9b2be002},
+{0x50, 0x83286002},
+{0x54, 0x9a03401e},
+{0x58, 0x94004013},
+{0x5c, 0x9a037fd0},
+{0x60, 0x833ae01f},
+{0x64, 0x8220400b},
+{0x68, 0x80a26000},
+{0x6c, 0x0480000f},
+{0x70, 0x9930601f},
+{0x74, 0xc2002300},
+{0x78, 0x80a04009},
+{0x7c, 0x82603fff},
+{0xf0, 0x57},
+{0x00, 0x8088400c},
+{0x04, 0x2280000a},
+{0x08, 0xc0234000},
+{0x0c, 0xc2002308},
+{0x10, 0x80a2c001},
+{0x14, 0x38800006},
+{0x18, 0xc0234000},
+{0x1c, 0xc2028000},
+{0x20, 0x10800003},
+{0x24, 0xc2234000},
+{0x28, 0xc0234000},
+{0x2c, 0x9602e001},
+{0x30, 0x9e03e001},
+{0x34, 0x9a036004},
+{0x38, 0x80a2c010},
+{0x3c, 0x04bfffe9},
+{0x40, 0x9402a004},
+{0x44, 0x92026001},
+{0x48, 0x80a24011},
+{0x4c, 0x04bfffdb},
+{0x50, 0x90022007},
+{0x54, 0x9007bfd0},
+{0x58, 0x7ffffaa5},
+{0x5c, 0x92102009},
+{0x60, 0xda07bfec},
+{0x64, 0xc207bfe8},
+{0x68, 0x8200400d},
+{0x6c, 0xda07bff0},
+{0x70, 0x8200400d},
+{0x74, 0x9b30601f},
+{0x78, 0x8200400d},
+{0x7c, 0xd6082347},
+{0xf0, 0x58},
+{0x00, 0x9602e001},
+{0x04, 0xda00256c},
+{0x08, 0xd808257f},
+{0x0c, 0x9a5b400b},
+{0x10, 0x98032001},
+{0x14, 0x81800000},
+{0x18, 0x01000000},
+{0x1c, 0x01000000},
+{0x20, 0x01000000},
+{0x24, 0x9a73400c},
+{0x28, 0x83386001},
+{0x2c, 0xc2202590},
+{0x30, 0xda20256c},
+{0x34, 0x96102000},
+{0x38, 0x94102c18},
+{0x3c, 0x992ae002},
+{0x40, 0xc20323b4},
+{0x44, 0x80a06000},
+{0x48, 0x12800009},
+{0x4c, 0x80a2e002},
+{0x50, 0xc2002520},
+{0x54, 0x14800004},
+{0x58, 0x9a200001},
+{0x5c, 0x10800014},
+{0x60, 0xc2232520},
+{0x64, 0x10800012},
+{0x68, 0xda232520},
+{0x6c, 0xda1323b4},
+{0x70, 0xc2002590},
+{0x74, 0x8258400d},
+{0x78, 0x9b38601f},
+{0x7c, 0x9b336018},
+{0xf0, 0x59},
+{0x00, 0x8200400d},
+{0x04, 0xda1323b6},
+{0x08, 0x83386008},
+{0x0c, 0x8200400d},
+{0x10, 0xda00256c},
+{0x14, 0x8258400d},
+{0x18, 0x83306007},
+{0x1c, 0x80a06c18},
+{0x20, 0x04800003},
+{0x24, 0xc2232520},
+{0x28, 0xd4232520},
+{0x2c, 0x9602e001},
+{0x30, 0x80a2e003},
+{0x34, 0x04bfffe3},
+{0x38, 0x992ae002},
+{0x3c, 0xda102472},
+{0x40, 0xc2002288},
+{0x44, 0x80a36000},
+{0x48, 0x02800004},
+{0x4c, 0xc220251c},
+{0x50, 0x10800005},
+{0x54, 0xda202530},
+{0x58, 0x0300001f},
+{0x5c, 0x821063ff},
+{0x60, 0xc2202530},
+{0x64, 0x81c7e008},
+{0x68, 0x81e80000},
+{0x6c, 0x9de3bf80},
+{0x70, 0x832e6003},
+{0x74, 0x82204019},
+{0x78, 0x82004001},
+{0x7c, 0x82004018},
+{0xf0, 0x5a},
+{0x00, 0x3b000018},
+{0x04, 0x83286002},
+{0x08, 0xc020254c},
+{0x0c, 0xba176220},
+{0x10, 0xea00401d},
+{0x14, 0x9e100019},
+{0x18, 0xb2100018},
+{0x1c, 0xc2002528},
+{0x20, 0x80a54001},
+{0x24, 0x9810001a},
+{0x28, 0x068000c9},
+{0x2c, 0xb0102000},
+{0x30, 0xa006401a},
+{0x34, 0xa403c01a},
+{0x38, 0x8207bfe0},
+{0x3c, 0xb2102004},
+{0x40, 0xc0204000},
+{0x44, 0xb2867fff},
+{0x48, 0x1cbffffe},
+{0x4c, 0x82006004},
+{0x50, 0x9e23c00c},
+{0x54, 0x80a3c012},
+{0x58, 0x14800061},
+{0x5c, 0xb92be003},
+{0x60, 0xba03c00f},
+{0x64, 0x82048012},
+{0x68, 0xb827000f},
+{0x6c, 0xba07400f},
+{0x70, 0x82004012},
+{0x74, 0xba274001},
+{0x78, 0x9607001c},
+{0x7c, 0x92274010},
+{0xf0, 0x5b},
+{0x00, 0x9410000b},
+{0x04, 0x2d000018},
+{0x08, 0x8203000c},
+{0x0c, 0xb2240001},
+{0x10, 0x80a64010},
+{0x14, 0x1480004c},
+{0x18, 0xbb3be01f},
+{0x1c, 0x82028019},
+{0x20, 0xba27400f},
+{0x24, 0x83286002},
+{0x28, 0xb815a220},
+{0x2c, 0xb6064009},
+{0x30, 0x9a00401c},
+{0x34, 0xa937601f},
+{0x38, 0xb406e008},
+{0x3c, 0x80a32001},
+{0x40, 0x0280000c},
+{0x44, 0x80a6600e},
+{0x48, 0x18800003},
+{0x4c, 0xba102001},
+{0x50, 0xba102000},
+{0x54, 0x80a3e019},
+{0x58, 0x18800003},
+{0x5c, 0x82102001},
+{0x60, 0x82102000},
+{0x64, 0x80974001},
+{0x68, 0x32800033},
+{0x6c, 0xb2066001},
+{0x70, 0xc2034000},
+{0x74, 0x80a04015},
+{0x78, 0x14800003},
+{0x7c, 0xba102001},
+{0xf0, 0x5c},
+{0x00, 0xba102000},
+{0x04, 0x833e601f},
+{0x08, 0x82204019},
+{0x0c, 0x8330601f},
+{0x10, 0x808f4001},
+{0x14, 0x0280000c},
+{0x18, 0x80a32001},
+{0x1c, 0xc2002308},
+{0x20, 0x80a04019},
+{0x24, 0x82603fff},
+{0x28, 0x80884014},
+{0x2c, 0x02800006},
+{0x30, 0x80a32001},
+{0x34, 0xc2002300},
+{0x38, 0x80a3c001},
+{0x3c, 0x08800083},
+{0x40, 0x80a32001},
+{0x44, 0x3280001c},
+{0x48, 0xb2066001},
+{0x4c, 0x8202c019},
+{0x50, 0xa3286002},
+{0x54, 0x912b001a},
+{0x58, 0xb6102000},
+{0x5c, 0xa615a220},
+{0x60, 0xb92ee002},
+{0x64, 0xc2072520},
+{0x68, 0xfa044013},
+{0x6c, 0x80a74001},
+{0x70, 0x0480000c},
+{0x74, 0x8207bff8},
+{0x78, 0x80a6e003},
+{0x7c, 0x14800006},
+{0xf0, 0x5d},
+{0x00, 0xb0070001},
+{0x04, 0xc2063fe8},
+{0x08, 0x82104008},
+{0x0c, 0x10800005},
+{0x10, 0xc2263fe8},
+{0x14, 0xc2063fe8},
+{0x18, 0x82006001},
+{0x1c, 0xc2263fe8},
+{0x20, 0xb606e001},
+{0x24, 0x80a6e004},
+{0x28, 0x08bfffef},
+{0x2c, 0xb92ee002},
+{0x30, 0xb2066001},
+{0x34, 0x9a036004},
+{0x38, 0x80a64010},
+{0x3c, 0x04bfffc0},
+{0x40, 0xb406a001},
+{0x44, 0x9e03e001},
+{0x48, 0x92026003},
+{0x4c, 0x9402a00e},
+{0x50, 0x80a3c012},
+{0x54, 0x04bfffad},
+{0x58, 0x9602e00e},
+{0x5c, 0xfa102470},
+{0x60, 0xc207bff0},
+{0x64, 0x80a0401d},
+{0x68, 0x14800003},
+{0x6c, 0xba102001},
+{0x70, 0xba102000},
+{0x74, 0x821b2002},
+{0x78, 0x80a00001},
+{0x7c, 0x82603fff},
+{0xf0, 0x5e},
+{0x00, 0x80974001},
+{0x04, 0x12800052},
+{0x08, 0xb0103fff},
+{0x0c, 0xc207bfe0},
+{0x10, 0x80886010},
+{0x14, 0x0280000a},
+{0x18, 0xfa07bfe4},
+{0x1c, 0xc207bfec},
+{0x20, 0x80886082},
+{0x24, 0x02800007},
+{0x28, 0x808f6082},
+{0x2c, 0x80886028},
+{0x30, 0x12800047},
+{0x34, 0xb0102003},
+{0x38, 0xfa07bfe4},
+{0x3c, 0x808f6082},
+{0x40, 0x02800007},
+{0x44, 0x808f6028},
+{0x48, 0xc207bfec},
+{0x4c, 0x80886028},
+{0x50, 0x3280003f},
+{0x54, 0xb0102002},
+{0x58, 0x808f6028},
+{0x5c, 0x02800008},
+{0x60, 0xf807bfe8},
+{0x64, 0xc207bfec},
+{0x68, 0x80886082},
+{0x6c, 0x02800005},
+{0x70, 0x820f200a},
+{0x74, 0x10800036},
+{0x78, 0xb0102002},
+{0x7c, 0x820f200a},
+{0xf0, 0x5f},
+{0x00, 0x8218600a},
+{0x04, 0x80a00001},
+{0x08, 0xb2043fff},
+{0x0c, 0xba603fff},
+{0x10, 0x821e6001},
+{0x14, 0x80a00001},
+{0x18, 0xb6402000},
+{0x1c, 0x808f401b},
+{0x20, 0x02800005},
+{0x24, 0x9e04bfff},
+{0x28, 0x80a3e001},
+{0x2c, 0x32800028},
+{0x30, 0xb0102001},
+{0x34, 0x820f2022},
+{0x38, 0x80a06022},
+{0x3c, 0x1280000d},
+{0x40, 0x820f2088},
+{0x44, 0xc2002308},
+{0x48, 0x821e4001},
+{0x4c, 0x80a00001},
+{0x50, 0xba402000},
+{0x54, 0x821be001},
+{0x58, 0x80a00001},
+{0x5c, 0x82402000},
+{0x60, 0x808f4001},
+{0x64, 0x3280001a},
+{0x68, 0xb0102001},
+{0x6c, 0x820f2088},
+{0x70, 0x82186088},
+{0x74, 0x80a00001},
+{0x78, 0x82603fff},
+{0x7c, 0x8088401b},
+{0xf0, 0x60},
+{0x00, 0x02800007},
+{0x04, 0x820f20a0},
+{0x08, 0xc2002300},
+{0x0c, 0x80a3c001},
+{0x10, 0x3280000f},
+{0x14, 0xb0102001},
+{0x18, 0x820f20a0},
+{0x1c, 0x80a060a0},
+{0x20, 0x1280000b},
+{0x24, 0xb0102000},
+{0x28, 0xc2002308},
+{0x2c, 0x80a64001},
+{0x30, 0x02800007},
+{0x34, 0x01000000},
+{0x38, 0xc2002300},
+{0x3c, 0x80a3c001},
+{0x40, 0x12800003},
+{0x44, 0xb0102001},
+{0x48, 0xb0102000},
+{0x4c, 0x81c7e008},
+{0x50, 0x81e80000},
+{0x54, 0x9de3bf98},
+{0x58, 0x832e2003},
+{0x5c, 0x82204018},
+{0x60, 0xb2100018},
+{0x64, 0xbb286003},
+{0x68, 0x31000018},
+{0x6c, 0x82162224},
+{0x70, 0xb6102002},
+{0x74, 0xf40022fc},
+{0x78, 0xf8074001},
+{0x7c, 0x80a6c01a},
+{0xf0, 0x61},
+{0x00, 0x1880000f},
+{0x04, 0x9e102001},
+{0x08, 0x82162220},
+{0x0c, 0x82074001},
+{0x10, 0x82006008},
+{0x14, 0xfa004000},
+{0x18, 0x80a7401c},
+{0x1c, 0x16800004},
+{0x20, 0x82006004},
+{0x24, 0xb810001d},
+{0x28, 0x9e10001b},
+{0x2c, 0xb606e001},
+{0x30, 0x80a6c01a},
+{0x34, 0x28bffff9},
+{0x38, 0xfa004000},
+{0x3c, 0x80a72000},
+{0x40, 0x16800017},
+{0x44, 0xb0102000},
+{0x48, 0x832e6003},
+{0x4c, 0x82204019},
+{0x50, 0x82004001},
+{0x54, 0x39000018},
+{0x58, 0x8200400f},
+{0x5c, 0x83286002},
+{0x60, 0xba17221c},
+{0x64, 0xb6172220},
+{0x68, 0xfa00401d},
+{0x6c, 0xf600401b},
+{0x70, 0xb8172224},
+{0x74, 0xc200401c},
+{0x78, 0xba07401b},
+{0x7c, 0xba074001},
+{0xf0, 0x62},
+{0x00, 0xc200220c},
+{0x04, 0xba20001d},
+{0x08, 0xba5f4001},
+{0x0c, 0x833f601f},
+{0x10, 0x83306018},
+{0x14, 0xba074001},
+{0x18, 0xb13f6008},
+{0x1c, 0x81c7e008},
+{0x20, 0x81e80000},
+{0x24, 0x9de3bee8},
+{0x28, 0xa0102000},
+{0x2c, 0xc20022f8},
+{0x30, 0x80a40001},
+{0x34, 0x1a80000a},
+{0x38, 0xa2042001},
+{0x3c, 0x8207bff8},
+{0x40, 0xa12c2002},
+{0x44, 0xa0040001},
+{0x48, 0x7fffffc3},
+{0x4c, 0x90100011},
+{0x50, 0xd0243fa0},
+{0x54, 0x10bffff6},
+{0x58, 0xa0100011},
+{0x5c, 0xc0202514},
+{0x60, 0xb607bff8},
+{0x64, 0x8207bf48},
+{0x68, 0xa2102013},
+{0x6c, 0xc0204000},
+{0x70, 0xa2847fff},
+{0x74, 0x1cbffffe},
+{0x78, 0x82006004},
+{0x7c, 0xa2102000},
+{0xf0, 0x63},
+{0x00, 0x832c6002},
+{0x04, 0xa2046001},
+{0x08, 0x80a46009},
+{0x0c, 0x04bffffd},
+{0x10, 0xc0206768},
+{0x14, 0xa0102001},
+{0x18, 0xc20022f8},
+{0x1c, 0x80a40001},
+{0x20, 0x18800086},
+{0x24, 0xb810201c},
+{0x28, 0xba10200e},
+{0x2c, 0xae10200e},
+{0x30, 0xa2102001},
+{0x34, 0xc20022fc},
+{0x38, 0x80a44001},
+{0x3c, 0x18800078},
+{0x40, 0x03000044},
+{0x44, 0xac040001},
+{0x48, 0x9b2f2002},
+{0x4c, 0x992f6002},
+{0x50, 0x972de002},
+{0x54, 0x03000050},
+{0x58, 0xaa040001},
+{0x5c, 0xa8036004},
+{0x60, 0xa6032008},
+{0x64, 0xa402e004},
+{0x68, 0xc2002308},
+{0x6c, 0x80a44001},
+{0x70, 0x3880002f},
+{0x74, 0xc2002304},
+{0x78, 0xc2002300},
+{0x7c, 0x80a40001},
+{0xf0, 0x64},
+{0x00, 0x38800041},
+{0x04, 0xc200237c},
+{0x08, 0x90100011},
+{0x0c, 0x92100010},
+{0x10, 0x7ffffeb7},
+{0x14, 0x94102001},
+{0x18, 0x80a22000},
+{0x1c, 0x02800057},
+{0x20, 0x1b000040},
+{0x24, 0x1b000018},
+{0x28, 0x8213621c},
+{0x2c, 0x96136220},
+{0x30, 0xd8048001},
+{0x34, 0xd604800b},
+{0x38, 0x9a136224},
+{0x3c, 0x832c2002},
+{0x40, 0x9803000b},
+{0x44, 0xda04800d},
+{0x48, 0x8200401b},
+{0x4c, 0x9803000d},
+{0x50, 0xc2007f9c},
+{0x54, 0x80a30001},
+{0x58, 0x06800048},
+{0x5c, 0x1b000040},
+{0x60, 0x80a22000},
+{0x64, 0x3680000d},
+{0x68, 0xc2002514},
+{0x6c, 0x90100011},
+{0x70, 0x92100010},
+{0x74, 0x7ffffe9e},
+{0x78, 0x94102002},
+{0x7c, 0x80a22000},
+{0xf0, 0x65},
+{0x00, 0x0280003e},
+{0x04, 0x1b000040},
+{0x08, 0xc2002514},
+{0x0c, 0x9b286002},
+{0x10, 0x10800034},
+{0x14, 0xea236768},
+{0x18, 0x9b2c6010},
+{0x1c, 0x9a034010},
+{0x20, 0x99286002},
+{0x24, 0x1080002f},
+{0x28, 0xda232768},
+{0x2c, 0x80a06000},
+{0x30, 0x02800007},
+{0x34, 0x19000018},
+{0x38, 0xc2002300},
+{0x3c, 0x80a40001},
+{0x40, 0x0880002e},
+{0x44, 0x1b000040},
+{0x48, 0x19000018},
+{0x4c, 0x82132220},
+{0x50, 0xda04c001},
+{0x54, 0xc200251c},
+{0x58, 0x80a34001},
+{0x5c, 0x24800027},
+{0x60, 0x1b000040},
+{0x64, 0x821321e8},
+{0x68, 0xc204c001},
+{0x6c, 0x80a0400d},
+{0x70, 0x36800022},
+{0x74, 0x1b000040},
+{0x78, 0x82132258},
+{0x7c, 0x10800013},
+{0xf0, 0x66},
+{0x00, 0xc204c001},
+{0x04, 0x80a06000},
+{0x08, 0x1280001c},
+{0x0c, 0x1b000040},
+{0x10, 0x19000018},
+{0x14, 0x82132220},
+{0x18, 0xda050001},
+{0x1c, 0xc200251c},
+{0x20, 0x80a34001},
+{0x24, 0x24800015},
+{0x28, 0x1b000040},
+{0x2c, 0x8213221c},
+{0x30, 0xc2050001},
+{0x34, 0x80a0400d},
+{0x38, 0x36800010},
+{0x3c, 0x1b000040},
+{0x40, 0x82132224},
+{0x44, 0xc2050001},
+{0x48, 0x80a34001},
+{0x4c, 0x0680000b},
+{0x50, 0x1b000040},
+{0x54, 0xc2002514},
+{0x58, 0x9b286002},
+{0x5c, 0xec236768},
+{0x60, 0x82006001},
+{0x64, 0xc2202514},
+{0x68, 0xc2002514},
+{0x6c, 0x80a06009},
+{0x70, 0x18800012},
+{0x74, 0x1b000040},
+{0x78, 0xa2046001},
+{0x7c, 0xc20022fc},
+{0xf0, 0x67},
+{0x00, 0xac05800d},
+{0x04, 0x80a44001},
+{0x08, 0xa404a004},
+{0x0c, 0xa604e004},
+{0x10, 0xa8052004},
+{0x14, 0x08bfff95},
+{0x18, 0xaa05400d},
+{0x1c, 0xa0042001},
+{0x20, 0xc20022f8},
+{0x24, 0x80a40001},
+{0x28, 0xae05e00e},
+{0x2c, 0xba07600e},
+{0x30, 0x08bfff80},
+{0x34, 0xb807200e},
+{0x38, 0x81c7e008},
+{0x3c, 0x81e80000},
+{0x40, 0x80a22000},
+{0x44, 0x2280001d},
+{0x48, 0xc2002558},
+{0x4c, 0xd4002208},
+{0x50, 0x80a2a000},
+{0x54, 0x0280002f},
+{0x58, 0x01000000},
+{0x5c, 0xc2002514},
+{0x60, 0x80a06000},
+{0x64, 0x12800007},
+{0x68, 0xc2002558},
+{0x6c, 0x80a06000},
+{0x70, 0x02800028},
+{0x74, 0x82007fff},
+{0x78, 0x10800026},
+{0x7c, 0xc2202558},
+{0xf0, 0x68},
+{0x00, 0x80a06000},
+{0x04, 0x32800023},
+{0x08, 0xd4202558},
+{0x0c, 0x17200040},
+{0x10, 0x193fc200},
+{0x14, 0x8212e001},
+{0x18, 0xc2230000},
+{0x1c, 0xc200233c},
+{0x20, 0x83306002},
+{0x24, 0x9a132070},
+{0x28, 0xc2234000},
+{0x2c, 0xd6230000},
+{0x30, 0x10800018},
+{0x34, 0xd4202558},
+{0x38, 0x80a06000},
+{0x3c, 0x32800007},
+{0x40, 0xc2002514},
+{0x44, 0xc2002208},
+{0x48, 0x80a06000},
+{0x4c, 0x1280000e},
+{0x50, 0x033fc200},
+{0x54, 0xc2002514},
+{0x58, 0x80a06001},
+{0x5c, 0x08800006},
+{0x60, 0xd800233c},
+{0x64, 0x82007fff},
+{0x68, 0xda002204},
+{0x6c, 0x8258400d},
+{0x70, 0x98030001},
+{0x74, 0x033fc200},
+{0x78, 0x82106070},
+{0x7c, 0x10800005},
+{0xf0, 0x69},
+{0x00, 0xd8204000},
+{0x04, 0xda002234},
+{0x08, 0x82106070},
+{0x0c, 0xda204000},
+{0x10, 0x81c3e008},
+{0x14, 0x01000000},
+{0x18, 0x82220009},
+{0x1c, 0x9a58400a},
+{0x20, 0x833b601f},
+{0x24, 0x80a20009},
+{0x28, 0x83306019},
+{0x2c, 0x04800004},
+{0x30, 0x90102000},
+{0x34, 0x82034001},
+{0x38, 0x91386007},
+{0x3c, 0x81c3e008},
+{0x40, 0x01000000},
+{0x44, 0x9de3bf98},
+{0x48, 0xc2002308},
+{0x4c, 0x82006001},
+{0x50, 0xe60022fc},
+{0x54, 0x80a4c001},
+{0x58, 0x2a800019},
+{0x5c, 0xe80022f8},
+{0x60, 0x15000018},
+{0x64, 0xa8102001},
+{0x68, 0xc20022f8},
+{0x6c, 0x80a50001},
+{0x70, 0x1880000c},
+{0x74, 0x832ce002},
+{0x78, 0x9a006038},
+{0x7c, 0x9612a224},
+{0xf0, 0x6a},
+{0x00, 0x9812a220},
+{0x04, 0xc203400c},
+{0x08, 0xc223400b},
+{0x0c, 0xa8052001},
+{0x10, 0xc20022f8},
+{0x14, 0x80a50001},
+{0x18, 0x08bffffb},
+{0x1c, 0x9a036038},
+{0x20, 0xc2002308},
+{0x24, 0xa604ffff},
+{0x28, 0x82006001},
+{0x2c, 0x80a4c001},
+{0x30, 0x1abfffee},
+{0x34, 0xa8102001},
+{0x38, 0xe80022f8},
+{0x3c, 0x80a52000},
+{0x40, 0x0280002a},
+{0x44, 0x832d2003},
+{0x48, 0xaa204014},
+{0x4c, 0x27000018},
+{0x50, 0xa52d6003},
+{0x54, 0x8214e228},
+{0x58, 0xa214e224},
+{0x5c, 0xd2048001},
+{0x60, 0xd408228c},
+{0x64, 0x7fffffcd},
+{0x68, 0xd0048011},
+{0x6c, 0xac14e220},
+{0x70, 0xd0248016},
+{0x74, 0xc2002308},
+{0x78, 0xa0054015},
+{0x7c, 0xa0040001},
+{0xf0, 0x6b},
+{0x00, 0xa12c2002},
+{0x04, 0x8214e21c},
+{0x08, 0xd2040001},
+{0x0c, 0xd408228d},
+{0x10, 0x7fffffc2},
+{0x14, 0xd0040016},
+{0x18, 0xd0240011},
+{0x1c, 0xc2002300},
+{0x20, 0x80a50001},
+{0x24, 0x2880000f},
+{0x28, 0xa8853fff},
+{0x2c, 0xa214e258},
+{0x30, 0x98100016},
+{0x34, 0x9a100012},
+{0x38, 0xa6102000},
+{0x3c, 0xc203400c},
+{0x40, 0xc2234011},
+{0x44, 0xc2002308},
+{0x48, 0xa604e001},
+{0x4c, 0x82006001},
+{0x50, 0x80a4c001},
+{0x54, 0x08bffffa},
+{0x58, 0x9a036004},
+{0x5c, 0xa8853fff},
+{0x60, 0x12bfffdb},
+{0x64, 0xaa057ff9},
+{0x68, 0xa6102001},
+{0x6c, 0xc2002308},
+{0x70, 0x80a4c001},
+{0x74, 0x18800019},
+{0x78, 0x23000018},
+{0x7c, 0xa12ce002},
+{0xf0, 0x6c},
+{0x00, 0x82146290},
+{0x04, 0xa4146258},
+{0x08, 0xd2040001},
+{0x0c, 0xd408228e},
+{0x10, 0x7fffffa2},
+{0x14, 0xd0040012},
+{0x18, 0x9a146220},
+{0x1c, 0xd024000d},
+{0x20, 0xc2002300},
+{0x24, 0xa1286003},
+{0x28, 0xa0240001},
+{0x2c, 0xa0040010},
+{0x30, 0xa0040013},
+{0x34, 0xa12c2002},
+{0x38, 0xa21461e8},
+{0x3c, 0xd004000d},
+{0x40, 0xd2040011},
+{0x44, 0x7fffff95},
+{0x48, 0xd408228f},
+{0x4c, 0xd0240012},
+{0x50, 0x10bfffe7},
+{0x54, 0xa604e001},
+{0x58, 0x17000018},
+{0x5c, 0x9012e224},
+{0x60, 0x9212e258},
+{0x64, 0xda024000},
+{0x68, 0xc2020000},
+{0x6c, 0x8200400d},
+{0x70, 0x9412e220},
+{0x74, 0x83386001},
+{0x78, 0xc2228000},
+{0x7c, 0xd8002308},
+{0xf0, 0x6d},
+{0x00, 0x992b2002},
+{0x04, 0x9612e25c},
+{0x08, 0xda03000b},
+{0x0c, 0xc203000a},
+{0x10, 0x8200400d},
+{0x14, 0x83386001},
+{0x18, 0xc2230008},
+{0x1c, 0xc2002300},
+{0x20, 0x9b286003},
+{0x24, 0x9a234001},
+{0x28, 0x9b2b6003},
+{0x2c, 0xd803400a},
+{0x30, 0xc203400b},
+{0x34, 0x8200400c},
+{0x38, 0x83386001},
+{0x3c, 0xc2234009},
+{0x40, 0xda002300},
+{0x44, 0x832b6003},
+{0x48, 0x8220400d},
+{0x4c, 0xda002308},
+{0x50, 0x82004001},
+{0x54, 0x8200400d},
+{0x58, 0x83286002},
+{0x5c, 0xda004009},
+{0x60, 0xd8004008},
+{0x64, 0x9a03400c},
+{0x68, 0x9b3b6001},
+{0x6c, 0xda20400b},
+{0x70, 0x81c7e008},
+{0x74, 0x81e80000},
+{0x78, 0x80a2200d},
+{0x7c, 0x82402000},
+{0xf0, 0x6e},
+{0x00, 0x80a26018},
+{0x04, 0x90402000},
+{0x08, 0x81c3e008},
+{0x0c, 0x90084008},
+{0x10, 0x9de3bf98},
+{0x14, 0xa026001b},
+{0x18, 0xae06001b},
+{0x1c, 0xf427a04c},
+{0x20, 0x03000007},
+{0x24, 0xba1063fe},
+{0x28, 0x80a40017},
+{0x2c, 0xb8102000},
+{0x30, 0xaa102000},
+{0x34, 0xac102000},
+{0x38, 0x1480001f},
+{0x3c, 0xb4100010},
+{0x40, 0x832c2003},
+{0x44, 0x82204010},
+{0x48, 0xa6004001},
+{0x4c, 0xa226401b},
+{0x50, 0xa806401b},
+{0x54, 0x80a44014},
+{0x58, 0x34800014},
+{0x5c, 0xa0042001},
+{0x60, 0x82044013},
+{0x64, 0xa5286002},
+{0x68, 0x90100011},
+{0x6c, 0x7fffffe3},
+{0x70, 0x92100010},
+{0x74, 0x80a22000},
+{0x78, 0x02800008},
+{0x7c, 0xa2046001},
+{0xf0, 0x6f},
+{0x00, 0x03000018},
+{0x04, 0x82106220},
+{0x08, 0xc2048001},
+{0x0c, 0x80a0401d},
+{0x10, 0x26800002},
+{0x14, 0xba100001},
+{0x18, 0x80a44014},
+{0x1c, 0x04bffff3},
+{0x20, 0xa404a004},
+{0x24, 0xa0042001},
+{0x28, 0x80a40017},
+{0x2c, 0x04bfffe8},
+{0x30, 0xa604e00e},
+{0x34, 0xc2002250},
+{0x38, 0x80a74001},
+{0x3c, 0x26800002},
+{0x40, 0xba100001},
+{0x44, 0xb006001b},
+{0x48, 0x80a68018},
+{0x4c, 0x14800029},
+{0x50, 0xa010001a},
+{0x54, 0x832ea003},
+{0x58, 0x8220401a},
+{0x5c, 0xa6004001},
+{0x60, 0xa226401b},
+{0x64, 0xa806401b},
+{0x68, 0x80a44014},
+{0x6c, 0x1480001a},
+{0x70, 0x82044013},
+{0x74, 0xa5286002},
+{0x78, 0x90100011},
+{0x7c, 0x7fffffbf},
+{0xf0, 0x70},
+{0x00, 0x92100010},
+{0x04, 0x80a22000},
+{0x08, 0x22800010},
+{0x0c, 0xa2046001},
+{0x10, 0x03000018},
+{0x14, 0x82106220},
+{0x18, 0xc2048001},
+{0x1c, 0x8220401d},
+{0x20, 0x9a046001},
+{0x24, 0x98042001},
+{0x28, 0x9658400d},
+{0x2c, 0x80a06000},
+{0x30, 0x04800005},
+{0x34, 0x9a58400c},
+{0x38, 0xaa05400d},
+{0x3c, 0xac05800b},
+{0x40, 0xb8070001},
+{0x44, 0xa2046001},
+{0x48, 0x80a44014},
+{0x4c, 0x04bfffeb},
+{0x50, 0xa404a004},
+{0x54, 0xa0042001},
+{0x58, 0x80a40018},
+{0x5c, 0x04bfffe1},
+{0x60, 0xa604e00e},
+{0x64, 0x80a72000},
+{0x68, 0x14800006},
+{0x6c, 0x9b2d6006},
+{0x70, 0xd807a04c},
+{0x74, 0x832b2002},
+{0x78, 0x1080001d},
+{0x7c, 0xc0206768},
+{0xf0, 0x71},
+{0x00, 0x833b601f},
+{0x04, 0x81806000},
+{0x08, 0x01000000},
+{0x0c, 0x01000000},
+{0x10, 0x01000000},
+{0x14, 0x9a7b401c},
+{0x18, 0x832da006},
+{0x1c, 0x9938601f},
+{0x20, 0x81832000},
+{0x24, 0x01000000},
+{0x28, 0x01000000},
+{0x2c, 0x01000000},
+{0x30, 0x8278401c},
+{0x34, 0xaa037fa0},
+{0x38, 0x80a56000},
+{0x3c, 0x14800003},
+{0x40, 0xac007fa0},
+{0x44, 0xaa102001},
+{0x48, 0x80a5a000},
+{0x4c, 0x24800002},
+{0x50, 0xac102001},
+{0x54, 0x9a0dafff},
+{0x58, 0x832d6010},
+{0x5c, 0x8210400d},
+{0x60, 0xd807a04c},
+{0x64, 0x9b2b2002},
+{0x68, 0xc2236768},
+{0x6c, 0x81c7e008},
+{0x70, 0x81e80000},
+{0x74, 0x9de3bf98},
+{0x78, 0x03000018},
+{0x7c, 0xb6106254},
+{0xf0, 0x72},
+{0x00, 0xb810625c},
+{0x04, 0x96106258},
+{0x08, 0xc2002274},
+{0x0c, 0x80a06000},
+{0x10, 0x832e2003},
+{0x14, 0x82204018},
+{0x18, 0x82004001},
+{0x1c, 0x82004019},
+{0x20, 0xb12e2006},
+{0x24, 0xbb2e6006},
+{0x28, 0xb5286002},
+{0x2c, 0xb0063fe0},
+{0x30, 0x9a066001},
+{0x34, 0x98066002},
+{0x38, 0x9f2e2010},
+{0x3c, 0x02800020},
+{0x40, 0x82077fe0},
+{0x44, 0xfa06801b},
+{0x48, 0xf806801c},
+{0x4c, 0xf406800b},
+{0x50, 0x8207401a},
+{0x54, 0xb610001d},
+{0x58, 0x80a7401c},
+{0x5c, 0x04800003},
+{0x60, 0xb000401c},
+{0x64, 0xb610001c},
+{0x68, 0x8227401b},
+{0x6c, 0xba26801b},
+{0x70, 0xba5f400d},
+{0x74, 0x82584019},
+{0x78, 0x8200401d},
+{0x7c, 0xb827001b},
+{0xf0, 0x73},
+{0x00, 0xb85f000c},
+{0x04, 0xba06c01b},
+{0x08, 0x8200401c},
+{0x0c, 0xba07401b},
+{0x10, 0xba26001d},
+{0x14, 0x83286006},
+{0x18, 0x9b38601f},
+{0x1c, 0x81836000},
+{0x20, 0x01000000},
+{0x24, 0x01000000},
+{0x28, 0x01000000},
+{0x2c, 0x8278401d},
+{0x30, 0x82807fa0},
+{0x34, 0x2c800002},
+{0x38, 0x82102000},
+{0x3c, 0xb003c001},
+{0x40, 0xb0263000},
+{0x44, 0x81c7e008},
+{0x48, 0x81e80000},
+{0x4c, 0x9de3bf98},
+{0x50, 0xa2102000},
+{0x54, 0xc2002514},
+{0x58, 0x80a44001},
+{0x5c, 0x1a800029},
+{0x60, 0xa12c6002},
+{0x64, 0xda042768},
+{0x68, 0x93336010},
+{0x6c, 0x8333600c},
+{0x70, 0x900b6fff},
+{0x74, 0x80886001},
+{0x78, 0x02800006},
+{0x7c, 0x920a6fff},
+{0xf0, 0x74},
+{0x00, 0x7fffffbd},
+{0x04, 0xa2046001},
+{0x08, 0x1080001a},
+{0x0c, 0xd0242768},
+{0x10, 0x80a36000},
+{0x14, 0x22800017},
+{0x18, 0xa2046001},
+{0x1c, 0x93336010},
+{0x20, 0xc200246c},
+{0x24, 0x98100009},
+{0x28, 0x9f33600e},
+{0x2c, 0x80a06000},
+{0x30, 0x900b6fff},
+{0x34, 0x920a6fff},
+{0x38, 0x0280000c},
+{0x3c, 0x94100011},
+{0x40, 0x808be001},
+{0x44, 0x12800005},
+{0x48, 0x96102002},
+{0x4c, 0x920b2fff},
+{0x50, 0x94100011},
+{0x54, 0x96102001},
+{0x58, 0x7fffff2e},
+{0x5c, 0xa2046001},
+{0x60, 0x10800005},
+{0x64, 0xc2002514},
+{0x68, 0x7ffff99f},
+{0x6c, 0xa2046001},
+{0x70, 0xc2002514},
+{0x74, 0x80a44001},
+{0x78, 0x0abfffdb},
+{0x7c, 0xa12c6002},
+{0xf0, 0x75},
+{0x00, 0x81c7e008},
+{0x04, 0x81e80000},
+{0x08, 0x9de3bf98},
+{0x0c, 0x9e102000},
+{0x10, 0x832be002},
+{0x14, 0xfa006768},
+{0x18, 0x80a76000},
+{0x1c, 0x2280002e},
+{0x20, 0x9e03e001},
+{0x24, 0x83376010},
+{0x28, 0xba0f6fff},
+{0x2c, 0x82086fff},
+{0x30, 0xb403e001},
+{0x34, 0x98076020},
+{0x38, 0x96006020},
+{0x3c, 0x80a6a009},
+{0x40, 0x9a007fe0},
+{0x44, 0xba077fe0},
+{0x48, 0x18800022},
+{0x4c, 0x832ea002},
+{0x50, 0xf8006768},
+{0x54, 0x80a72000},
+{0x58, 0x2280001c},
+{0x5c, 0xb406a001},
+{0x60, 0xb7372010},
+{0x64, 0xb60eefff},
+{0x68, 0xb20f2fff},
+{0x6c, 0x80a6c00d},
+{0x70, 0x14800003},
+{0x74, 0xb0102001},
+{0x78, 0xb0102000},
+{0x7c, 0x80a6c00b},
+{0xf0, 0x76},
+{0x00, 0x06800003},
+{0x04, 0xb8102001},
+{0x08, 0xb8102000},
+{0x0c, 0x808e001c},
+{0x10, 0x2280000e},
+{0x14, 0xb406a001},
+{0x18, 0x80a6401d},
+{0x1c, 0x14800003},
+{0x20, 0xb6102001},
+{0x24, 0xb6102000},
+{0x28, 0x80a6400c},
+{0x2c, 0x06800003},
+{0x30, 0xb8102001},
+{0x34, 0xb8102000},
+{0x38, 0x808ec01c},
+{0x3c, 0x32800002},
+{0x40, 0xc0206768},
+{0x44, 0xb406a001},
+{0x48, 0x10bfffe0},
+{0x4c, 0x80a6a009},
+{0x50, 0x9e03e001},
+{0x54, 0x80a3e009},
+{0x58, 0x08bfffcf},
+{0x5c, 0x832be002},
+{0x60, 0x81c7e008},
+{0x64, 0x81e80000},
+{0x68, 0xc2002510},
+{0x6c, 0x82006001},
+{0x70, 0x80a06008},
+{0x74, 0x08800003},
+{0x78, 0xc2202510},
+{0x7c, 0xc0202510},
+{0xf0, 0x77},
+{0x00, 0xd8002510},
+{0x04, 0x96102000},
+{0x08, 0x832b2002},
+{0x0c, 0x8200400c},
+{0x10, 0x83286003},
+{0x14, 0x82006600},
+{0x18, 0x9b2ae002},
+{0x1c, 0x80a32000},
+{0x20, 0xc2236790},
+{0x24, 0x12800003},
+{0x28, 0x98033fff},
+{0x2c, 0x98102008},
+{0x30, 0x9602e001},
+{0x34, 0x80a2e008},
+{0x38, 0x04bffff5},
+{0x3c, 0x832b2002},
+{0x40, 0x0303ffc7},
+{0x44, 0x921063ff},
+{0x48, 0x98102000},
+{0x4c, 0x96102000},
+{0x50, 0x9b2ae002},
+{0x54, 0xc2036768},
+{0x58, 0x82084009},
+{0x5c, 0x9602e001},
+{0x60, 0x952b2002},
+{0x64, 0x80a06000},
+{0x68, 0x02800004},
+{0x6c, 0xc2236768},
+{0x70, 0x98032001},
+{0x74, 0xc222a768},
+{0x78, 0x80a2e009},
+{0x7c, 0x24bffff6},
+{0xf0, 0x78},
+{0x00, 0x9b2ae002},
+{0x04, 0x9610000c},
+{0x08, 0x80a32009},
+{0x0c, 0x14800007},
+{0x10, 0xd8202514},
+{0x14, 0x832ae002},
+{0x18, 0x9602e001},
+{0x1c, 0x80a2e009},
+{0x20, 0x04bffffd},
+{0x24, 0xc0206768},
+{0x28, 0x81c3e008},
+{0x2c, 0x01000000},
+{0x30, 0x9de3bf98},
+{0x34, 0xc20022f4},
+{0x38, 0x80a06000},
+{0x3c, 0x02800049},
+{0x40, 0xb0102000},
+{0x44, 0xc2002514},
+{0x48, 0x80a60001},
+{0x4c, 0x1a800045},
+{0x50, 0x033c003f},
+{0x54, 0x9e1063ff},
+{0x58, 0xb52e2002},
+{0x5c, 0xfa06a768},
+{0x60, 0x8337600c},
+{0x64, 0x80886001},
+{0x68, 0x3280003a},
+{0x6c, 0xb0062001},
+{0x70, 0xb9376010},
+{0x74, 0xb80f2fff},
+{0x78, 0x80a7201f},
+{0x7c, 0x2880001a},
+{0xf0, 0x79},
+{0x00, 0xfa06a768},
+{0x04, 0xc2002300},
+{0x08, 0x83286006},
+{0x0c, 0x82007fe0},
+{0x10, 0x80a70001},
+{0x14, 0x38800014},
+{0x18, 0xfa06a768},
+{0x1c, 0x808f2020},
+{0x20, 0x02800008},
+{0x24, 0xb60f3fe0},
+{0x28, 0x8238001c},
+{0x2c, 0x8208601f},
+{0x30, 0xc20862d4},
+{0x34, 0x8226c001},
+{0x38, 0x10800005},
+{0x3c, 0x8200601f},
+{0x40, 0x820f201f},
+{0x44, 0xc20862d4},
+{0x48, 0x8206c001},
+{0x4c, 0x82086fff},
+{0x50, 0x83286010},
+{0x54, 0xba0f400f},
+{0x58, 0xba174001},
+{0x5c, 0xfa26a768},
+{0x60, 0xfa06a768},
+{0x64, 0xb80f6fff},
+{0x68, 0x80a7201f},
+{0x6c, 0x28800019},
+{0x70, 0xb0062001},
+{0x74, 0xc2002308},
+{0x78, 0x83286006},
+{0x7c, 0x82007fe0},
+{0xf0, 0x7a},
+{0x00, 0x80a70001},
+{0x04, 0x38800013},
+{0x08, 0xb0062001},
+{0x0c, 0x808f6020},
+{0x10, 0xb60f6fe0},
+{0x14, 0x02800008},
+{0x18, 0xb20f7000},
+{0x1c, 0x8238001c},
+{0x20, 0x8208601f},
+{0x24, 0xc2086254},
+{0x28, 0x8226c001},
+{0x2c, 0x10800005},
+{0x30, 0x8200601f},
+{0x34, 0x820f601f},
+{0x38, 0xc2086254},
+{0x3c, 0x8206c001},
+{0x40, 0x82086fff},
+{0x44, 0x82164001},
+{0x48, 0xc226a768},
+{0x4c, 0xb0062001},
+{0x50, 0xc2002514},
+{0x54, 0x80a60001},
+{0x58, 0x0abfffc1},
+{0x5c, 0xb52e2002},
+{0x60, 0x81c7e008},
+{0x64, 0x81e80000},
+{0x68, 0x912a2002},
+{0x6c, 0xc2002794},
+{0x70, 0xda004008},
+{0x74, 0x033c003c},
+{0x78, 0x822b4001},
+{0x7c, 0x98102790},
+{0xf0, 0x7b},
+{0x00, 0xda030000},
+{0x04, 0xc2234008},
+{0x08, 0xd8030000},
+{0x0c, 0xda030008},
+{0x10, 0x03000020},
+{0x14, 0x822b4001},
+{0x18, 0x81c3e008},
+{0x1c, 0xc2230008},
+{0x20, 0x912a2002},
+{0x24, 0xc2002790},
+{0x28, 0xc0204008},
+{0x2c, 0xc2002794},
+{0x30, 0xc2104008},
+{0x34, 0xda002798},
+{0x38, 0xda134008},
+{0x3c, 0x82086fff},
+{0x40, 0x94004001},
+{0x44, 0x9a0b6fff},
+{0x48, 0x80a2800d},
+{0x4c, 0x18800003},
+{0x50, 0x9422800d},
+{0x54, 0x94102000},
+{0x58, 0xd6002790},
+{0x5c, 0x9a0aafff},
+{0x60, 0xd802c008},
+{0x64, 0x0303ffc0},
+{0x68, 0x9b2b6010},
+{0x6c, 0x822b0001},
+{0x70, 0x8210400d},
+{0x74, 0xc222c008},
+{0x78, 0xc2002794},
+{0x7c, 0xc2004008},
+{0xf0, 0x7c},
+{0x00, 0xda002798},
+{0x04, 0xda034008},
+{0x08, 0x82086fff},
+{0x0c, 0x94004001},
+{0x10, 0x9a0b6fff},
+{0x14, 0x80a2800d},
+{0x18, 0x18800003},
+{0x1c, 0x9422800d},
+{0x20, 0x94102000},
+{0x24, 0xd8002790},
+{0x28, 0xc2030008},
+{0x2c, 0x9a0aafff},
+{0x30, 0x82087000},
+{0x34, 0x8210400d},
+{0x38, 0xc2230008},
+{0x3c, 0xd8002790},
+{0x40, 0xc2030008},
+{0x44, 0x1b000020},
+{0x48, 0x8210400d},
+{0x4c, 0x81c3e008},
+{0x50, 0xc2230008},
+{0x54, 0x912a2002},
+{0x58, 0xc2002790},
+{0x5c, 0xc0204008},
+{0x60, 0xc2002794},
+{0x64, 0xda104008},
+{0x68, 0xc200279c},
+{0x6c, 0xd6104008},
+{0x70, 0xc2002798},
+{0x74, 0x9a0b6fff},
+{0x78, 0xd8104008},
+{0x7c, 0x832b6002},
+{0xf0, 0x7d},
+{0x00, 0x8200400d},
+{0x04, 0x960aefff},
+{0x08, 0x980b2fff},
+{0x0c, 0x8200400b},
+{0x10, 0x992b2002},
+{0x14, 0x80a0400c},
+{0x18, 0x18800003},
+{0x1c, 0x8220400c},
+{0x20, 0x82102000},
+{0x24, 0xd6002790},
+{0x28, 0x9b306001},
+{0x2c, 0xd802c008},
+{0x30, 0x9a0b6fff},
+{0x34, 0x0303ffc0},
+{0x38, 0x822b0001},
+{0x3c, 0x9b2b6010},
+{0x40, 0x8210400d},
+{0x44, 0xc222c008},
+{0x48, 0xc2002794},
+{0x4c, 0xda004008},
+{0x50, 0xc200279c},
+{0x54, 0xd6004008},
+{0x58, 0xc2002798},
+{0x5c, 0x9a0b6fff},
+{0x60, 0xd8004008},
+{0x64, 0x832b6002},
+{0x68, 0x8200400d},
+{0x6c, 0x960aefff},
+{0x70, 0x980b2fff},
+{0x74, 0x8200400b},
+{0x78, 0x992b2002},
+{0x7c, 0x80a0400c},
+{0xf0, 0x7e},
+{0x00, 0x18800003},
+{0x04, 0x8220400c},
+{0x08, 0x82102000},
+{0x0c, 0xd8002790},
+{0x10, 0x9b306001},
+{0x14, 0xc2030008},
+{0x18, 0x9a0b6fff},
+{0x1c, 0x82087000},
+{0x20, 0x8210400d},
+{0x24, 0xc2230008},
+{0x28, 0xd8002790},
+{0x2c, 0xc2030008},
+{0x30, 0x1b000020},
+{0x34, 0x8210400d},
+{0x38, 0x81c3e008},
+{0x3c, 0xc2230008},
+{0x40, 0x9de3bf98},
+{0x44, 0xa2102000},
+{0x48, 0xa12c6002},
+{0x4c, 0xc2002794},
+{0x50, 0xc2004010},
+{0x54, 0x80a06000},
+{0x58, 0x0280001f},
+{0x5c, 0x0303ffc3},
+{0x60, 0xc2002798},
+{0x64, 0xc2004010},
+{0x68, 0x80a06000},
+{0x6c, 0x0280000c},
+{0x70, 0x01000000},
+{0x74, 0x8330600d},
+{0x78, 0x80886001},
+{0x7c, 0x12800008},
+{0xf0, 0x7f},
+{0x00, 0x01000000},
+{0x04, 0xc200279c},
+{0x08, 0xda004010},
+{0x0c, 0x8333600d},
+{0x10, 0x80886001},
+{0x14, 0x02800006},
+{0x18, 0x80a36000},
+{0x1c, 0x7fffff73},
+{0x20, 0x90100011},
+{0x24, 0x10800010},
+{0x28, 0xc2002794},
+{0x2c, 0x02800006},
+{0x30, 0x01000000},
+{0x34, 0x7fffffa8},
+{0x38, 0x90100011},
+{0x3c, 0x1080000a},
+{0x40, 0xc2002794},
+{0x44, 0x7fffff77},
+{0x48, 0x90100011},
+{0x4c, 0x10800006},
+{0x50, 0xc2002794},
+{0x54, 0x821063ff},
+{0x58, 0xda002790},
+{0x5c, 0xc2234010},
+{0x60, 0xc2002794},
+{0x64, 0xc2004010},
+{0x68, 0x8330600c},
+{0x6c, 0x80886001},
+{0x70, 0x02800007},
+{0x74, 0xa2046001},
+{0x78, 0xc2002790},
+{0x7c, 0xda004010},
+{0xf0, 0x80},
+{0x00, 0x19000004},
+{0x04, 0x9a13400c},
+{0x08, 0xda204010},
+{0x0c, 0x80a46009},
+{0x10, 0x04bfffcf},
+{0x14, 0xa12c6002},
+{0x18, 0x81c7e008},
+{0x1c, 0x81e80000},
+{0x20, 0xd6020000},
+{0x24, 0xd8024000},
+{0x28, 0x9132e010},
+{0x2c, 0x95332010},
+{0x30, 0x900a2fff},
+{0x34, 0x940aafff},
+{0x38, 0x03000007},
+{0x3c, 0x9a22000a},
+{0x40, 0x821063ff},
+{0x44, 0x940b0001},
+{0x48, 0x900ac001},
+{0x4c, 0x9022000a},
+{0x50, 0x9a5b400d},
+{0x54, 0x905a0008},
+{0x58, 0x81c3e008},
+{0x5c, 0x90034008},
+{0x60, 0x031fffff},
+{0x64, 0x9002200c},
+{0x68, 0x821063ff},
+{0x6c, 0x9a102063},
+{0x70, 0xc2220000},
+{0x74, 0x9a837fff},
+{0x78, 0x1cbffffe},
+{0x7c, 0x90022004},
+{0xf0, 0x81},
+{0x00, 0x81c3e008},
+{0x04, 0x01000000},
+{0x08, 0x031fffff},
+{0x0c, 0x821063ff},
+{0x10, 0xc2222008},
+{0x14, 0x92102000},
+{0x18, 0x96100008},
+{0x1c, 0x94102000},
+{0x20, 0x9a02e00c},
+{0x24, 0xd8034000},
+{0x28, 0xc2022008},
+{0x2c, 0x80a30001},
+{0x30, 0x16800005},
+{0x34, 0x9a036004},
+{0x38, 0xd8222008},
+{0x3c, 0xd4220000},
+{0x40, 0xd2222004},
+{0x44, 0x9402a001},
+{0x48, 0x80a2a009},
+{0x4c, 0x24bffff7},
+{0x50, 0xd8034000},
+{0x54, 0x92026001},
+{0x58, 0x80a26009},
+{0x5c, 0x04bffff0},
+{0x60, 0x9602e028},
+{0x64, 0xda022008},
+{0x68, 0x03200000},
+{0x6c, 0x8238400d},
+{0x70, 0x80a00001},
+{0x74, 0x81c3e008},
+{0x78, 0x90402000},
+{0x7c, 0xc2022004},
+{0xf0, 0x82},
+{0x00, 0x9b286002},
+{0x04, 0x9a034001},
+{0x08, 0x031fffff},
+{0x0c, 0x9b2b6003},
+{0x10, 0x9a034008},
+{0x14, 0x981063ff},
+{0x18, 0x9a03600c},
+{0x1c, 0x82102009},
+{0x20, 0xd8234000},
+{0x24, 0x82807fff},
+{0x28, 0x1cbffffe},
+{0x2c, 0x9a036004},
+{0x30, 0xc2020000},
+{0x34, 0x83286002},
+{0x38, 0x82004008},
+{0x3c, 0x8200600c},
+{0x40, 0x9a102009},
+{0x44, 0xd8204000},
+{0x48, 0x9a837fff},
+{0x4c, 0x1cbffffe},
+{0x50, 0x82006028},
+{0x54, 0x81c3e008},
+{0x58, 0x01000000},
+{0x5c, 0x98100008},
+{0x60, 0x90102008},
+{0x64, 0x9a102100},
+{0x68, 0x832b4008},
+{0x6c, 0x80a30001},
+{0x70, 0x14800006},
+{0x74, 0x01000000},
+{0x78, 0x90023fff},
+{0x7c, 0x80a22000},
+{0xf0, 0x83},
+{0x00, 0x14bffffb},
+{0x04, 0x832b4008},
+{0x08, 0x81c3e008},
+{0x0c, 0x01000000},
+{0x10, 0x9de3bdd0},
+{0x14, 0xae07be58},
+{0x18, 0x7fffffb2},
+{0x1c, 0x90100017},
+{0x20, 0xa6102000},
+{0x24, 0xa12ce002},
+{0x28, 0xd2002790},
+{0x2c, 0xc2024010},
+{0x30, 0x8330600f},
+{0x34, 0x80886001},
+{0x38, 0x2280000f},
+{0x3c, 0xd000245c},
+{0x40, 0xc2002794},
+{0x44, 0x90004010},
+{0x48, 0xc2004010},
+{0x4c, 0x8330600d},
+{0x50, 0x80886001},
+{0x54, 0x02800004},
+{0x58, 0x92024010},
+{0x5c, 0x10800006},
+{0x60, 0xd000245c},
+{0x64, 0x7fffff8f},
+{0x68, 0x01000000},
+{0x6c, 0x7fffffdc},
+{0x70, 0x01000000},
+{0x74, 0xc2002358},
+{0x78, 0x9807bff8},
+{0x7c, 0x825a0001},
+{0xf0, 0x84},
+{0x00, 0x9a04000c},
+{0x04, 0xa604e001},
+{0x08, 0x80a4e009},
+{0x0c, 0x04bfffe6},
+{0x10, 0xc2237e38},
+{0x14, 0xac10000c},
+{0x18, 0xa6102000},
+{0x1c, 0xa8102000},
+{0x20, 0xea002790},
+{0x24, 0x0303ffc3},
+{0x28, 0xda054014},
+{0x2c, 0x821063ff},
+{0x30, 0x80a34001},
+{0x34, 0x22800014},
+{0x38, 0xa604e001},
+{0x3c, 0xa2102000},
+{0x40, 0xc2002514},
+{0x44, 0x80a44001},
+{0x48, 0x3a80000f},
+{0x4c, 0xa604e001},
+{0x50, 0xa005be6c},
+{0x54, 0xa4102768},
+{0x58, 0x90100012},
+{0x5c, 0x7fffff71},
+{0x60, 0x92054014},
+{0x64, 0xd0240000},
+{0x68, 0xa2046001},
+{0x6c, 0xc2002514},
+{0x70, 0x80a44001},
+{0x74, 0xa404a004},
+{0x78, 0x0abffff8},
+{0x7c, 0xa0042028},
+{0xf0, 0x85},
+{0x00, 0xa604e001},
+{0x04, 0xa8052004},
+{0x08, 0x80a4e009},
+{0x0c, 0x04bfffe5},
+{0x10, 0xac05a004},
+{0x14, 0xa2102000},
+{0x18, 0xc2002514},
+{0x1c, 0x80a44001},
+{0x20, 0x1a80002d},
+{0x24, 0x01000000},
+{0x28, 0x7fffff78},
+{0x2c, 0x90100017},
+{0x30, 0x80a22000},
+{0x34, 0xa0046001},
+{0x38, 0x02800027},
+{0x3c, 0x90100017},
+{0x40, 0xd807be58},
+{0x44, 0x832b2002},
+{0x48, 0x8200401e},
+{0x4c, 0xc2007e30},
+{0x50, 0xda002230},
+{0x54, 0x9a034001},
+{0x58, 0xc2002548},
+{0x5c, 0x9a5b4001},
+{0x60, 0xc2002334},
+{0x64, 0x82006001},
+{0x68, 0x81800000},
+{0x6c, 0x01000000},
+{0x70, 0x01000000},
+{0x74, 0x01000000},
+{0x78, 0x9a734001},
+{0x7c, 0xc207be60},
+{0xf0, 0x86},
+{0x00, 0x80a0400d},
+{0x04, 0x98032001},
+{0x08, 0xc207be5c},
+{0x0c, 0x992b201c},
+{0x10, 0x0a800007},
+{0x14, 0x95286002},
+{0x18, 0xc202a768},
+{0x1c, 0x1b3c0000},
+{0x20, 0x8210400d},
+{0x24, 0x10800008},
+{0x28, 0xc222a768},
+{0x2c, 0xda02a768},
+{0x30, 0x033c0000},
+{0x34, 0x822b4001},
+{0x38, 0x8210400c},
+{0x3c, 0x7fffff70},
+{0x40, 0xc222a768},
+{0x44, 0xc2002514},
+{0x48, 0x80a40001},
+{0x4c, 0x0abfffd7},
+{0x50, 0xa2100010},
+{0x54, 0x81c7e008},
+{0x58, 0x81e80000},
+{0x5c, 0x92102000},
+{0x60, 0xc2002514},
+{0x64, 0x80a24001},
+{0x68, 0x1a800037},
+{0x6c, 0x0303ffff},
+{0x70, 0x901063ff},
+{0x74, 0x952a6002},
+{0x78, 0xc202a768},
+{0x7c, 0x8330601c},
+{0xf0, 0x87},
+{0x00, 0x80a00001},
+{0x04, 0x9a603fff},
+{0x08, 0x8218600f},
+{0x0c, 0x80a00001},
+{0x10, 0x82603fff},
+{0x14, 0x80934001},
+{0x18, 0x22800027},
+{0x1c, 0x92026001},
+{0x20, 0x9a102001},
+{0x24, 0x96102000},
+{0x28, 0x992ae002},
+{0x2c, 0xc2032768},
+{0x30, 0x8330601c},
+{0x34, 0x80a0400d},
+{0x38, 0x02800013},
+{0x3c, 0x80a2e00a},
+{0x40, 0xc2002794},
+{0x44, 0xc200400c},
+{0x48, 0x8330601c},
+{0x4c, 0x80a0400d},
+{0x50, 0x0280000d},
+{0x54, 0x80a2e00a},
+{0x58, 0xc2002798},
+{0x5c, 0xc200400c},
+{0x60, 0x8330601c},
+{0x64, 0x80a0400d},
+{0x68, 0x02800007},
+{0x6c, 0x80a2e00a},
+{0x70, 0x9602e001},
+{0x74, 0x80a2e009},
+{0x78, 0x08bfffed},
+{0x7c, 0x992ae002},
+{0xf0, 0x88},
+{0x00, 0x80a2e00a},
+{0x04, 0x22800007},
+{0x08, 0xc202a768},
+{0x0c, 0x9a036001},
+{0x10, 0x80a3600a},
+{0x14, 0x08bfffe5},
+{0x18, 0x96102000},
+{0x1c, 0xc202a768},
+{0x20, 0x9b2b601c},
+{0x24, 0x82084008},
+{0x28, 0x8210400d},
+{0x2c, 0xc222a768},
+{0x30, 0x92026001},
+{0x34, 0xc2002514},
+{0x38, 0x80a24001},
+{0x3c, 0x0abfffcf},
+{0x40, 0x952a6002},
+{0x44, 0x81c3e008},
+{0x48, 0x01000000},
+{0x4c, 0x98102000},
+{0x50, 0x9b2b2002},
+{0x54, 0x98032001},
+{0x58, 0xc2002790},
+{0x5c, 0x80a32009},
+{0x60, 0x08bffffc},
+{0x64, 0xc020400d},
+{0x68, 0x98102000},
+{0x6c, 0xc2002514},
+{0x70, 0x80a30001},
+{0x74, 0x1a800012},
+{0x78, 0x033fffc7},
+{0x7c, 0x941063ff},
+{0xf0, 0x89},
+{0x00, 0x832b2002},
+{0x04, 0xda006768},
+{0x08, 0x8333601c},
+{0x0c, 0x82007fff},
+{0x10, 0x98032001},
+{0x14, 0x80a06009},
+{0x18, 0x97286002},
+{0x1c, 0x18800004},
+{0x20, 0x9a0b400a},
+{0x24, 0xc2002790},
+{0x28, 0xda20400b},
+{0x2c, 0xc2002514},
+{0x30, 0x80a30001},
+{0x34, 0x0abffff4},
+{0x38, 0x832b2002},
+{0x3c, 0x81c3e008},
+{0x40, 0x01000000},
+{0x44, 0x9de3bf98},
+{0x48, 0x92102000},
+{0x4c, 0x94026001},
+{0x50, 0x80a2a009},
+{0x54, 0x18800068},
+{0x58, 0x9610000a},
+{0x5c, 0x033c003f},
+{0x60, 0x901063ff},
+{0x64, 0xf6002790},
+{0x68, 0xb32ae002},
+{0x6c, 0xfa06c019},
+{0x70, 0x80a76000},
+{0x74, 0x2280005c},
+{0x78, 0x9602e001},
+{0x7c, 0xb52a6002},
+{0xf0, 0x8a},
+{0x00, 0xc206c01a},
+{0x04, 0x80a06000},
+{0x08, 0x22800057},
+{0x0c, 0x9602e001},
+{0x10, 0xda002794},
+{0x14, 0xf0034019},
+{0x18, 0x80a62000},
+{0x1c, 0x22800052},
+{0x20, 0x9602e001},
+{0x24, 0xf803401a},
+{0x28, 0x80a72000},
+{0x2c, 0x2280004e},
+{0x30, 0x9602e001},
+{0x34, 0x83306010},
+{0x38, 0xbb376010},
+{0x3c, 0x98086fff},
+{0x40, 0x9e0f6fff},
+{0x44, 0x80a3000f},
+{0x48, 0x16800009},
+{0x4c, 0xbb372010},
+{0x50, 0x83362010},
+{0x54, 0xba0f6fff},
+{0x58, 0x82086fff},
+{0x5c, 0x80a74001},
+{0x60, 0x3480000d},
+{0x64, 0xc206c01a},
+{0x68, 0x80a3000f},
+{0x6c, 0x2480003e},
+{0x70, 0x9602e001},
+{0x74, 0xbb372010},
+{0x78, 0x83362010},
+{0x7c, 0xba0f6fff},
+{0xf0, 0x8b},
+{0x00, 0x82086fff},
+{0x04, 0x80a74001},
+{0x08, 0x36800037},
+{0x0c, 0x9602e001},
+{0x10, 0xc206c01a},
+{0x14, 0xfa06c019},
+{0x18, 0xb0086fff},
+{0x1c, 0xb80f6fff},
+{0x20, 0x80a6001c},
+{0x24, 0x1680000a},
+{0x28, 0x01000000},
+{0x2c, 0xfa034019},
+{0x30, 0xc203401a},
+{0x34, 0x82086fff},
+{0x38, 0xba0f6fff},
+{0x3c, 0x80a0401d},
+{0x40, 0x3480000e},
+{0x44, 0xfa16c01a},
+{0x48, 0x80a6001c},
+{0x4c, 0x24800026},
+{0x50, 0x9602e001},
+{0x54, 0xc2002794},
+{0x58, 0xfa004019},
+{0x5c, 0xc200401a},
+{0x60, 0x82086fff},
+{0x64, 0xba0f6fff},
+{0x68, 0x80a0401d},
+{0x6c, 0x3680001e},
+{0x70, 0x9602e001},
+{0x74, 0xfa16c01a},
+{0x78, 0xf806c019},
+{0x7c, 0xba0f6fff},
+{0xf0, 0x8c},
+{0x00, 0xbb2f6010},
+{0x04, 0x820f0008},
+{0x08, 0x8210401d},
+{0x0c, 0xc226c019},
+{0x10, 0xf6002790},
+{0x14, 0xc206c01a},
+{0x18, 0x3b03ffc0},
+{0x1c, 0xb80f001d},
+{0x20, 0x82084008},
+{0x24, 0x8210401c},
+{0x28, 0xc226c01a},
+{0x2c, 0xf8002790},
+{0x30, 0xf6070019},
+{0x34, 0xfa07001a},
+{0x38, 0xba0f6fff},
+{0x3c, 0x820ef000},
+{0x40, 0x8210401d},
+{0x44, 0xc2270019},
+{0x48, 0xfa002790},
+{0x4c, 0xc207401a},
+{0x50, 0x82087000},
+{0x54, 0xb60eefff},
+{0x58, 0x8210401b},
+{0x5c, 0xc227401a},
+{0x60, 0x9602e001},
+{0x64, 0x80a2e009},
+{0x68, 0x28bfffa0},
+{0x6c, 0xf6002790},
+{0x70, 0x80a2a009},
+{0x74, 0x08bfff96},
+{0x78, 0x9210000a},
+{0x7c, 0x81c7e008},
+{0xf0, 0x8d},
+{0x00, 0x81e80000},
+{0x04, 0x9de3bf98},
+{0x08, 0xa6102000},
+{0x0c, 0xda002244},
+{0x10, 0x80a36000},
+{0x14, 0x02800033},
+{0x18, 0xa12ce002},
+{0x1c, 0xe4002790},
+{0x20, 0xc2048010},
+{0x24, 0x80a06000},
+{0x28, 0x22800004},
+{0x2c, 0xc204282c},
+{0x30, 0x1080002c},
+{0x34, 0xc024282c},
+{0x38, 0x80a06000},
+{0x3c, 0x2280000b},
+{0x40, 0xc2002518},
+{0x44, 0xc2002794},
+{0x48, 0xc2004010},
+{0x4c, 0x1b000008},
+{0x50, 0x8210400d},
+{0x54, 0xc2248010},
+{0x58, 0xc204282c},
+{0x5c, 0x82007fff},
+{0x60, 0x10800020},
+{0x64, 0xc224282c},
+{0x68, 0x80a0400d},
+{0x6c, 0x2a80001e},
+{0x70, 0xa604e001},
+{0x74, 0xe2002794},
+{0x78, 0xc2044010},
+{0x7c, 0x80a06000},
+{0xf0, 0x8e},
+{0x00, 0x22800019},
+{0x04, 0xa604e001},
+{0x08, 0x8330600d},
+{0x0c, 0x80886001},
+{0x10, 0x32800015},
+{0x14, 0xa604e001},
+{0x18, 0xd2002798},
+{0x1c, 0xc2024010},
+{0x20, 0x80a06000},
+{0x24, 0x22800010},
+{0x28, 0xa604e001},
+{0x2c, 0x92024010},
+{0x30, 0x7ffffe3c},
+{0x34, 0x90044010},
+{0x38, 0xc200224c},
+{0x3c, 0x80a20001},
+{0x40, 0x38800009},
+{0x44, 0xa604e001},
+{0x48, 0xc2002248},
+{0x4c, 0xc224282c},
+{0x50, 0xc2044010},
+{0x54, 0x1b000008},
+{0x58, 0x8210400d},
+{0x5c, 0xc2248010},
+{0x60, 0xa604e001},
+{0x64, 0x80a4e009},
+{0x68, 0x24bfffca},
+{0x6c, 0xda002244},
+{0x70, 0x81c7e008},
+{0x74, 0x81e80000},
+{0x78, 0x9de3bf98},
+{0x7c, 0xc2002514},
+{0xf0, 0x8f},
+{0x00, 0x80a06000},
+{0x04, 0x22800006},
+{0x08, 0xc2002200},
+{0x0c, 0xc2002314},
+{0x10, 0x82200001},
+{0x14, 0x10800062},
+{0x18, 0xc2202538},
+{0x1c, 0x80a06000},
+{0x20, 0x1280005f},
+{0x24, 0x01000000},
+{0x28, 0xfa002314},
+{0x2c, 0x80a76000},
+{0x30, 0x0280005b},
+{0x34, 0x01000000},
+{0x38, 0xc2002538},
+{0x3c, 0x82006001},
+{0x40, 0x80a0401d},
+{0x44, 0x06800056},
+{0x48, 0xc2202538},
+{0x4c, 0x9e102001},
+{0x50, 0xc20022fc},
+{0x54, 0x80a3c001},
+{0x58, 0x18800051},
+{0x5c, 0xc0202538},
+{0x60, 0x13000017},
+{0x64, 0x9a102001},
+{0x68, 0xc20022f8},
+{0x6c, 0x80a34001},
+{0x70, 0x18800046},
+{0x74, 0xf20be37f},
+{0x78, 0x0300003f},
+{0x7c, 0x941063ff},
+{0xf0, 0x90},
+{0x00, 0x21000017},
+{0x04, 0x961263f8},
+{0x08, 0x901261d0},
+{0x0c, 0x98102001},
+{0x10, 0xf8002548},
+{0x14, 0x80a72008},
+{0x18, 0xf400234c},
+{0x1c, 0x08800005},
+{0x20, 0x82064019},
+{0x24, 0xc210400b},
+{0x28, 0x10800003},
+{0x2c, 0xb6004001},
+{0x30, 0xf610400b},
+{0x34, 0xb0064019},
+{0x38, 0x81800000},
+{0x3c, 0x01000000},
+{0x40, 0x01000000},
+{0x44, 0x01000000},
+{0x48, 0xba76c01c},
+{0x4c, 0xc2160008},
+{0x50, 0xb6a74001},
+{0x54, 0x22800027},
+{0x58, 0xc200247c},
+{0x5c, 0x80a6e000},
+{0x60, 0x04800007},
+{0x64, 0x832b001a},
+{0x68, 0x80a6c001},
+{0x6c, 0x3480000c},
+{0x70, 0xb73ec01a},
+{0x74, 0x1080000a},
+{0x78, 0xb6102001},
+{0x7c, 0x36800009},
+{0xf0, 0x91},
+{0x00, 0xb41421d0},
+{0x04, 0x832b001a},
+{0x08, 0x82200001},
+{0x0c, 0x80a6c001},
+{0x10, 0x36800003},
+{0x14, 0xb6103fff},
+{0x18, 0xb73ec01a},
+{0x1c, 0xb41421d0},
+{0x20, 0xc216001a},
+{0x24, 0xb606c001},
+{0x28, 0x808e6001},
+{0x2c, 0x0280000a},
+{0x30, 0x83366001},
+{0x34, 0xb9286002},
+{0x38, 0xc207001a},
+{0x3c, 0x3b3fffc0},
+{0x40, 0x8208401d},
+{0x44, 0xba0ec00a},
+{0x48, 0x8200401d},
+{0x4c, 0x10800008},
+{0x50, 0xc227001a},
+{0x54, 0x83286002},
+{0x58, 0xfa00401a},
+{0x5c, 0xb92ee010},
+{0x60, 0xba0f400a},
+{0x64, 0xb807001d},
+{0x68, 0xf820401a},
+{0x6c, 0xc200247c},
+{0x70, 0xb2064001},
+{0x74, 0x9a036001},
+{0x78, 0xc20022f8},
+{0x7c, 0x80a34001},
+{0xf0, 0x92},
+{0x00, 0x28bfffc5},
+{0x04, 0xf8002548},
+{0x08, 0x9e03e001},
+{0x0c, 0xc20022fc},
+{0x10, 0x80a3c001},
+{0x14, 0x08bfffb5},
+{0x18, 0x9a102001},
+{0x1c, 0x81c7e008},
+{0x20, 0x81e80000},
+{0x24, 0xc0202514},
+{0x28, 0x9a102000},
+{0x2c, 0x832b6002},
+{0x30, 0xc2020001},
+{0x34, 0x80a06000},
+{0x38, 0x02800005},
+{0x3c, 0x9a036001},
+{0x40, 0xc2002514},
+{0x44, 0x82006001},
+{0x48, 0xc2202514},
+{0x4c, 0x80a36009},
+{0x50, 0x04bffff8},
+{0x54, 0x832b6002},
+{0x58, 0x81c3e008},
+{0x5c, 0x01000000},
+{0x60, 0x9de3bf98},
+{0x64, 0xa8102000},
+{0x68, 0xa0102000},
+{0x6c, 0xc200235c},
+{0x70, 0x80a06000},
+{0x74, 0x32800004},
+{0x78, 0xc0242768},
+{0x7c, 0x1080005d},
+{0xf0, 0x93},
+{0x00, 0xc2002790},
+{0x04, 0xc2002790},
+{0x08, 0xc2004010},
+{0x0c, 0x80a06000},
+{0x10, 0x02800019},
+{0x14, 0xda042854},
+{0x18, 0x03300000},
+{0x1c, 0x808b4001},
+{0x20, 0x32800010},
+{0x24, 0xc2002790},
+{0x28, 0xda002514},
+{0x2c, 0x80a36000},
+{0x30, 0x22800053},
+{0x34, 0xa8052001},
+{0x38, 0x8203400d},
+{0x3c, 0x8200400d},
+{0x40, 0x82007ffd},
+{0x44, 0xda00235c},
+{0x48, 0x9b334001},
+{0x4c, 0x9a0b6007},
+{0x50, 0x03200000},
+{0x54, 0x9a134001},
+{0x58, 0xda242854},
+{0x5c, 0xc2002790},
+{0x60, 0xc2004010},
+{0x64, 0x80a06000},
+{0x68, 0x32800007},
+{0x6c, 0xc2042854},
+{0x70, 0xda042854},
+{0x74, 0x03200000},
+{0x78, 0x822b4001},
+{0x7c, 0xc2242854},
+{0xf0, 0x94},
+{0x00, 0xc2042854},
+{0x04, 0x1b300000},
+{0x08, 0x9a08400d},
+{0x0c, 0x19200000},
+{0x10, 0x80a3400c},
+{0x14, 0x12800019},
+{0x18, 0xa40860ff},
+{0x1c, 0x98102000},
+{0x20, 0x832b2002},
+{0x24, 0xc2006790},
+{0x28, 0xc2004010},
+{0x2c, 0x80a06000},
+{0x30, 0x0280000b},
+{0x34, 0x9b30600d},
+{0x38, 0x808b6001},
+{0x3c, 0x12800009},
+{0x40, 0x80a30012},
+{0x44, 0x98032001},
+{0x48, 0x80a30012},
+{0x4c, 0x24bffff6},
+{0x50, 0x832b2002},
+{0x54, 0x10800006},
+{0x58, 0xc2042854},
+{0x5c, 0x80a30012},
+{0x60, 0x24800027},
+{0x64, 0xa8052001},
+{0x68, 0xc2042854},
+{0x6c, 0x1b100000},
+{0x70, 0x8210400d},
+{0x74, 0xc2242854},
+{0x78, 0xa32ca002},
+{0x7c, 0xd0046790},
+{0xf0, 0x95},
+{0x00, 0xc2020010},
+{0x04, 0x80a06000},
+{0x08, 0x12800006},
+{0x0c, 0x03100000},
+{0x10, 0xda042854},
+{0x14, 0x822b4001},
+{0x18, 0x10800018},
+{0x1c, 0xc2242854},
+{0x20, 0xe6042854},
+{0x24, 0x8334e01e},
+{0x28, 0x80886001},
+{0x2c, 0x22800014},
+{0x30, 0xa8052001},
+{0x34, 0x80a4a000},
+{0x38, 0x2280000e},
+{0x3c, 0xc2046790},
+{0x40, 0xd204678c},
+{0x44, 0x90020010},
+{0x48, 0x7ffffd56},
+{0x4c, 0x92024010},
+{0x50, 0x80a22008},
+{0x54, 0x34800007},
+{0x58, 0xc2046790},
+{0x5c, 0x820cfff0},
+{0x60, 0x9a04bfff},
+{0x64, 0x8210400d},
+{0x68, 0xc2242854},
+{0x6c, 0xc2046790},
+{0x70, 0xc2004010},
+{0x74, 0xc2242768},
+{0x78, 0xa8052001},
+{0x7c, 0x80a52009},
+{0xf0, 0x96},
+{0x00, 0x04bfff9b},
+{0x04, 0xa0042004},
+{0x08, 0x81c7e008},
+{0x0c, 0x81e80000},
+{0x10, 0x8332a01f},
+{0x14, 0x8200400a},
+{0x18, 0x83386001},
+{0x1c, 0x80a24001},
+{0x20, 0x26800015},
+{0x24, 0x90102000},
+{0x28, 0x9a024001},
+{0x2c, 0x80a36008},
+{0x30, 0x24800004},
+{0x34, 0x92224001},
+{0x38, 0x1080000f},
+{0x3c, 0x90102000},
+{0x40, 0x80a2400d},
+{0x44, 0x1480000b},
+{0x48, 0x912a2002},
+{0x4c, 0x832a6002},
+{0x50, 0xc2006790},
+{0x54, 0xc2004008},
+{0x58, 0x80a06000},
+{0x5c, 0x02bffff7},
+{0x60, 0x92026001},
+{0x64, 0x80a2400d},
+{0x68, 0x04bffffa},
+{0x6c, 0x832a6002},
+{0x70, 0x90102001},
+{0x74, 0x81c3e008},
+{0x78, 0x01000000},
+{0x7c, 0x9de3bf98},
+{0xf0, 0x97},
+{0x00, 0x92100019},
+{0x04, 0x90100018},
+{0x08, 0x7fffffe2},
+{0x0c, 0x9410001a},
+{0x10, 0xa4100018},
+{0x14, 0x80a22000},
+{0x18, 0x12800028},
+{0x1c, 0x92100019},
+{0x20, 0xa33ea01f},
+{0x24, 0x8334601f},
+{0x28, 0x82068001},
+{0x2c, 0x83386001},
+{0x30, 0x80a64001},
+{0x34, 0x2680000e},
+{0x38, 0x8334601f},
+{0x3c, 0x82264001},
+{0x40, 0x83286002},
+{0x44, 0xda006790},
+{0x48, 0x832e2002},
+{0x4c, 0xc2034001},
+{0x50, 0x80a06000},
+{0x54, 0x02800019},
+{0x58, 0x92103fff},
+{0x5c, 0x10800004},
+{0x60, 0x8334601f},
+{0x64, 0x10800015},
+{0x68, 0x92100018},
+{0x6c, 0x82068001},
+{0x70, 0x83386001},
+{0x74, 0xa0102001},
+{0x78, 0x80a40001},
+{0x7c, 0x1480000e},
+{0xf0, 0x98},
+{0x00, 0x90100012},
+{0x04, 0xb0064010},
+{0x08, 0x92100018},
+{0x0c, 0x7fffffc1},
+{0x10, 0x9410001a},
+{0x14, 0x8334601f},
+{0x18, 0x82068001},
+{0x1c, 0xa0042001},
+{0x20, 0x80a22000},
+{0x24, 0x12bffff0},
+{0x28, 0x83386001},
+{0x2c, 0x10bffff4},
+{0x30, 0x80a40001},
+{0x34, 0x92103fff},
+{0x38, 0x81c7e008},
+{0x3c, 0x91e80009},
+{0x40, 0x9de3bf98},
+{0x44, 0xa32e2002},
+{0x48, 0xc20467b4},
+{0x4c, 0x80a06000},
+{0x50, 0x0280001c},
+{0x54, 0xb0102001},
+{0x58, 0x8336a01f},
+{0x5c, 0x82068001},
+{0x60, 0xb5386001},
+{0x64, 0xa026401a},
+{0x68, 0xb2066001},
+{0x6c, 0xc20ea35f},
+{0x70, 0xb4584001},
+{0x74, 0x80a40019},
+{0x78, 0x14800011},
+{0x7c, 0xb0102000},
+{0xf0, 0x99},
+{0x00, 0x832c2002},
+{0x04, 0xd0006790},
+{0x08, 0x90020011},
+{0x0c, 0x7ffffce5},
+{0x10, 0x920467b4},
+{0x14, 0x80a2001a},
+{0x18, 0x04800003},
+{0x1c, 0xa0042001},
+{0x20, 0xb0062001},
+{0x24, 0x80a40019},
+{0x28, 0x04bffff7},
+{0x2c, 0x832c2002},
+{0x30, 0x80a62001},
+{0x34, 0x14800003},
+{0x38, 0xb0102001},
+{0x3c, 0xb0102000},
+{0x40, 0x81c7e008},
+{0x44, 0x81e80000},
+{0x48, 0x9de3bf48},
+{0x4c, 0xc2082360},
+{0x50, 0x80a06000},
+{0x54, 0x0280007c},
+{0x58, 0xba102000},
+{0x5c, 0xa6102000},
+{0x60, 0xda04e854},
+{0x64, 0x8333601e},
+{0x68, 0x80886001},
+{0x6c, 0x22800073},
+{0x70, 0xba076001},
+{0x74, 0x83336008},
+{0x78, 0x820860ff},
+{0x7c, 0x80a06002},
+{0xf0, 0x9a},
+{0x00, 0x0480000c},
+{0x04, 0xa4102003},
+{0x08, 0x82006002},
+{0x0c, 0xa4106001},
+{0x10, 0x80a4a009},
+{0x14, 0x04800005},
+{0x18, 0x80a4a002},
+{0x1c, 0x10800005},
+{0x20, 0xa4102009},
+{0x24, 0x80a4a002},
+{0x28, 0x0480005d},
+{0x2c, 0x1b3fffc0},
+{0x30, 0x94100012},
+{0x34, 0xd20ce857},
+{0x38, 0x7fffff91},
+{0x3c, 0x9010001d},
+{0x40, 0xa2100008},
+{0x44, 0x94100012},
+{0x48, 0x92946000},
+{0x4c, 0x04800051},
+{0x50, 0x9010001d},
+{0x54, 0x7fffffbb},
+{0x58, 0x01000000},
+{0x5c, 0x80a22000},
+{0x60, 0x32bffff1},
+{0x64, 0xa404bffe},
+{0x68, 0xad3ca01f},
+{0x6c, 0x8335a01f},
+{0x70, 0x82048001},
+{0x74, 0x83386001},
+{0x78, 0x9a044001},
+{0x7c, 0xa0244001},
+{0xf0, 0x9b},
+{0x00, 0x80a4000d},
+{0x04, 0x1480000f},
+{0x08, 0x9610000d},
+{0x0c, 0x9807bff8},
+{0x10, 0x832c2002},
+{0x14, 0xda006790},
+{0x18, 0xc2134013},
+{0x1c, 0x82086fff},
+{0x20, 0xc2233fd8},
+{0x24, 0xc2034013},
+{0x28, 0x82086fff},
+{0x2c, 0xc2233fb0},
+{0x30, 0xa0042001},
+{0x34, 0x80a4000b},
+{0x38, 0x04bffff6},
+{0x3c, 0x98032004},
+{0x40, 0x92100012},
+{0x44, 0x7ffff22a},
+{0x48, 0x9007bfd0},
+{0x4c, 0x9007bfa8},
+{0x50, 0x7ffff227},
+{0x54, 0x92100012},
+{0x58, 0x9935a01f},
+{0x5c, 0x9804800c},
+{0x60, 0x993b2001},
+{0x64, 0x8207bff8},
+{0x68, 0x952b2002},
+{0x6c, 0x94028001},
+{0x70, 0xda02bfd8},
+{0x74, 0xd604e768},
+{0x78, 0x9a0b6fff},
+{0x7c, 0x0303ffc0},
+{0xf0, 0x9c},
+{0x00, 0x9b2b6010},
+{0x04, 0x822ac001},
+{0x08, 0x8210400d},
+{0x0c, 0xc224e768},
+{0x10, 0xda02bfb0},
+{0x14, 0x9a0b6fff},
+{0x18, 0x82087000},
+{0x1c, 0x8210400d},
+{0x20, 0xc224e768},
+{0x24, 0x832c6002},
+{0x28, 0xda006790},
+{0x2c, 0x8204400c},
+{0x30, 0xa024400c},
+{0x34, 0x80a40001},
+{0x38, 0x031fffff},
+{0x3c, 0xea034013},
+{0x40, 0xae1063ff},
+{0x44, 0x14800011},
+{0x48, 0x832c2002},
+{0x4c, 0xe8006790},
+{0x50, 0x90050013},
+{0x54, 0x7ffffc73},
+{0x58, 0x9204e768},
+{0x5c, 0x8335a01f},
+{0x60, 0x82048001},
+{0x64, 0x83386001},
+{0x68, 0xa0042001},
+{0x6c, 0x80a20017},
+{0x70, 0x16800004},
+{0x74, 0x82044001},
+{0x78, 0xae100008},
+{0x7c, 0xea050013},
+{0xf0, 0x9d},
+{0x00, 0x10bffff1},
+{0x04, 0x80a40001},
+{0x08, 0x10800004},
+{0x0c, 0xea24e768},
+{0x10, 0x10bfffa5},
+{0x14, 0xa404bffe},
+{0x18, 0x1b3fffc0},
+{0x1c, 0xc204e854},
+{0x20, 0x9a1360ff},
+{0x24, 0x8208400d},
+{0x28, 0x9b2ca008},
+{0x2c, 0x8210400d},
+{0x30, 0xc224e854},
+{0x34, 0xba076001},
+{0x38, 0x80a76009},
+{0x3c, 0x04bfff89},
+{0x40, 0xa604e004},
+{0x44, 0x81c7e008},
+{0x48, 0x81e80000},
+{0x4c, 0x9de3bf98},
+{0x50, 0xa6102000},
+{0x54, 0xa12ce002},
+{0x58, 0xda042768},
+{0x5c, 0x80a36000},
+{0x60, 0x12800008},
+{0x64, 0x82102001},
+{0x68, 0xc02427b4},
+{0x6c, 0xda002550},
+{0x70, 0x83284013},
+{0x74, 0x822b4001},
+{0x78, 0x1080001c},
+{0x7c, 0xc2202550},
+{0xf0, 0x9e},
+{0x00, 0xe80427b4},
+{0x04, 0x80a52000},
+{0x08, 0x12800004},
+{0x0c, 0xa5284013},
+{0x10, 0x10800016},
+{0x14, 0xda2427b4},
+{0x18, 0xe2002550},
+{0x1c, 0x808c4012},
+{0x20, 0x32800011},
+{0x24, 0xc2042768},
+{0x28, 0x8333600c},
+{0x2c, 0x80886001},
+{0x30, 0x3280000d},
+{0x34, 0xc2042768},
+{0x38, 0x90042768},
+{0x3c, 0x7ffffc39},
+{0x40, 0x920427b4},
+{0x44, 0xc2002354},
+{0x48, 0x80a20001},
+{0x4c, 0x1a800004},
+{0x50, 0x82144012},
+{0x54, 0x10800005},
+{0x58, 0xe8242768},
+{0x5c, 0xc2202550},
+{0x60, 0xc2042768},
+{0x64, 0xc22427b4},
+{0x68, 0xa604e001},
+{0x6c, 0x80a4e009},
+{0x70, 0x08bfffda},
+{0x74, 0xa12ce002},
+{0x78, 0x81c7e008},
+{0x7c, 0x81e80000},
+{0xf0, 0x9f},
+{0x00, 0x9de3bf98},
+{0x04, 0xc2060000},
+{0x08, 0xbb30600c},
+{0x0c, 0xb9306010},
+{0x10, 0xb80f2fff},
+{0x14, 0xb08f6001},
+{0x18, 0xb6086fff},
+{0x1c, 0x12800014},
+{0x20, 0x9f30601c},
+{0x24, 0xc250229e},
+{0x28, 0xfa5022a2},
+{0x2c, 0x8226c001},
+{0x30, 0xba27001d},
+{0x34, 0xf850229c},
+{0x38, 0xf65022a0},
+{0x3c, 0x8258401c},
+{0x40, 0xba5f401b},
+{0x44, 0x82006800},
+{0x48, 0xba076800},
+{0x4c, 0xb938601f},
+{0x50, 0xb73f601f},
+{0x54, 0xb9372014},
+{0x58, 0xb736e014},
+{0x5c, 0x8200401c},
+{0x60, 0xba07401b},
+{0x64, 0xb738600c},
+{0x68, 0xb93f600c},
+{0x6c, 0xf4002324},
+{0x70, 0xf2002328},
+{0x74, 0xfa002308},
+{0x78, 0xc2002300},
+{0x7c, 0xb65ec01a},
+{0xf0, 0xa0},
+{0x00, 0xbb2f6006},
+{0x04, 0xb85f0019},
+{0x08, 0x83286006},
+{0x0c, 0x9b3ee01f},
+{0x10, 0x81836000},
+{0x14, 0x01000000},
+{0x18, 0x01000000},
+{0x1c, 0x01000000},
+{0x20, 0xb67ec01d},
+{0x24, 0x9b3f201f},
+{0x28, 0x81836000},
+{0x2c, 0x01000000},
+{0x30, 0x01000000},
+{0x34, 0x01000000},
+{0x38, 0xb87f0001},
+{0x3c, 0x80a62000},
+{0x40, 0x32800031},
+{0x44, 0x3b03ffc0},
+{0x48, 0xc20022a4},
+{0x4c, 0x80a06000},
+{0x50, 0x0280000a},
+{0x54, 0x80a6e000},
+{0x58, 0xc25022a6},
+{0x5c, 0x80a6c001},
+{0x60, 0x14800031},
+{0x64, 0xb0102000},
+{0x68, 0xc25022a4},
+{0x6c, 0x80a6c001},
+{0x70, 0x0680002d},
+{0x74, 0x80a6e000},
+{0x78, 0x24800002},
+{0x7c, 0xb6102001},
+{0xf0, 0xa1},
+{0x00, 0x80a6c01a},
+{0x04, 0x3a800002},
+{0x08, 0xb606bfff},
+{0x0c, 0xc20022a8},
+{0x10, 0x80a06000},
+{0x14, 0x0280000a},
+{0x18, 0x80a72000},
+{0x1c, 0xc25022aa},
+{0x20, 0x80a70001},
+{0x24, 0x14800020},
+{0x28, 0xb0102000},
+{0x2c, 0xc25022a8},
+{0x30, 0x80a70001},
+{0x34, 0x0680001c},
+{0x38, 0x80a72000},
+{0x3c, 0x24800002},
+{0x40, 0xb8102001},
+{0x44, 0x80a70019},
+{0x48, 0x3a800002},
+{0x4c, 0xb8067fff},
+{0x50, 0xc20023c8},
+{0x54, 0x80886002},
+{0x58, 0x32800002},
+{0x5c, 0xb626801b},
+{0x60, 0x80886004},
+{0x64, 0x32800002},
+{0x68, 0xb826401c},
+{0x6c, 0x80886008},
+{0x70, 0x02800005},
+{0x74, 0x3b03ffc0},
+{0x78, 0xb61ec01c},
+{0x7c, 0xb81f001b},
+{0xf0, 0xa2},
+{0x00, 0xb61ec01c},
+{0x04, 0x832ee010},
+{0x08, 0x8208401d},
+{0x0c, 0xbb2be01c},
+{0x10, 0xba074001},
+{0x14, 0x0300003f},
+{0x18, 0x821063ff},
+{0x1c, 0x820f0001},
+{0x20, 0xb0074001},
+{0x24, 0x81c7e008},
+{0x28, 0x81e80000},
+{0x2c, 0x9de3bf98},
+{0x30, 0xda002514},
+{0x34, 0xc2002284},
+{0x38, 0x80a34001},
+{0x3c, 0x0880000a},
+{0x40, 0xa0102000},
+{0x44, 0xc20023c8},
+{0x48, 0x80886001},
+{0x4c, 0x02800007},
+{0x50, 0xa2102000},
+{0x54, 0x033fc180},
+{0x58, 0xc0204000},
+{0x5c, 0x1080001c},
+{0x60, 0xc0202514},
+{0x64, 0xa2102000},
+{0x68, 0x912c6002},
+{0x6c, 0xc2022768},
+{0x70, 0x9b30601c},
+{0x74, 0x80a36000},
+{0x78, 0x0280000f},
+{0x7c, 0xa2046001},
+{0xf0, 0xa3},
+{0x00, 0xc2002284},
+{0x04, 0x80a34001},
+{0x08, 0x1880000b},
+{0x0c, 0x90022768},
+{0x10, 0x7fffff7c},
+{0x14, 0x01000000},
+{0x18, 0x80a22000},
+{0x1c, 0x02800007},
+{0x20, 0x80a46009},
+{0x24, 0xa0042001},
+{0x28, 0x9b2c2002},
+{0x2c, 0x033fc180},
+{0x30, 0xd0234001},
+{0x34, 0x80a46009},
+{0x38, 0x28bfffed},
+{0x3c, 0x912c6002},
+{0x40, 0x033fc180},
+{0x44, 0xe0204000},
+{0x48, 0xe0202514},
+{0x4c, 0x81c7e008},
+{0x50, 0x81e80000},
+{0x54, 0x9de3bf98},
+{0x58, 0xd0002320},
+{0x5c, 0x80a22000},
+{0x60, 0x0280004b},
+{0x64, 0x01000000},
+{0x68, 0xc200231c},
+{0x6c, 0x80a06000},
+{0x70, 0x22800016},
+{0x74, 0xd800231c},
+{0x78, 0x82063fff},
+{0x7c, 0x80a06001},
+{0xf0, 0xa4},
+{0x00, 0x38800012},
+{0x04, 0xd800231c},
+{0x08, 0xc2002318},
+{0x0c, 0x80a06000},
+{0x10, 0x12800008},
+{0x14, 0x213fc000},
+{0x18, 0xa0142020},
+{0x1c, 0x82102001},
+{0x20, 0x7ffff019},
+{0x24, 0xc2240000},
+{0x28, 0x10800007},
+{0x2c, 0xc0240000},
+{0x30, 0xa0142020},
+{0x34, 0x7ffff014},
+{0x38, 0xc0240000},
+{0x3c, 0x82102001},
+{0x40, 0xc2240000},
+{0x44, 0xd800231c},
+{0x48, 0x80a0000c},
+{0x4c, 0x82603fff},
+{0x50, 0x9a1e2001},
+{0x54, 0x80a0000d},
+{0x58, 0x9a603fff},
+{0x5c, 0x8088400d},
+{0x60, 0x0280000d},
+{0x64, 0x80a0000c},
+{0x68, 0xc2002318},
+{0x6c, 0x80a06000},
+{0x70, 0x12800006},
+{0x74, 0x033fc000},
+{0x78, 0x9a102001},
+{0x7c, 0x82106020},
+{0xf0, 0xa5},
+{0x00, 0x10800004},
+{0x04, 0xda204000},
+{0x08, 0x82106020},
+{0x0c, 0xc0204000},
+{0x10, 0x80a0000c},
+{0x14, 0x82603fff},
+{0x18, 0x9a1e2002},
+{0x1c, 0x80a0000d},
+{0x20, 0x9a603fff},
+{0x24, 0x8088400d},
+{0x28, 0x0280000d},
+{0x2c, 0x80a62000},
+{0x30, 0xc2002318},
+{0x34, 0x80a06000},
+{0x38, 0x12800005},
+{0x3c, 0x033fc000},
+{0x40, 0x82106020},
+{0x44, 0x10800005},
+{0x48, 0xc0204000},
+{0x4c, 0x9a102001},
+{0x50, 0x82106020},
+{0x54, 0xda204000},
+{0x58, 0x80a62000},
+{0x5c, 0x1280000c},
+{0x60, 0x01000000},
+{0x64, 0xc2002318},
+{0x68, 0x80a06000},
+{0x6c, 0x12800005},
+{0x70, 0x033fc000},
+{0x74, 0x82106020},
+{0x78, 0x10800005},
+{0x7c, 0xc0204000},
+{0xf0, 0xa6},
+{0x00, 0x9a102001},
+{0x04, 0x82106020},
+{0x08, 0xda204000},
+{0x0c, 0x81c7e008},
+{0x10, 0x81e80000},
+{0x14, 0x9de3bf98},
+{0x18, 0xc2002514},
+{0x1c, 0x80a06000},
+{0x20, 0x12800007},
+{0x24, 0x90102001},
+{0x28, 0xda002568},
+{0x2c, 0xc2002570},
+{0x30, 0x80a34001},
+{0x34, 0x22800006},
+{0x38, 0xc2002514},
+{0x3c, 0x82102001},
+{0x40, 0x7fffffa5},
+{0x44, 0xc220250c},
+{0x48, 0xc2002514},
+{0x4c, 0x80a06000},
+{0x50, 0x1280000c},
+{0x54, 0x01000000},
+{0x58, 0xc200250c},
+{0x5c, 0x80a06000},
+{0x60, 0x02800008},
+{0x64, 0x9a007fff},
+{0x68, 0xb0102002},
+{0x6c, 0x80a36000},
+{0x70, 0x12800004},
+{0x74, 0xda20250c},
+{0x78, 0x7fffff97},
+{0x7c, 0x81e80000},
+{0xf0, 0xa7},
+{0x00, 0x01000000},
+{0x04, 0x81c7e008},
+{0x08, 0x81e80000},
+{0x0c, 0x01000000},
+{0x10, 0x27001040},
+{0x14, 0xa614e00f},
+{0x18, 0xe6a00040},
+{0x1c, 0x01000000},
+{0x20, 0x81c3e008},
+{0x24, 0x01000000},
+{0x28, 0x9de3bf98},
+{0x2c, 0xc2002508},
+{0x30, 0x80a06000},
+{0x34, 0x0280000e},
+{0x38, 0x1b3fc180},
+{0x3c, 0x82102001},
+{0x40, 0x9a13603c},
+{0x44, 0xc2234000},
+{0x48, 0xc2002508},
+{0x4c, 0x80a06000},
+{0x50, 0x02800005},
+{0x54, 0x033fc180},
+{0x58, 0x7fffffed},
+{0x5c, 0x01000000},
+{0x60, 0x30bffffa},
+{0x64, 0x8210603c},
+{0x68, 0xc0204000},
+{0x6c, 0x81c7e008},
+{0x70, 0x81e80000},
+{0x74, 0x9de3bf98},
+{0x78, 0xda002500},
+{0x7c, 0xc20022d0},
+{0xf0, 0xa8},
+{0x00, 0x80a34001},
+{0x04, 0x18800025},
+{0x08, 0xa4102000},
+{0x0c, 0xd2002790},
+{0x10, 0x832ca002},
+{0x14, 0xe2024001},
+{0x18, 0x80a46000},
+{0x1c, 0x12800004},
+{0x20, 0xa12ca003},
+{0x24, 0x10800019},
+{0x28, 0xc02427dc},
+{0x2c, 0x92024001},
+{0x30, 0xc20427dc},
+{0x34, 0x80a06000},
+{0x38, 0x02800008},
+{0x3c, 0x900427dc},
+{0x40, 0x7ffffaf8},
+{0x44, 0x01000000},
+{0x48, 0xc20022ac},
+{0x4c, 0x80a20001},
+{0x50, 0x28800005},
+{0x54, 0xc20427e0},
+{0x58, 0xe22427dc},
+{0x5c, 0x1080000b},
+{0x60, 0xc02427e0},
+{0x64, 0x82006001},
+{0x68, 0xc22427e0},
+{0x6c, 0xda002378},
+{0x70, 0x80a0400d},
+{0x74, 0x28800006},
+{0x78, 0xa404a001},
+{0x7c, 0x7ffff069},
+{0xf0, 0xa9},
+{0x00, 0x01000000},
+{0x04, 0x30800005},
+{0x08, 0xa404a001},
+{0x0c, 0x80a4a009},
+{0x10, 0x24bfffe0},
+{0x14, 0xd2002790},
+{0x18, 0x81c7e008},
+{0x1c, 0x81e80000},
+{0x20, 0x9de3bf98},
+{0x24, 0x7ffff54c},
+{0x28, 0x01000000},
+{0x2c, 0x7ffff390},
+{0x30, 0x01000000},
+{0x34, 0x7ffff3d0},
+{0x38, 0x01000000},
+{0x3c, 0x7ffff535},
+{0x40, 0x01000000},
+{0x44, 0x7ffff800},
+{0x48, 0x01000000},
+{0x4c, 0x7ffff571},
+{0x50, 0x01000000},
+{0x54, 0x7ffff714},
+{0x58, 0x01000000},
+{0x5c, 0x7ffff7b9},
+{0x60, 0x90102001},
+{0x64, 0x7ffff93a},
+{0x68, 0x01000000},
+{0x6c, 0x7ffffca3},
+{0x70, 0x01000000},
+{0x74, 0x7ffff9cf},
+{0x78, 0x01000000},
+{0x7c, 0x7ffff963},
+{0xf0, 0xaa},
+{0x00, 0x01000000},
+{0x04, 0x7ffffd08},
+{0x08, 0x90102768},
+{0x0c, 0x7ffff997},
+{0x10, 0x01000000},
+{0x14, 0x7ffffa8b},
+{0x18, 0x01000000},
+{0x1c, 0x7ffffb1d},
+{0x20, 0x01000000},
+{0x24, 0x7ffffb8e},
+{0x28, 0x01000000},
+{0x2c, 0x7ffffbc8},
+{0x30, 0x01000000},
+{0x34, 0x7ffffbe4},
+{0x38, 0x01000000},
+{0x3c, 0x7ffffc52},
+{0x40, 0x01000000},
+{0x44, 0x7ffffcf8},
+{0x48, 0xd0002790},
+{0x4c, 0xc2002514},
+{0x50, 0x7ffffd04},
+{0x54, 0xc2202518},
+{0x58, 0x7ffffddc},
+{0x5c, 0x01000000},
+{0x60, 0x7ffffe5b},
+{0x64, 0x01000000},
+{0x68, 0x7fffffa3},
+{0x6c, 0x01000000},
+{0x70, 0x7ffffeef},
+{0x74, 0x01000000},
+{0x78, 0x7fffff67},
+{0x7c, 0x01000000},
+{0xf0, 0xab},
+{0x00, 0x7fffff8a},
+{0x04, 0x81e80000},
+{0x08, 0x01000000},
+{0x0c, 0x9de3bf98},
+{0x10, 0xc200253c},
+{0x14, 0x80a06000},
+{0x18, 0x12800048},
+{0x1c, 0xb0102000},
+{0x20, 0xd6002460},
+{0x24, 0x82102080},
+{0x28, 0x80a2e000},
+{0x2c, 0x02800043},
+{0x30, 0xc220256c},
+{0x34, 0x10800005},
+{0x38, 0xb0102001},
+{0x3c, 0xc220256c},
+{0x40, 0x1080003e},
+{0x44, 0xf00e2468},
+{0x48, 0xd80022fc},
+{0x4c, 0x80a6000c},
+{0x50, 0x1880002d},
+{0x54, 0x9a102000},
+{0x58, 0xd40022f8},
+{0x5c, 0x33000018},
+{0x60, 0xb6102001},
+{0x64, 0x80a6c00a},
+{0x68, 0x18800020},
+{0x6c, 0xb4102000},
+{0x70, 0x832e2002},
+{0x74, 0xb8006038},
+{0x78, 0xa0166220},
+{0x7c, 0x901661e8},
+{0xf0, 0xac},
+{0x00, 0x92166258},
+{0x04, 0xde0022f8},
+{0x08, 0xfa070010},
+{0x0c, 0x80a7400b},
+{0x10, 0x26800013},
+{0x14, 0xb606e001},
+{0x18, 0x80a6e001},
+{0x1c, 0x22800007},
+{0x20, 0xc20022f8},
+{0x24, 0xc2070008},
+{0x28, 0x80a74001},
+{0x2c, 0x2480000c},
+{0x30, 0xb606e001},
+{0x34, 0xc20022f8},
+{0x38, 0x80a6c001},
+{0x3c, 0x22800007},
+{0x40, 0xb406a001},
+{0x44, 0xc2070009},
+{0x48, 0x80a74001},
+{0x4c, 0x26800004},
+{0x50, 0xb606e001},
+{0x54, 0xb406a001},
+{0x58, 0xb606e001},
+{0x5c, 0x80a6c00f},
+{0x60, 0x08bfffea},
+{0x64, 0xb8072038},
+{0x68, 0x80a6800d},
+{0x6c, 0x34800002},
+{0x70, 0x9a10001a},
+{0x74, 0xb0062001},
+{0x78, 0x80a6000c},
+{0x7c, 0x28bfffda},
+{0xf0, 0xad},
+{0x00, 0xb6102001},
+{0x04, 0xb0102000},
+{0x08, 0xc20e2464},
+{0x0c, 0x80a06000},
+{0x10, 0x22800006},
+{0x14, 0xb0062001},
+{0x18, 0x80a34001},
+{0x1c, 0x34bfffc8},
+{0x20, 0xc20e2278},
+{0x24, 0xb0062001},
+{0x28, 0x80a62003},
+{0x2c, 0x24bffff8},
+{0x30, 0xc20e2464},
+{0x34, 0xb0102000},
+{0x38, 0x81c7e008},
+{0x3c, 0x81e80000},
+{0x40, 0x9de3bf98},
+{0x44, 0xc2002574},
+{0x48, 0x80a06000},
+{0x4c, 0x02800021},
+{0x50, 0x90100018},
+{0x54, 0x82007fff},
+{0x58, 0x7ffff164},
+{0x5c, 0xc2202574},
+{0x60, 0xc2002574},
+{0x64, 0x80a06000},
+{0x68, 0x3280001b},
+{0x6c, 0xc2002578},
+{0x70, 0xc200253c},
+{0x74, 0xda002334},
+{0x78, 0x8200400d},
+{0x7c, 0x82006001},
+{0xf0, 0xae},
+{0x00, 0xc2202548},
+{0x04, 0xc2002564},
+{0x08, 0x80a06000},
+{0x0c, 0x1280000f},
+{0x10, 0x01000000},
+{0x14, 0x7ffff1bc},
+{0x18, 0x01000000},
+{0x1c, 0x033fc200},
+{0x20, 0xda002334},
+{0x24, 0xd800232c},
+{0x28, 0x82106074},
+{0x2c, 0xd8204000},
+{0x30, 0x96102001},
+{0x34, 0x9a036001},
+{0x38, 0xda202574},
+{0x3c, 0xd6202540},
+{0x40, 0x10800004},
+{0x44, 0xd6202564},
+{0x48, 0x7ffff16c},
+{0x4c, 0x01000000},
+{0x50, 0xc2002578},
+{0x54, 0x80a06000},
+{0x58, 0x12800014},
+{0x5c, 0x01000000},
+{0x60, 0xc2002574},
+{0x64, 0x80a06000},
+{0x68, 0x12800010},
+{0x6c, 0x01000000},
+{0x70, 0x7fffff87},
+{0x74, 0x01000000},
+{0x78, 0x80a22000},
+{0x7c, 0x1280000a},
+{0xf0, 0xaf},
+{0x00, 0xd020253c},
+{0x04, 0xc2002334},
+{0x08, 0x9a102001},
+{0x0c, 0x82006001},
+{0x10, 0xc2202574},
+{0x14, 0xda202578},
+{0x18, 0xda202540},
+{0x1c, 0x7ffff709},
+{0x20, 0x91e82000},
+{0x24, 0xd0202574},
+{0x28, 0x81c7e008},
+{0x2c, 0x81e80000},
+{0x30, 0x9de3bf98},
+{0x34, 0x033fc200},
+{0x38, 0x82106030},
+{0x3c, 0xda004000},
+{0x40, 0xc200257c},
+{0x44, 0x80a34001},
+{0x48, 0x12800017},
+{0x4c, 0x01000000},
+{0x50, 0x7ffff01d},
+{0x54, 0x01000000},
+{0x58, 0x80a22000},
+{0x5c, 0x32800008},
+{0x60, 0xc2002514},
+{0x64, 0x7ffff066},
+{0x68, 0xb0102000},
+{0x6c, 0x80a22000},
+{0x70, 0x0280000f},
+{0x74, 0x01000000},
+{0x78, 0xc2002514},
+{0x7c, 0x80a06000},
+{0xf0, 0xb0},
+{0x00, 0x12800006},
+{0x04, 0x90102002},
+{0x08, 0xc200250c},
+{0x0c, 0x80a06000},
+{0x10, 0x02800005},
+{0x14, 0x01000000},
+{0x18, 0x033fc180},
+{0x1c, 0x7ffffe6e},
+{0x20, 0xc0204000},
+{0x24, 0x7fffef7f},
+{0x28, 0xb0102001},
+{0x2c, 0x81c7e008},
+{0x30, 0x81e80000},
+{0x34, 0x9de3bf98},
+{0x38, 0x7ffffed5},
+{0x3c, 0x01000000},
+{0x40, 0xe0002500},
+{0x44, 0x80a42015},
+{0x48, 0x08800016},
+{0x4c, 0x80a42000},
+{0x50, 0x7ffff15a},
+{0x54, 0x01000000},
+{0x58, 0x033fc140},
+{0x5c, 0x82106048},
+{0x60, 0xda004000},
+{0x64, 0x03000040},
+{0x68, 0x11000016},
+{0x6c, 0x808b4001},
+{0x70, 0x12800004},
+{0x74, 0x90122180},
+{0x78, 0x11000016},
+{0x7c, 0x901223a8},
+{0xf0, 0xb1},
+{0x00, 0x7fffff90},
+{0x04, 0x01000000},
+{0x08, 0x7fffffca},
+{0x0c, 0x01000000},
+{0x10, 0x80a22000},
+{0x14, 0x2280001d},
+{0x18, 0xc2002500},
+{0x1c, 0x3080002f},
+{0x20, 0x1280000f},
+{0x24, 0x80a42014},
+{0x28, 0x7fffef21},
+{0x2c, 0x01000000},
+{0x30, 0x80a22000},
+{0x34, 0x32800003},
+{0x38, 0x90102002},
+{0x3c, 0x90102001},
+{0x40, 0x7ffffe45},
+{0x44, 0x01000000},
+{0x48, 0x7fffef56},
+{0x4c, 0x01000000},
+{0x50, 0x7fffee94},
+{0x54, 0x01000000},
+{0x58, 0x30800009},
+{0x5c, 0x3880000b},
+{0x60, 0xc2002500},
+{0x64, 0x808c2001},
+{0x68, 0x32800008},
+{0x6c, 0xc2002500},
+{0x70, 0x90043ff8},
+{0x74, 0x7ffff074},
+{0x78, 0x91322001},
+{0x7c, 0x7ffff0cf},
+{0xf0, 0xb2},
+{0x00, 0x01000000},
+{0x04, 0xc2002500},
+{0x08, 0x80a40001},
+{0x0c, 0x3280000d},
+{0x10, 0xc2002578},
+{0x14, 0x031fffff},
+{0x18, 0x821063f0},
+{0x1c, 0x80a40001},
+{0x20, 0x38800003},
+{0x24, 0x21040000},
+{0x28, 0xa0042001},
+{0x2c, 0x033fc180},
+{0x30, 0x82106034},
+{0x34, 0xe0204000},
+{0x38, 0xe0202500},
+{0x3c, 0xc2002578},
+{0x40, 0x80a06000},
+{0x44, 0x02800005},
+{0x48, 0x01000000},
+{0x4c, 0x7ffffed5},
+{0x50, 0x01000000},
+{0x54, 0xc0202578},
+{0x58, 0x81c7e008},
+{0x5c, 0x81e80000},
+{0x60, 0x81c3e008},
+{0x64, 0x01000000},
+{0x68, 0x01000000},
+{0x6c, 0x01000000},
+{0x70, 0x01000000},
+{0x74, 0x01000000},
+{0x78, 0x01000000},
+{0x7c, 0x01000000},
+{0xf0, 0xb3},
+{0x00, 0x00001682},
+{0x04, 0x00000000},
+{0x08, 0x46656220},
+{0x0c, 0x20352032},
+{0x10, 0x30313300},
+{0x14, 0x00000000},
+{0x18, 0x31353a34},
+{0x1c, 0x383a3334},
+{0x20, 0x00000000},
+{0x24, 0x00000000},
+{0x28, 0x00000000},
+{0x2c, 0x00000000},
+{0x30, 0x00000000},
+{0x34, 0x00000000},
+{0x38, 0x00000000},
+{0x3c, 0x00000000},
+{0x40, 0x00000000},
+{0x44, 0x00000000},
+{0x48, 0x00000000},
+{0x4c, 0x00000000},
+{0x50, 0x00000000},
+{0x54, 0x00000000},
+{0x58, 0x00000000},
+{0x5c, 0x00000000},
+{0x60, 0x00000000},
+{0x64, 0x00000000},
+{0x68, 0x00000000},
+{0x6c, 0x00000000},
+{0x70, 0x00000000},
+{0x74, 0x00000000},
+{0x78, 0x00000000},
+{0x7c, 0x00000000},
+};
Index: linux-3.14.43/drivers/leds/leds-ipq40xx.c
===================================================================
--- linux-3.14.43.orig/drivers/leds/leds-ipq40xx.c
+++ linux-3.14.43/drivers/leds/leds-ipq40xx.c
@@ -70,7 +70,6 @@ struct ipq40xx_led_data {
 
 static struct ipq40xx_led_data *leds;
 static void *ledc_base_addr;
-static int ledc_base_reg_offset;
 static int blink_idx_cnt;
 static int led_blink_array[MAX_BLINK_IDX];
 
@@ -84,7 +83,7 @@ static int ipq40xx_set_led_blink_set(str
 	int reg, mask;
 
 	if (*delay_on <= 0)
-		blink_enable = 0;
+		blink_enable = blink_freq = blink_duty = 0;
 	else
 		blink_enable = 1;
 
@@ -194,9 +193,9 @@ static int __init ipq40xx_led_probe(stru
 		return -ENOMEM;
 	}
 
-	res = of_property_read_u32_array(of_node, "qcom,tcsr_ledc_values",
+	ret = of_property_read_u32_array(of_node, "qcom,tcsr_ledc_values",
 		val_arr, LEDC_MAX_OFFSET);
-	if (res) {
+	if (ret) {
 		dev_err(&pdev->dev,
 		"invalid or missing property: qcom,tcsr_ledc_values\n");
 		return -ENODEV;
@@ -214,9 +213,9 @@ static int __init ipq40xx_led_probe(stru
 	if (blink_idx_cnt > MAX_BLINK_IDX)
 		blink_idx_cnt = MAX_BLINK_IDX;
 
-	res = of_property_read_u32_array(of_node, "qcom,ledc_blink_indices",
+	ret = of_property_read_u32_array(of_node, "qcom,ledc_blink_indices",
 		led_blink_array, blink_idx_cnt);
-	if (res) {
+	if (ret) {
 		dev_err(&pdev->dev,
 			"invalid or missing property: blink indices\n");
 		return -ENODEV;
Index: linux-3.14.43/drivers/mfd/qcom_rpm.c
===================================================================
--- linux-3.14.43.orig/drivers/mfd/qcom_rpm.c
+++ linux-3.14.43/drivers/mfd/qcom_rpm.c
@@ -35,6 +35,7 @@ struct qcom_rpm_data {
 	u32 version;
 	const struct qcom_rpm_resource *resource_table;
 	unsigned n_resources;
+	unsigned disable_mpm;
 };
 
 struct qcom_rpm {
@@ -361,6 +362,7 @@ static const struct qcom_rpm_data ipq806
 	.version = 3,
 	.resource_table = ipq806x_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(ipq806x_rpm_resource_table),
+	.disable_mpm = 1,
 };
 
 static const struct of_device_id qcom_rpm_of_match[] = {
@@ -495,12 +497,20 @@ static int qcom_rpm_probe(struct platfor
 	}
 
 	match = of_match_device(qcom_rpm_of_match, &pdev->dev);
+	if (!match || !match->data) {
+		dev_err(&pdev->dev, "match data missing\n");
+		return -EINVAL;
+	}
+
 	rpm->data = match->data;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	rpm->status_regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(rpm->status_regs))
+	if (IS_ERR(rpm->status_regs)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
 		return PTR_ERR(rpm->status_regs);
+	}
+
 	rpm->ctrl_regs = rpm->status_regs + 0x400;
 	rpm->req_regs = rpm->status_regs + 0x600;
 
@@ -561,9 +571,11 @@ static int qcom_rpm_probe(struct platfor
 		return ret;
 	}
 
-	ret = irq_set_irq_wake(irq_ack, 1);
-	if (ret)
-		dev_warn(&pdev->dev, "failed to mark ack irq as wakeup\n");
+	if (!rpm->data->disable_mpm) {
+		ret = irq_set_irq_wake(irq_ack, 1);
+		if (ret)
+			dev_warn(&pdev->dev, "failed to mark ack irq as wakeup\n");
+	}
 
 	ret = devm_request_irq(&pdev->dev,
 			       irq_err,
@@ -587,9 +599,11 @@ static int qcom_rpm_probe(struct platfor
 		return ret;
 	}
 
-	ret = irq_set_irq_wake(irq_wakeup, 1);
-	if (ret)
-		dev_warn(&pdev->dev, "failed to mark wakeup irq as wakeup\n");
+	if (!rpm->data->disable_mpm) {
+		ret = irq_set_irq_wake(irq_wakeup, 1);
+		if (ret)
+			dev_warn(&pdev->dev, "failed to mark wakeup irq as wakeup\n");
+	}
 
 	return of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
 }
Index: linux-3.14.43/drivers/misc/qseecom.c
===================================================================
--- linux-3.14.43.orig/drivers/misc/qseecom.c
+++ linux-3.14.43/drivers/misc/qseecom.c
@@ -104,9 +104,9 @@ __packed struct qseecom_command_scm_resp
 __packed struct qseecom_client_send_data_ireq {
 	uint32_t qsee_cmd_id;
 	uint32_t app_id;
-	void *req_ptr;
+	dma_addr_t req_ptr;
 	uint32_t req_len;
-	void *rsp_ptr;	 /* First 4 bytes should always be the return status */
+	dma_addr_t rsp_ptr;	 /* First 4 bytes should always be the return status */
 	uint32_t rsp_len;
 };
 
@@ -394,8 +394,8 @@ static int tzapp_test(void *input, void
 		ret1 = dma_mapping_error(NULL, msgreq->data);
 		ret2 = dma_mapping_error(NULL, msgreq->data2);
 		if (ret1 || ret2) {
-			pr_err("\nDMA Mapping Error"
-				"(input data)" ? ret1 : "(output data)");
+			pr_err("\nDMA Mapping Error Return Values:"
+				"input data %d output data %d", ret1, ret2) ;
 			return ret1 ? ret1 : ret2;
 		}
 
@@ -431,8 +431,8 @@ static int tzapp_test(void *input, void
 			sizeof(*msgrsp), DMA_FROM_DEVICE);
 	}
 	if (ret1 || ret2) {
-		pr_err("\nDMA Mapping Error"
-			"(req_Ptr)" ? ret1 : "(rsp_ptr)");
+		pr_err("\nDMA Mapping Error Return values:"
+			"req_ptr %d rsp_ptr %d", ret1, ret2);
 		return ret1 ? ret1 : ret2;
 	}
 
@@ -453,8 +453,13 @@ static int tzapp_test(void *input, void
 			goto fn_exit;
 		}
 	}
-	if (option == 1)
+	if (option == 1) {
+		if (msgrsp->status) {
+			pr_err("Input size exceeded supported range\n");
+			ret = -EINVAL;
+		}
 		basic_output = msgrsp->data;
+	}
 fn_exit:
 	free_page(pg_addr);
 	return ret;
@@ -510,16 +515,15 @@ static int load_app(void)
 	load_req.mdt_len = mdt_size;
 	load_req.img_len = img_size;
 	load_req.phy_addr = dma_map_single(NULL, qsee_sbuffer,
-				sizeof(qsee_sbuffer), DMA_TO_DEVICE);
+				img_size, DMA_TO_DEVICE);
 	ret1 = dma_mapping_error(NULL, load_req.phy_addr);
-
 	if (ret1 == 0) {
 		/* SCM_CALL to load the app and get the app_id back */
 		ret = scm_call(SCM_SVC_TZSCHEDULER, 1,	&load_req,
 			sizeof(struct qseecom_load_app_ireq),
 			&resp, sizeof(resp));
 		dma_unmap_single(NULL, load_req.phy_addr,
-				sizeof(qsee_sbuffer), DMA_TO_DEVICE);
+				img_size, DMA_TO_DEVICE);
 	}
 	if (ret1) {
 		pr_err("\nDMA Mapping error (qsee_sbuffer)");
@@ -552,36 +556,36 @@ static int load_app(void)
 
 /* To show basic multiplication output */
 static ssize_t
-show_basic_output(struct device *dev, struct device *attr,
+show_basic_output(struct device *dev, struct device_attribute *attr,
 					char *buf)
 {
-	return snprintf(buf, (basic_data_len + 1), "%d", basic_output);
+	return snprintf(buf, (basic_data_len + 1), "%u", basic_output);
 }
 
 /* Basic multiplication App*/
 static ssize_t
-store_basic_input(struct device *dev, struct device *attr,
+store_basic_input(struct device *dev, struct device_attribute *attr,
 					const char *buf, size_t count)
 {
 	uint32_t basic_input __aligned(32);
-
+	uint32_t ret = 0;
 	basic_data_len = count;
 	if ((count - 1) == 0) {
 		pr_err("\n Input cannot be NULL!");
 		return -EINVAL;
 	}
 	if (kstrtouint(buf, 10, &basic_input))
-		pr_info("\n Please enter a valid unsigned integer");
+		pr_err("\n Please enter a valid unsigned integer");
 
 	else
-		tzapp_test(&basic_input, NULL, 0, 1);
+		ret = tzapp_test(&basic_input, NULL, 0, 1);
 
-	return count;
+	return ret ? ret : count;
 }
 
 /* To show encrypted plain text*/
 static ssize_t
-show_encrypt_output(struct device *dev, struct device *attr,
+show_encrypt_output(struct device *dev, struct device_attribute *attr,
 					char *buf)
 {
 	return snprintf(buf, (enc_len + 1), "%s", (char *) encrypt_text);
@@ -589,7 +593,7 @@ show_encrypt_output(struct device *dev,
 
 /* To Encrypt input plain text */
 static ssize_t
-store_encrypt_input(struct device *dev, struct device *attr,
+store_encrypt_input(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	int32_t ret = -EINVAL;
@@ -629,7 +633,7 @@ store_encrypt_input(struct device *dev,
 
 /* To show decrypted cipher text */
 static ssize_t
-show_decrypt_output(struct device *dev, struct device *attr,
+show_decrypt_output(struct device *dev, struct device_attribute *attr,
 		 char *buf)
 {
 	return snprintf(buf, (dec_len + 1), "%s", (char *) decrypt_text);
@@ -637,7 +641,7 @@ show_decrypt_output(struct device *dev,
 
 /* To decrypt input cipher text */
 static ssize_t
-store_decrypt_input(struct device *dev, struct device *attr,
+store_decrypt_input(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	int32_t ret = -EINVAL;
@@ -676,7 +680,7 @@ store_decrypt_input(struct device *dev,
 }
 
 static ssize_t
-store_load_start(struct device *dev, struct device *attr,
+store_load_start(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	int load_cmd;
@@ -694,13 +698,13 @@ store_load_start(struct device *dev, str
 	return count;
 }
 
-static	DEVICE_ATTR(encrypt, 0666, show_encrypt_output,
+static DEVICE_ATTR(encrypt, 0644, show_encrypt_output,
 					store_encrypt_input);
-static	DEVICE_ATTR(decrypt, 0666, show_decrypt_output,
+static DEVICE_ATTR(decrypt, 0644, show_decrypt_output,
 					store_decrypt_input);
-static	DEVICE_ATTR(basic_data, 0666, show_basic_output,
+static DEVICE_ATTR(basic_data, 0644, show_basic_output,
 					store_basic_input);
-static	DEVICE_ATTR(load_start, 0222, NULL,
+static DEVICE_ATTR(load_start, 0222, NULL,
 					store_load_start);
 
 static struct attribute *tzapp_attrs[] = {
Index: linux-3.14.43/drivers/mmc/host/mmci.c
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/mmci.c
+++ linux-3.14.43/drivers/mmc/host/mmci.c
@@ -309,8 +309,14 @@ static void mmci_set_clkreg(struct mmci_
 		clk |= variant->clkreg_8bit_bus_enable;
 
 	if (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50 ||
-	    host->mmc->ios.timing == MMC_TIMING_MMC_DDR52)
+	    host->mmc->ios.timing == MMC_TIMING_MMC_DDR52) {
+#ifndef CONFIG_MMC_QCOM_TUNING
 		clk |= variant->clkreg_neg_edge_enable;
+#else
+		clk |= variant->datactrl_mask_ddrmode;
+		mmci_qcom_ddr_tuning(host);
+#endif
+	}
 
 #ifdef CONFIG_MMC_QCOM_TUNING
 	if (variant->qcom_uhs_gpio >= 0)
@@ -742,7 +748,16 @@ static void mmci_start_data(struct mmci_
 	host->size = data->blksz * data->blocks;
 	data->bytes_xfered = 0;
 
+#ifdef CONFIG_MMC_QCOM_TUNING
+	if (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50)
+		clks = (unsigned long long)data->timeout_ns *
+			(host->cclk / 2);
+	else
+		clks = (unsigned long long)data->timeout_ns * host->cclk;
+#else
 	clks = (unsigned long long)data->timeout_ns * host->cclk;
+#endif
+
 	do_div(clks, NSEC_PER_SEC);
 
 	timeout = data->timeout_clks + (unsigned int)clks;
@@ -790,10 +805,11 @@ static void mmci_start_data(struct mmci_
 
 			mmci_write_clkreg(host, clk);
 		}
-
+#ifndef CONFIG_MMC_QCOM_TUNING
 	if (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50 ||
 	    host->mmc->ios.timing == MMC_TIMING_MMC_DDR52)
 		datactrl |= variant->datactrl_mask_ddrmode;
+#endif
 
 	/*
 	 * Attempt to use DMA operation mode, if this
@@ -1391,7 +1407,6 @@ static int mmci_get_cd(struct mmc_host *
 static int mmci_sig_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	int ret = 0;
-
 	if (!IS_ERR(mmc->supply.vqmmc)) {
 
 		pm_runtime_get_sync(mmc_dev(mmc));
Index: linux-3.14.43/drivers/mmc/host/mmci_qcom_dml.c
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/mmci_qcom_dml.c
+++ linux-3.14.43/drivers/mmc/host/mmci_qcom_dml.c
@@ -123,7 +123,7 @@ int dml_hw_init(struct mmci_host *host,
 {
 	u32 config;
 	void __iomem *base;
-	u32 consumer_id, producer_id;
+	int consumer_id, producer_id;
 
 	consumer_id = of_get_dml_pipe_index(np, "tx");
 	producer_id = of_get_dml_pipe_index(np, "rx");
Index: linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.c
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/mmci_qcom_tuning.c
+++ linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.c
@@ -236,6 +236,9 @@ static int mmci_qtune_config_cm_sdc4_dll
 	unsigned long flags;
 	u32 config;
 
+	if (!host)
+		return -EINVAL;
+
 	spin_lock_irqsave(&host->lock, flags);
 
 	config = readl_relaxed(host->base + MCIDLL_CONFIG);
@@ -248,6 +251,12 @@ static int mmci_qtune_config_cm_sdc4_dll
 	if (rc)
 		goto err_out;
 
+	if (phase >= ARRAY_SIZE(grey_coded_phase_table)) {
+		pr_warn("%s: out of bound access - grey_coded_phase_table[%d]\n",
+				__func__, phase);
+		return -EINVAL;
+	}
+
 	/*
 	 * Write the selected DLL clock output phase (0 ... 15)
 	 * to CDR_SELEXT bit field of MCIDLL_CONFIG register.
@@ -566,6 +575,20 @@ out:
 	return rc;
 }
 
+void mmci_qcom_ddr_tuning(struct mmci_host *host)
+{
+	/* Write 1 to DLL_RST bit of MCI_DLL_CONFIG register */
+	writel_relaxed((readl_relaxed(host->base +
+			MCIDLL_CONFIG) | MCI_DLL_RST),
+			host->base + MCIDLL_CONFIG);
+
+	/* Write 1 to DLL_PDN bit of MCI_DLL_CONFIG register */
+	writel_relaxed((readl_relaxed(host->base +
+			MCIDLL_CONFIG) | MCI_DLL_PDN),
+			host->base + MCIDLL_CONFIG);
+
+}
+
 void set_default_hw_caps(struct mmci_host *host)
 {
 	u32 version;
Index: linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.h
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/mmci_qcom_tuning.h
+++ linux-3.14.43/drivers/mmc/host/mmci_qcom_tuning.h
@@ -53,6 +53,7 @@
 
 int mmci_qtune_execute_tuning(struct mmc_host *mmc, u32 opcode);
 void set_default_hw_caps(struct mmci_host *host);
+void mmci_qcom_ddr_tuning(struct mmci_host *host);
 int mmci_qtune_init(struct mmci_host *host, struct device_node *np);
 
 #endif /* __MMCI_QCOM_TUNING_H_ */
Index: linux-3.14.43/drivers/mmc/host/sdhci-msm.c
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/sdhci-msm.c
+++ linux-3.14.43/drivers/mmc/host/sdhci-msm.c
@@ -484,6 +484,22 @@ out:
 	return rc;
 }
 
+static void sdhci_msm_toggle_cdr(struct sdhci_host *host, bool enable)
+{
+	u32 config;
+	config = readl_relaxed(host->ioaddr + CORE_DLL_CONFIG);
+
+	if (enable) {
+		config |= CORE_CDR_EN;
+		config &= ~CORE_CDR_EXT_EN;
+		writel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);
+	} else {
+		config &= ~CORE_CDR_EN;
+		config |= CORE_CDR_EXT_EN;
+		writel_relaxed(config, host->ioaddr + CORE_DLL_CONFIG);
+	}
+}
+
 static const struct of_device_id sdhci_msm_dt_match[] = {
 	{ .compatible = "qcom,sdhci-msm-v4" },
 	{},
@@ -493,6 +509,7 @@ MODULE_DEVICE_TABLE(of, sdhci_msm_dt_mat
 
 static struct sdhci_ops sdhci_msm_ops = {
 	.platform_execute_tuning = sdhci_msm_execute_tuning,
+	.toggle_cdr = sdhci_msm_toggle_cdr,
 };
 
 static int sdhci_msm_probe(struct platform_device *pdev)
Index: linux-3.14.43/drivers/mmc/host/sdhci.c
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/sdhci.c
+++ linux-3.14.43/drivers/mmc/host/sdhci.c
@@ -923,8 +923,19 @@ static void sdhci_set_transfer_mode(stru
 		}
 	}
 
-	if (data->flags & MMC_DATA_READ)
+	if (data->flags & MMC_DATA_READ) {
 		mode |= SDHCI_TRNS_READ;
+		if (host->ops->toggle_cdr) {
+			if ((cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200) ||
+					(cmd->opcode == MMC_SEND_TUNING_BLOCK))
+				host->ops->toggle_cdr(host, false);
+			else
+				host->ops->toggle_cdr(host, true);
+		}
+	}
+	if (host->ops->toggle_cdr && (data->flags & MMC_DATA_WRITE))
+		host->ops->toggle_cdr(host, false);
+
 	if (host->flags & SDHCI_REQ_USE_DMA)
 		mode |= SDHCI_TRNS_DMA;
 
Index: linux-3.14.43/drivers/mmc/host/sdhci.h
===================================================================
--- linux-3.14.43.orig/drivers/mmc/host/sdhci.h
+++ linux-3.14.43/drivers/mmc/host/sdhci.h
@@ -296,6 +296,7 @@ struct sdhci_ops {
 	void    (*adma_workaround)(struct sdhci_host *host, u32 intmask);
 	void	(*platform_init)(struct sdhci_host *host);
 	void    (*card_event)(struct sdhci_host *host);
+	void	(*toggle_cdr)(struct sdhci_host *host, bool enable);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
Index: linux-3.14.43/drivers/mtd/devices/m25p80.c
===================================================================
--- linux-3.14.43.orig/drivers/mtd/devices/m25p80.c
+++ linux-3.14.43/drivers/mtd/devices/m25p80.c
@@ -922,6 +922,8 @@ static const struct spi_device_id m25p_i
 	/* GigaDevice */
 	{ "gd25q32", INFO(0xc84016, 0, 64 * 1024,  64, SECT_4K) },
 	{ "gd25q64", INFO(0xc84017, 0, 64 * 1024, 128, SECT_4K) },
+	{ "gd25q16", INFO(0xc84015, 0, 64 * 1024, 32, SECT_4K) },
+	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, SECT_4K) },
 
 	/* Intel/Numonyx -- xxxs33b */
 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
Index: linux-3.14.43/drivers/mtd/devices/msm_qpic_nand.c
===================================================================
--- linux-3.14.43.orig/drivers/mtd/devices/msm_qpic_nand.c
+++ linux-3.14.43/drivers/mtd/devices/msm_qpic_nand.c
@@ -2735,9 +2735,9 @@ static int msm_nand_probe(struct platfor
 {
 	struct msm_nand_info *info;
 	struct resource *res;
-	int i, err;
+	int err;
 #ifdef CONFIG_MSM_SMD
-	int nr_parts;
+	int i, nr_parts;
 #else
 	struct mtd_part_parser_data ppdata;
 #endif
@@ -2880,6 +2880,9 @@ static int msm_nand_remove(struct platfo
 {
 	struct msm_nand_info *info = dev_get_drvdata(&pdev->dev);
 
+	if (!info)
+		return -EINVAL;
+
 	if (info->clk_data.client_handle)
 		msm_nand_bus_unregister(info);
 
Index: linux-3.14.43/drivers/mtd/devices/msm_qpic_nand.h
===================================================================
--- linux-3.14.43.orig/drivers/mtd/devices/msm_qpic_nand.h
+++ linux-3.14.43/drivers/mtd/devices/msm_qpic_nand.h
@@ -396,9 +396,8 @@ struct flash_partition_table {
 
 #ifdef CONFIG_MSM_SMD
 static struct flash_partition_table ptable;
-#endif
-
 static struct mtd_partition mtd_part[FLASH_PTABLE_MAX_PARTS_V4];
+#endif
 
 static inline bool is_buffer_in_page(const void *buf, size_t len)
 {
Index: linux-3.14.43/drivers/mtd/nand/nand_base.c
===================================================================
--- linux-3.14.43.orig/drivers/mtd/nand/nand_base.c
+++ linux-3.14.43/drivers/mtd/nand/nand_base.c
@@ -3438,7 +3438,11 @@ static void nand_decode_bbm_options(stru
 			(mtd->writesize == 2048 &&
 			 maf_id == NAND_MFR_MICRON) ||
 			(mtd->writesize == 2048 &&
-			 maf_id == NAND_MFR_GIGA))
+			 maf_id == NAND_MFR_GIGA) ||
+			(mtd->writesize == 2048 &&
+			 maf_id == NAND_MFR_MACRONIX) ||
+			(mtd->writesize == 2048 &&
+			 maf_id == NAND_MFR_WINBOND))
 		chip->bbt_options |= NAND_BBT_SCAN2NDPAGE;
 }
 
Index: linux-3.14.43/drivers/mtd/nand/nand_ids.c
===================================================================
--- linux-3.14.43.orig/drivers/mtd/nand/nand_ids.c
+++ linux-3.14.43/drivers/mtd/nand/nand_ids.c
@@ -40,6 +40,9 @@ struct nand_flash_dev nand_flash_ids[] =
 	{"MX35LFxGE4AB 128MiB 3.3V",
 		{ .id = {0xc2, 0x12} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
 
+	{"W25N01GV 128MiB 3.3V",
+		{ .id = {0xef, 0xaa, 0x21} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
+
 	{"GD5F1GQ1RC 128MiB 1.8V",
 		{ .id = {0xc8, 0xA1} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
 
@@ -185,6 +188,7 @@ struct nand_manufacturers nand_manuf_ids
 	{NAND_MFR_INTEL, "Intel"},
 	{NAND_MFR_GIGA, "GigaDevice"},
 	{NAND_MFR_ATO, "ATO"},
+	{NAND_MFR_WINBOND, "Winbond"},
 	{0x0, "Unknown"}
 };
 
Index: linux-3.14.43/drivers/mtd/nand/qcom_nand.c
===================================================================
--- linux-3.14.43.orig/drivers/mtd/nand/qcom_nand.c
+++ linux-3.14.43/drivers/mtd/nand/qcom_nand.c
@@ -4336,7 +4336,7 @@ uint32_t flash_onenand_probe(struct msm_
 int msm_onenand_read_oob(struct mtd_info *mtd,
 		loff_t from, struct mtd_oob_ops *ops)
 {
-	struct msm_nand_chip *chip = mtd->priv;
+	struct msm_nand_chip *chip;
 
 	struct {
 		dmov_s cmd[53];
@@ -4397,6 +4397,8 @@ int msm_onenand_read_oob(struct mtd_info
 				(uint32_t)mtd);
 		return -EINVAL;
 	}
+	chip = mtd->priv;
+
 	if (from & (mtd->writesize - 1)) {
 		pr_err("%s: unsupported from, 0x%llx\n", __func__,
 				from);
@@ -5017,7 +5019,7 @@ int msm_onenand_read(struct mtd_info *mt
 static int msm_onenand_write_oob(struct mtd_info *mtd, loff_t to,
 		struct mtd_oob_ops *ops)
 {
-	struct msm_nand_chip *chip = mtd->priv;
+	struct msm_nand_chip *chip;
 
 	struct {
 		dmov_s cmd[53];
@@ -5082,6 +5084,8 @@ static int msm_onenand_write_oob(struct
 				(uint32_t)mtd);
 		return -EINVAL;
 	}
+	chip = mtd->priv;
+
 	if (to & (mtd->writesize - 1)) {
 		pr_err("%s: unsupported to, 0x%llx\n", __func__, to);
 		return -EINVAL;
@@ -5195,7 +5199,8 @@ static int msm_onenand_write_oob(struct
 		if (dma_mapping_error(chip->dev, data_dma_addr)) {
 			pr_err("%s: failed to get dma addr for %p\n",
 					__func__, ops->datbuf);
-			return -EIO;
+			err = -EIO;
+			goto free;
 		}
 	}
 	if (ops->oobbuf) {
@@ -5740,6 +5745,7 @@ err_dma_map_oobbuf_failed:
 	pr_info("================================================="
 			"================\n");
 #endif
+free:
 	kfree(init_spare_bytes);
 	return err;
 }
@@ -7051,7 +7057,7 @@ int msm_nand_scan(struct mtd_info *mtd,
 			if (nand_manuf_ids[i].id == manid)
 				flashman = &nand_manuf_ids[i];
 		for (i = 0; !flashdev && nand_flash_ids[i].id; ++i)
-			if (nand_flash_ids[i].id == devid)
+			if (nand_flash_ids[i].id[1] == devid)
 				flashdev = &nand_flash_ids[i];
 		if (!flashdev || !flashman) {
 			pr_err("ERROR: unknown nand device manuf=%x devid=%x\n",
@@ -7290,7 +7296,7 @@ static ssize_t boot_layout_show(struct d
                                   struct device_attribute *attr,
                                   char *buf)
 {
-	return sprintf(buf, "%d\n", boot_layout);
+	return snprintf(buf, PAGE_SIZE, "%d\n", boot_layout);
 }
 
 static ssize_t boot_layout_store(struct device *dev,
@@ -7303,7 +7309,10 @@ static ssize_t boot_layout_store(struct
 	unsigned int spare_size;
 	unsigned int ecc_num_data_bytes;
 
-	sscanf(buf, "%d", &boot_layout);
+	if (sscanf(buf, "%u", &boot_layout) != 1) {
+		pr_err("%s: invalid boot_layout\n", __func__);
+		return -EINVAL;
+	}
 
 	ud_size = boot_layout? 512: 516;
 	spare_size = boot_layout? (chip->cw_size -
Index: linux-3.14.43/drivers/net/bonding/bond_3ad.c
===================================================================
--- linux-3.14.43.orig/drivers/net/bonding/bond_3ad.c
+++ linux-3.14.43/drivers/net/bonding/bond_3ad.c
@@ -30,7 +30,9 @@
 #include <linux/etherdevice.h>
 #include <linux/if_bonding.h>
 #include <linux/pkt_sched.h>
+#include <linux/export.h>
 #include <net/net_namespace.h>
+#include <net/ip.h>
 #include "bonding.h"
 #include "bond_3ad.h"
 
@@ -120,6 +122,24 @@ static void ad_marker_info_received(stru
 static void ad_marker_response_received(struct bond_marker *marker,
 					struct port *port);
 
+/*------------------------------- Exported APIs -----------------------------*/
+static struct bond_cb nss_cb;
+struct bond_cb *bond_cb;
+
+void bond_register_cb(struct bond_cb *cb)
+{
+	memcpy((void *)&nss_cb, (void *)cb, sizeof(*cb));
+	bond_cb = &nss_cb;
+}
+EXPORT_SYMBOL(bond_register_cb);
+
+void bond_unregister_cb(void)
+{
+	bond_cb = NULL;
+	memset((void *)&nss_cb, 0, sizeof(nss_cb));
+}
+EXPORT_SYMBOL(bond_unregister_cb);
+
 
 /* ================= api to bonding and kernel code ================== */
 
@@ -946,6 +966,19 @@ static void ad_mux_machine(struct port *
 			port->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;
 			ad_disable_collecting_distributing(port);
 			port->ntt = true;
+
+			/*
+			 * Send a notificaton about change in state of this
+			 * port. We only want to handle case where port moves
+			 * from AD_MUX_COLLECTING_DISTRIBUTING ->
+			 * AD_MUX_ATTACHED. Link down and interface down events
+			 * are handled by ECM.
+			 */
+			if (IS_UP(port->slave->dev) &&
+			     (last_state == AD_MUX_COLLECTING_DISTRIBUTING)) {
+				if (bond_cb && bond_cb->bond_cb_link_down)
+					bond_cb->bond_cb_link_down(port->slave->dev);
+			}
 			break;
 		case AD_MUX_COLLECTING_DISTRIBUTING:
 			port->actor_oper_port_state |= AD_STATE_COLLECTING;
@@ -1720,6 +1753,10 @@ static void ad_enable_collecting_distrib
 			 port->actor_port_number,
 			 port->aggregator->aggregator_identifier);
 		__enable_port(port);
+
+		if (bond_cb && bond_cb->bond_cb_link_up) {
+			bond_cb->bond_cb_link_up(port->slave->dev);
+		}
 	}
 }
 
@@ -2415,32 +2452,67 @@ int bond_3ad_get_active_agg_info(struct
 	return ret;
 }
 
-int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev)
+/*
+ * bond_3ad_get_tx_dev - Calculate egress interface for a given packet,
+ * 			 for a LAG that is configured in 802.3AD mode
+ * @skb: pointer to skb to be egressed
+ * @src_mac: pointer to source L2 address
+ * @dst_mac: pointer to destination L2 address
+ * @src: pointer to source L3 address
+ * @dst: pointer to destination L3 address
+ * @protocol: L3 protocol id from L2 header
+ * @bond_dev: pointer to bond master device
+ *
+ * If @skb is NULL, bond_xmit_hash is used to calculate hash using L2/L3
+ * addresses.
+ *
+ * Returns: Either valid slave device, or NULL otherwise
+ */
+struct net_device *bond_3ad_get_tx_dev(struct sk_buff *skb, uint8_t *src_mac,
+		                       uint8_t *dst_mac, void *src,
+		                       void *dst, uint16_t protocol,
+		                       struct net_device *bond_dev,
+				       __be16 *layer4hdr)
 {
-	struct bonding *bond = netdev_priv(dev);
+	struct bonding *bond = netdev_priv(bond_dev);
 	struct slave *slave, *first_ok_slave;
 	struct aggregator *agg;
 	struct ad_info ad_info;
 	struct list_head *iter;
 	int slaves_in_agg;
-	int slave_agg_no;
+	int slave_agg_no = 0;
 	int agg_id;
 
 	if (__bond_3ad_get_active_agg_info(bond, &ad_info)) {
 		pr_debug("%s: Error: __bond_3ad_get_active_agg_info failed\n",
-			 dev->name);
-		goto err_free;
+			 bond_dev->name);
+		return NULL;
 	}
 
 	slaves_in_agg = ad_info.ports;
 	agg_id = ad_info.aggregator_id;
 
 	if (slaves_in_agg == 0) {
-		pr_debug("%s: Error: active aggregator is empty\n", dev->name);
-		goto err_free;
+		pr_debug("%s: Error: active aggregator is empty\n", bond_dev->name);
+		return NULL;
+	}
+
+	if (skb) {
+	        slave_agg_no = bond_xmit_hash(bond, skb, slaves_in_agg);
+	} else {
+		uint32_t hash;
+
+		if (bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER23
+			&& bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER2
+			&& bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER34) {
+			pr_debug("%s: Error: Unsupported hash policy for 802.3AD fast path\n", bond_dev->name);
+			return NULL;
+		}
+
+		hash = bond_xmit_hash_without_skb(src_mac, dst_mac, src, dst, protocol, bond_dev, layer4hdr);
+		slave_agg_no = hash % slaves_in_agg;
 	}
 
-	slave_agg_no = bond_xmit_hash(bond, skb, slaves_in_agg);
 	first_ok_slave = NULL;
 
 	bond_for_each_slave_rcu(bond, slave, iter) {
@@ -2455,32 +2527,44 @@ int bond_3ad_xmit_xor(struct sk_buff *sk
 			continue;
 		}
 
-		if (SLAVE_IS_OK(slave)) {
-			bond_dev_queue_xmit(bond, skb, slave->dev);
-			goto out;
-		}
+		if (SLAVE_IS_OK(slave))
+		        return slave->dev;
 	}
 
 	if (slave_agg_no >= 0) {
 		pr_err("%s: Error: Couldn't find a slave to tx on for aggregator ID %d\n",
-		       dev->name, agg_id);
-		goto err_free;
+		       bond_dev->name, agg_id);
+		return NULL;
 	}
 
 	/* we couldn't find any suitable slave after the agg_no, so use the
 	 * first suitable found, if found.
 	 */
 	if (first_ok_slave)
-		bond_dev_queue_xmit(bond, skb, first_ok_slave->dev);
-	else
-		goto err_free;
+		return first_ok_slave->dev;
+
+        return NULL;
+}
+
+int bond_3ad_xmit_xor(struct sk_buff *skb, struct net_device *dev)
+{
+        struct bonding *bond = netdev_priv(dev);
+	struct net_device *outdev = NULL;
+
+	outdev = bond_3ad_get_tx_dev(skb, NULL, NULL, NULL, NULL, 0, dev, NULL);
+
+	if (!outdev) {
+		goto out;
+	}
+
+	bond_dev_queue_xmit(bond, skb, outdev);
+	goto final;
 
 out:
+	dev_kfree_skb(skb);
+
+final:
 	return NETDEV_TX_OK;
-err_free:
-	/* no suitable interface, frame not sent */
-	dev_kfree_skb_any(skb);
-	goto out;
 }
 
 int bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,
Index: linux-3.14.43/drivers/net/bonding/bond_3ad.h
===================================================================
--- linux-3.14.43.orig/drivers/net/bonding/bond_3ad.h
+++ linux-3.14.43/drivers/net/bonding/bond_3ad.h
@@ -281,5 +281,10 @@ int bond_3ad_lacpdu_recv(const struct sk
 			 struct slave *slave);
 int bond_3ad_set_carrier(struct bonding *bond);
 void bond_3ad_update_lacp_rate(struct bonding *bond);
+struct net_device *bond_3ad_get_tx_dev(struct sk_buff *skb, uint8_t *src_mac,
+		                       uint8_t *dst_mac, void *src,
+		                       void *dst, uint16_t protocol,
+		                       struct net_device *bond_dev,
+				       __be16 *layer4hdr);
 #endif //__BOND_3AD_H__
 
Index: linux-3.14.43/drivers/net/bonding/bond_main.c
===================================================================
--- linux-3.14.43.orig/drivers/net/bonding/bond_main.c
+++ linux-3.14.43/drivers/net/bonding/bond_main.c
@@ -205,6 +205,10 @@ static int arp_ip_count;
 static int bond_mode	= BOND_MODE_ROUNDROBIN;
 static int xmit_hashtype = BOND_XMIT_POLICY_LAYER2;
 static int lacp_fast;
+static unsigned long bond_id_mask = 0xFFFFFFF0;
+
+/*-------------------------- External variables -----------------------------*/
+extern struct bond_cb *bond_cb;
 
 /*-------------------------- Forward declarations ---------------------------*/
 
@@ -231,6 +235,20 @@ const char *bond_mode_name(int mode)
 	return names[mode];
 }
 
+/*---------------------------- Exported APIs --------------------------------*/
+int bond_get_id(struct net_device *bond_dev)
+{
+	struct bonding *bond = NULL;
+
+	if (!((bond_dev->priv_flags & IFF_BONDING) && (bond_dev->flags & IFF_MASTER))) {
+		return -EINVAL;
+	}
+
+	bond = netdev_priv(bond_dev);
+	return bond->id;
+}
+EXPORT_SYMBOL(bond_get_id);
+
 /*---------------------------------- VLAN -----------------------------------*/
 
 /**
@@ -813,6 +831,11 @@ void bond_change_active_slave(struct bon
 			if (bond->params.mode == BOND_MODE_8023AD)
 				bond_3ad_handle_link_change(new_active, BOND_LINK_UP);
 
+			if (bond->params.mode == BOND_MODE_XOR) {
+				if (bond_cb && bond_cb->bond_cb_link_up)
+					bond_cb->bond_cb_link_up(new_active->dev);
+			}
+
 			if (bond_is_lb(bond))
 				bond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);
 		} else {
@@ -1560,6 +1583,10 @@ int bond_enslave(struct net_device *bond
 		unblock_netpoll_tx();
 	}
 
+	if (bond_cb && bond_cb->bond_cb_enslave) {
+		bond_cb->bond_cb_enslave(slave_dev);
+	}
+
 	pr_info("%s: enslaving %s as a%s interface with a%s link.\n",
 		bond_dev->name, slave_dev->name,
 		bond_is_active_slave(new_slave) ? "n active" : " backup",
@@ -1620,6 +1647,10 @@ err_undo_flags:
 	    ether_addr_equal_64bits(bond_dev->dev_addr, slave_dev->dev_addr))
 		eth_hw_addr_random(bond_dev);
 
+	if (bond_cb && bond_cb->bond_cb_release) {
+		bond_cb->bond_cb_release(slave_dev);
+	}
+
 	return res;
 }
 
@@ -1664,9 +1695,14 @@ static int __bond_release_one(struct net
 		return -EINVAL;
 	}
 
+	if (bond_cb && bond_cb->bond_cb_release) {
+		bond_cb->bond_cb_release(slave_dev);
+	}
+
 	bond_sysfs_slave_del(slave);
 
 	bond_upper_dev_unlink(bond_dev, slave_dev);
+
 	/* unregister rx_handler early so bond_handle_frame wouldn't be called
 	 * for this slave anymore.
 	 */
@@ -1975,6 +2011,7 @@ static void bond_miimon_commit(struct bo
 {
 	struct list_head *iter;
 	struct slave *slave;
+	struct net_device *slave_dev = NULL;
 
 	bond_for_each_slave(bond, slave, iter) {
 		switch (slave->new_link) {
@@ -2009,6 +2046,10 @@ static void bond_miimon_commit(struct bo
 				bond_alb_handle_link_change(bond, slave,
 							    BOND_LINK_UP);
 
+			if ((bond->params.mode == BOND_MODE_XOR) && (slave_dev == NULL)) {
+				slave_dev = slave->dev;
+			}
+
 			if (!bond->curr_active_slave ||
 			    (slave == bond->primary_slave))
 				goto do_failover;
@@ -2061,6 +2102,10 @@ do_failover:
 	}
 
 	bond_set_carrier(bond);
+
+	if (slave_dev && bond_cb && bond_cb->bond_cb_link_up)
+	    	bond_cb->bond_cb_link_up(slave_dev);
+
 }
 
 /*
@@ -2953,6 +2998,45 @@ static inline u32 bond_eth_hash(struct s
 	return 0;
 }
 
+static inline u32 bond_ipv6_addr_to_hash(const uint32_t *a)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
+	const unsigned long *ul = (const unsigned long *)a;
+	unsigned long x = ul[0] ^ ul[1];
+
+	return (u32)(x ^ (x >> 32));
+#else
+	return (__force u32)(a[0] ^ a[1] ^ a[2] ^ a[3]);
+#endif
+}
+
+/* Extract the appropriate headers based on bond's xmit policy */
+static bool bond_flow_dissect_without_skb(struct bonding *bond, uint8_t *src_mac, uint8_t *dst_mac,
+                                          void *psrc, void *pdst, uint16_t protocol, __be16 *layer4hdr,
+					  struct flow_keys *fk)
+{
+        uint32_t *src = NULL;
+        uint32_t *dst = NULL;
+
+	fk->ports = 0;
+        src = (uint32_t *)psrc;
+        dst = (uint32_t *)pdst;
+
+	if (protocol == htons(ETH_P_IP)) {
+		fk->src = src[0];
+		fk->dst = dst[0];
+	} else if (protocol == htons(ETH_P_IPV6)) {
+		fk->src = (__force __be32)bond_ipv6_addr_to_hash((const uint32_t*)src);
+		fk->dst = (__force __be32)bond_ipv6_addr_to_hash((const uint32_t*)dst);
+	} else {
+		return false;
+	}
+	if ((bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34) && (layer4hdr != NULL))
+		fk->ports = *layer4hdr;
+
+	return true;
+}
+
 /* Extract the appropriate headers based on bond's xmit policy */
 static bool bond_flow_dissect(struct bonding *bond, struct sk_buff *skb,
 			      struct flow_keys *fk)
@@ -3655,21 +3739,167 @@ static int bond_xmit_activebackup(struct
 	return NETDEV_TX_OK;
 }
 
+/*
+ * bond_xmit_hash_without_skb - Applies load balancing algorithm for a packet,
+ * to calculate hash for a given set of L2/L3 addresses. Does not
+ * calculate egress interface.
+ */
+uint32_t bond_xmit_hash_without_skb(uint8_t *src_mac, uint8_t *dst_mac, void *psrc,
+			            void *pdst, uint16_t protocol, struct net_device *bond_dev,
+				    __be16 *layer4hdr)
+{
+	struct bonding *bond = netdev_priv(bond_dev);
+	struct flow_keys flow;
+        u32 hash;
+
+	if (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER2 ||
+	    !bond_flow_dissect_without_skb(bond, src_mac, dst_mac, psrc, pdst, protocol, layer4hdr, &flow))
+		return (dst_mac[5] ^ src_mac[5]);
+
+	if (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER23)
+                hash = dst_mac[5] ^ src_mac[5];
+	else if (layer4hdr != NULL)
+		hash = (__force u32)flow.ports;
+
+	hash ^= (__force u32)flow.dst ^ (__force u32)flow.src;
+	hash ^= (hash >> 16);
+	hash ^= (hash >> 8);
+
+        return hash;
+}
+
+/*
+ * bond_xor_get_tx_dev - Calculate egress interface for a given packet for a LAG
+ * 			 that is configured in balance-xor mode
+ * @skb: pointer to skb to be egressed
+ * @src_mac: pointer to source L2 address
+ * @dst_mac: pointer to destination L2 address
+ * @src: pointer to source L3 address in network order
+ * @dst: pointer to destination L3 address in network order
+ * @protocol: L3 protocol
+ * @bond_dev: pointer to bond master device
+ *
+ * If @skb is NULL, bond_xmit_hash_without_skb is used to calculate hash using L2/L3
+ *  addresses.
+ *
+ * Returns: Either valid slave device, or NULL otherwise
+ */
+struct net_device *bond_xor_get_tx_dev(struct sk_buff *skb, uint8_t *src_mac,
+                                      uint8_t *dst_mac, void *src,
+                                      void *dst, uint16_t protocol,
+                                      struct net_device *bond_dev,
+				      __be16 *layer4hdr)
+{
+	struct bonding *bond = netdev_priv(bond_dev);
+	int slave_cnt = ACCESS_ONCE(bond->slave_cnt);
+	int slave_id = 0, i = 0;
+	struct list_head *iter;
+	struct slave *slave;
+
+        if (slave_cnt == 0) {
+                pr_debug("%s: Error: No slave is attached to the interface\n", bond_dev->name);
+                return NULL;
+        }
+
+	if (skb) {
+		slave_id = bond_xmit_hash(bond, skb, slave_cnt);
+	} else {
+		uint32_t hash;
+
+		if (bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER23
+				&& bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER2
+				&& bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER34) {
+			pr_debug("%s: Error: Unsupported hash policy for balance-XOR fast path\n", bond_dev->name);
+			return NULL;
+		}
+
+		hash = bond_xmit_hash_without_skb(src_mac, dst_mac, src, dst, protocol, bond_dev, layer4hdr);
+		slave_id = hash % slave_cnt;
+	}
+
+	i = slave_id;
+
+	/* Here we start from the slave with slave_id */
+	bond_for_each_slave_rcu(bond, slave, iter) {
+		if (--i < 0) {
+			if (slave_can_tx(slave)) {
+				return slave->dev;
+			}
+		}
+	}
+
+	/* Here we start from the first slave up to slave_id */
+	i = slave_id;
+	bond_for_each_slave_rcu(bond, slave, iter) {
+		if (--i < 0)
+			break;
+		if (slave_can_tx(slave)) {
+			return slave->dev;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * bond_get_tx_dev - Calculate egress interface for a given packet.
+ *
+ * Supports 802.3AD and balance-xor modes
+ *
+ * @skb: pointer to skb to be egressed, if valid
+ * @src_mac: pointer to source L2 address
+ * @dst_mac: pointer to destination L2 address
+ * @src: pointer to source L3 address in network order
+ * @dst: pointer to destination L3 address in network order
+ * @protocol: L3 protocol id from L2 header
+ * @bond_dev: pointer to bond master device
+ *
+ * Returns: Either valid slave device, or NULL for un-supported LAG modes
+ */
+struct net_device *bond_get_tx_dev(struct sk_buff *skb, uint8_t *src_mac,
+		                   uint8_t *dst_mac, void *src,
+		                   void *dst, uint16_t protocol,
+		                   struct net_device *bond_dev, __be16 *layer4hdr)
+{
+	struct bonding *bond = netdev_priv(bond_dev);
+
+	if (!bond) {
+		return NULL;
+	}
+
+	switch (bond->params.mode) {
+		case BOND_MODE_XOR:
+			return bond_xor_get_tx_dev(skb, src_mac, dst_mac, src, dst, protocol, bond_dev, layer4hdr);
+		case BOND_MODE_8023AD:
+			return bond_3ad_get_tx_dev(skb, src_mac, dst_mac, src, dst, protocol, bond_dev, layer4hdr);
+		default:
+			return NULL;
+	}
+}
+EXPORT_SYMBOL(bond_get_tx_dev);
+
 /* In bond_xmit_xor() , we determine the output device by using a pre-
  * determined xmit_hash_policy(), If the selected device is not enabled,
  * find the next active slave.
  */
-static int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)
+static int bond_xmit_xor(struct sk_buff *skb, struct net_device *dev)
 {
-	struct bonding *bond = netdev_priv(bond_dev);
-	int slave_cnt = ACCESS_ONCE(bond->slave_cnt);
+        struct bonding *bond = netdev_priv(dev);
+	struct net_device *outdev;
 
-	if (likely(slave_cnt))
-		bond_xmit_slave_id(bond, skb,
-				   bond_xmit_hash(bond, skb, bond->slave_cnt));
-	else
-		dev_kfree_skb_any(skb);
+        outdev = bond_xor_get_tx_dev(skb, NULL, NULL, NULL, NULL, 0, dev, NULL);
+
+	if (!outdev) {
+		goto out;
+	}
 
+        bond_dev_queue_xmit(bond, skb, outdev);
+
+        goto final;
+out:
+	/* no suitable interface, frame not sent */
+	dev_kfree_skb(skb);
+final:
 	return NETDEV_TX_OK;
 }
 
@@ -3894,6 +4124,10 @@ static void bond_destructor(struct net_d
 	struct bonding *bond = netdev_priv(bond_dev);
 	if (bond->wq)
 		destroy_workqueue(bond->wq);
+
+	if (bond->id != (~0U))
+	        clear_bit(bond->id, &bond_id_mask);
+
 	free_netdev(bond_dev);
 }
 
@@ -4454,6 +4688,7 @@ int bond_create(struct net *net, const c
 {
 	struct net_device *bond_dev;
 	int res;
+	struct bonding *bond = NULL;
 
 	rtnl_lock();
 
@@ -4476,6 +4711,14 @@ int bond_create(struct net *net, const c
 	rtnl_unlock();
 	if (res < 0)
 		bond_destructor(bond_dev);
+
+	bond = netdev_priv(bond_dev);
+        bond->id = ~0U;
+	if (bond_id_mask != (~0UL)) {
+		bond->id = (u32)ffz(bond_id_mask);
+		set_bit(bond->id, &bond_id_mask);
+	}
+
 	return res;
 }
 
Index: linux-3.14.43/drivers/net/bonding/bonding.h
===================================================================
--- linux-3.14.43.orig/drivers/net/bonding/bonding.h
+++ linux-3.14.43/drivers/net/bonding/bonding.h
@@ -257,6 +257,7 @@ struct bonding {
 	/* debugging support via debugfs */
 	struct	 dentry *debug_dir;
 #endif /* CONFIG_DEBUG_FS */
+	u32      id;
 };
 
 #define bond_slave_get_rcu(dev) \
@@ -506,6 +507,9 @@ int bond_option_arp_ip_target_rem(struct
 struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond);
 struct net_device *bond_option_active_slave_get(struct bonding *bond);
 const char *bond_slave_link_status(s8 link);
+uint32_t bond_xmit_hash_without_skb(uint8_t *src_mac, uint8_t *dst_mac, void *psrc,
+                                    void *pdst, uint16_t protocol, struct net_device *bond_dev, __be16 *layer4hdr);
+
 
 struct bond_net {
 	struct net *		net;	/* Associated network namespace */
Index: linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.c
===================================================================
--- linux-3.14.43.orig/drivers/net/ethernet/qcom/essedma/edma.c
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.c
@@ -33,10 +33,10 @@ extern int ssdk_rfs_ipct_rule_set(__be32
  * edma_alloc_tx_ring()
  *	Allocate Tx descriptors ring
  */
-static int edma_alloc_tx_ring(struct edma_common_info *c_info,
+static int edma_alloc_tx_ring(struct edma_common_info *edma_cinfo,
 		struct edma_tx_desc_ring *etdr)
 {
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 
 	/* Initialize ring */
 	etdr->size = sizeof(struct edma_sw_desc) * etdr->count;
@@ -67,10 +67,10 @@ static int edma_alloc_tx_ring(struct edm
  * edma_free_tx_ring()
  *	Free tx rings allocated by edma_alloc_tx_rings
  */
-static void edma_free_tx_ring(struct edma_common_info *c_info,
+static void edma_free_tx_ring(struct edma_common_info *edma_cinfo,
 		struct edma_tx_desc_ring *etdr)
 {
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 
 	if (likely(etdr->dma))
 		dma_free_coherent(&pdev->dev, etdr->size, etdr->hw_desc,
@@ -84,10 +84,10 @@ static void edma_free_tx_ring(struct edm
  * edma_alloc_rx_ring()
  *	allocate rx descriptor ring
  */
-static int edma_alloc_rx_ring(struct edma_common_info *c_info,
+static int edma_alloc_rx_ring(struct edma_common_info *edma_cinfo,
 		struct edma_rfd_desc_ring *erxd)
 {
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 
 	erxd->size = sizeof(struct edma_sw_desc) * erxd->count;
 	erxd->sw_next_to_fill = 0;
@@ -113,10 +113,10 @@ static int edma_alloc_rx_ring(struct edm
  * edma_free_rx_ring()
  *	Free rx ring allocated by alloc_rx_ring
  */
-static void edma_free_rx_ring(struct edma_common_info *c_info,
+static void edma_free_rx_ring(struct edma_common_info *edma_cinfo,
 		struct edma_rfd_desc_ring *rxdr)
 {
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 
 	if (likely(rxdr->dma))
 		dma_free_coherent(&pdev->dev, rxdr->size, rxdr->hw_desc,
@@ -130,56 +130,56 @@ static void edma_free_rx_ring(struct edm
  * edma_configure_tx()
  *	Configure transmission control data
  */
-static void edma_configure_tx(struct edma_common_info *c_info)
+static void edma_configure_tx(struct edma_common_info *edma_cinfo)
 {
 	u32 txq_ctrl_data;
 
 	txq_ctrl_data = (EDMA_TPD_BURST << EDMA_TXQ_NUM_TPD_BURST_SHIFT);
 	txq_ctrl_data |= EDMA_TXQ_CTRL_TPD_BURST_EN;
 	txq_ctrl_data |= (EDMA_TXF_BURST << EDMA_TXQ_TXF_BURST_NUM_SHIFT);
-	edma_write_reg(REG_TXQ_CTRL, txq_ctrl_data);
+	edma_write_reg(EDMA_REG_TXQ_CTRL, txq_ctrl_data);
 }
 
 /*
  * edma_configure_rx()
  *	configure reception control data
  */
-static void edma_configure_rx(struct edma_common_info *c_info)
+static void edma_configure_rx(struct edma_common_info *edma_cinfo)
 {
-	struct edma_hw *hw = &c_info->hw;
+	struct edma_hw *hw = &edma_cinfo->hw;
 	u32 rss_type, rx_desc1, rxq_ctrl_data;
 
 	/* Set RSS type */
 	rss_type = hw->rss_type;
-	edma_write_reg(REG_RSS_TYPE, rss_type);
+	edma_write_reg(EDMA_REG_RSS_TYPE, rss_type);
 
 	/* Set RFD burst number */
-	rx_desc1 = (EDMA_RFD_BURST << RXQ_RFD_BURST_NUM_SHIFT);
+	rx_desc1 = (EDMA_RFD_BURST << EDMA_RXQ_RFD_BURST_NUM_SHIFT);
 
 	/* Set RFD prefetch threshold */
-	rx_desc1 |= (EDMA_RFD_THR << RXQ_RFD_PF_THRESH_SHIFT);
+	rx_desc1 |= (EDMA_RFD_THR << EDMA_RXQ_RFD_PF_THRESH_SHIFT);
 
 	/* Set RFD in host ring low threshold to generte interrupt */
-	rx_desc1 |= (EDMA_RFD_LTHR << RXQ_RFD_LOW_THRESH_SHIFT);
-	edma_write_reg(REG_RX_DESC1, rx_desc1);
+	rx_desc1 |= (EDMA_RFD_LTHR << EDMA_RXQ_RFD_LOW_THRESH_SHIFT);
+	edma_write_reg(EDMA_REG_RX_DESC1, rx_desc1);
 
 	/* Set Rx FIFO threshold to start to DMA data to host */
-	rxq_ctrl_data = FIFO_THRESH_128_BYTE;
+	rxq_ctrl_data = EDMA_FIFO_THRESH_128_BYTE;
 
 	/* Set RX remove vlan bit */
-	rxq_ctrl_data |= RXQ_CTRL_RMV_VLAN;
+	rxq_ctrl_data |= EDMA_RXQ_CTRL_RMV_VLAN;
 
-	edma_write_reg(REG_RXQ_CTRL, rxq_ctrl_data);
+	edma_write_reg(EDMA_REG_RXQ_CTRL, rxq_ctrl_data);
 }
 
 /*
  * edma_alloc_rx_buf()
  *	does skb allocation for the received packets.
  */
-static __always_inline int edma_alloc_rx_buf(struct edma_common_info *c_info,
+static __always_inline int edma_alloc_rx_buf(struct edma_common_info *edma_cinfo,
 	struct edma_rfd_desc_ring *erdr, int cleaned_count, int queue_id)
 {
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 	struct edma_rx_free_desc *rx_desc;
 	struct edma_sw_desc *sw_desc;
 	struct sk_buff *skb;
@@ -197,7 +197,7 @@ static __always_inline int edma_alloc_rx
 
 	while (cleaned_count) {
 		sw_desc = &erdr->sw_desc[i];
-		length = c_info->rx_head_buffer_len;
+		length = edma_cinfo->rx_head_buffer_len;
 
 		if (sw_desc->flags & EDMA_SW_DESC_FLAG_SKB_REUSE)
 			skb = sw_desc->skb;
@@ -210,7 +210,7 @@ static __always_inline int edma_alloc_rx
 			}
 		}
 
-		if (unlikely(c_info->page_mode)) {
+		if (unlikely(edma_cinfo->page_mode)) {
 			struct page *pg = alloc_page(GFP_ATOMIC);
 			if (!pg) {
 				dev_kfree_skb_any(skb);
@@ -218,16 +218,16 @@ static __always_inline int edma_alloc_rx
 			}
 
 			sw_desc->dma = dma_map_page(&pdev->dev, pg, 0,
-				c_info->rx_page_buffer_len, DMA_FROM_DEVICE);
+				edma_cinfo->rx_page_buffer_len, DMA_FROM_DEVICE);
 			if (unlikely(dma_mapping_error(&pdev->dev, sw_desc->dma))) {
 				__free_page(pg);
 				dev_kfree_skb_any(skb);
 				break;
 			}
 
-			skb_fill_page_desc(skb, 0, pg, 0, c_info->rx_page_buffer_len);
+			skb_fill_page_desc(skb, 0, pg, 0, edma_cinfo->rx_page_buffer_len);
 			sw_desc->flags = EDMA_SW_DESC_FLAG_SKB_FRAG;
-			sw_desc->length = c_info->rx_page_buffer_len;
+			sw_desc->length = edma_cinfo->rx_page_buffer_len;
 		} else {
 			sw_desc->dma = dma_map_single(&pdev->dev, skb->data,
 				length, DMA_FROM_DEVICE);
@@ -257,10 +257,10 @@ static __always_inline int edma_alloc_rx
 		prod_idx = i - 1;
 
 	/* Update the producer index */
-	edma_read_reg(REG_RFD_IDX_Q(queue_id), &reg_data);
-	reg_data &= ~RFD_PROD_IDX_BITS;
+	edma_read_reg(EDMA_REG_RFD_IDX_Q(queue_id), &reg_data);
+	reg_data &= ~EDMA_RFD_PROD_IDX_BITS;
 	reg_data |= prod_idx;
-	edma_write_reg(REG_RFD_IDX_Q(queue_id), reg_data);
+	edma_write_reg(EDMA_REG_RFD_IDX_Q(queue_id), reg_data);
 	return cleaned_count;
 }
 
@@ -268,7 +268,7 @@ static __always_inline int edma_alloc_rx
  * edma_init_desc()
  *	update descriptor ring size, buffer and producer/consumer index
  */
-static void edma_init_desc(struct edma_common_info *c_info)
+static void edma_init_desc(struct edma_common_info *edma_cinfo)
 {
 	struct edma_rfd_desc_ring *rfd_ring;
 	struct edma_tx_desc_ring *etdr;
@@ -277,61 +277,61 @@ static void edma_init_desc(struct edma_c
 	u16 hw_cons_idx = 0;
 
 	/* Set the base address of every TPD ring. */
-	for (i = 0; i < c_info->num_tx_queues; i++) {
-		etdr = c_info->tpd_ring[i];
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
+		etdr = edma_cinfo->tpd_ring[i];
 
 		/* Update descriptor ring base address */
-		edma_write_reg(REG_TPD_BASE_ADDR_Q(i),
+		edma_write_reg(EDMA_REG_TPD_BASE_ADDR_Q(i),
 			(u32)(etdr->dma & 0xffffffff));
-		edma_read_reg(REG_TPD_IDX_Q(i), &data);
+		edma_read_reg(EDMA_REG_TPD_IDX_Q(i), &data);
 
 		/* Calculate hardware consumer index */
-		hw_cons_idx = (data >> TPD_CONS_IDX_SHIFT) & 0xffff;
+		hw_cons_idx = (data >> EDMA_TPD_CONS_IDX_SHIFT) & 0xffff;
 		etdr->sw_next_to_fill = hw_cons_idx;
 		etdr->sw_next_to_clean = hw_cons_idx;
-		data &= ~(TPD_PROD_IDX_MASK << TPD_PROD_IDX_SHIFT);
+		data &= ~(EDMA_TPD_PROD_IDX_MASK << EDMA_TPD_PROD_IDX_SHIFT);
 		data |= hw_cons_idx;
 
 		/* update producer index */
-		edma_write_reg(REG_TPD_IDX_Q(i), data);
+		edma_write_reg(EDMA_REG_TPD_IDX_Q(i), data);
 
 		/* update SW consumer index register */
-		edma_write_reg(REG_TX_SW_CONS_IDX_Q(i), hw_cons_idx);
+		edma_write_reg(EDMA_REG_TX_SW_CONS_IDX_Q(i), hw_cons_idx);
 
 		/* Set TPD ring size */
-		edma_write_reg(REG_TPD_RING_SIZE,
-			(u32)(c_info->tx_ring_count & TPD_RING_SIZE_MASK));
+		edma_write_reg(EDMA_REG_TPD_RING_SIZE,
+			(u32)(edma_cinfo->tx_ring_count & EDMA_TPD_RING_SIZE_MASK));
 	}
 
-	for (i = 0; i < c_info->num_rx_queues; i++) {
-		rfd_ring = c_info->rfd_ring[i];
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
+		rfd_ring = edma_cinfo->rfd_ring[i];
 
 		/* Update Receive Free descriptor ring base address */
-		edma_write_reg(REG_RFD_BASE_ADDR_Q(i),
+		edma_write_reg(EDMA_REG_RFD_BASE_ADDR_Q(i),
 			(u32)(rfd_ring->dma & 0xffffffff));
 
 	}
 
-	if (unlikely(c_info->page_mode))
-		data = (c_info->rx_page_buffer_len & RX_BUF_SIZE_MASK)
-				<< RX_BUF_SIZE_SHIFT;
+	if (unlikely(edma_cinfo->page_mode))
+		data = (edma_cinfo->rx_page_buffer_len & EDMA_RX_BUF_SIZE_MASK)
+				<< EDMA_RX_BUF_SIZE_SHIFT;
 	else
-		data = (c_info->rx_head_buffer_len & RX_BUF_SIZE_MASK)
-				<< RX_BUF_SIZE_SHIFT;
+		data = (edma_cinfo->rx_head_buffer_len & EDMA_RX_BUF_SIZE_MASK)
+				<< EDMA_RX_BUF_SIZE_SHIFT;
 
 	/* Update RFD ring size and RX buffer size */
-	data |= (c_info->rx_ring_count & RFD_RING_SIZE_MASK)
-			<< RFD_RING_SIZE_SHIFT;
+	data |= (edma_cinfo->rx_ring_count & EDMA_RFD_RING_SIZE_MASK)
+			<< EDMA_RFD_RING_SIZE_SHIFT;
 
-	edma_write_reg(REG_RX_DESC0, data);
+	edma_write_reg(EDMA_REG_RX_DESC0, data);
 
 	/* Disable TX FIFO low watermark and high watermark */
-	edma_write_reg(REG_TXF_WATER_MARK, 0);
+	edma_write_reg(EDMA_REG_TXF_WATER_MARK, 0);
 
 	/* Load all of base address above */
-	edma_read_reg(REG_TX_SRAM_PART, &data);
-	data |= 1 << LOAD_PTR_SHIFT;
-	edma_write_reg(REG_TX_SRAM_PART, data);
+	edma_read_reg(EDMA_REG_TX_SRAM_PART, &data);
+	data |= 1 << EDMA_LOAD_PTR_SHIFT;
+	edma_write_reg(EDMA_REG_TX_SRAM_PART, data);
 }
 
 /*
@@ -364,7 +364,11 @@ static void edma_clean_rfd(struct edma_r
 
 	rx_desc = (&((struct edma_rx_free_desc *)(erdr->hw_desc))[index]);
 	sw_desc = &erdr->sw_desc[index];
-	dev_kfree_skb_any(sw_desc->skb);
+	if (sw_desc->skb) {
+		dev_kfree_skb_any(sw_desc->skb);
+		sw_desc->skb = NULL;
+	}
+
 	memset(rx_desc, 0, sizeof(struct edma_rx_free_desc));
 }
 
@@ -372,29 +376,27 @@ static void edma_clean_rfd(struct edma_r
  * edma_rx_complete()
  *	Main api called from the poll function to process rx packets.
  */
-static void edma_rx_complete(struct edma_common_info *c_info,
+static void edma_rx_complete(struct edma_common_info *edma_cinfo,
 	int *work_done, int work_to_do, int queue_id, struct napi_struct *napi)
 {
-	u16 cleaned_count = 0, length = 0, num_rfds = 1, ret_count = 0;
-	int i = 0;
-	u16 hash_type, rrd[8];
-	volatile u32 data = 0;
-	u16 sw_next_to_clean, hw_next_to_clean = 0, vlan = 0;
-	struct platform_device *pdev = c_info->pdev;
-	struct edma_rfd_desc_ring *erdr = c_info->rfd_ring[queue_id];
+	struct platform_device *pdev = edma_cinfo->pdev;
+	struct edma_rfd_desc_ring *erdr = edma_cinfo->rfd_ring[queue_id];
 	struct net_device *netdev;
 	struct edma_adapter *adapter;
 	struct edma_sw_desc *sw_desc;
 	struct sk_buff *skb;
 	struct edma_rx_return_desc *rd;
+	u16 hash_type, rrd[8], cleaned_count = 0, length = 0, num_rfds = 1,
+	    sw_next_to_clean, hw_next_to_clean = 0, vlan = 0, ret_count = 0;
+        volatile u32 data = 0;
 	u8 *vaddr;
-	int port_id, priority, drop_count = 0;
+	int port_id, priority, i, drop_count = 0;
 	u16 count = erdr->count, rfd_avail;
 	u8 queue_to_rxid[8] = {0, 0, 1, 1, 2, 2, 3, 3};
 	sw_next_to_clean = erdr->sw_next_to_clean;
-        edma_read_reg(REG_RFD_IDX_Q(queue_id), &data);
-        hw_next_to_clean = (data >> RFD_CONS_IDX_SHIFT) &
-                        RFD_CONS_IDX_MASK;
+        edma_read_reg(EDMA_REG_RFD_IDX_Q(queue_id), &data);
+        hw_next_to_clean = (data >> EDMA_RFD_CONS_IDX_SHIFT) &
+                        EDMA_RFD_CONS_IDX_MASK;
 
 	do {
 		while (sw_next_to_clean != hw_next_to_clean) {
@@ -413,7 +415,7 @@ static void edma_rx_complete(struct edma
 					sw_desc->length, DMA_FROM_DEVICE);
 
 			/* Get RRD */
-			if (unlikely(c_info->page_mode)) {
+			if (unlikely(edma_cinfo->page_mode)) {
 				vaddr = kmap_atomic(skb_frag_page(&skb_shinfo(skb)->frags[0]));
 				memcpy((uint8_t *)&rrd[0], vaddr, 16);
 				rd = (struct edma_rx_return_desc *)rrd;
@@ -439,10 +441,10 @@ static void edma_rx_complete(struct edma
 				continue;
 			}
 
-			if (port_id == c_info->edma_port_id_wan)
-				netdev = c_info->netdev[0];
+			if (port_id == edma_cinfo->edma_port_id_wan)
+				netdev = edma_cinfo->netdev[0];
 			else
-				netdev = c_info->netdev[1];
+				netdev = edma_cinfo->netdev[1];
 			adapter = netdev_priv(netdev);
 
 			/* This code is added to handle a usecase where high priority stream
@@ -457,12 +459,8 @@ static void edma_rx_complete(struct edma
 			 */
 			priority = (rd->rrd1 >> EDMA_RRD_PRIORITY_SHIFT)
 				& EDMA_RRD_PRIORITY_MASK;
-			if (likely(!priority && !c_info->page_mode)) {
-				u32 hw_rfd_used;
-				edma_read_reg(REG_RFD_IDX_Q(queue_id), &data);
-				hw_rfd_used = (data >> RFD_CONS_IDX_SHIFT) &
-						RFD_CONS_IDX_MASK;
-				rfd_avail = (count + sw_next_to_clean - hw_rfd_used - 1) & (count - 1);
+			if (likely(!priority && !edma_cinfo->page_mode)) {
+				rfd_avail = (count + sw_next_to_clean - hw_next_to_clean - 1) & (count - 1);
 				if (rfd_avail < EDMA_RFD_AVAIL_THR) {
 					sw_desc->flags = EDMA_SW_DESC_FLAG_SKB_REUSE;
 					sw_next_to_clean = (sw_next_to_clean + 1) & (erdr->count - 1);
@@ -476,8 +474,8 @@ static void edma_rx_complete(struct edma
 					}
 					if (cleaned_count == EDMA_RX_BUFFER_WRITE) {
 						/* If buffer clean count reaches 16, we replenish HW buffers. */
-						ret_count = edma_alloc_rx_buf(c_info, erdr, cleaned_count, queue_id);
-						edma_write_reg(REG_RX_SW_CONS_IDX_Q(queue_id),
+						ret_count = edma_alloc_rx_buf(edma_cinfo, erdr, cleaned_count, queue_id);
+						edma_write_reg(EDMA_REG_RX_SW_CONS_IDX_Q(queue_id),
 							sw_next_to_clean);
 						cleaned_count = ret_count;
 					}
@@ -499,7 +497,7 @@ static void edma_rx_complete(struct edma
                         /* Get the number of RFD from RRD */
                         num_rfds = rd->rrd1 & EDMA_RRD_NUM_RFD_MASK;
 
-			if (likely(!c_info->page_mode)) {
+			if (likely(!edma_cinfo->page_mode)) {
 				/* Addition of 16 bytes is required, as in the packet
 			 	 * first 16 bytes are rrd descriptors, so actual data
 			 	 * starts from an offset of 16.
@@ -532,7 +530,7 @@ static void edma_rx_complete(struct edma
 						dma_unmap_page(&pdev->dev, sw_desc->dma,
 							sw_desc->length, DMA_FROM_DEVICE);
 
-						if (size_remaining < c_info->rx_page_buffer_len)
+						if (size_remaining < edma_cinfo->rx_page_buffer_len)
 							frag->size = size_remaining;
 
 						skb_fill_page_desc(skb, i, skb_frag_page(frag),
@@ -616,8 +614,8 @@ static void edma_rx_complete(struct edma
 			adapter->stats.rx_packets++;
 			adapter->stats.rx_bytes += length;
 			if (cleaned_count == EDMA_RX_BUFFER_WRITE) {
-				ret_count = edma_alloc_rx_buf(c_info, erdr, cleaned_count, queue_id);
-				edma_write_reg(REG_RX_SW_CONS_IDX_Q(queue_id),
+				ret_count = edma_alloc_rx_buf(edma_cinfo, erdr, cleaned_count, queue_id);
+				edma_write_reg(EDMA_REG_RX_SW_CONS_IDX_Q(queue_id),
 						sw_next_to_clean);
 				cleaned_count = ret_count;
 			}
@@ -627,9 +625,9 @@ static void edma_rx_complete(struct edma
 		if (unlikely(!work_to_do))
 			break;
 
-		edma_read_reg(REG_RFD_IDX_Q(queue_id), &data);
-		hw_next_to_clean = (data >> RFD_CONS_IDX_SHIFT) &
-			RFD_CONS_IDX_MASK;
+		edma_read_reg(EDMA_REG_RFD_IDX_Q(queue_id), &data);
+		hw_next_to_clean = (data >> EDMA_RFD_CONS_IDX_SHIFT) &
+			EDMA_RFD_CONS_IDX_MASK;
 	} while (hw_next_to_clean != sw_next_to_clean);
 
 
@@ -637,11 +635,11 @@ static void edma_rx_complete(struct edma
 
 	/* alloc_rx_buf */
 	if (likely(cleaned_count)) {
-		ret_count = edma_alloc_rx_buf(c_info, erdr, cleaned_count, queue_id);
+		ret_count = edma_alloc_rx_buf(edma_cinfo, erdr, cleaned_count, queue_id);
 		if (unlikely(ret_count))
 			dev_dbg(&pdev->dev, "Not all buffers was reallocated");
-		edma_write_reg(REG_RX_SW_CONS_IDX_Q(queue_id),
-					erdr->sw_next_to_clean);
+		edma_write_reg(EDMA_REG_RX_SW_CONS_IDX_Q(queue_id),
+				erdr->sw_next_to_clean);
 	}
 }
 
@@ -793,17 +791,17 @@ static inline void edma_tx_unmap_and_fre
  * edma_tx_complete()
  *	Used to clean tx queues and update hardware and consumer index
  */
-static void edma_tx_complete(struct edma_common_info *c_info, int queue_id)
+static void edma_tx_complete(struct edma_common_info *edma_cinfo, int queue_id)
 {
-	struct edma_tx_desc_ring *etdr = c_info->tpd_ring[queue_id];
+	struct edma_tx_desc_ring *etdr = edma_cinfo->tpd_ring[queue_id];
 	struct edma_sw_desc *sw_desc;
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 
 	u16 sw_next_to_clean = etdr->sw_next_to_clean;
 	u16 hw_next_to_clean = 0;
 	volatile u32 data = 0;
-	edma_read_reg(REG_TPD_IDX_Q(queue_id), &data);
-	hw_next_to_clean = (data >> TPD_CONS_IDX_SHIFT) & TPD_CONS_IDX_MASK;
+	edma_read_reg(EDMA_REG_TPD_IDX_Q(queue_id), &data);
+	hw_next_to_clean = (data >> EDMA_TPD_CONS_IDX_SHIFT) & EDMA_TPD_CONS_IDX_MASK;
 
 	/* clean the buffer here */
 	while (sw_next_to_clean != hw_next_to_clean) {
@@ -815,7 +813,7 @@ static void edma_tx_complete(struct edma
 	etdr->sw_next_to_clean = sw_next_to_clean;
 
 	/* update the TPD consumer index register */
-	edma_write_reg(REG_TX_SW_CONS_IDX_Q(queue_id), sw_next_to_clean);
+	edma_write_reg(EDMA_REG_TX_SW_CONS_IDX_Q(queue_id), sw_next_to_clean);
 
 	if (netif_tx_queue_stopped(etdr->nq) &&
 		netif_carrier_ok(&(etdr->netdev)))
@@ -826,10 +824,10 @@ static void edma_tx_complete(struct edma
  * edma_get_tx_buffer()
  *	Get sw_desc corresponding to the TPD
  */
-static struct edma_sw_desc *edma_get_tx_buffer(struct edma_common_info *c_info,
+static struct edma_sw_desc *edma_get_tx_buffer(struct edma_common_info *edma_cinfo,
 		struct edma_tx_desc *tpd, int queue_id)
 {
-	struct edma_tx_desc_ring *etdr = c_info->tpd_ring[queue_id];
+	struct edma_tx_desc_ring *etdr = edma_cinfo->tpd_ring[queue_id];
 	return &etdr->sw_desc[tpd - (struct edma_tx_desc *)etdr->hw_desc];
 }
 
@@ -837,10 +835,10 @@ static struct edma_sw_desc *edma_get_tx_
  * edma_get_next_tpd()
  *	Return a TPD descriptor for transfer
  */
-static struct edma_tx_desc *edma_get_next_tpd(struct edma_common_info *c_info,
+static struct edma_tx_desc *edma_get_next_tpd(struct edma_common_info *edma_cinfo,
 		int queue_id)
 {
-	struct edma_tx_desc_ring *etdr = c_info->tpd_ring[queue_id];
+	struct edma_tx_desc_ring *etdr = edma_cinfo->tpd_ring[queue_id];
 	u16 sw_next_to_fill = etdr->sw_next_to_fill;
 	struct edma_tx_desc *tpd_desc =
 		(&((struct edma_tx_desc *)(etdr->hw_desc))[sw_next_to_fill]);
@@ -854,10 +852,10 @@ static struct edma_tx_desc *edma_get_nex
  * edma_tpd_available()
  *	Check number of free TPDs
  */
-static inline u16 edma_tpd_available(struct edma_common_info *c_info,
+static inline u16 edma_tpd_available(struct edma_common_info *edma_cinfo,
 		int queue_id)
 {
-	struct edma_tx_desc_ring *etdr = c_info->tpd_ring[queue_id];
+	struct edma_tx_desc_ring *etdr = edma_cinfo->tpd_ring[queue_id];
 
 	u16 sw_next_to_fill = 0;
 	u16 sw_next_to_clean = 0;
@@ -889,19 +887,19 @@ static inline int edma_tx_queue_get(stru
  * edma_tx_update_hw_idx()
  *	update the producer index for the ring transmitted
  */
-static void edma_tx_update_hw_idx(struct edma_common_info *c_info,
+static void edma_tx_update_hw_idx(struct edma_common_info *edma_cinfo,
 		struct sk_buff *skb, int queue_id)
 {
-	struct edma_tx_desc_ring *etdr = c_info->tpd_ring[queue_id];
+	struct edma_tx_desc_ring *etdr = edma_cinfo->tpd_ring[queue_id];
 	volatile u32 tpd_idx_data;
 
 	/* Read and update the producer index */
-	edma_read_reg(REG_TPD_IDX_Q(queue_id), &tpd_idx_data);
-	tpd_idx_data &= ~TPD_PROD_IDX_BITS;
-	tpd_idx_data |= (etdr->sw_next_to_fill & TPD_PROD_IDX_MASK)
-		<< TPD_PROD_IDX_SHIFT;
+	edma_read_reg(EDMA_REG_TPD_IDX_Q(queue_id), &tpd_idx_data);
+	tpd_idx_data &= ~EDMA_TPD_PROD_IDX_BITS;
+	tpd_idx_data |= (etdr->sw_next_to_fill & EDMA_TPD_PROD_IDX_MASK)
+		<< EDMA_TPD_PROD_IDX_SHIFT;
 
-	edma_write_reg(REG_TPD_IDX_Q(queue_id), tpd_idx_data);
+	edma_write_reg(EDMA_REG_TPD_IDX_Q(queue_id), tpd_idx_data);
 }
 
 /*
@@ -911,7 +909,7 @@ static void edma_tx_update_hw_idx(struct
 static void edma_rollback_tx(struct edma_adapter *adapter,
 		struct edma_tx_desc *start_tpd, int queue_id)
 {
-	struct edma_tx_desc_ring *etdr = adapter->c_info->tpd_ring[queue_id];
+	struct edma_tx_desc_ring *etdr = adapter->edma_cinfo->tpd_ring[queue_id];
 	struct edma_sw_desc *sw_desc;
 	struct edma_tx_desc *tpd = NULL;
 	u16 start_index, index;
@@ -937,13 +935,13 @@ static void edma_rollback_tx(struct edma
  * This is where the dma of the buffer to be transmitted
  * gets mapped
  */
-static int edma_tx_map_and_fill(struct edma_common_info *c_info,
+static int edma_tx_map_and_fill(struct edma_common_info *edma_cinfo,
 	struct edma_adapter *adapter, struct sk_buff *skb, int queue_id,
 	unsigned int flags_transmit, u16 from_cpu, u16 dp_bitmap,
 	bool packet_is_rstp, int nr_frags)
 {
 	struct edma_sw_desc *sw_desc = NULL;
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 	struct edma_tx_desc *tpd, *start_tpd = NULL;
 	struct sk_buff *iter_skb;
 	int i = 0;
@@ -1015,8 +1013,8 @@ static int edma_tx_map_and_fill(struct e
 		if (lso_word1 & EDMA_TPD_LSO_V2_EN) {
 
 			/* IPv6 LSOv2 descriptor */
-			start_tpd = tpd = edma_get_next_tpd(c_info, queue_id);
-			sw_desc = edma_get_tx_buffer(c_info, tpd, queue_id);
+			start_tpd = tpd = edma_get_next_tpd(edma_cinfo, queue_id);
+			sw_desc = edma_get_tx_buffer(edma_cinfo, tpd, queue_id);
 			sw_desc->flags |= EDMA_SW_DESC_FLAG_SKB_NONE;
 
 			/* LSOv2 descriptor overrides addr field to pass length */
@@ -1026,10 +1024,10 @@ static int edma_tx_map_and_fill(struct e
 			tpd->word3 = word3;
 		}
 
-		tpd = edma_get_next_tpd(c_info, queue_id);
+		tpd = edma_get_next_tpd(edma_cinfo, queue_id);
 		if (!start_tpd)
 			start_tpd = tpd;
-		sw_desc = edma_get_tx_buffer(c_info, tpd, queue_id);
+		sw_desc = edma_get_tx_buffer(edma_cinfo, tpd, queue_id);
 
 		/* The last buffer info contain the skb address,
 		 * tso it will be free after unmap
@@ -1061,12 +1059,12 @@ static int edma_tx_map_and_fill(struct e
 	if (likely(buf_len)) {
 
 		/* TODO Do not dequeue descriptor if there is a potential error */
-		tpd = edma_get_next_tpd(c_info, queue_id);
+		tpd = edma_get_next_tpd(edma_cinfo, queue_id);
 
 		if (!start_tpd)
 			start_tpd = tpd;
 
-		sw_desc = edma_get_tx_buffer(c_info, tpd, queue_id);
+		sw_desc = edma_get_tx_buffer(edma_cinfo, tpd, queue_id);
 
 		/* The last buffer info contain the skb address,
 		 * so it will be free after unmap
@@ -1090,8 +1088,8 @@ static int edma_tx_map_and_fill(struct e
 	while (nr_frags--) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 		buf_len = skb_frag_size(frag);
-		tpd = edma_get_next_tpd(c_info, queue_id);
-		sw_desc = edma_get_tx_buffer(c_info, tpd, queue_id);
+		tpd = edma_get_next_tpd(edma_cinfo, queue_id);
+		sw_desc = edma_get_tx_buffer(edma_cinfo, tpd, queue_id);
 		sw_desc->length = buf_len;
 		sw_desc->flags |= EDMA_SW_DESC_FLAG_SKB_FRAG;
 
@@ -1112,8 +1110,8 @@ static int edma_tx_map_and_fill(struct e
 	/* Walk through all fragist skbs */
 	skb_walk_frags(skb, iter_skb) {
 		buf_len = iter_skb->len;
-		tpd = edma_get_next_tpd(c_info, queue_id);
-		sw_desc = edma_get_tx_buffer(c_info, tpd, queue_id);
+		tpd = edma_get_next_tpd(edma_cinfo, queue_id);
+		sw_desc = edma_get_tx_buffer(edma_cinfo, tpd, queue_id);
 		sw_desc->length = buf_len;
 		sw_desc->dma =  dma_map_single(&adapter->pdev->dev,
 				iter_skb->data, buf_len, DMA_TO_DEVICE);
@@ -1207,18 +1205,17 @@ netdev_tx_t edma_xmit(struct sk_buff *sk
 		struct net_device *net_dev)
 {
 	struct edma_adapter *adapter = netdev_priv(net_dev);
-	int queue_id = 0;
-	struct edma_common_info *c_info = adapter->c_info;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 	struct edma_tx_desc_ring *etdr;
-	u16 txq_id, from_cpu, dp_bitmap;
-	int ret, nr_frags = 0, num_tpds_needed = 1;
+	u16 from_cpu, dp_bitmap, txq_id;
+	int ret, nr_frags = 0, num_tpds_needed = 1, queue_id = 0;
 	unsigned int flags_transmit = 0;
 	bool packet_is_rstp = false;
 
-	if (skb_shinfo(skb)->nr_frags) {
+	if (unlikely(skb_shinfo(skb)->nr_frags)) {
 		nr_frags = skb_shinfo(skb)->nr_frags;
 		num_tpds_needed += nr_frags;
-	} else if (skb_has_frag_list(skb)) {
+	} else if (unlikely(skb_has_frag_list(skb))) {
 		struct sk_buff *iter_skb;
 
 		skb_walk_frags(skb, iter_skb)
@@ -1239,7 +1236,7 @@ netdev_tx_t edma_xmit(struct sk_buff *sk
 		u8 mac_addr[EDMA_ETH_HDR_LEN];
 		int i;
 		ath_eth_type = ntohs(*(uint16_t *)&skb->data[12]);
-		if (ath_eth_type == edma_ath_eth_type) {
+		if (unlikely(ath_eth_type == edma_ath_eth_type)) {
 			packet_is_rstp = true;
 			ath_hdr = htons(*(uint16_t *)&skb->data[14]);
 			dp_bitmap = ath_hdr & EDMA_TX_ATH_HDR_PORT_BITMAP_MASK;
@@ -1251,16 +1248,13 @@ netdev_tx_t edma_xmit(struct sk_buff *sk
 
 			for (i = 0; i < EDMA_ETH_HDR_LEN; i++)
 				skb->data[i] = mac_addr[i];
-		} else {
-			dev_dbg(&adapter->pdev->dev, "atheros ether type not matched\n");
 		}
 	}
 
 	/* this will be one of the 4 TX queues exposed to linux kernel */
 	txq_id = skb_get_queue_mapping(skb);
-
 	queue_id = edma_tx_queue_get(adapter, skb, txq_id);
-	etdr = c_info->tpd_ring[queue_id];
+	etdr = edma_cinfo->tpd_ring[queue_id];
         etdr->nq = netdev_get_tx_queue(net_dev, txq_id);
 
 	/* Tx is not handled in bottom half context. Hence, we need to protect
@@ -1268,17 +1262,17 @@ netdev_tx_t edma_xmit(struct sk_buff *sk
 	 */
 	local_bh_disable();
 
-	if (unlikely(num_tpds_needed > edma_tpd_available(c_info, queue_id))) {
+	if (unlikely(num_tpds_needed > edma_tpd_available(edma_cinfo, queue_id))) {
 		/* not enough descriptor, just stop queue */
 		netif_tx_stop_queue(etdr->nq);
 		local_bh_enable();
 		dev_dbg(&net_dev->dev, "Not enough descriptors available");
-		c_info->edma_ethstats.tx_desc_error++;
+		edma_cinfo->edma_ethstats.tx_desc_error++;
 		return NETDEV_TX_BUSY;
 	}
 
 	/* Check and mark VLAN tag offload */
-	if (vlan_tx_tag_present(skb))
+	if (unlikely(vlan_tx_tag_present(skb)))
 		flags_transmit |= EDMA_VLAN_TX_TAG_INSERT_FLAG;
 	else if (adapter->default_vlan_tag)
 		flags_transmit |= EDMA_VLAN_TX_TAG_INSERT_DEFAULT_FLAG;
@@ -1288,7 +1282,7 @@ netdev_tx_t edma_xmit(struct sk_buff *sk
 		flags_transmit |= EDMA_HW_CHECKSUM;
 
 	/* Map and fill descriptor for Tx */
-	ret = edma_tx_map_and_fill(c_info, adapter, skb, queue_id,
+	ret = edma_tx_map_and_fill(edma_cinfo, adapter, skb, queue_id,
 		flags_transmit, from_cpu, dp_bitmap, packet_is_rstp, nr_frags);
 	if (unlikely(ret)) {
 		dev_kfree_skb_any(skb);
@@ -1297,7 +1291,7 @@ netdev_tx_t edma_xmit(struct sk_buff *sk
 	}
 
 	/* Update SW producer index */
-	edma_tx_update_hw_idx(c_info, skb, queue_id);
+	edma_tx_update_hw_idx(edma_cinfo, skb, queue_id);
 
 	/* update tx statistics */
 	adapter->stats.tx_packets++;
@@ -1464,64 +1458,79 @@ int edma_register_rfs_filter(struct net_
 /* edma_select_xps_queue()
  *	Called by Linux TX stack to populate Linux TX queue
  */
-int edma_select_xps_queue(struct net_device *dev, struct sk_buff *skb,
+u16 edma_select_xps_queue(struct net_device *dev, struct sk_buff *skb,
 		void *accel_priv, select_queue_fallback_t fallback)
 {
 	return smp_processor_id();
 }
 
 /*
- * edma_get_default_vlan_tag()
- *	Used by other modules to get the default vlan tag
+ * edma_alloc_tx_rings()
+ *	Allocate rx rings
  */
-int edma_get_default_vlan_tag(struct net_device *netdev)
+int edma_alloc_tx_rings(struct edma_common_info *edma_cinfo)
 {
-	struct edma_adapter *adapter = netdev_priv(netdev);
+	struct platform_device *pdev = edma_cinfo->pdev;
+	int i, err = 0;
 
-	if (adapter->default_vlan_tag)
-		return adapter->default_vlan_tag;
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
+		err = edma_alloc_tx_ring(edma_cinfo, edma_cinfo->tpd_ring[i]);
+		if (err) {
+			dev_err(&pdev->dev, "Tx Queue alloc %u failed\n", i);
+			return err;
+		}
+	}
 
 	return 0;
 }
 
 /*
- * edma_free_queues()
- *	Free the queues allocaated
+ * edma_free_tx_rings()
+ *	Free tx rings
  */
-void edma_free_queues(struct edma_common_info *c_info)
+void edma_free_tx_rings(struct edma_common_info *edma_cinfo)
 {
 	int i;
 
-	for (i = 0; i < c_info->num_tx_queues; i++) {
-		if (c_info->tpd_ring[i])
-			kfree(c_info->tpd_ring[i]);
-		c_info->tpd_ring[i] = NULL;
-	}
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+		edma_free_tx_ring(edma_cinfo, edma_cinfo->tpd_ring[i]);
+}
 
-	for (i = 0; i < c_info->num_rx_queues; i++) {
-		if (c_info->rfd_ring[i])
-			kfree(c_info->rfd_ring[i]);
-		c_info->rfd_ring[i] = NULL;
-	}
+/*
+ * edma_free_tx_resources()
+ *	Free buffers associated with tx rings
+ */
+void edma_free_tx_resources(struct edma_common_info *edma_cinfo)
+{
+	struct edma_tx_desc_ring *etdr;
+	struct edma_sw_desc *sw_desc;
+	struct platform_device *pdev = edma_cinfo->pdev;
+	int i, j;
 
-	c_info->num_rx_queues = 0;
-	c_info->num_tx_queues = 0;
-	return;
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
+		etdr = edma_cinfo->tpd_ring[i];
+		for (j = 0; j < EDMA_TX_RING_SIZE; j++) {
+			sw_desc = &etdr->sw_desc[j];
+			if (sw_desc->flags & (EDMA_SW_DESC_FLAG_SKB_HEAD |
+				EDMA_SW_DESC_FLAG_SKB_FRAG | EDMA_SW_DESC_FLAG_SKB_FRAGLIST))
+				edma_tx_unmap_and_free(pdev, sw_desc);
+		}
+	}
 }
 
 /*
- * edma_alloc_tx_rings()
+ * edma_alloc_rx_rings()
  *	Allocate rx rings
  */
-int edma_alloc_tx_rings(struct edma_common_info *c_info)
+int edma_alloc_rx_rings(struct edma_common_info *edma_cinfo)
 {
-	struct platform_device *pdev = c_info->pdev;
+	struct platform_device *pdev = edma_cinfo->pdev;
 	int i, err = 0;
 
-	for (i = 0; i < c_info->num_tx_queues; i++) {
-		err = edma_alloc_tx_ring(c_info, c_info->tpd_ring[i]);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
+		err = edma_alloc_rx_ring(edma_cinfo, edma_cinfo->rfd_ring[i]);
 		if (err) {
-			dev_err(&pdev->dev, "Tx Queue alloc %u failed\n", i);
+			dev_err(&pdev->dev, "Rx Queue alloc%u failed\n", i);
 			return err;
 		}
 	}
@@ -1530,69 +1539,91 @@ int edma_alloc_tx_rings(struct edma_comm
 }
 
 /*
- * edma_free_tx_rings()
- *	Free tx rings
+ * edma_free_rx_rings()
+ *	free rx rings
  */
-void edma_free_tx_rings(struct edma_common_info *c_info)
+void edma_free_rx_rings(struct edma_common_info *edma_cinfo)
 {
 	int i;
 
-	for (i = 0; i < c_info->num_tx_queues; i++)
-		edma_free_tx_ring(c_info, c_info->tpd_ring[i]);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
+		edma_free_rx_ring(edma_cinfo, edma_cinfo->rfd_ring[i]);
 }
 
 /*
- * edma_alloc_rx_rings()
- *	Allocate rx rings
+ * edma_free_queues()
+ *	Free the queues allocaated
  */
-int edma_alloc_rx_rings(struct edma_common_info *c_info)
+void edma_free_queues(struct edma_common_info *edma_cinfo)
 {
-	struct platform_device *pdev = c_info->pdev;
-	int i, err = 0;
+	int i;
 
-	for (i = 0; i < c_info->num_rx_queues; i++) {
-		err = edma_alloc_rx_ring(c_info, c_info->rfd_ring[i]);
-		if (err) {
-			dev_err(&pdev->dev, "Rx Queue alloc%u failed\n", i);
-			return err;
-		}
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
+		if (edma_cinfo->tpd_ring[i])
+			kfree(edma_cinfo->tpd_ring[i]);
+		edma_cinfo->tpd_ring[i] = NULL;
 	}
 
-	return 0;
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
+		if (edma_cinfo->rfd_ring[i])
+			kfree(edma_cinfo->rfd_ring[i]);
+		edma_cinfo->rfd_ring[i] = NULL;
+	}
+
+	edma_cinfo->num_rx_queues = 0;
+	edma_cinfo->num_tx_queues = 0;
+
+	return;
 }
 
 /*
- * edma_free_rx_rings()
- *	free rx rings
+ * edma_free_rx_resources()
+ *	Free buffers associated with tx rings
  */
-void edma_free_rx_rings(struct edma_common_info *c_info)
+void edma_free_rx_resources(struct edma_common_info *edma_cinfo)
 {
-	int i;
+        struct edma_rfd_desc_ring *erdr;
+	struct edma_sw_desc *sw_desc;
+	struct platform_device *pdev = edma_cinfo->pdev;
+	int i, j;
 
-	for (i = 0; i < c_info->num_rx_queues; i++)
-		edma_free_rx_ring(c_info, c_info->rfd_ring[i]);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
+		erdr = edma_cinfo->rfd_ring[i];
+		for (j = 0; j < EDMA_RX_RING_SIZE; j++) {
+			sw_desc = &erdr->sw_desc[j];
+			if (likely(sw_desc->flags & EDMA_SW_DESC_FLAG_SKB_HEAD)) {
+				dma_unmap_single(&pdev->dev, sw_desc->dma,
+					sw_desc->length, DMA_FROM_DEVICE);
+				edma_clean_rfd(erdr, j);
+			} else if ((sw_desc->flags & EDMA_SW_DESC_FLAG_SKB_FRAG)) {
+				dma_unmap_page(&pdev->dev, sw_desc->dma,
+					sw_desc->length, DMA_FROM_DEVICE);
+				edma_clean_rfd(erdr, j);
+			}
+		}
+	}
 }
 
 /*
  * edma_alloc_queues_tx()
  *	Allocate memory for all rings
  */
-int edma_alloc_queues_tx(struct edma_common_info *c_info)
+int edma_alloc_queues_tx(struct edma_common_info *edma_cinfo)
 {
 	int i;
 
-	for (i = 0; i < c_info->num_tx_queues; i++) {
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
 		struct edma_tx_desc_ring *etdr;
 		etdr = kzalloc(sizeof(struct edma_tx_desc_ring), GFP_KERNEL);
 		if (!etdr)
 			goto err;
-		etdr->count = c_info->tx_ring_count;
-		c_info->tpd_ring[i] = etdr;
+		etdr->count = edma_cinfo->tx_ring_count;
+		edma_cinfo->tpd_ring[i] = etdr;
 	}
 
 	return 0;
 err:
-	edma_free_queues(c_info);
+	edma_free_queues(edma_cinfo);
 	return -1;
 }
 
@@ -1600,22 +1631,22 @@ err:
  * edma_alloc_queues_rx()
  *	Allocate memory for all rings
  */
-int edma_alloc_queues_rx(struct edma_common_info *c_info)
+int edma_alloc_queues_rx(struct edma_common_info *edma_cinfo)
 {
 	int i;
 
-	for (i = 0; i < c_info->num_rx_queues; i++) {
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
 		struct edma_rfd_desc_ring *rfd_ring;
 		rfd_ring = kzalloc(sizeof(struct edma_rfd_desc_ring),
 				GFP_KERNEL);
 		if (!rfd_ring)
 			goto err;
-		rfd_ring->count = c_info->rx_ring_count;
-		c_info->rfd_ring[i] = rfd_ring;
+		rfd_ring->count = edma_cinfo->rx_ring_count;
+		edma_cinfo->rfd_ring[i] = rfd_ring;
 	}
 	return 0;
 err:
-	edma_free_queues(c_info);
+	edma_free_queues(edma_cinfo);
 	return -1;
 }
 
@@ -1623,103 +1654,43 @@ err:
  * edma_configure()
  *	Configure skb, edma interrupts and control register.
  */
-int edma_configure(struct edma_common_info *c_info)
+int edma_configure(struct edma_common_info *edma_cinfo)
 {
-	struct edma_hw *hw = &c_info->hw;
+	struct edma_hw *hw = &edma_cinfo->hw;
 	u32 intr_modrt_data;
 	u32 intr_ctrl_data = 0;
 	int i, ret_count;
 
-	edma_read_reg(REG_INTR_CTRL, &intr_ctrl_data);
-	intr_ctrl_data &= ~(1 << INTR_SW_IDX_W_TYP_SHIFT);
-	intr_ctrl_data |= hw->intr_sw_idx_w << INTR_SW_IDX_W_TYP_SHIFT;
-	edma_write_reg(REG_INTR_CTRL, intr_ctrl_data);
+	edma_read_reg(EDMA_REG_INTR_CTRL, &intr_ctrl_data);
+	intr_ctrl_data &= ~(1 << EDMA_INTR_SW_IDX_W_TYP_SHIFT);
+	intr_ctrl_data |= hw->intr_sw_idx_w << EDMA_INTR_SW_IDX_W_TYP_SHIFT;
+	edma_write_reg(EDMA_REG_INTR_CTRL, intr_ctrl_data);
 
 	/* clear interrupt status */
-	edma_write_reg(REG_RX_ISR, 0xff);
-	edma_write_reg(REG_TX_ISR, 0xffff);
-	edma_write_reg(REG_MISC_ISR, 0x1fff);
-	edma_write_reg(REG_WOL_ISR, 0x1);
+	edma_write_reg(EDMA_REG_RX_ISR, 0xff);
+	edma_write_reg(EDMA_REG_TX_ISR, 0xffff);
+	edma_write_reg(EDMA_REG_MISC_ISR, 0x1fff);
+	edma_write_reg(EDMA_REG_WOL_ISR, 0x1);
 
 	/* Clear any WOL status */
-	edma_write_reg(REG_WOL_CTRL, 0);
-	intr_modrt_data = (EDMA_TX_IMT << IRQ_MODRT_TX_TIMER_SHIFT);
-	intr_modrt_data |= (EDMA_RX_IMT << IRQ_MODRT_RX_TIMER_SHIFT);
-	edma_write_reg(REG_IRQ_MODRT_TIMER_INIT, intr_modrt_data);
-	edma_configure_tx(c_info);
-	edma_configure_rx(c_info);
+	edma_write_reg(EDMA_REG_WOL_CTRL, 0);
+	intr_modrt_data = (EDMA_TX_IMT << EDMA_IRQ_MODRT_TX_TIMER_SHIFT);
+	intr_modrt_data |= (EDMA_RX_IMT << EDMA_IRQ_MODRT_RX_TIMER_SHIFT);
+	edma_write_reg(EDMA_REG_IRQ_MODRT_TIMER_INIT, intr_modrt_data);
+	edma_configure_tx(edma_cinfo);
+	edma_configure_rx(edma_cinfo);
 
 	/* Allocate the RX buffer */
-	for (i = 0; i < c_info->num_rx_queues; i++) {
-		struct edma_rfd_desc_ring *ring = c_info->rfd_ring[i];
-		ret_count = edma_alloc_rx_buf(c_info, ring, ring->count, i);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++) {
+		struct edma_rfd_desc_ring *ring = edma_cinfo->rfd_ring[i];
+		ret_count = edma_alloc_rx_buf(edma_cinfo, ring, ring->count, i);
 		if (ret_count) {
-			dev_dbg(&c_info->pdev->dev, "not all rx buffers allocated\n");
+			dev_dbg(&edma_cinfo->pdev->dev, "not all rx buffers allocated\n");
 		}
 	}
 
 	/* Configure descriptor Ring */
-	edma_init_desc(c_info);
-	return 0;
-}
-
-/*
- * edma_open()
- *	gets called when netdevice is up, start the queue.
- */
-int edma_open(struct net_device *netdev)
-{
-	struct edma_adapter *adapter = netdev_priv(netdev);
-	struct platform_device *pdev = adapter->c_info->pdev;
-
-	netif_tx_start_all_queues(netdev);
-	edma_initialise_rfs_flow_table(adapter);
-	set_bit(__EDMA_UP, &adapter->state_flags);
-
-	/* if Link polling is enabled, in our case enabled for WAN, then
-	 * do a phy start, else always set link as UP
-	 */
-	if (adapter->poll_required) {
-		if (!IS_ERR(adapter->phydev)) {
-			genphy_resume(adapter->phydev);
-			phy_start(adapter->phydev);
-			phy_start_aneg(adapter->phydev);
-			adapter->link_state = __EDMA_LINKDOWN;
-		} else {
-			dev_dbg(&pdev->dev, "Invalid PHY device for a link polled interface\n");
-		}
-		return;
-	} else {
-		adapter->link_state = __EDMA_LINKUP;
-		netif_carrier_on(netdev);
-	}
-
-	return 0;
-}
-
-/*
- * edma_close()
- *	gets called when netdevice is down, stops the queue.
- */
-int edma_close(struct net_device *netdev)
-{
-	struct edma_adapter *adapter = netdev_priv(netdev);
-
-	edma_free_rfs_flow_table(adapter);
-	netif_carrier_off(netdev);
-	netif_tx_stop_all_queues(netdev);
-
-	if (adapter->poll_required) {
-		if (!IS_ERR(adapter->phydev))
-			phy_stop(adapter->phydev);
-	}
-
-	adapter->link_state = __EDMA_LINKDOWN;
-
-	/* Set GMAC state to UP before link state is checked
-	 */
-	clear_bit(__EDMA_UP, &adapter->state_flags);
-
+	edma_init_desc(edma_cinfo);
 	return 0;
 }
 
@@ -1727,33 +1698,33 @@ int edma_close(struct net_device *netdev
  * edma_irq_enable()
  *	Enable default interrupt generation settings
  */
-void edma_irq_enable(struct edma_common_info *c_info)
+void edma_irq_enable(struct edma_common_info *edma_cinfo)
 {
-	struct edma_hw *hw = &c_info->hw;
+	struct edma_hw *hw = &edma_cinfo->hw;
 	int i;
 
-	edma_write_reg(REG_RX_ISR, 0xFF);
-	for (i = 0; i < c_info->num_rx_queues; i++)
-		edma_write_reg(REG_RX_INT_MASK_Q(i), hw->rx_intr_mask);
-	edma_write_reg(REG_TX_ISR, 0xFFFF);
-	for (i = 0; i < c_info->num_tx_queues; i++)
-		edma_write_reg(REG_TX_INT_MASK_Q(i), hw->tx_intr_mask);
+	edma_write_reg(EDMA_REG_RX_ISR, 0xFF);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
+		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(i), hw->rx_intr_mask);
+	edma_write_reg(EDMA_REG_TX_ISR, 0xFFFF);
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(i), hw->tx_intr_mask);
 }
 
 /*
  * edma_irq_disable()
  *	Disable Interrupt
  */
-void edma_irq_disable(struct edma_common_info *c_info)
+void edma_irq_disable(struct edma_common_info *edma_cinfo)
 {
 	int i;
 
-	for (i = 0; i < c_info->num_rx_queues; i++)
-		edma_write_reg(REG_RX_INT_MASK_Q(i), 0x0);
-	for (i = 0; i < c_info->num_tx_queues; i++)
-		edma_write_reg(REG_TX_INT_MASK_Q(i), 0x0);
-	edma_write_reg(REG_MISC_IMR, 0);
-	edma_write_reg(REG_WOL_IMR, 0);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
+		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(i), 0x0);
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(i), 0x0);
+	edma_write_reg(EDMA_REG_MISC_IMR, 0);
+	edma_write_reg(EDMA_REG_WOL_IMR, 0);
 }
 
 /*
@@ -1762,15 +1733,15 @@ void edma_irq_disable(struct edma_common
  */
 void edma_free_irqs(struct edma_adapter *adapter)
 {
-	struct edma_common_info *c_info = adapter->c_info;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 	int i, j;
 
 	for (i = 0; i < EDMA_NR_CPU; i++) {
-		for (j = c_info->q_cinfo[i].tx_start; j < (c_info->q_cinfo[i].tx_start + 4); j++)
-			free_irq(c_info->tx_irq[j], adapter->netdev);
+		for (j = edma_cinfo->edma_percpu_info[i].tx_start; j < (edma_cinfo->edma_percpu_info[i].tx_start + 4); j++)
+			free_irq(edma_cinfo->tx_irq[j], adapter->netdev);
 
-		for (j = c_info->q_cinfo[i].rx_start; j < (c_info->q_cinfo[i].rx_start + 2); j++)
-			free_irq(c_info->rx_irq[j], adapter->netdev);
+		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < (edma_cinfo->edma_percpu_info[i].rx_start + 2); j++)
+			free_irq(edma_cinfo->rx_irq[j], adapter->netdev);
 	}
 }
 
@@ -1782,9 +1753,9 @@ void edma_enable_rx_ctrl(struct edma_hw
 {
 	volatile u32 data;
 
-	edma_read_reg(REG_RXQ_CTRL, &data);
-	data |= RXQ_CTRL_EN;
-	edma_write_reg(REG_RXQ_CTRL, data);
+	edma_read_reg(EDMA_REG_RXQ_CTRL, &data);
+	data |= EDMA_RXQ_CTRL_EN;
+	edma_write_reg(EDMA_REG_RXQ_CTRL, data);
 }
 
 /*
@@ -1795,9 +1766,9 @@ void edma_enable_tx_ctrl(struct edma_hw
 {
 	volatile u32 data;
 
-	edma_read_reg(REG_TXQ_CTRL, &data);
-	data |= TXQ_CTRL_TXQ_EN;
-	edma_write_reg(REG_TXQ_CTRL, data);
+	edma_read_reg(EDMA_REG_TXQ_CTRL, &data);
+	data |= EDMA_TXQ_CTRL_TXQ_EN;
+	edma_write_reg(EDMA_REG_TXQ_CTRL, data);
 }
 
 /*
@@ -1808,33 +1779,33 @@ void edma_stop_rx_tx(struct edma_hw *hw)
 {
 	volatile u32 data;
 
-	edma_read_reg(REG_RXQ_CTRL, &data);
-	data &= ~RXQ_CTRL_EN;
-	edma_write_reg(REG_RXQ_CTRL, data);
-	edma_read_reg(REG_TXQ_CTRL, &data);
-	data &= ~TXQ_CTRL_TXQ_EN;
-	edma_write_reg(REG_TXQ_CTRL, data);
+	edma_read_reg(EDMA_REG_RXQ_CTRL, &data);
+	data &= ~EDMA_RXQ_CTRL_EN;
+	edma_write_reg(EDMA_REG_RXQ_CTRL, data);
+	edma_read_reg(EDMA_REG_TXQ_CTRL, &data);
+	data &= ~EDMA_TXQ_CTRL_TXQ_EN;
+	edma_write_reg(EDMA_REG_TXQ_CTRL, data);
 }
 
 /*
  * edma_reset()
  *	Reset the EDMA
  */
-int edma_reset(struct edma_common_info *c_info)
+int edma_reset(struct edma_common_info *edma_cinfo)
 {
-	struct edma_hw *hw = &c_info->hw;
+	struct edma_hw *hw = &edma_cinfo->hw;
 	int i;
 
-	for (i = 0; i < c_info->num_rx_queues; i++)
-		edma_write_reg(REG_RX_INT_MASK_Q(i), 0);
-	for (i = 0; i < c_info->num_tx_queues; i++)
-		edma_write_reg(REG_TX_INT_MASK_Q(i), 0);
-	edma_write_reg(REG_MISC_IMR, 0);
-	edma_write_reg(REG_WOL_IMR, 0);
-	edma_write_reg(REG_RX_ISR, 0xff);
-	edma_write_reg(REG_TX_ISR, 0xffff);
-	edma_write_reg(REG_MISC_ISR, 0x1fff);
-	edma_write_reg(REG_WOL_ISR, 0x1);
+	for (i = 0; i < edma_cinfo->num_rx_queues; i++)
+		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(i), 0);
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(i), 0);
+	edma_write_reg(EDMA_REG_MISC_IMR, 0);
+	edma_write_reg(EDMA_REG_WOL_IMR, 0);
+	edma_write_reg(EDMA_REG_RX_ISR, 0xff);
+	edma_write_reg(EDMA_REG_TX_ISR, 0xffff);
+	edma_write_reg(EDMA_REG_MISC_ISR, 0x1fff);
+	edma_write_reg(EDMA_REG_WOL_ISR, 0x1);
 
 	edma_stop_rx_tx(hw);
 
@@ -1845,11 +1816,11 @@ int edma_reset(struct edma_common_info *
  * edma_fill_netdev()
  * 	Fill netdev for each etdr
  */
-void edma_fill_netdev(struct edma_common_info *c_info, int queue_id, int dev)
+void edma_fill_netdev(struct edma_common_info *edma_cinfo, int queue_id, int dev)
 {
 	struct edma_tx_desc_ring *etdr;
 
-	etdr = c_info->tpd_ring[queue_id];
+	etdr = edma_cinfo->tpd_ring[queue_id];
 	etdr->netdev = *netdev[dev];
 }
 
@@ -1860,13 +1831,13 @@ void edma_fill_netdev(struct edma_common
 int edma_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
-	struct edma_common_info *c_info = adapter->c_info;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 	int old_mtu = netdev->mtu;
 	int max_frame_size = new_mtu + ETH_HLEN + ETH_FCS_LEN + (2 * VLAN_HLEN);
 
 	if ((max_frame_size < ETH_ZLEN + ETH_FCS_LEN) ||
 		(max_frame_size > EDMA_MAX_JUMBO_FRAME_SIZE)) {
-			dev_err(&c_info->pdev->dev, "MTU setting not correct\n");
+			dev_err(&edma_cinfo->pdev->dev, "MTU setting not correct\n");
 			return -EINVAL;
 	}
 
@@ -1916,6 +1887,80 @@ void edma_assign_ath_hdr_type(int eth_ty
 }
 
 /*
+ * edma_get_default_vlan_tag()
+ *	Used by other modules to get the default vlan tag
+ */
+int edma_get_default_vlan_tag(struct net_device *netdev)
+{
+	struct edma_adapter *adapter = netdev_priv(netdev);
+
+	if (adapter->default_vlan_tag)
+		return adapter->default_vlan_tag;
+
+	return 0;
+}
+
+/*
+ * edma_open()
+ *	gets called when netdevice is up, start the queue.
+ */
+int edma_open(struct net_device *netdev)
+{
+	struct edma_adapter *adapter = netdev_priv(netdev);
+	struct platform_device *pdev = adapter->edma_cinfo->pdev;
+
+	netif_tx_start_all_queues(netdev);
+	edma_initialise_rfs_flow_table(adapter);
+	set_bit(__EDMA_UP, &adapter->state_flags);
+
+	/* if Link polling is enabled, in our case enabled for WAN, then
+	 * do a phy start, else always set link as UP
+	 */
+	if (adapter->poll_required) {
+		if (!IS_ERR(adapter->phydev)) {
+			genphy_resume(adapter->phydev);
+			phy_start(adapter->phydev);
+			phy_start_aneg(adapter->phydev);
+			adapter->link_state = __EDMA_LINKDOWN;
+		} else {
+			dev_dbg(&pdev->dev, "Invalid PHY device for a link polled interface\n");
+		}
+		return;
+	} else {
+		adapter->link_state = __EDMA_LINKUP;
+		netif_carrier_on(netdev);
+	}
+
+	return 0;
+}
+
+/*
+ * edma_close()
+ *	gets called when netdevice is down, stops the queue.
+ */
+int edma_close(struct net_device *netdev)
+{
+	struct edma_adapter *adapter = netdev_priv(netdev);
+
+	edma_free_rfs_flow_table(adapter);
+	netif_carrier_off(netdev);
+	netif_tx_stop_all_queues(netdev);
+
+	if (adapter->poll_required) {
+		if (!IS_ERR(adapter->phydev))
+			phy_stop(adapter->phydev);
+	}
+
+	adapter->link_state = __EDMA_LINKDOWN;
+
+	/* Set GMAC state to UP before link state is checked
+	 */
+	clear_bit(__EDMA_UP, &adapter->state_flags);
+
+	return 0;
+}
+
+/*
  * edma_poll
  *	polling function that gets called when the napi gets scheduled.
  *
@@ -1925,9 +1970,9 @@ void edma_assign_ath_hdr_type(int eth_ty
  */
 int edma_poll(struct napi_struct *napi, int budget)
 {
-	struct queue_per_cpu_info *q_cinfo = container_of(napi,
-		struct queue_per_cpu_info, napi);
-	struct edma_common_info *c_info = q_cinfo->c_info;
+	struct edma_per_cpu_queues_info *edma_percpu_info = container_of(napi,
+		struct edma_per_cpu_queues_info, napi);
+	struct edma_common_info *edma_cinfo = edma_percpu_info->edma_cinfo;
 	volatile u32 reg_data;
 	u32 shadow_rx_status, shadow_tx_status;
 	int queue_id;
@@ -1936,40 +1981,40 @@ int edma_poll(struct napi_struct *napi,
 	/* Store the Rx/Tx status by ANDing it with
 	 * appropriate CPU RX?TX mask
 	 */
-	edma_read_reg(REG_RX_ISR, &reg_data);
-	q_cinfo->rx_status |= reg_data & q_cinfo->rx_mask;
-	shadow_rx_status = q_cinfo->rx_status;
-	edma_read_reg(REG_TX_ISR, &reg_data);
-	q_cinfo->tx_status |= reg_data & q_cinfo->tx_mask;
-	shadow_tx_status = q_cinfo->tx_status;
+	edma_read_reg(EDMA_REG_RX_ISR, &reg_data);
+	edma_percpu_info->rx_status |= reg_data & edma_percpu_info->rx_mask;
+	shadow_rx_status = edma_percpu_info->rx_status;
+	edma_read_reg(EDMA_REG_TX_ISR, &reg_data);
+	edma_percpu_info->tx_status |= reg_data & edma_percpu_info->tx_mask;
+	shadow_tx_status = edma_percpu_info->tx_status;
 
 	/* Every core will have a start, which will be computed
-	 * in probe and stored in q_cinfo->tx_start variable.
+	 * in probe and stored in edma_percpu_info->tx_start variable.
 	 * We will shift the status bit by tx_start to obtain
 	 * status bits for the core on which the current processing
 	 * is happening. Since, there are 4 tx queues per core,
 	 * we will run the loop till we get the correct queue to clear.
 	 */
-	while (q_cinfo->tx_status) {
-		queue_id = ffs(q_cinfo->tx_status) - 1;
-		edma_tx_complete(c_info, queue_id);
-		q_cinfo->tx_status &= ~(1 << queue_id);
+	while (edma_percpu_info->tx_status) {
+		queue_id = ffs(edma_percpu_info->tx_status) - 1;
+		edma_tx_complete(edma_cinfo, queue_id);
+		edma_percpu_info->tx_status &= ~(1 << queue_id);
 	}
 
 	/* Every core will have a start, which will be computed
-	 * in probe and stored in q_cinfo->tx_start variable.
+	 * in probe and stored in edma_percpu_info->tx_start variable.
 	 * We will shift the status bit by tx_start to obtain
 	 * status bits for the core on which the current processing
 	 * is happening. Since, there are 4 tx queues per core, we
 	 * will run the loop till we get the correct queue to clear.
 	 */
-	while (q_cinfo->rx_status) {
-		queue_id = ffs(q_cinfo->rx_status) - 1;
-		edma_rx_complete(c_info, &work_done,
+	while (edma_percpu_info->rx_status) {
+		queue_id = ffs(edma_percpu_info->rx_status) - 1;
+		edma_rx_complete(edma_cinfo, &work_done,
 			budget, queue_id, napi);
 
 		if (likely(work_done < budget))
-			q_cinfo->rx_status &= ~(1 << queue_id);
+			edma_percpu_info->rx_status &= ~(1 << queue_id);
 		else
 			break;
 	}
@@ -1980,8 +2025,8 @@ int edma_poll(struct napi_struct *napi,
 	 * once the  producer/consumer index has been updated to
 	 * reflect that the packet transmission/reception went fine.
 	 */
-	edma_write_reg(REG_RX_ISR, shadow_rx_status);
-	edma_write_reg(REG_TX_ISR, shadow_tx_status);
+	edma_write_reg(EDMA_REG_RX_ISR, shadow_rx_status);
+	edma_write_reg(EDMA_REG_TX_ISR, shadow_tx_status);
 
 	/* If budget not fully consumed, exit the polling mode */
 	if (likely(work_done < budget)) {
@@ -1989,9 +2034,9 @@ int edma_poll(struct napi_struct *napi,
 
 		/* re-enable the interrupts */
 		for (i = 0; i < 2; i++)
-			edma_write_reg(REG_RX_INT_MASK_Q(q_cinfo->rx_start + i), 0x1);
+			edma_write_reg(EDMA_REG_RX_INT_MASK_Q(edma_percpu_info->rx_start + i), 0x1);
 		for (i = 0; i < 4; i++)
-			edma_write_reg(REG_TX_INT_MASK_Q(q_cinfo->tx_start + i), 0x1);
+			edma_write_reg(EDMA_REG_TX_INT_MASK_Q(edma_percpu_info->tx_start + i), 0x1);
 	}
 
 	return work_done;
@@ -2003,17 +2048,17 @@ int edma_poll(struct napi_struct *napi,
  */
 irqreturn_t edma_interrupt(int irq, void *dev)
 {
-	struct queue_per_cpu_info *q_cinfo = (struct queue_per_cpu_info *) dev;
+	struct edma_per_cpu_queues_info *edma_percpu_info = (struct edma_per_cpu_queues_info *) dev;
 	int i;
 
 	/* Unmask the TX/RX interrupt register */
 	for (i = 0; i < 2; i++)
-		edma_write_reg(REG_RX_INT_MASK_Q(q_cinfo->rx_start + i), 0x0);
+		edma_write_reg(EDMA_REG_RX_INT_MASK_Q(edma_percpu_info->rx_start + i), 0x0);
 
 	for (i = 0; i < 4; i++)
-		edma_write_reg(REG_TX_INT_MASK_Q(q_cinfo->tx_start + i), 0x0);
+		edma_write_reg(EDMA_REG_TX_INT_MASK_Q(edma_percpu_info->tx_start + i), 0x0);
 
-	napi_schedule(&q_cinfo->napi);
+	napi_schedule(&edma_percpu_info->napi);
 
 	return IRQ_HANDLED;
 }
Index: linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.h
===================================================================
--- linux-3.14.43.orig/drivers/net/ethernet/qcom/essedma/edma.h
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma.h
@@ -41,25 +41,33 @@
 #include <asm-generic/bug.h>
 #include "ess_edma.h"
 
+/* Number of Core/queues */
 #define EDMA_NR_CPU 4
 #define EDMA_NR_NETDEV 2
 #define EDMA_MAX_RECEIVE_QUEUE 8
 #define EDMA_MAX_TRANSMIT_QUEUE 16
-#define EDMA_PORT_ID_SHIFT 12
-#define EDMA_PORT_ID_MASK 0x7
+
+/* WAN/LAN adapter number */
 #define EDMA_WAN 0
 #define EDMA_LAN 1
-#define EDMA_LAN_DEFAULT 1
-#define EDMA_WAN_DEFAULT 2
-#define EDMA_PORT_SHIFT 1
 
-#define EDMA_NETDEV_TX_QUEUE 4 /* TX queue exposed to Linux kernel */
-#define EDMA_NETDEV_RX_QUEUE 4 /* RX queue exposed to Linux kernel */
+/* VLAN tag */
+#define EDMA_LAN_DEFAULT_VLAN 1
+#define EDMA_WAN_DEFAULT_VLAN 2
+
+/* Queues exposed to linux kernel */
+#define EDMA_NETDEV_TX_QUEUE 4
+#define EDMA_NETDEV_RX_QUEUE 4
 
+/* Number of queues per core */
 #define EDMA_NUM_TXQ_PER_CORE 4
 #define EDMA_NUM_RXQ_PER_CORE 2
+
 #define EDMA_TPD_EOP_SHIFT 31
 
+#define EDMA_PORT_ID_SHIFT 12
+#define EDMA_PORT_ID_MASK 0x7
+
 /* tpd word 3 bit 18-28 */
 #define EDMA_TPD_PORT_BITMAP_SHIFT 18
 
@@ -76,16 +84,19 @@
 #define EDMA_RX_RING_SIZE 512
 #define EDMA_TX_RING_SIZE 512
 
+/* Flags used in paged/non paged mode */
 #define EDMA_RX_HEAD_BUFF_SIZE_JUMBO 256
 #define EDMA_RX_HEAD_BUFF_SIZE 1540
 
+/* MAX frame size supported by switch */
 #define EDMA_MAX_JUMBO_FRAME_SIZE 9216
 
+/* Configurations */
 #define EDMA_INTR_CLEAR_TYPE 0
 #define EDMA_INTR_SW_IDX_W_TYPE 0
 #define EDMA_FIFO_THRESH_TYPE 0
 #define EDMA_RSS_TYPE 0
-#define EDMA_RX_IMT 0x0008
+#define EDMA_RX_IMT 0x0020
 #define EDMA_TX_IMT 0x0050
 #define EDMA_TPD_BURST 5
 #define EDMA_TXF_BURST 0x100
@@ -93,6 +104,7 @@
 #define EDMA_RFD_THR 16
 #define EDMA_RFD_LTHR 0
 
+/* RX/TX per CPU based mask/shift */
 #define EDMA_TX_PER_CPU_MASK 0xF
 #define EDMA_RX_PER_CPU_MASK 0x3
 #define EDMA_TX_PER_CPU_MASK_SHIFT 0x2
@@ -100,6 +112,7 @@
 #define EDMA_TX_CPU_START_SHIFT 0x2
 #define EDMA_RX_CPU_START_SHIFT 0x1
 
+/* FLags used in transmit direction */
 #define EDMA_HW_CHECKSUM 0x00000001
 #define EDMA_VLAN_TX_TAG_INSERT_FLAG 0x00000002
 #define EDMA_VLAN_TX_TAG_INSERT_DEFAULT_FLAG 0x00000004
@@ -121,15 +134,14 @@
 					| SUPPORTED_100baseT_Full \
 					| SUPPORTED_1000baseT_Full)
 
+/* Recevie side atheros Header */
 #define EDMA_RX_ATH_HDR_VERSION 0x2
 #define EDMA_RX_ATH_HDR_VERSION_SHIFT 14
 #define EDMA_RX_ATH_HDR_PRIORITY_SHIFT 11
 #define EDMA_RX_ATH_PORT_TYPE_SHIFT 6
 #define EDMA_RX_ATH_HDR_RSTP_PORT_TYPE 0x4
 
-#define EDMA_ETH_HDR_LEN 12
-#define EDMA_ETH_TYPE_MASK 0xFFFF
-
+/* Transmit side atheros Header */
 #define EDMA_TX_ATH_HDR_PORT_BITMAP_MASK 0x7F
 #define EDMA_TX_ATH_HDR_FROM_CPU_MASK 0x80
 #define EDMA_TX_ATH_HDR_FROM_CPU_SHIFT 7
@@ -144,12 +156,14 @@
 #define EDMA_TXQ_IRQ_MASK_CORE2 0x000F
 #define EDMA_TXQ_IRQ_MASK_CORE3 0x00F0
 
+#define EDMA_ETH_HDR_LEN 12
+#define EDMA_ETH_TYPE_MASK 0xFFFF
+
 #define EDMA_RX_BUFFER_WRITE 16
 #define EDMA_RFD_AVAIL_THR 80
 
 #define EDMA_GMAC_NO_MDIO_PHY	PHY_MAX_ADDR
 
-
 struct edma_ethtool_statistics {
 	uint32_t tx_q0_pkt;
 	uint32_t tx_q1_pkt;
@@ -269,8 +283,8 @@ struct edma_sw_desc {
 	u32 flags;
 };
 
-/* per core queue related information */
-struct queue_per_cpu_info {
+/* per core related information */
+struct edma_per_cpu_queues_info {
 	struct napi_struct napi; /* napi associated with the core */
 	u32 tx_mask; /* tx interrupt mask */
 	u32 rx_mask; /* rx interrupt mask */
@@ -278,7 +292,7 @@ struct queue_per_cpu_info {
 	u32 rx_status; /* rx interrupt status */
 	u32 tx_start; /* tx queue start */
 	u32 rx_start; /* rx queue start */
-	struct edma_common_info *c_info; /* edma common info */
+	struct edma_common_info *edma_cinfo; /* edma common info */
 };
 
 /* edma specific common info */
@@ -301,13 +315,14 @@ struct edma_common_info {
 	u16 rx_page_buffer_len; /* rx buffer length */
 	u32 page_mode; /* Jumbo frame supported flag */
 	struct edma_hw hw; /* edma hw specific structure */
-	struct queue_per_cpu_info q_cinfo[EDMA_NR_CPU]; /* per cpu information */
+	struct ctl_table_header *edma_ctl_table_hdr;
+	struct edma_per_cpu_queues_info edma_percpu_info[EDMA_NR_CPU]; /* per cpu information */
 	spinlock_t stats_lock; /* protect interrupt registers access */
 };
 
 /* transimit packet descriptor (tpd) ring */
 struct edma_tx_desc_ring {
-        struct netdev_queue *nq; /* Linux queue index */
+	struct netdev_queue *nq; /* Linux queue index */
 	struct net_device netdev;
 	u16 size; /* descriptor ring length in bytes */
 	u16 count; /* number of descriptors in the ring */
@@ -353,7 +368,7 @@ struct edma_rfs_flow_table {
 struct edma_adapter {
 	struct net_device *netdev; /* netdevice */
 	struct platform_device *pdev; /* platform device */
-	struct edma_common_info *c_info; /* edma common info */
+	struct edma_common_info *edma_cinfo; /* edma common info */
 	struct edma_rfs_flow_table rfs; /* edma rfs flow table */
 	struct net_device_stats stats; /* netdev statistics */
 	struct phy_device *phydev; /* Phy device */
@@ -369,22 +384,24 @@ struct edma_adapter {
 	int default_vlan_tag; /* vlan tag */
 };
 
-int edma_alloc_queues_tx(struct edma_common_info *c_info);
-int edma_alloc_queues_rx(struct edma_common_info *c_info);
+int edma_alloc_queues_tx(struct edma_common_info *edma_cinfo);
+int edma_alloc_queues_rx(struct edma_common_info *edma_cinfo);
 int edma_open(struct net_device *netdev);
 int edma_close(struct net_device *netdev);
-int edma_alloc_tx_rings(struct edma_common_info *c_info);
-int edma_alloc_rx_rings(struct edma_common_info *c_info);
-void edma_free_tx_rings(struct edma_common_info *c_info);
-void edma_free_rx_rings(struct edma_common_info *c_info);
-void edma_free_queues(struct edma_common_info *c_info);
-void edma_irq_disable(struct edma_common_info *c_info);
-int edma_reset(struct edma_common_info *c_info);
+void edma_free_tx_resources(struct edma_common_info *edma_c_info);
+void edma_free_rx_resources(struct edma_common_info *edma_c_info);
+int edma_alloc_tx_rings(struct edma_common_info *edma_cinfo);
+int edma_alloc_rx_rings(struct edma_common_info *edma_cinfo);
+void edma_free_tx_rings(struct edma_common_info *edma_cinfo);
+void edma_free_rx_rings(struct edma_common_info *edma_cinfo);
+void edma_free_queues(struct edma_common_info *edma_cinfo);
+void edma_irq_disable(struct edma_common_info *edma_cinfo);
+int edma_reset(struct edma_common_info *edma_cinfo);
 int edma_poll(struct napi_struct *napi, int budget);
 netdev_tx_t edma_xmit(struct sk_buff *skb,
 		struct net_device *netdev);
-int edma_configure(struct edma_common_info *c_info);
-void edma_irq_enable(struct edma_common_info *c_info);
+int edma_configure(struct edma_common_info *edma_cinfo);
+void edma_irq_enable(struct edma_common_info *edma_cinfo);
 void edma_enable_tx_ctrl(struct edma_hw *hw);
 void edma_enable_rx_ctrl(struct edma_hw *hw);
 void edma_stop_rx_tx(struct edma_hw *hw);
@@ -405,8 +422,8 @@ void edma_set_stp_rstp(bool tag);
 void edma_assign_ath_hdr_type(int tag);
 int edma_get_default_vlan_tag(struct net_device *netdev);
 void edma_adjust_link(struct net_device *netdev);
-void edma_fill_netdev(struct edma_common_info *c_info, int qid, int num);
-int edma_select_xps_queue(struct net_device *dev, struct sk_buff *skb,
+void edma_fill_netdev(struct edma_common_info *edma_cinfo, int qid, int num);
+u16 edma_select_xps_queue(struct net_device *dev, struct sk_buff *skb,
 	void *accel_priv, select_queue_fallback_t fallback);
-void edma_read_append_stats(c_info);
+void edma_read_append_stats(edma_cinfo);
 #endif /* _EDMA_H_ */
Index: linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma_axi.c
===================================================================
--- linux-3.14.43.orig/drivers/net/ethernet/qcom/essedma/edma_axi.c
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma_axi.c
@@ -41,8 +41,8 @@ u16 tx_start[4] = {EDMA_TXQ_START_CORE0,
 u32 tx_mask[4] = {EDMA_TXQ_IRQ_MASK_CORE0, EDMA_TXQ_IRQ_MASK_CORE1,
 			EDMA_TXQ_IRQ_MASK_CORE2, EDMA_TXQ_IRQ_MASK_CORE3};
 
-int edma_default_ltag  __read_mostly = EDMA_LAN_DEFAULT;
-int edma_default_wtag  __read_mostly = EDMA_WAN_DEFAULT;
+int edma_default_ltag  __read_mostly = EDMA_LAN_DEFAULT_VLAN;
+int edma_default_wtag  __read_mostly = EDMA_WAN_DEFAULT_VLAN;
 int edma_weight_assigned_to_q __read_mostly;
 int edma_queue_to_virtual_q __read_mostly;
 bool edma_enable_rstp  __read_mostly;
@@ -65,46 +65,46 @@ void edma_read_reg(u16 reg_addr, volatil
 	*reg_value = readl((void __iomem *)(edma_hw_addr + reg_addr));
 }
 
-void edma_read_append_stats(struct edma_common_info *c_info)
+void edma_read_append_stats(struct edma_common_info *edma_cinfo)
 {
-	uint8_t *p = (uint8_t *)&(c_info->edma_ethstats);
-	int i, j;
+	uint8_t *p = (uint8_t *)&(edma_cinfo->edma_ethstats);
+	int i;
 	u32 stat;
 
-	spin_lock(&c_info->stats_lock);
+	spin_lock(&edma_cinfo->stats_lock);
 
 	for (i = 0; i < EDMA_MAX_TRANSMIT_QUEUE; i++) {
-		edma_read_reg(REG_TX_STAT_PKT_Q(i), &stat);
+		edma_read_reg(EDMA_REG_TX_STAT_PKT_Q(i), &stat);
 		*(uint32_t *)p += stat;
 		p += sizeof(uint32_t);
 	}
 
 	for (i = 0; i < EDMA_MAX_TRANSMIT_QUEUE; i++) {
-		edma_read_reg(REG_TX_STAT_BYTE_Q(i), &stat);
+		edma_read_reg(EDMA_REG_TX_STAT_BYTE_Q(i), &stat);
 		*(uint32_t *)p += stat;
 		p += sizeof(uint32_t);
 	}
 
 	for (i = 0; i < EDMA_MAX_RECEIVE_QUEUE; i++) {
-		edma_read_reg(REG_RX_STAT_PKT_Q(i), &stat);
+		edma_read_reg(EDMA_REG_RX_STAT_PKT_Q(i), &stat);
 		*(uint32_t *)p += stat;
 		p += sizeof(uint32_t);
 	}
 
 	for (i = 0; i < EDMA_MAX_RECEIVE_QUEUE; i++) {
-		edma_read_reg(REG_RX_STAT_BYTE_Q(i), &stat);
+		edma_read_reg(EDMA_REG_RX_STAT_BYTE_Q(i), &stat);
 		*(uint32_t *)p += stat;
 		p += sizeof(uint32_t);
 	}
 
-	spin_unlock(&c_info->stats_lock);
+	spin_unlock(&edma_cinfo->stats_lock);
 }
 
 static void edma_statistics_timer(unsigned long data)
 {
-	struct edma_common_info *c_info = (struct edma_common_info *)data;
+	struct edma_common_info *edma_cinfo = (struct edma_common_info *)data;
 
-	edma_read_append_stats(c_info);
+	edma_read_append_stats(edma_cinfo);
 
 	mod_timer(&edma_stats_timer, jiffies + 1*HZ);
 }
@@ -183,21 +183,21 @@ static int edma_weight_assigned_to_queue
 
 		data = weight << EDMA_WRR_SHIFT(queue_id);
 		if (queue_id <= 3) {
-			edma_read_reg(REG_WRR_CTRL_Q0_Q3, &reg_data);
+			edma_read_reg(EDMA_REG_WRR_CTRL_Q0_Q3, &reg_data);
 			reg_data &= ~(1 << EDMA_WRR_SHIFT(queue_id));
-			edma_write_reg(REG_WRR_CTRL_Q0_Q3, data | reg_data);
+			edma_write_reg(EDMA_REG_WRR_CTRL_Q0_Q3, data | reg_data);
 		} else if (queue_id <= 7) {
-			edma_read_reg(REG_WRR_CTRL_Q4_Q7, &reg_data);
+			edma_read_reg(EDMA_REG_WRR_CTRL_Q4_Q7, &reg_data);
 			reg_data &= ~(1 << EDMA_WRR_SHIFT(queue_id));
-			edma_write_reg(REG_WRR_CTRL_Q4_Q7, data | reg_data);
+			edma_write_reg(EDMA_REG_WRR_CTRL_Q4_Q7, data | reg_data);
 		} else if (queue_id <= 11) {
-			edma_read_reg(REG_WRR_CTRL_Q8_Q11, &reg_data);
+			edma_read_reg(EDMA_REG_WRR_CTRL_Q8_Q11, &reg_data);
 			reg_data &= ~(1 << EDMA_WRR_SHIFT(queue_id));
-			edma_write_reg(REG_WRR_CTRL_Q8_Q11, data | reg_data);
+			edma_write_reg(EDMA_REG_WRR_CTRL_Q8_Q11, data | reg_data);
 		} else {
-			edma_read_reg(REG_WRR_CTRL_Q12_Q15, &reg_data);
+			edma_read_reg(EDMA_REG_WRR_CTRL_Q12_Q15, &reg_data);
 			reg_data &= ~(1 << EDMA_WRR_SHIFT(queue_id));
-			edma_write_reg(REG_WRR_CTRL_Q12_Q15, data | reg_data);
+			edma_write_reg(EDMA_REG_WRR_CTRL_Q12_Q15, data | reg_data);
 		}
 	}
 
@@ -224,15 +224,15 @@ static int edma_queue_to_virtual_queue_m
 			return -EINVAL;
 		}
 
-		data = virtual_qid << VQ_ID_SHIFT(queue_id);
+		data = virtual_qid << EDMA_VQ_ID_SHIFT(queue_id);
 		if (queue_id <= 7) {
-			edma_read_reg(REG_VQ_CTRL0, &reg_data);
-			reg_data &= ~(1 << VQ_ID_SHIFT(queue_id));
-			edma_write_reg(REG_VQ_CTRL0, data | reg_data);
+			edma_read_reg(EDMA_REG_VQ_CTRL0, &reg_data);
+			reg_data &= ~(1 << EDMA_VQ_ID_SHIFT(queue_id));
+			edma_write_reg(EDMA_REG_VQ_CTRL0, data | reg_data);
 		} else {
-			edma_read_reg(REG_VQ_CTRL1, &reg_data);
-			reg_data &= ~(1 << VQ_ID_SHIFT(queue_id));
-			edma_write_reg(REG_VQ_CTRL1, data | reg_data);
+			edma_read_reg(EDMA_REG_VQ_CTRL1, &reg_data);
+			reg_data &= ~(1 << EDMA_VQ_ID_SHIFT(queue_id));
+			edma_write_reg(EDMA_REG_VQ_CTRL1, data | reg_data);
 		}
 	}
 
@@ -320,7 +320,7 @@ static const struct net_device_ops edma_
  */
 static int edma_axi_probe(struct platform_device *pdev)
 {
-	struct edma_common_info *c_info;
+	struct edma_common_info *edma_cinfo;
 	struct edma_hw *hw;
 	struct edma_adapter *adapter[2];
 	struct resource *res;
@@ -332,8 +332,6 @@ static int edma_axi_probe(struct platfor
 	struct edma_mdio_data *mdio_data = NULL;
 	int i, j, err = 0, ret = 0;
 	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
-	const __be32 *prop = NULL;
-
 
 	/* Use to allocate net devices for multiple TX/RX queues */
 	netdev[0] = alloc_etherdev_mqs(sizeof(struct edma_adapter),
@@ -355,38 +353,38 @@ static int edma_axi_probe(struct platfor
 	SET_NETDEV_DEV(netdev[1], &pdev->dev);
 	platform_set_drvdata(pdev, netdev[1]);
 
-	c_info = vzalloc(sizeof(struct edma_common_info));
-	if (!c_info) {
+	edma_cinfo = vzalloc(sizeof(struct edma_common_info));
+	if (!edma_cinfo) {
 		err = -ENOMEM;
 		goto err_ioremap;
 	}
 
-	c_info->pdev = pdev;
-	c_info->netdev[0] = netdev[0];
-        c_info->netdev[1] = netdev[1];
+	edma_cinfo->pdev = pdev;
+	edma_cinfo->netdev[0] = netdev[0];
+        edma_cinfo->netdev[1] = netdev[1];
 
 	/* Fill ring details */
-	c_info->num_tx_queues = EDMA_MAX_TRANSMIT_QUEUE;
-	c_info->tx_ring_count = EDMA_TX_RING_SIZE;
-	c_info->num_rx_queues = EDMA_MAX_RECEIVE_QUEUE;
-	c_info->rx_ring_count = EDMA_RX_RING_SIZE;
+	edma_cinfo->num_tx_queues = EDMA_MAX_TRANSMIT_QUEUE;
+	edma_cinfo->tx_ring_count = EDMA_TX_RING_SIZE;
+	edma_cinfo->num_rx_queues = EDMA_MAX_RECEIVE_QUEUE;
+	edma_cinfo->rx_ring_count = EDMA_RX_RING_SIZE;
 
-	hw = &c_info->hw;
+	hw = &edma_cinfo->hw;
 
 	/* Fill HW defaults */
 	hw->tx_intr_mask = EDMA_TX_IMR_NORMAL_MASK;
 	hw->rx_intr_mask = EDMA_RX_IMR_NORMAL_MASK;
 
-	of_property_read_u32(np, "qcom,page-mode", &c_info->page_mode);
+	of_property_read_u32(np, "qcom,page-mode", &edma_cinfo->page_mode);
 	of_property_read_u32(np, "qcom,rx_head_buf_size", &hw->rx_head_buff_size);
-	of_property_read_u32(np, "qcom,port_id_wan", &c_info->edma_port_id_wan);
+	of_property_read_u32(np, "qcom,port_id_wan", &edma_cinfo->edma_port_id_wan);
 
 	if (overwrite_mode) {
 		dev_info(&pdev->dev, "page mode overwritten");
-		c_info->page_mode = page_mode;
+		edma_cinfo->page_mode = page_mode;
 	}
 
-	if (c_info->page_mode)
+	if (edma_cinfo->page_mode)
 		hw->rx_head_buff_size = EDMA_RX_HEAD_BUFF_SIZE_JUMBO;
 	else if (!hw->rx_head_buff_size)
 		hw->rx_head_buff_size = EDMA_RX_HEAD_BUFF_SIZE;
@@ -406,49 +404,49 @@ static int edma_axi_probe(struct platfor
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
-	c_info->hw.hw_addr = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(c_info->hw.hw_addr)) {
-		ret = PTR_ERR(c_info->hw.hw_addr);
+	edma_cinfo->hw.hw_addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(edma_cinfo->hw.hw_addr)) {
+		ret = PTR_ERR(edma_cinfo->hw.hw_addr);
 		goto err_hwaddr;
 	}
 
-	edma_hw_addr = (unsigned long)c_info->hw.hw_addr;
+	edma_hw_addr = (unsigned long)edma_cinfo->hw.hw_addr;
 
 	/* Parse tx queue interrupt number from device tree */
-	for (i = 0; i < c_info->num_tx_queues; i++)
-		c_info->tx_irq[i] = platform_get_irq(pdev, i);
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++)
+		edma_cinfo->tx_irq[i] = platform_get_irq(pdev, i);
 
 	/* Parse rx queue interrupt number from device tree
 	 * Here we are setting j to point to the point where we
 	 * left tx interrupt parsing(i.e 16) and run run the loop
 	 * from 0 to 7 to parse rx interrupt number.
 	 */
-	for (i = 0, j = c_info->num_tx_queues; i < c_info->num_rx_queues;
+	for (i = 0, j = edma_cinfo->num_tx_queues; i < edma_cinfo->num_rx_queues;
 			i++, j++)
-		c_info->rx_irq[i] = platform_get_irq(pdev, j);
+		edma_cinfo->rx_irq[i] = platform_get_irq(pdev, j);
 
-	c_info->rx_head_buffer_len = c_info->hw.rx_head_buff_size;
-	c_info->rx_page_buffer_len = PAGE_SIZE;
+	edma_cinfo->rx_head_buffer_len = edma_cinfo->hw.rx_head_buff_size;
+	edma_cinfo->rx_page_buffer_len = PAGE_SIZE;
 
-	err = edma_alloc_queues_tx(c_info);
+	err = edma_alloc_queues_tx(edma_cinfo);
 	if (err) {
 		dev_err(&pdev->dev, "Allocation of TX queue failed\n");
 		goto err_tx_qinit;
 	}
 
-	err = edma_alloc_queues_rx(c_info);
+	err = edma_alloc_queues_rx(edma_cinfo);
 	if (err) {
 		dev_err(&pdev->dev, "Allocation of RX queue failed\n");
 		goto err_rx_qinit;
 	}
 
-	err = edma_alloc_tx_rings(c_info);
+	err = edma_alloc_tx_rings(edma_cinfo);
 	if (err) {
 		dev_err(&pdev->dev, "Allocation of TX resources failed\n");
 		goto err_tx_rinit;
 	}
 
-	err = edma_alloc_rx_rings(c_info);
+	err = edma_alloc_rx_rings(edma_cinfo);
 	if (err) {
 		dev_err(&pdev->dev, "Allocation of RX resources failed\n");
 		goto err_rx_rinit;
@@ -480,10 +478,10 @@ static int edma_axi_probe(struct platfor
 			 * q0,q1,q4,q5,q8,q9,q12,q13 goes to WAN, others to LAN
 			 */
 			for (k = adapter[i]->tx_start_offset[j]; k < (adapter[i]->tx_start_offset[j] + 2); k++) {
-				edma_fill_netdev(c_info, k, i);
+				edma_fill_netdev(edma_cinfo, k, i);
 			}
 		}
-		adapter[i]->c_info = c_info;
+		adapter[i]->edma_cinfo = edma_cinfo;
 		netdev[i]->netdev_ops = &edma_axi_netdev_ops;
 		netdev[i]->features = NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX
 				| NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_SG | NETIF_F_TSO |
@@ -532,12 +530,16 @@ static int edma_axi_probe(struct platfor
 #endif
 	}
 
-        register_net_sysctl(&init_net, "net/edma", edma_table);
+	edma_cinfo->edma_ctl_table_hdr = register_net_sysctl(&init_net, "net/edma", edma_table);
+	if (!edma_cinfo->edma_ctl_table_hdr) {
+		dev_err(&pdev->dev, "edma sysctl table hdr not registered\n");
+		goto err_unregister_sysctl_tbl;
+	}
 
 	/* Set default LAN tag */
-	adapter[EDMA_LAN]->default_vlan_tag = EDMA_LAN_DEFAULT;
+	adapter[EDMA_LAN]->default_vlan_tag = EDMA_LAN_DEFAULT_VLAN;
 	/* Set default WAN tag */
-        adapter[EDMA_WAN]->default_vlan_tag = EDMA_WAN_DEFAULT;
+        adapter[EDMA_WAN]->default_vlan_tag = EDMA_WAN_DEFAULT_VLAN;
 
 
 	if (of_property_read_bool(np, "qcom,mdio_supported")) {
@@ -560,7 +562,7 @@ static int edma_axi_probe(struct platfor
 		if (!mdio_node) {
 			dev_dbg(&pdev->dev, "cannot find mdio node by phandle");
 			ret = -EIO;
-			goto mdiobus_init_fail;
+			goto err_mdiobus_init_fail;
 		}
 
 		mdio_plat = of_find_device_by_node(mdio_node);
@@ -568,7 +570,7 @@ static int edma_axi_probe(struct platfor
 			dev_dbg(&pdev->dev, "cannot find platform device from mdio node");
 			of_node_put(mdio_node);
 			ret = -EIO;
-			goto mdiobus_init_fail;
+			goto err_mdiobus_init_fail;
 		}
 
 		mdio_data = dev_get_drvdata(&mdio_plat->dev);
@@ -576,7 +578,7 @@ static int edma_axi_probe(struct platfor
 			dev_dbg(&pdev->dev, "cannot get mii bus reference from device data");
 			of_node_put(mdio_node);
 			ret = -EIO;
-			goto mdiobus_init_fail;
+			goto err_mdiobus_init_fail;
 		}
 
 		miibus = mdio_data->mii_bus;
@@ -587,9 +589,9 @@ static int edma_axi_probe(struct platfor
 	}
 
 	/* Disable all 16 Tx and 8 rx irqs */
-	edma_irq_disable(c_info);
+	edma_irq_disable(edma_cinfo);
 
-	err = edma_reset(c_info);
+	err = edma_reset(edma_cinfo);
 	if (err) {
 		err = -EIO;
 		goto err_reset;
@@ -600,37 +602,37 @@ static int edma_axi_probe(struct platfor
 	 */
 	for (i = 0; i < EDMA_NR_CPU; i++) {
 		u8 rx_start;
-		c_info->q_cinfo[i].napi.state = 0;
-		netif_napi_add(netdev[0], &c_info->q_cinfo[i].napi,
+		edma_cinfo->edma_percpu_info[i].napi.state = 0;
+		netif_napi_add(netdev[0], &edma_cinfo->edma_percpu_info[i].napi,
 					edma_poll, 64);
-		napi_enable(&c_info->q_cinfo[i].napi);
-		c_info->q_cinfo[i].tx_mask = tx_mask[i];
-		c_info->q_cinfo[i].rx_mask = EDMA_RX_PER_CPU_MASK <<
+		napi_enable(&edma_cinfo->edma_percpu_info[i].napi);
+		edma_cinfo->edma_percpu_info[i].tx_mask = tx_mask[i];
+		edma_cinfo->edma_percpu_info[i].rx_mask = EDMA_RX_PER_CPU_MASK <<
 					(i << EDMA_RX_PER_CPU_MASK_SHIFT);
-		c_info->q_cinfo[i].tx_start = tx_start[i];
-		c_info->q_cinfo[i].rx_start =  rx_start =
+		edma_cinfo->edma_percpu_info[i].tx_start = tx_start[i];
+		edma_cinfo->edma_percpu_info[i].rx_start =  rx_start =
 					i << EDMA_RX_CPU_START_SHIFT;
-		c_info->q_cinfo[i].tx_status = 0;
-		c_info->q_cinfo[i].rx_status = 0;
-		c_info->q_cinfo[i].c_info = c_info;
+		edma_cinfo->edma_percpu_info[i].tx_status = 0;
+		edma_cinfo->edma_percpu_info[i].rx_status = 0;
+		edma_cinfo->edma_percpu_info[i].edma_cinfo = edma_cinfo;
 
 		/* Request irq per core */
-		for (j = c_info->q_cinfo[i].tx_start; j < tx_start[i] + 4; j++) {
+		for (j = edma_cinfo->edma_percpu_info[i].tx_start; j < tx_start[i] + 4; j++) {
 			sprintf(&edma_tx_irq[j][0], "edma_eth_tx%d", j);
-			err = request_irq(c_info->tx_irq[j], edma_interrupt,
-				IRQF_DISABLED, &edma_tx_irq[j][0], &c_info->q_cinfo[i]);
+			err = request_irq(edma_cinfo->tx_irq[j], edma_interrupt,
+				IRQF_DISABLED, &edma_tx_irq[j][0], &edma_cinfo->edma_percpu_info[i]);
 		}
 
-		for (j = c_info->q_cinfo[i].rx_start; j < rx_start + 2; j++) {
+		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < rx_start + 2; j++) {
 			sprintf(&edma_rx_irq[j][0], "edma_eth_rx%d", j);
-			err = request_irq(c_info->rx_irq[j], edma_interrupt,
-				IRQF_DISABLED, &edma_rx_irq[j][0], &c_info->q_cinfo[i]);
+			err = request_irq(edma_cinfo->rx_irq[j], edma_interrupt,
+				IRQF_DISABLED, &edma_rx_irq[j][0], &edma_cinfo->edma_percpu_info[i]);
 		}
 
 #ifdef CONFIG_RFS_ACCEL
-		for (j = c_info->q_cinfo[i].rx_start; j < rx_start + 2; j += 2) {
+		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < rx_start + 2; j += 2) {
 			err = irq_cpu_rmap_add(netdev[0]->rx_cpu_rmap,
-				c_info->rx_irq[j]);
+				edma_cinfo->rx_irq[j]);
 			if (err)
 				goto err_rmap_add_fail;
 		}
@@ -640,7 +642,7 @@ static int edma_axi_probe(struct platfor
 	/* Used to clear interrupt status, allocate rx buffer,
 	 * configure edma descriptors registers
 	 */
-	err = edma_configure(c_info);
+	err = edma_configure(edma_cinfo);
 	if (err) {
 		err = -EIO;
 		goto err_configure;
@@ -659,19 +661,19 @@ static int edma_axi_probe(struct platfor
 	 * following pattern: load_balance{0,1,2,3} = {Q0,Q1,Q3,Q4}
 	 * respectively.
 	 */
-	edma_write_reg(REG_LB_RING, EDMA_LB_REG_VALUE);
+	edma_write_reg(EDMA_REG_LB_RING, EDMA_LB_REG_VALUE);
 
 	/* Configure Virtual queue for Tx rings
 	 * User can also change this value runtime through
 	 * a sysctl
 	 */
-	edma_write_reg(REG_VQ_CTRL0, EDMA_VQ_REG_VALUE);
-	edma_write_reg(REG_VQ_CTRL1, EDMA_VQ_REG_VALUE);
+	edma_write_reg(EDMA_REG_VQ_CTRL0, EDMA_VQ_REG_VALUE);
+	edma_write_reg(EDMA_REG_VQ_CTRL1, EDMA_VQ_REG_VALUE);
 
 	/* Enable All 16 tx and 8 rx irq mask */
-	edma_irq_enable(c_info);
-	edma_enable_tx_ctrl(&c_info->hw);
-	edma_enable_rx_ctrl(&c_info->hw);
+	edma_irq_enable(edma_cinfo);
+	edma_enable_tx_ctrl(&edma_cinfo->hw);
+	edma_enable_rx_ctrl(&edma_cinfo->hw);
 
 	if (adapter[EDMA_WAN]->poll_required) {
 		adapter[EDMA_WAN]->phydev =
@@ -687,11 +689,11 @@ static int edma_axi_probe(struct platfor
 		}
 	}
 
-	spin_lock_init(&c_info->stats_lock);
+	spin_lock_init(&edma_cinfo->stats_lock);
 
         init_timer(&edma_stats_timer);
         edma_stats_timer.expires = jiffies + 1*HZ;
-        edma_stats_timer.data = (unsigned long)c_info;
+        edma_stats_timer.data = (unsigned long)edma_cinfo;
         edma_stats_timer.function = edma_statistics_timer;                              /* timer handler */
         add_timer(&edma_stats_timer);
 
@@ -707,27 +709,27 @@ err_configure:
 	}
 #endif
 err_rmap_add_fail:
-        for (i = 0; i < EDMA_NR_NETDEV; i++)
+err_reset:
+	for (i = 0; i < EDMA_NR_NETDEV; i++)
 		edma_free_irqs(adapter[i]);
 	for (i = 0; i < EDMA_NR_CPU; i++)
-		napi_disable(&c_info->q_cinfo[i].napi);
+		napi_disable(&edma_cinfo->edma_percpu_info[i].napi);
+err_mdiobus_init_fail:
+err_unregister_sysctl_tbl:
 err_rmap_alloc_fail:
-err_reset:
 	for (i = 0; i < EDMA_NR_NETDEV; i++)
 		unregister_netdev(netdev[i]);
 err_register:
-	phy_disconnect(adapter[EDMA_WAN]->phydev);
-mdiobus_init_fail:
-	edma_free_rx_rings(c_info);
+	edma_free_rx_rings(edma_cinfo);
 err_rx_rinit:
-	edma_free_tx_rings(c_info);
+	edma_free_tx_rings(edma_cinfo);
 err_tx_rinit:
-	edma_free_queues(c_info);
+	edma_free_queues(edma_cinfo);
 err_rx_qinit:
 err_tx_qinit:
-	iounmap(c_info->hw.hw_addr);
+	iounmap(edma_cinfo->hw.hw_addr);
 err_hwaddr:
-	kfree(c_info);
+	vfree(edma_cinfo);
 err_ioremap:
 	for (i = 0; i < EDMA_NR_NETDEV; i++)
 		free_netdev(netdev[i]);
@@ -736,31 +738,49 @@ err_alloc:
 }
 
 /*
- * edma_axi_remove - Device Removal Routine
- *	edma_axi_remove is called by the platform subsystem to alert the driver
- *	that it should release a platform device.
+ * edma_axi_remove()
+ * 	Device Removal Routine
+ *
+ * edma_axi_remove is called by the platform subsystem to alert the driver
+ * that it should release a platform device.
  */
 static int edma_axi_remove(struct platform_device *pdev)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev[0]);
-	struct edma_common_info *c_info = adapter->c_info;
-	struct edma_hw *hw = &c_info->hw;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	struct edma_hw *hw = &edma_cinfo->hw;
 	int i;
 
+	for (i = 0; i < EDMA_NR_NETDEV; i++)
+		unregister_netdev(netdev[i]);
+
 	edma_stop_rx_tx(hw);
 	for (i = 0; i < EDMA_NR_CPU; i++)
-		napi_disable(&c_info->q_cinfo[i].napi);
-	edma_irq_disable(c_info);
-	edma_free_irqs(adapter);
-	edma_reset(c_info);
-	edma_free_tx_rings(c_info);
-	edma_free_rx_rings(c_info);
-	edma_free_queues(c_info);
+		napi_disable(&edma_cinfo->edma_percpu_info[i].napi);
+
+	edma_irq_disable(edma_cinfo);
+	edma_write_reg(EDMA_REG_RX_ISR, 0xff);
+	edma_write_reg(EDMA_REG_TX_ISR, 0xffff);
+#ifdef CONFIG_RFS_ACCEL
 	for (i = 0; i < EDMA_NR_NETDEV; i++) {
-		unregister_netdev(netdev[i]);
-		free_netdev(netdev[i]);
+		free_irq_cpu_rmap(netdev[0]->rx_cpu_rmap);
+		netdev[0]->rx_cpu_rmap = NULL;
 	}
+#endif
+
+	phy_disconnect(adapter->phydev);
 	del_timer_sync(&edma_stats_timer);
+	edma_free_irqs(adapter);
+	unregister_net_sysctl_table(edma_cinfo->edma_ctl_table_hdr);
+        edma_free_tx_resources(edma_cinfo);
+        edma_free_rx_resources(edma_cinfo);
+	edma_free_tx_rings(edma_cinfo);
+	edma_free_rx_rings(edma_cinfo);
+	edma_free_queues(edma_cinfo);
+	for (i = 0; i < EDMA_NR_NETDEV; i++)
+		free_netdev(netdev[i]);
+
+	vfree(edma_cinfo);
 
 	return 0;
 }
Index: linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma_ethtool.c
===================================================================
--- linux-3.14.43.orig/drivers/net/ethernet/qcom/essedma/edma_ethtool.c
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/edma_ethtool.c
@@ -129,14 +129,14 @@ static void edma_get_ethtool_stats(struc
 		struct ethtool_stats *stats, uint64_t *data)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
-	struct edma_common_info *c_info = adapter->c_info;
-	int32_t i, j;
+	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
+	int32_t i;
 	uint8_t *p = NULL;
 
-	edma_read_append_stats(c_info);
+	edma_read_append_stats(edma_cinfo);
 
 	for(i = 0; i < EDMA_STATS_LEN; i++) {
-		p = (uint8_t *)&(c_info->edma_ethstats) +
+		p = (uint8_t *)&(edma_cinfo->edma_ethstats) +
 			edma_gstrings_stats[i].stat_offset;
 		data[i] = *(uint32_t *)p;
 	}
Index: linux-3.14.43/drivers/net/ethernet/qcom/essedma/ess_edma.h
===================================================================
--- linux-3.14.43.orig/drivers/net/ethernet/qcom/essedma/ess_edma.h
+++ linux-3.14.43/drivers/net/ethernet/qcom/essedma/ess_edma.h
@@ -22,95 +22,92 @@ struct edma_adapter;
 struct edma_hw;
 
 /* register definition */
-#define REG_EDMA_MAS_CTRL 0x0
-#define REG_TIMEOUT_CTRL 0x004
-#define REG_EDMA_DBG0 0x008
-#define REG_EDMA_DBG1 0x00C
-#define REG_SW_CTRL0 0x100
-#define REG_SW_CTRL1 0x104
+#define EDMA_REG_MAS_CTRL 0x0
+#define EDMA_REG_TIMEOUT_CTRL 0x004
+#define EDMA_REG_DBG0 0x008
+#define EDMA_REG_DBG1 0x00C
+#define EDMA_REG_SW_CTRL0 0x100
+#define EDMA_REG_SW_CTRL1 0x104
 
 /* Interrupt Status Register */
-#define REG_RX_ISR 0x200
-#define REG_TX_ISR 0x208
-#define REG_MISC_ISR 0x210
-#define REG_WOL_ISR 0x218
-
-#define MISC_ISR_RX_URG_Q(x) (1 << x)
-
-#define MISC_ISR_AXIR_TIMEOUT 0x00000100
-#define MISC_ISR_AXIR_ERR 0x00000200
-#define MISC_ISR_TXF_DEAD 0x00000400
-#define MISC_ISR_AXIW_ERR 0x00000800
-#define MISC_ISR_AXIW_TIMEOUT 0x00001000
+#define EDMA_REG_RX_ISR 0x200
+#define EDMA_REG_TX_ISR 0x208
+#define EDMA_REG_MISC_ISR 0x210
+#define EDMA_REG_WOL_ISR 0x218
+
+#define EDMA_MISC_ISR_RX_URG_Q(x) (1 << x)
+
+#define EDMA_MISC_ISR_AXIR_TIMEOUT 0x00000100
+#define EDMA_MISC_ISR_AXIR_ERR 0x00000200
+#define EDMA_MISC_ISR_TXF_DEAD 0x00000400
+#define EDMA_MISC_ISR_AXIW_ERR 0x00000800
+#define EDMA_MISC_ISR_AXIW_TIMEOUT 0x00001000
 
-#define WOL_ISR_WOL 0x00000001
-
-#define ISR_RX_PKT(x) (1 << x)
-#define ISR_TX_PKT(x) (1 << x)
+#define EDMA_WOL_ISR 0x00000001
 
 /* Interrupt Mask Register */
-#define REG_MISC_IMR 0x214
-#define REG_WOL_IMR 0x218
+#define EDMA_REG_MISC_IMR 0x214
+#define EDMA_REG_WOL_IMR 0x218
 
 #define EDMA_RX_IMR_NORMAL_MASK 0x1
 #define EDMA_TX_IMR_NORMAL_MASK 0x1
-#define MISC_IMR_NORMAL_MASK 0x80001FFF
-#define WOL_IMR_NORMAL_MASK 0x1
+#define EDMA_MISC_IMR_NORMAL_MASK 0x80001FFF
+#define EDMA_WOL_IMR_NORMAL_MASK 0x1
 
 /* Edma receive consumer index */
-#define REG_RX_SW_CONS_IDX_Q(x) (0x220 + ((x) << 2)) /* x is the queue id */
+#define EDMA_REG_RX_SW_CONS_IDX_Q(x) (0x220 + ((x) << 2)) /* x is the queue id */
 /* Edma transmit consumer index */
-#define REG_TX_SW_CONS_IDX_Q(x) (0x240 + ((x) << 2)) /* x is the queue id */
+#define EDMA_REG_TX_SW_CONS_IDX_Q(x) (0x240 + ((x) << 2)) /* x is the queue id */
 
 /* IRQ Moderator Initial Timer Register */
-#define REG_IRQ_MODRT_TIMER_INIT 0x280
-#define IRQ_MODRT_TIMER_MASK 0xFFFF
-#define IRQ_MODRT_RX_TIMER_SHIFT 0
-#define IRQ_MODRT_TX_TIMER_SHIFT 16
+#define EDMA_REG_IRQ_MODRT_TIMER_INIT 0x280
+#define EDMA_IRQ_MODRT_TIMER_MASK 0xFFFF
+#define EDMA_IRQ_MODRT_RX_TIMER_SHIFT 0
+#define EDMA_IRQ_MODRT_TX_TIMER_SHIFT 16
 
 /* Interrupt Control Register */
-#define REG_INTR_CTRL 0x284
-#define INTR_CLR_TYP_SHIFT 0
-#define INTR_SW_IDX_W_TYP_SHIFT 1
-#define INTR_CLEAR_TYPE_W1 0
-#define INTR_CLEAR_TYPE_R 1
+#define EDMA_REG_INTR_CTRL 0x284
+#define EDMA_INTR_CLR_TYP_SHIFT 0
+#define EDMA_INTR_SW_IDX_W_TYP_SHIFT 1
+#define EDMA_INTR_CLEAR_TYPE_W1 0
+#define EDMA_INTR_CLEAR_TYPE_R 1
 
 /* RX Interrupt Mask Register */
-#define REG_RX_INT_MASK_Q(x) (0x300 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_RX_INT_MASK_Q(x) (0x300 + ((x) << 2)) /* x = queue id */
 
 /* TX Interrupt mask register */
-#define REG_TX_INT_MASK_Q(x) (0x340 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_TX_INT_MASK_Q(x) (0x340 + ((x) << 2)) /* x = queue id */
 
 /* Load Ptr Register
  * Software sets this bit after the initialization of the head and tail
  */
-#define REG_TX_SRAM_PART 0x400
-#define LOAD_PTR_SHIFT 16
+#define EDMA_REG_TX_SRAM_PART 0x400
+#define EDMA_LOAD_PTR_SHIFT 16
 
 /* TXQ Control Register */
-#define REG_TXQ_CTRL 0x404
-#define TXQ_CTRL_IP_OPTION_EN 0x10
-#define TXQ_CTRL_TXQ_EN 0x20
-#define TXQ_CTRL_ENH_MODE 0x40
-#define TXQ_CTRL_LS_8023_EN 0x80
+#define EDMA_REG_TXQ_CTRL 0x404
+#define EDMA_TXQ_CTRL_IP_OPTION_EN 0x10
+#define EDMA_TXQ_CTRL_TXQ_EN 0x20
+#define EDMA_TXQ_CTRL_ENH_MODE 0x40
+#define EDMA_TXQ_CTRL_LS_8023_EN 0x80
 #define EDMA_TXQ_CTRL_TPD_BURST_EN 0x100
-#define TXQ_CTRL_LSO_BREAK_EN 0x200
+#define EDMA_TXQ_CTRL_LSO_BREAK_EN 0x200
 #define EDMA_TXQ_NUM_TPD_BURST_MASK 0xF
 #define EDMA_TXQ_TXF_BURST_NUM_MASK 0xFFFF
 #define EDMA_TXQ_NUM_TPD_BURST_SHIFT 0
 #define EDMA_TXQ_TXF_BURST_NUM_SHIFT 16
 
-#define	REG_TXF_WATER_MARK 0x408 /* In 8-bytes */
-#define TXF_WATER_MARK_MASK 0x0FFF
-#define TXF_LOW_WATER_MARK_SHIFT 0
-#define TXF_HIGH_WATER_MARK_SHIFT 16
-#define TXQ_CTRL_BURST_MODE_EN 0x80000000
+#define	EDMA_REG_TXF_WATER_MARK 0x408 /* In 8-bytes */
+#define EDMA_TXF_WATER_MARK_MASK 0x0FFF
+#define EDMA_TXF_LOW_WATER_MARK_SHIFT 0
+#define EDMA_TXF_HIGH_WATER_MARK_SHIFT 16
+#define EDMA_TXQ_CTRL_BURST_MODE_EN 0x80000000
 
 /* WRR Control Register */
-#define REG_WRR_CTRL_Q0_Q3 0x40c
-#define REG_WRR_CTRL_Q4_Q7 0x410
-#define REG_WRR_CTRL_Q8_Q11 0x414
-#define REG_WRR_CTRL_Q12_Q15 0x418
+#define EDMA_REG_WRR_CTRL_Q0_Q3 0x40c
+#define EDMA_REG_WRR_CTRL_Q4_Q7 0x410
+#define EDMA_REG_WRR_CTRL_Q8_Q11 0x414
+#define EDMA_REG_WRR_CTRL_Q12_Q15 0x418
 
 /* Weight round robin(WRR), it takes queue as input, and computes
  * starting bits where we need to write the weight for a particular
@@ -119,41 +116,41 @@ struct edma_hw;
 #define EDMA_WRR_SHIFT(x) (((x) * 5) % 20)
 
 /* Tx Descriptor Control Register */
-#define REG_TPD_RING_SIZE 0x41C
-#define TPD_RING_SIZE_SHIFT 0
-#define TPD_RING_SIZE_MASK 0xFFFF
+#define EDMA_REG_TPD_RING_SIZE 0x41C
+#define EDMA_TPD_RING_SIZE_SHIFT 0
+#define EDMA_TPD_RING_SIZE_MASK 0xFFFF
 
 /* Transmit descriptor base address */
-#define REG_TPD_BASE_ADDR_Q(x) (0x420 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_TPD_BASE_ADDR_Q(x) (0x420 + ((x) << 2)) /* x = queue id */
 
 /* TPD Index Register */
-#define REG_TPD_IDX_Q(x) (0x460 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_TPD_IDX_Q(x) (0x460 + ((x) << 2)) /* x = queue id */
 
-#define TPD_PROD_IDX_BITS 0x0000FFFF
-#define TPD_CONS_IDX_BITS 0xFFFF0000
-#define TPD_PROD_IDX_MASK 0xFFFF
-#define TPD_CONS_IDX_MASK 0xFFFF
-#define TPD_PROD_IDX_SHIFT 0
-#define TPD_CONS_IDX_SHIFT 16
+#define EDMA_TPD_PROD_IDX_BITS 0x0000FFFF
+#define EDMA_TPD_CONS_IDX_BITS 0xFFFF0000
+#define EDMA_TPD_PROD_IDX_MASK 0xFFFF
+#define EDMA_TPD_CONS_IDX_MASK 0xFFFF
+#define EDMA_TPD_PROD_IDX_SHIFT 0
+#define EDMA_TPD_CONS_IDX_SHIFT 16
 
 /* TX Virtual Queue Mapping Control Register */
-#define REG_VQ_CTRL0 0x4A0
-#define REG_VQ_CTRL1 0x4A4
+#define EDMA_REG_VQ_CTRL0 0x4A0
+#define EDMA_REG_VQ_CTRL1 0x4A4
 
 /* Virtual QID shift, it takes queue as input, and computes
  * Virtual QID position in virtual qid control register
  */
-#define VQ_ID_SHIFT(i) (((i) * 3) % 24)
+#define EDMA_VQ_ID_SHIFT(i) (((i) * 3) % 24)
 
 /* Virtual Queue Default Value */
 #define EDMA_VQ_REG_VALUE 0x240240
 
 /* Tx side Port Interface Control Register */
-#define REG_PORT_CTRL 0x4A8
-#define PAD_EN_SHIFT 15
+#define EDMA_REG_PORT_CTRL 0x4A8
+#define EDMA_PAD_EN_SHIFT 15
 
 /* Tx side VLAN Configuration Register */
-#define REG_VLAN_CFG 0x4AC
+#define EDMA_REG_VLAN_CFG 0x4AC
 
 #define EDMA_TX_CVLAN 16
 #define EDMA_TX_INS_CVLAN 17
@@ -164,35 +161,35 @@ struct edma_hw;
 #define EDMA_TX_SVLAN_TAG_SHIFT 16
 
 /* Tx Queue Packet Statistic Register */
-#define REG_TX_STAT_PKT_Q(x) (0x700 + ((x) << 3)) /* x = queue id */
+#define EDMA_REG_TX_STAT_PKT_Q(x) (0x700 + ((x) << 3)) /* x = queue id */
 
-#define TX_STAT_PKT_MASK 0xFFFFFF
+#define EDMA_TX_STAT_PKT_MASK 0xFFFFFF
 
 /* Tx Queue Byte Statistic Register */
-#define REG_TX_STAT_BYTE_Q(x) (0x704 + ((x) << 3)) /* x = queue id */
+#define EDMA_REG_TX_STAT_BYTE_Q(x) (0x704 + ((x) << 3)) /* x = queue id */
 
 /* Load Balance Based Ring Offset Register */
-#define REG_LB_RING 0x800
-#define LB_RING_ENTRY_MASK 0xff
-#define LB_RING_ID_MASK 0x7
-#define LB_RING_PROFILE_ID_MASK 0x3
-#define LB_RING_ENTRY_BIT_OFFSET 8
-#define LB_RING_ID_OFFSET 0
-#define LB_RING_PROFILE_ID_OFFSET 3
+#define EDMA_REG_LB_RING 0x800
+#define EDMA_LB_RING_ENTRY_MASK 0xff
+#define EDMA_LB_RING_ID_MASK 0x7
+#define EDMA_LB_RING_PROFILE_ID_MASK 0x3
+#define EDMA_LB_RING_ENTRY_BIT_OFFSET 8
+#define EDMA_LB_RING_ID_OFFSET 0
+#define EDMA_LB_RING_PROFILE_ID_OFFSET 3
 #define EDMA_LB_REG_VALUE 0x6040200
 
 /* Load Balance Priority Mapping Register */
-#define REG_LB_PRI_START 0x804
-#define REG_LB_PRI_END 0x810
-#define LB_PRI_REG_INC 4
-#define LB_PRI_ENTRY_BIT_OFFSET 4
-#define LB_PRI_ENTRY_MASK 0xf
+#define EDMA_REG_LB_PRI_START 0x804
+#define EDMA_REG_LB_PRI_END 0x810
+#define EDMA_LB_PRI_REG_INC 4
+#define EDMA_LB_PRI_ENTRY_BIT_OFFSET 4
+#define EDMA_LB_PRI_ENTRY_MASK 0xf
 
 /* RSS Priority Mapping Register */
-#define REG_RSS_PRI 0x820
-#define RSS_PRI_ENTRY_MASK 0xf
-#define RSS_RING_ID_MASK 0x7
-#define RSS_PRI_ENTRY_BIT_OFFSET 4
+#define EDMA_REG_RSS_PRI 0x820
+#define EDMA_RSS_PRI_ENTRY_MASK 0xf
+#define EDMA_RSS_RING_ID_MASK 0x7
+#define EDMA_RSS_PRI_ENTRY_BIT_OFFSET 4
 
 /* RSS Indirection Register */
 #define EDMA_REG_RSS_IDT(x) (0x840 + ((x) << 2)) /* x = No. of indirection table */
@@ -200,11 +197,11 @@ struct edma_hw;
 #define EDMA_RSS_IDT_VALUE 0x64206420
 
 /* Default RSS Ring Register */
-#define REG_DEF_RSS 0x890
-#define DEF_RSS_MASK 0x7
+#define EDMA_REG_DEF_RSS 0x890
+#define EDMA_DEF_RSS_MASK 0x7
 
 /* RSS Hash Function Type Register */
-#define REG_RSS_TYPE 0x894
+#define EDMA_REG_RSS_TYPE 0x894
 #define EDMA_RSS_TYPE_NONE 0x01
 #define EDMA_RSS_TYPE_IPV4TCP 0x02
 #define EDMA_RSS_TYPE_IPV6_TCP 0x04
@@ -212,11 +209,11 @@ struct edma_hw;
 #define EDMA_RSS_TYPE_IPV6UDP 0x10
 #define EDMA_RSS_TYPE_IPV4 0x20
 #define EDMA_RSS_TYPE_IPV6 0x40
-#define RSS_HASH_MODE_MASK 0x7f
+#define EDMA_RSS_HASH_MODE_MASK 0x7f
 
-#define REG_RSS_HASH_VALUE 0x8C0
+#define EDMA_REG_RSS_HASH_VALUE 0x8C0
 
-#define REG_RSS_TYPE_RESULT 0x8C4
+#define EDMA_REG_RSS_TYPE_RESULT 0x8C4
 
 #define EDMA_HASH_TYPE_START 0
 #define EDMA_HASH_TYPE_END 5
@@ -227,77 +224,77 @@ struct edma_hw;
 #define EDMA_RFS_EXPIRE_COUNT_PER_CALL 128
 
 /* RFD Base Address Register */
-#define REG_RFD_BASE_ADDR_Q(x) (0x950 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_RFD_BASE_ADDR_Q(x) (0x950 + ((x) << 2)) /* x = queue id */
 
 /* RFD Index Register */
-#define REG_RFD_IDX_Q(x) (0x9B0 + ((x) << 2))
+#define EDMA_REG_RFD_IDX_Q(x) (0x9B0 + ((x) << 2))
 
-#define RFD_PROD_IDX_BITS 0x00000FFF
-#define RFD_CONS_IDX_BITS 0x0FFF0000
-#define RFD_PROD_IDX_MASK 0xFFF
-#define RFD_CONS_IDX_MASK 0xFFF
-#define RFD_PROD_IDX_SHIFT 0
-#define RFD_CONS_IDX_SHIFT 16
+#define EDMA_RFD_PROD_IDX_BITS 0x00000FFF
+#define EDMA_RFD_CONS_IDX_BITS 0x0FFF0000
+#define EDMA_RFD_PROD_IDX_MASK 0xFFF
+#define EDMA_RFD_CONS_IDX_MASK 0xFFF
+#define EDMA_RFD_PROD_IDX_SHIFT 0
+#define EDMA_RFD_CONS_IDX_SHIFT 16
 
 /* Rx Descriptor Control Register */
-#define REG_RX_DESC0 0xA10
-#define RFD_RING_SIZE_MASK 0xFFF
-#define RX_BUF_SIZE_MASK 0xFFFF
-#define RFD_RING_SIZE_SHIFT 0
-#define RX_BUF_SIZE_SHIFT 16
-
-#define REG_RX_DESC1 0xA14
-#define RXQ_RFD_BURST_NUM_MASK 0x3F
-#define RXQ_RFD_PF_THRESH_MASK 0x1F
-#define RXQ_RFD_LOW_THRESH_MASK 0xFFF
-#define RXQ_RFD_BURST_NUM_SHIFT 0
-#define RXQ_RFD_PF_THRESH_SHIFT 8
-#define RXQ_RFD_LOW_THRESH_SHIFT 16
+#define EDMA_REG_RX_DESC0 0xA10
+#define EDMA_RFD_RING_SIZE_MASK 0xFFF
+#define EDMA_RX_BUF_SIZE_MASK 0xFFFF
+#define EDMA_RFD_RING_SIZE_SHIFT 0
+#define EDMA_RX_BUF_SIZE_SHIFT 16
+
+#define EDMA_REG_RX_DESC1 0xA14
+#define EDMA_RXQ_RFD_BURST_NUM_MASK 0x3F
+#define EDMA_RXQ_RFD_PF_THRESH_MASK 0x1F
+#define EDMA_RXQ_RFD_LOW_THRESH_MASK 0xFFF
+#define EDMA_RXQ_RFD_BURST_NUM_SHIFT 0
+#define EDMA_RXQ_RFD_PF_THRESH_SHIFT 8
+#define EDMA_RXQ_RFD_LOW_THRESH_SHIFT 16
 
 /* RXQ Control Register */
-#define REG_RXQ_CTRL 0xA18
-#define FIFO_THRESH_TYPE_SHIF 0
-#define FIFO_THRESH_128_BYTE 0x0
-#define FIFO_THRESH_64_BYTE 0x1
-#define RXQ_CTRL_RMV_VLAN 0x00000002
-#define RXQ_CTRL_EN 0x0000FF00
+#define EDMA_REG_RXQ_CTRL 0xA18
+#define EDMA_FIFO_THRESH_TYPE_SHIF 0
+#define EDMA_FIFO_THRESH_128_BYTE 0x0
+#define EDMA_FIFO_THRESH_64_BYTE 0x1
+#define EDMA_RXQ_CTRL_RMV_VLAN 0x00000002
+#define EDMA_RXQ_CTRL_EN 0x0000FF00
 
 /* Rx Statistics Register */
-#define REG_RX_STAT_BYTE_Q(x) (0xA30 + ((x) << 2)) /* x = queue id */
-#define REG_RX_STAT_PKT_Q(x) (0xA50 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_RX_STAT_BYTE_Q(x) (0xA30 + ((x) << 2)) /* x = queue id */
+#define EDMA_REG_RX_STAT_PKT_Q(x) (0xA50 + ((x) << 2)) /* x = queue id */
 
 /* WoL Pattern Length Register */
-#define REG_WOL_PATTERN_LEN0 0xC00
-#define WOL_PT_LEN_MASK 0xFF
-#define WOL_PT0_LEN_SHIFT 0
-#define WOL_PT1_LEN_SHIFT 8
-#define WOL_PT2_LEN_SHIFT 16
-#define WOL_PT3_LEN_SHIFT 24
-
-#define REG_WOL_PATTERN_LEN1 0xC04
-#define WOL_PT4_LEN_SHIFT 0
-#define WOL_PT5_LEN_SHIFT 8
-#define WOL_PT6_LEN_SHIFT 16
+#define EDMA_REG_WOL_PATTERN_LEN0 0xC00
+#define EDMA_WOL_PT_LEN_MASK 0xFF
+#define EDMA_WOL_PT0_LEN_SHIFT 0
+#define EDMA_WOL_PT1_LEN_SHIFT 8
+#define EDMA_WOL_PT2_LEN_SHIFT 16
+#define EDMA_WOL_PT3_LEN_SHIFT 24
+
+#define EDMA_REG_WOL_PATTERN_LEN1 0xC04
+#define EDMA_WOL_PT4_LEN_SHIFT 0
+#define EDMA_WOL_PT5_LEN_SHIFT 8
+#define EDMA_WOL_PT6_LEN_SHIFT 16
 
 /* WoL Control Register */
-#define REG_WOL_CTRL 0xC08
-#define WOL_WK_EN 0x00000001
-#define WOL_MG_EN 0x00000002
-#define WOL_PT0_EN 0x00000004
-#define WOL_PT1_EN 0x00000008
-#define WOL_PT2_EN 0x00000010
-#define WOL_PT3_EN 0x00000020
-#define WOL_PT4_EN 0x00000040
-#define WOL_PT5_EN 0x00000080
-#define WOL_PT6_EN 0x00000100
+#define EDMA_REG_WOL_CTRL 0xC08
+#define EDMA_WOL_WK_EN 0x00000001
+#define EDMA_WOL_MG_EN 0x00000002
+#define EDMA_WOL_PT0_EN 0x00000004
+#define EDMA_WOL_PT1_EN 0x00000008
+#define EDMA_WOL_PT2_EN 0x00000010
+#define EDMA_WOL_PT3_EN 0x00000020
+#define EDMA_WOL_PT4_EN 0x00000040
+#define EDMA_WOL_PT5_EN 0x00000080
+#define EDMA_WOL_PT6_EN 0x00000100
 
 /* MAC Control Register */
-#define REG_MAC_CTRL0 0xC20
-#define REG_MAC_CTRL1 0xC24
+#define EDMA_REG_MAC_CTRL0 0xC20
+#define EDMA_REG_MAC_CTRL1 0xC24
 
 /* WoL Pattern Register */
-#define REG_WOL_PATTERN_START 0x5000
-#define PATTERN_PART_REG_OFFSET 0x40
+#define EDMA_REG_WOL_PATTERN_START 0x5000
+#define EDMA_PATTERN_PART_REG_OFFSET 0x40
 
 
 /* TX descriptor fields */
Index: linux-3.14.43/drivers/net/phy/ar8216.c
===================================================================
--- linux-3.14.43.orig/drivers/net/phy/ar8216.c
+++ linux-3.14.43/drivers/net/phy/ar8216.c
@@ -1645,44 +1645,59 @@ ar8327_hw_config_of(struct ar8xxx_priv *
 #endif
 
 static void
-ar8327_port_phy_linkdown(struct ar8xxx_priv *priv)
+ar8327_port_phy_linkdown(struct ar8xxx_priv *priv, int port)
 {
 	struct mii_bus *bus;
-	int i;
 	u16 val;
 
 	bus = priv->mii_bus;
-	for (i = 0; i < AR8327_NUM_PHYS; i++) {
-		mdiobus_write(bus, i, MII_CTRL1000, 0);
-		mdiobus_write(bus, i, MII_ADVERTISE, 0);
-		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
-		ar8xxx_phy_dbg_read(priv, i, AR8337_PHY_DEBUG_0, &val);
-		val |= AR8337_PHY_MANU_CTRL_EN;
-		ar8xxx_phy_dbg_write(priv, i, AR8337_PHY_DEBUG_0, val);
-		/*disable transmit*/
-		ar8xxx_phy_dbg_read(priv, i, AR8337_PHY_DEBUG_2, &val);
-		val &= 0xf00f;
-		ar8xxx_phy_dbg_write(priv, i, AR8337_PHY_DEBUG_2, val);
-	}
+
+	mdiobus_write(bus, port - 1, MII_CTRL1000, 0);
+	mdiobus_write(bus, port - 1, MII_ADVERTISE, 0);
+	mdiobus_write(bus, port - 1, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	ar8xxx_phy_dbg_read(priv, port - 1, AR8337_PHY_DEBUG_0, &val);
+	val |= AR8337_PHY_MANU_CTRL_EN;
+	ar8xxx_phy_dbg_write(priv, port - 1, AR8337_PHY_DEBUG_0, val);
+	/*disable transmit*/
+	ar8xxx_phy_dbg_read(priv, port - 1, AR8337_PHY_DEBUG_2, &val);
+	val &= 0xf00f;
+	ar8xxx_phy_dbg_write(priv, port - 1, AR8337_PHY_DEBUG_2, val);
+
 }
 
 static void
-ar8327_port_phy_init(struct ar8xxx_priv *priv)
+ar8327_phy_linkdown(struct ar8xxx_priv *priv)
 {
-	struct mii_bus *bus;
 	int i;
 
+	for (i = 0; i < AR8327_NUM_PHYS; i++)
+		ar8327_port_phy_linkdown(priv, i + 1);
+}
+
+static void
+ar8327_port_phy_init(struct ar8xxx_priv *priv, int port)
+{
+	struct mii_bus *bus;
+
 	bus = priv->mii_bus;
-	for (i = 0; i < AR8327_NUM_PHYS; i++) {
-		ar8327_phy_fixup(priv, i);
+	ar8327_phy_fixup(priv, port - 1);
 
-		/* start aneg on the PHY */
-		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
-						     ADVERTISE_PAUSE_CAP |
-						     ADVERTISE_PAUSE_ASYM);
-		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
-		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
-	}
+	/* start aneg on the PHY */
+	mdiobus_write(bus, port - 1, MII_ADVERTISE, ADVERTISE_ALL |
+					     ADVERTISE_PAUSE_CAP |
+					     ADVERTISE_PAUSE_ASYM);
+	mdiobus_write(bus, port - 1, MII_CTRL1000, ADVERTISE_1000FULL);
+	mdiobus_write(bus, port - 1, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+
+}
+
+static void
+ar8327_phy_init(struct ar8xxx_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < AR8327_NUM_PHYS; i++)
+		ar8327_port_phy_init(priv, i + 1);
 
 	msleep(1000);
 }
@@ -1702,7 +1717,7 @@ ar8327_hw_init(struct ar8xxx_priv *priv)
 		return ret;
 
 	ar8327_leds_init(priv);
-	ar8327_port_phy_init(priv);
+	ar8327_phy_init(priv);
 	return 0;
 }
 
@@ -1967,6 +1982,21 @@ ar8xxx_sw_get_pvid(struct switch_dev *de
 }
 
 static int
+ar8xxx_sw_set_port_linkdown(struct switch_dev *dev,
+			   const struct switch_attr *attr,
+			   struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	if (val->value.i == 1)
+		ar8327_port_phy_linkdown(priv, val->port_vlan);
+	else
+		ar8327_port_phy_init(priv, val->port_vlan);
+
+	return 0;
+}
+
+static int
 ar8xxx_sw_set_linkdown(struct switch_dev *dev,
 			   const struct switch_attr *attr,
 			   struct switch_val *val)
@@ -1974,9 +2004,9 @@ ar8xxx_sw_set_linkdown(struct switch_dev
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 
 	if (val->value.i == 1)
-		ar8327_port_phy_linkdown(priv);
+		ar8327_phy_linkdown(priv);
 	else
-		ar8327_port_phy_init(priv);
+		ar8327_phy_init(priv);
 
 	return 0;
 }
@@ -2685,6 +2715,13 @@ static struct switch_attr ar8xxx_sw_attr
 		.set = NULL,
 		.get = ar8xxx_sw_get_port_mib,
 	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "linkdown",
+		.description = "Link down single phy",
+		.set = ar8xxx_sw_set_port_linkdown,
+		.max = 1
+	},
 };
 
 static struct switch_attr ar8xxx_sw_attr_vlan[] = {
@@ -2983,7 +3020,7 @@ ar8xxx_phy_config_init(struct phy_device
 
 	if (chip_is_ar8327(priv) || chip_is_ar8337(priv)) {
 		if(phydev->addr == 0)
-			ar8327_port_phy_init(priv);
+			ar8327_phy_init(priv);
 		return 0;
 	}
 
Index: linux-3.14.43/drivers/net/phy/swconfig.c
===================================================================
--- linux-3.14.43.orig/drivers/net/phy/swconfig.c
+++ linux-3.14.43/drivers/net/phy/swconfig.c
@@ -813,13 +813,15 @@ swconfig_set_attr(struct sk_buff *skb, s
 
 error:
 	/* free memory if necessary */
-	switch(attr->type) {
-	case SWITCH_TYPE_EXT:
-		switch_ext_p = val.value.ext_val;
-		while(switch_ext_p) {
-			struct switch_ext *ext_value_p = switch_ext_p;
-			switch_ext_p = switch_ext_p->next;
-			kfree(ext_value_p);
+	if (attr) {
+		switch (attr->type) {
+		case SWITCH_TYPE_EXT:
+			switch_ext_p = val.value.ext_val;
+			while (switch_ext_p) {
+				struct switch_ext *ext_value_p = switch_ext_p;
+				switch_ext_p = switch_ext_p->next;
+				kfree(ext_value_p);
+			}
 		}
 	}
 
Index: linux-3.14.43/drivers/net/ppp/ppp_generic.c
===================================================================
--- linux-3.14.43.orig/drivers/net/ppp/ppp_generic.c
+++ linux-3.14.43/drivers/net/ppp/ppp_generic.c
@@ -2304,6 +2304,20 @@ char *ppp_dev_name(struct ppp_channel *c
 	return name;
 }
 
+/* Return the PPP net device index */
+int ppp_dev_index(struct ppp_channel *chan)
+{
+	struct channel *pch = chan->ppp;
+	int ifindex = 0;
+
+	if (pch) {
+		read_lock_bh(&pch->upl);
+		if (pch->ppp && pch->ppp->dev)
+			ifindex = pch->ppp->dev->ifindex;
+		read_unlock_bh(&pch->upl);
+	}
+	return ifindex;
+}
 
 /*
  * Disconnect a channel from the generic layer.
@@ -3002,7 +3016,10 @@ static void *unit_find(struct idr *p, in
  * Updates the PPP interface statistics.
  */
 void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
-		unsigned long rx_bytes, unsigned long tx_packets, unsigned long tx_bytes)
+		unsigned long rx_bytes, unsigned long tx_packets,
+		unsigned long tx_bytes, unsigned long rx_errors,
+		unsigned long tx_errors, unsigned long rx_dropped,
+		unsigned long tx_dropped)
 {
 	struct ppp *ppp;
 
@@ -3017,11 +3034,19 @@ void ppp_update_stats(struct net_device
 	ppp_xmit_lock(ppp);
 	ppp->stats64.tx_packets += tx_packets;
 	ppp->stats64.tx_bytes += tx_bytes;
+	ppp->dev->stats.tx_errors += tx_errors;
+	ppp->dev->stats.tx_dropped += tx_dropped;
+	if (tx_packets)
+		ppp->last_xmit = jiffies;
 	ppp_xmit_unlock(ppp);
 
 	ppp_recv_lock(ppp);
 	ppp->stats64.rx_packets += rx_packets;
 	ppp->stats64.rx_bytes += rx_bytes;
+	ppp->dev->stats.rx_errors += rx_errors;
+	ppp->dev->stats.rx_dropped += rx_dropped;
+	if (rx_packets)
+		ppp->last_recv = jiffies;
 	ppp_recv_unlock(ppp);
 }
 
@@ -3130,6 +3155,32 @@ int ppp_is_multilink(struct net_device *
 }
 
 /*
+ * __ppp_is_multilink()
+ *	Returns >0 if the device is a multilink PPP netdevice, 0 if not or < 0
+ *	if the device is not PPP. Caller should acquire ppp_lock before calling
+ *	this function
+ */
+int __ppp_is_multilink(struct net_device *dev)
+{
+	struct ppp *ppp;
+	unsigned int flags;
+
+	if (!dev) {
+		return -1;
+	}
+	if (dev->type != ARPHRD_PPP) {
+		return -1;
+	}
+
+	ppp = netdev_priv(dev);
+	flags = ppp->flags;
+	if (flags & SC_MULTILINK) {
+		return 1;
+	}
+	return 0;
+}
+
+/*
  * ppp_channel_get_protocol()
  *	Call this to obtain the underlying protocol of the PPP channel, e.g. PX_PROTO_OE
  *
@@ -3237,6 +3288,65 @@ int ppp_hold_channels(struct net_device
 }
 
 /*
+ * __ppp_hold_channels()
+ *	Returns the PPP channels of the PPP device, storing each one into channels[].
+ *
+ * channels[] has chan_sz elements.
+ * This function returns the number of channels stored, up to chan_sz.
+ * It will return < 0 if the device is not PPP.
+ *
+ * You MUST acquire ppp_lock and  release the channels using ppp_release_channels().
+ */
+int __ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[], unsigned int chan_sz)
+{
+	struct ppp *ppp;
+	int c;
+	struct channel *pch;
+
+	if (!dev) {
+		return -1;
+	}
+	if (dev->type != ARPHRD_PPP) {
+		return -1;
+	}
+
+	ppp = netdev_priv(dev);
+
+	c = 0;
+	list_for_each_entry(pch, &ppp->channels, clist) {
+		struct ppp_channel *chan;
+
+		if (!pch->chan) {
+			/*
+			 * Channel is going / gone away
+			 */
+			continue;
+		}
+		if (c == chan_sz) {
+			/*
+			 * No space to record channel
+			 */
+			return c;
+		}
+
+		/*
+		 * Hold the channel, if supported
+		 */
+		chan = pch->chan;
+		if (!chan->ops->hold) {
+			continue;
+		}
+		chan->ops->hold(chan);
+
+		/*
+		 * Record the channel
+		 */
+		channels[c++] = chan;
+	}
+	return c;
+}
+
+/*
  * ppp_release_channels()
  *	Releases channels
  */
@@ -3261,6 +3371,7 @@ EXPORT_SYMBOL(ppp_unregister_channel);
 EXPORT_SYMBOL(ppp_channel_index);
 EXPORT_SYMBOL(ppp_unit_number);
 EXPORT_SYMBOL(ppp_dev_name);
+EXPORT_SYMBOL(ppp_dev_index);
 EXPORT_SYMBOL(ppp_input);
 EXPORT_SYMBOL(ppp_input_error);
 EXPORT_SYMBOL(ppp_output_wakeup);
@@ -3270,7 +3381,9 @@ EXPORT_SYMBOL(ppp_update_stats);
 EXPORT_SYMBOL(ppp_register_destroy_method);
 EXPORT_SYMBOL(ppp_unregister_destroy_method);
 EXPORT_SYMBOL(ppp_is_multilink);
+EXPORT_SYMBOL(__ppp_is_multilink);
 EXPORT_SYMBOL(ppp_hold_channels);
+EXPORT_SYMBOL(__ppp_hold_channels);
 EXPORT_SYMBOL(ppp_release_channels);
 EXPORT_SYMBOL(ppp_channel_get_protocol);
 EXPORT_SYMBOL(ppp_channel_hold);
Index: linux-3.14.43/drivers/net/ppp/pppoe.c
===================================================================
--- linux-3.14.43.orig/drivers/net/ppp/pppoe.c
+++ linux-3.14.43/drivers/net/ppp/pppoe.c
@@ -598,8 +598,10 @@ static int pppoe_release(struct socket *
 	po = pppox_sk(sk);
 
 	if (sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {
-		dev_put(po->pppoe_dev);
-		po->pppoe_dev = NULL;
+		if (po->pppoe_dev) {
+			dev_put(po->pppoe_dev);
+			po->pppoe_dev = NULL;
+		}
 	}
 
 	pppox_unbind_sock(sk);
Index: linux-3.14.43/drivers/pci/host/pci-qcom.c
===================================================================
--- linux-3.14.43.orig/drivers/pci/host/pci-qcom.c
+++ linux-3.14.43/drivers/pci/host/pci-qcom.c
@@ -20,6 +20,7 @@
 #include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/of_address.h>
+#include <linux/of_platform.h>
 #include <linux/clk.h>
 #include <linux/reset.h>
 #include <linux/delay.h>
@@ -29,6 +30,7 @@
 #define PCIE_DEVICE_ID_RCP		0x0101
 
 #define __set(v, a, b)	(((v) << (b)) & GENMASK(a, b))
+#define __mask(a, b)	(((1 << ((a) + 1)) - 1) & ~((1 << (b)) - 1))
 
 #define PCIE20_PARF_PCS_DEEMPH		0x34
 #define PCIE20_PARF_PCS_DEEMPH_TX_DEEMPH_GEN1(x)	__set(x, 21, 16)
@@ -60,6 +62,12 @@
 #define PCIE20_BUSNUMBERS		0x18
 #define PCIE20_MEMORY_BASE_LIMIT	0x20
 
+#define PCIE20_DEV_CAS			0x78
+#define PCIE20_MRRS_MASK		__mask(14, 12)
+#define PCIE20_MRRS(x)			__set(x, 14, 12)
+#define PCIE20_MPS_MASK			__mask(7, 5)
+#define PCIE20_MPS(x)			__set(x, 7, 5)
+
 #define PCIE20_AXI_MSTR_RESP_COMP_CTRL0 0x818
 #define PCIE20_AXI_MSTR_RESP_COMP_CTRL1 0x81c
 #define PCIE20_PLR_IATU_VIEWPORT	0x900
@@ -113,6 +121,9 @@ struct qcom_pcie {
 	struct clk		*iface_clk;
 	struct clk		*bus_clk;
 	struct clk		*phy_clk;
+	struct clk		*alt_clk;
+	struct clk		*alt_src;
+	struct clk		*aux_clk;
 	int			irq_int[4];
 	int			root_bus_nr;
 	struct reset_control	*axi_reset;
@@ -120,15 +131,24 @@ struct qcom_pcie {
 	struct reset_control	*por_reset;
 	struct reset_control	*pci_reset;
 	struct reset_control	*phy_reset;
+	struct reset_control	*ext_reset;
 
 	struct resource		conf;
 	struct resource		io;
 	struct resource		mem;
+	int			phy_txterm_offset;
+	int			force_gen1;
+	struct pci_bus		*pci_bus;
 };
 
+static atomic_t rc_removed;
 static int nr_controllers;
+static struct qcom_pcie *qcom_pcie_dev[MAX_RC_NUM];
+
 static DEFINE_SPINLOCK(qcom_hw_pci_lock);
 
+static int qcom_pcie_enumerate(struct qcom_pcie *dev);
+
 static inline struct qcom_pcie *sys_to_pcie(struct pci_sys_data *sys)
 {
 	return sys->private_data;
@@ -147,6 +167,30 @@ static int qcom_pcie_is_link_up(struct q
 			     BIT(29);
 }
 
+static struct of_device_id qcom_pcie_match[] = {
+	{
+		.compatible = "qcom,pcie-ipq8064",
+		.data       =
+			(void *)PCIE20_PARF_PHY_CTRL_PHY_TX0_TERM_OFFST(7),
+	},
+	{
+		.compatible = "qcom,pcie-ipq8064-v2",
+		.data       =
+			(void *)PCIE20_PARF_PHY_CTRL_PHY_TX0_TERM_OFFST(0),
+	},
+	{}
+};
+
+static u32 qcom_get_phy_tx0_term_offset(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(qcom_pcie_match, &pdev->dev);
+	if (!of_id)
+		return PCIE20_PARF_PHY_CTRL_PHY_TX0_TERM_OFFST(7);
+
+	return (u32)of_id->data;
+}
+
 inline int msm_pcie_get_cfgtype(struct pci_bus *bus)
 {
 	struct qcom_pcie *dev = sys_to_pcie(bus->sysdata);
@@ -305,6 +349,7 @@ static struct pci_bus *qcom_pcie_scan_bu
 		bus = NULL;
 		BUG();
 	}
+	qcom_pcie->pci_bus = bus;
 
 	return bus;
 }
@@ -525,6 +570,24 @@ static int qcom_pcie_parse_dt(struct qco
 		return PTR_ERR(qcom_pcie->bus_clk);
 	}
 
+	qcom_pcie->alt_clk = devm_clk_get(&pdev->dev, "alt_clk");
+	if (IS_ERR(qcom_pcie->alt_clk)) {
+		dev_err(&pdev->dev, "Failed to get pcie alt ref clock\n");
+		return PTR_ERR(qcom_pcie->alt_clk);
+	}
+
+	qcom_pcie->alt_src = devm_clk_get(&pdev->dev, "alt_src");
+	if (IS_ERR(qcom_pcie->alt_src)) {
+		dev_err(&pdev->dev, "Failed to get pcie alt ref src clock\n");
+		return PTR_ERR(qcom_pcie->alt_src);
+	}
+
+	qcom_pcie->aux_clk = devm_clk_get(&pdev->dev, "aux");
+	if (IS_ERR(qcom_pcie->aux_clk)) {
+		dev_err(&pdev->dev, "Failed to get pcie aux clock\n");
+		return PTR_ERR(qcom_pcie->aux_clk);
+	}
+
 	qcom_pcie->axi_reset = devm_reset_control_get(&pdev->dev, "axi");
 	if (IS_ERR(qcom_pcie->axi_reset)) {
 		dev_err(&pdev->dev, "Failed to get axi reset\n");
@@ -555,6 +618,12 @@ static int qcom_pcie_parse_dt(struct qco
 		return PTR_ERR(qcom_pcie->phy_reset);
 	}
 
+	qcom_pcie->ext_reset = devm_reset_control_get(&pdev->dev, "ext");
+	if (IS_ERR(qcom_pcie->ext_reset)) {
+		dev_err(&pdev->dev, "Failed to get ext reset\n");
+		return PTR_ERR(qcom_pcie->ext_reset);
+	}
+
 	for (i = 0; i < 4; i++) {
 		qcom_pcie->irq_int[i] = platform_get_irq(pdev, i+1);
 		if (qcom_pcie->irq_int[i] < 0) {
@@ -566,15 +635,113 @@ static int qcom_pcie_parse_dt(struct qco
 	return 0;
 }
 
+static int qcom_rc_remove(struct qcom_pcie *qcom_pcie)
+{
+	gpio_set_value(qcom_pcie->reset_gpio, 0);
+	usleep_range(10000, 15000);
+
+	/* assert PICe PHY, Core, POR, Ahb, Ext and AXI clk domain resets */
+	reset_control_assert(qcom_pcie->axi_reset);
+	reset_control_assert(qcom_pcie->ahb_reset);
+	reset_control_assert(qcom_pcie->por_reset);
+	reset_control_assert(qcom_pcie->pci_reset);
+	reset_control_assert(qcom_pcie->phy_reset);
+	reset_control_assert(qcom_pcie->ext_reset);
+
+	/* wait 150ms for clock acquisition */
+	usleep_range(10000, 15000);
+
+	qcom_parf_writel_relaxed(qcom_pcie, 0x1, PCIE20_PARF_PHY_CTRL);
+
+	/* disable clocks */
+	clk_disable_unprepare(qcom_pcie->iface_clk);
+	clk_disable_unprepare(qcom_pcie->bus_clk);
+	clk_disable_unprepare(qcom_pcie->aux_clk);
+	clk_disable_unprepare(qcom_pcie->alt_src);
+	clk_disable_unprepare(qcom_pcie->alt_clk);
+	pci_stop_root_bus(qcom_pcie->pci_bus);
+	pci_remove_root_bus(qcom_pcie->pci_bus);
+	qcom_pcie->pci_bus = NULL;
+	nr_controllers--;
+
+	return 0;
+}
+
+int qcom_pcie_rescan(void)
+{
+	int i;
+
+	if (!atomic_read(&rc_removed))
+		return 0;
+
+	for (i = 0; i < MAX_RC_NUM; i++) {
+		/* reset and enumerate the pcie devices */
+		if (qcom_pcie_dev[i])
+			qcom_pcie_enumerate(qcom_pcie_dev[i]);
+	}
+	atomic_set(&rc_removed, 0);
+
+	return 0;
+}
+
+void qcom_pcie_remove_bus(void)
+{
+	int i;
+
+	if (atomic_read(&rc_removed))
+		return;
+
+	for (i = 0; i < MAX_RC_NUM; i++) {
+		if (qcom_pcie_dev[i]) {
+			pr_notice("---> Removing %d", i);
+			qcom_rc_remove(qcom_pcie_dev[i]);
+			pr_notice(" ... done<---\n");
+		}
+	}
+	atomic_set(&rc_removed, 1);
+}
+
+static ssize_t qcom_bus_rescan_store(struct bus_type *bus, const char *buf,
+					size_t count)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		pci_lock_rescan_remove();
+		qcom_pcie_rescan();
+		pci_unlock_rescan_remove();
+	}
+	return count;
+}
+static BUS_ATTR(rcrescan, (S_IWUSR|S_IWGRP), NULL, qcom_bus_rescan_store);
+
+static ssize_t qcom_bus_remove_store(struct bus_type *bus, const char *buf,
+					size_t count)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		pci_lock_rescan_remove();
+		qcom_pcie_remove_bus();
+		pci_unlock_rescan_remove();
+	}
+	return count;
+}
+static BUS_ATTR(rcremove, (S_IWUSR|S_IWGRP), NULL, qcom_bus_remove_store);
+
 static int qcom_pcie_probe(struct platform_device *pdev)
 {
-	unsigned long flags;
-	struct qcom_pcie *qcom_pcie;
 	struct device_node *np = pdev->dev.of_node;
-	struct hw_pci *hw;
+	struct qcom_pcie *qcom_pcie;
 	int ret;
-	u32 val;
 	uint32_t force_gen1 = 0;
+	static int rc_idx;
 
 	qcom_pcie = devm_kzalloc(&pdev->dev, sizeof(*qcom_pcie), GFP_KERNEL);
 	if (!qcom_pcie) {
@@ -588,11 +755,53 @@ static int qcom_pcie_probe(struct platfo
 		return ret;
 
 	qcom_pcie->cfg_base = devm_ioremap_resource(&pdev->dev,
-						    &qcom_pcie->conf);
+						&qcom_pcie->conf);
 	if (IS_ERR(qcom_pcie->cfg_base)) {
 		dev_err(&pdev->dev, "Failed to ioremap PCIe cfg space\n");
 		return PTR_ERR(qcom_pcie->cfg_base);
 	}
+	/* get tx termination offset */
+	qcom_pcie->phy_txterm_offset =
+				qcom_get_phy_tx0_term_offset(pdev);
+
+	/*
+	 * Force Gen1 in Gen1 marked PCIe SLOT
+	 */
+	ret = of_property_read_u32(np, "force_gen1", &force_gen1);
+	if (!ret && force_gen1)
+		qcom_pcie->force_gen1 = 1;
+
+	platform_set_drvdata(pdev, qcom_pcie);
+
+	qcom_pcie_enumerate(qcom_pcie);
+
+	/* create sysfs files to support power save mode */
+	if (!rc_idx) {
+		ret = bus_create_file(&pci_bus_type, &bus_attr_rcrescan);
+		if (ret != 0) {
+			dev_err(&pdev->dev,
+				"Failed to create sysfs rcrescan file\n");
+			return ret;
+		}
+
+		ret = bus_create_file(&pci_bus_type, &bus_attr_rcremove);
+		if (ret != 0) {
+			dev_err(&pdev->dev,
+				"Failed to create sysfs rcremove file\n");
+			return ret;
+		}
+	}
+
+	qcom_pcie_dev[rc_idx++] = qcom_pcie;
+	return 0;
+}
+
+static int qcom_pcie_enumerate(struct qcom_pcie *qcom_pcie)
+{
+	unsigned long flags;
+	struct hw_pci *hw;
+	int ret;
+	u32 val;
 
 	gpio_set_value(qcom_pcie->reset_gpio, 0);
 	usleep_range(10000, 15000);
@@ -610,6 +819,15 @@ static int qcom_pcie_probe(struct platfo
 	ret = clk_prepare_enable(qcom_pcie->bus_clk);
 	if (ret)
 		return ret;
+	ret = clk_prepare_enable(qcom_pcie->aux_clk);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(qcom_pcie->alt_src);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(qcom_pcie->alt_clk);
+	if (ret)
+		return ret;
 
 	/*
 	 * de-assert PCIe PARF reset;
@@ -624,11 +842,7 @@ static int qcom_pcie_probe(struct platfo
 
 	/* Set Tx Termination Offset */
 	val = qcom_parf_readl_relaxed(qcom_pcie, PCIE20_PARF_PHY_CTRL);
-	if (of_device_is_compatible(np, "qcom,pcie-ipq8064-v2"))
-		val |= PCIE20_PARF_PHY_CTRL_PHY_TX0_TERM_OFFST(0);
-	else
-		val |= PCIE20_PARF_PHY_CTRL_PHY_TX0_TERM_OFFST(7);
-
+	val |= qcom_pcie->phy_txterm_offset;
 	qcom_parf_writel_relaxed(qcom_pcie, val, PCIE20_PARF_PHY_CTRL);
 
 	/* PARF programming */
@@ -657,6 +871,7 @@ static int qcom_pcie_probe(struct platfo
 	reset_control_deassert(qcom_pcie->pci_reset);
 	reset_control_deassert(qcom_pcie->por_reset);
 	reset_control_deassert(qcom_pcie->axi_reset);
+	reset_control_deassert(qcom_pcie->ext_reset);
 
 	/* wait 150ms for clock acquisition */
 	usleep_range(10000, 15000);
@@ -666,15 +881,12 @@ static int qcom_pcie_probe(struct platfo
 	usleep_range(10000, 15000);
 
 	/*
-	 * Force Gen1 in Gen1 marked PCIe SLOT
-	 */
-	if (of_device_is_compatible(np, "qcom,pcie-ipq8064")) {
-		ret = of_property_read_u32(np, "force_gen1", &force_gen1);
-		if (!ret && force_gen1) {
-			writel_relaxed((readl_relaxed(
-				qcom_pcie->dwc_base + PCIE20_LNK_CAS2) | 1),
-				qcom_pcie->dwc_base + PCIE20_LNK_CAS2);
-		}
+	* Force Gen1 in Gen1 marked PCIe SLOT
+	*/
+	if (qcom_pcie->force_gen1) {
+		writel_relaxed((readl_relaxed(
+			qcom_pcie->dwc_base + PCIE20_LNK_CAS2) | 1),
+			qcom_pcie->dwc_base + PCIE20_LNK_CAS2);
 	}
 
 	/* enable link training */
@@ -688,12 +900,9 @@ static int qcom_pcie_probe(struct platfo
 			(qcom_pcie->dwc_base + PCIE20_CAP_LINKCTRLSTATUS),
 			val, (val & BIT(29)), 10000, 100000);
 
-	dev_info(&pdev->dev, "link initialized %d\n", ret);
-
+	dev_info(qcom_pcie->dev, "link initialized %d\n", ret);
 	qcom_pcie_config_controller(qcom_pcie);
 
-	platform_set_drvdata(pdev, qcom_pcie);
-
 	spin_lock_irqsave(&qcom_hw_pci_lock, flags);
 	qcom_hw_pci[nr_controllers].private_data = (void **)&qcom_pcie;
 	hw = &qcom_hw_pci[nr_controllers];
@@ -705,16 +914,13 @@ static int qcom_pcie_probe(struct platfo
 	return 0;
 }
 
+
+
 static int __exit qcom_pcie_remove(struct platform_device *pdev)
 {
 	return 0;
 }
 
-static struct of_device_id qcom_pcie_match[] = {
-	{	.compatible = "qcom,pcie-ipq8064", },
-	{}
-};
-
 static struct platform_driver qcom_pcie_driver = {
 	.probe	= qcom_pcie_probe,
 	.remove	= qcom_pcie_remove,
@@ -738,3 +944,32 @@ static void msm_pcie_fixup_early(struct
 		dev->class = (dev->class & 0xff) | (PCI_CLASS_BRIDGE_PCI << 8);
 }
 DECLARE_PCI_FIXUP_EARLY(PCIE_VENDOR_ID_RCP, PCIE_DEVICE_ID_RCP, msm_pcie_fixup_early);
+
+static void msm_pcie_fixup_final(struct pci_dev *dev)
+{
+	int cap, err;
+	u16 ctl, reg_val;
+
+	cap = pci_pcie_cap(dev);
+	if (!cap)
+		return;
+
+	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+
+	if (err)
+		return;
+
+	reg_val = ctl;
+
+	if (((reg_val & PCIE20_MRRS_MASK) >> 12) > 1)
+		reg_val = (reg_val & ~(PCIE20_MRRS_MASK)) | PCIE20_MRRS(0x1);
+
+	if (((ctl & PCIE20_MPS_MASK) >> 5) > 1)
+		reg_val = (reg_val & ~(PCIE20_MPS_MASK)) | PCIE20_MPS(0x1);
+
+	err = pci_write_config_word(dev, cap + PCI_EXP_DEVCTL, reg_val);
+
+	if (err)
+		pr_err("pcie config write failed %d\n", err);
+}
+DECLARE_PCI_FIXUP_FINAL(PCIE_VENDOR_ID_RCP, PCIE_DEVICE_ID_RCP, msm_pcie_fixup_final);
Index: linux-3.14.43/drivers/pci/pci-sysfs.c
===================================================================
--- linux-3.14.43.orig/drivers/pci/pci-sysfs.c
+++ linux-3.14.43/drivers/pci/pci-sysfs.c
@@ -32,8 +32,6 @@
 #include "pci.h"
 
 static int sysfs_initialized;	/* = 0 */
-extern int msm_pcie_rescan(void);
-extern void msm_pcie_remove_bus(void);
 
 /* show configuration fields */
 #define pci_config_attr(field, format_string)				\
@@ -299,24 +297,6 @@ msi_bus_store(struct device *dev, struct
 }
 static DEVICE_ATTR_RW(msi_bus);
 
-static ssize_t msm_bus_rescan_store(struct bus_type *bus, const char *buf,
-					size_t count)
-{
-	unsigned long val;
-
-	if (kstrtoul(buf, 0, &val) < 0)
-		return -EINVAL;
-
-	if (val) {
-		pci_lock_rescan_remove();
-		msm_pcie_rescan();
-		pci_unlock_rescan_remove();
-	}
-	return count;
-}
-
-static BUS_ATTR(rcrescan, (S_IWUSR|S_IWGRP), NULL, msm_bus_rescan_store);
-
 static ssize_t bus_rescan_store(struct bus_type *bus, const char *buf,
 				size_t count)
 {
@@ -338,7 +318,6 @@ static BUS_ATTR(rescan, (S_IWUSR|S_IWGRP
 
 static struct attribute *pci_bus_attrs[] = {
 	&bus_attr_rescan.attr,
-	&bus_attr_rcrescan.attr,
 	NULL,
 };
 
@@ -400,30 +379,6 @@ static struct device_attribute dev_remov
 							(S_IWUSR|S_IWGRP),
 							NULL, remove_store);
 
-static void msm_remove_callback(struct device *dev)
-{
-	msm_pcie_remove_bus();
-}
-
-static ssize_t
-msm_bus_remove_store(struct device *dev, struct device_attribute *attr,
-			const char *buf, size_t count)
-{
-	unsigned long val;
-	int ret = 0;
-
-	if (kstrtoul(buf, 0, &val) < 0)
-		return -EINVAL;
-
-	if (val)
-		ret = device_schedule_callback(dev, msm_remove_callback);
-	if (ret)
-		count = ret;
-
-	return count;
-}
-static DEVICE_ATTR(rcremove, (S_IWUSR|S_IWGRP), NULL, msm_bus_remove_store);
-
 static ssize_t
 dev_bus_rescan_store(struct device *dev, struct device_attribute *attr,
 		 const char *buf, size_t count)
@@ -591,7 +546,6 @@ const struct attribute_group *pci_dev_gr
 
 static struct attribute *pcibus_attrs[] = {
 	&dev_attr_rescan.attr,
-	&dev_attr_rcremove.attr,
 	&dev_attr_cpuaffinity.attr,
 	&dev_attr_cpulistaffinity.attr,
 	NULL,
Index: linux-3.14.43/drivers/phy/phy-qcom-ipq806x-sata.c
===================================================================
--- linux-3.14.43.orig/drivers/phy/phy-qcom-ipq806x-sata.c
+++ linux-3.14.43/drivers/phy/phy-qcom-ipq806x-sata.c
@@ -73,6 +73,14 @@ static int qcom_ipq806x_sata_phy_init(st
 {
 	struct qcom_ipq806x_sata_phy *phy = phy_get_drvdata(generic_phy);
 	u32 reg;
+	int ret;
+
+	/* Enable sata phy cfg clock */
+	ret = clk_prepare_enable(phy->cfg_clk);
+	if (ret) {
+		dev_err(phy->dev, "Failed to enable sata cfg clock\n");
+		return ret;
+	}
 
 	/* Setting SSC_EN to 1 */
 	reg = readl_relaxed(phy->mmio + SATA_PHY_P0_PARAM3);
@@ -142,6 +150,8 @@ static int qcom_ipq806x_sata_phy_exit(st
 	reg = reg | SATA_PHY_RESET;
 	writel_relaxed(reg, phy->mmio + SATA_PHY_P0_PARAM4);
 
+	clk_disable_unprepare(phy->cfg_clk);
+
 	return 0;
 }
 
Index: linux-3.14.43/drivers/pinctrl/qcom/pinctrl-ipq8064.c
===================================================================
--- linux-3.14.43.orig/drivers/pinctrl/qcom/pinctrl-ipq8064.c
+++ linux-3.14.43/drivers/pinctrl/qcom/pinctrl-ipq8064.c
@@ -297,6 +297,8 @@ enum ipq8064_functions {
 	IPQ_MUX_pcie3_pwren,
 	IPQ_MUX_pcie3_clk_req,
 	IPQ_MUX_ps_hold,
+	IPQ_MUX_pcie_2g_pwrdwn,
+	IPQ_MUX_pcie_5g_pwrdwn,
 	IPQ_MUX_NA,
 };
 
@@ -314,7 +316,7 @@ static const char * const gpio_groups[]
 };
 
 static const char * const mdio_groups[] = {
-	"gpio0", "gpio1", "gpio10", "gpio11",
+	"gpio0", "gpio1", "gpio2", "gpio10", "gpio11", "gpio66",
 };
 
 static const char * const mi2s_groups[] = {
@@ -418,8 +420,8 @@ static const char * const usb2_hsic_grou
 };
 
 static const char * const rgmii2_groups[] = {
-	"gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
-	"gpio51", "gpio52", "gpio59", "gpio60", "gpio61", "gpio62",
+	"gpio2", "gpio27", "gpio28", "gpio29", "gpio30", "gpio31", "gpio32",
+	"gpio51", "gpio52", "gpio59", "gpio60", "gpio61", "gpio62", "gpio66",
 };
 
 static const char * const sata_groups[] = {
@@ -502,6 +504,14 @@ static const char * const ps_hold_groups
 	"gpio26",
 };
 
+static const char * const pcie_2g_pwrdwn_groups[] = {
+	"gpio9",
+};
+
+static const char * const pcie_5g_pwrdwn_groups[] = {
+	"gpio26",
+};
+
 static const struct msm_function ipq8064_functions[] = {
 	FUNCTION(gpio),
 	FUNCTION(mdio),
@@ -549,19 +559,21 @@ static const struct msm_function ipq8064
 	FUNCTION(pcie3_pwrflt),
 	FUNCTION(pcie3_clk_req),
 	FUNCTION(ps_hold),
+	FUNCTION(pcie_2g_pwrdwn),
+	FUNCTION(pcie_5g_pwrdwn),
 };
 
 static const struct msm_pingroup ipq8064_groups[] = {
 	PINGROUP(0, mdio, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(1, mdio, NA, NA, NA, NA, NA, NA, NA, NA, NA),
-	PINGROUP(2, gsbi5_spi_cs3, NA, NA, NA, NA, NA, NA, NA, NA, NA),
+	PINGROUP(2, gsbi5_spi_cs3, rgmii2, mdio, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(3, pcie1_rst, pcie1_prsnt, pdm, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(4, pcie1_pwren_n, pcie1_pwren, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(5, pcie1_clk_req, pcie1_pwrflt, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(6, gsbi7, usb_fs, gsbi5_spi_cs1, usb_fs_n, NA, NA, NA, NA, NA, NA),
 	PINGROUP(7, gsbi7, usb_fs, gsbi5_spi_cs2, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(8, gsbi7, usb_fs, NA, NA, NA, NA, NA, NA, NA, NA),
-	PINGROUP(9, gsbi7, NA, NA, NA, NA, NA, NA, NA, NA, NA),
+	PINGROUP(9, gsbi7, pcie_2g_pwrdwn, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(10, gsbi4, spdif, sata, ssbi, mdio, spmi, NA, NA, NA, NA),
 	PINGROUP(11, gsbi4, pcie2_prsnt, pcie1_prsnt, pcie3_prsnt, ssbi, mdio, spmi, NA, NA, NA),
 	PINGROUP(12, gsbi4, pcie2_pwren_n, pcie1_pwren_n, pcie3_pwren_n, pcie2_pwren, pcie1_pwren, pcie3_pwren, NA, NA, NA),
@@ -578,7 +590,7 @@ static const struct msm_pingroup ipq8064
 	PINGROUP(23, gsbi2, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(24, gsbi2, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(25, gsbi2, NA, NA, NA, NA, NA, NA, NA, NA, NA),
-	PINGROUP(26, ps_hold, NA, NA, NA, NA, NA, NA, NA, NA, NA),
+	PINGROUP(26, ps_hold, pcie_5g_pwrdwn, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(27, mi2s, rgmii2, gsbi6, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(28, mi2s, rgmii2, gsbi6, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(29, mi2s, rgmii2, gsbi6, NA, NA, NA, NA, NA, NA, NA),
@@ -618,7 +630,7 @@ static const struct msm_pingroup ipq8064
 	PINGROUP(63, pcie3_rst, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(64, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(65, pcie3_clk_req, NA, NA, NA, NA, NA, NA, NA, NA, NA),
-	PINGROUP(66, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA),
+	PINGROUP(66, rgmii2, mdio, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(67, usb2_hsic, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	PINGROUP(68, usb2_hsic, NA, NA, NA, NA, NA, NA, NA, NA, NA),
 	SDC_PINGROUP(sdc3_clk, 0x204a, 14, 6),
Index: linux-3.14.43/drivers/pinctrl/qcom/pinctrl-msm.c
===================================================================
--- linux-3.14.43.orig/drivers/pinctrl/qcom/pinctrl-msm.c
+++ linux-3.14.43/drivers/pinctrl/qcom/pinctrl-msm.c
@@ -184,9 +184,6 @@ static void msm_pinmux_disable(struct pi
 
 	g = &pctrl->soc->groups[group];
 
-	if (WARN_ON(g->mux_bit < 0))
-		return;
-
 	spin_lock_irqsave(&pctrl->lock, flags);
 
 	/* Clear the mux bits to select gpio mode */
@@ -844,6 +841,11 @@ static void msm_gpio_irq_handler(unsigne
 	u32 val;
 	int i;
 
+	if (!chip) {
+		dev_err(pctrl->dev, "Failed to get chip\n");
+		return;
+	}
+
 	chained_irq_enter(chip, desc);
 
 	/*
Index: linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_arb_adhoc.c
===================================================================
--- linux-3.14.43.orig/drivers/platform/msm/msm_bus/msm_bus_arb_adhoc.c
+++ linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_arb_adhoc.c
@@ -475,7 +475,7 @@ static int msm_bus_apply_rules(struct li
 
 	list_for_each_entry(rule, list, link) {
 		if (!rule)
-			continue;
+			break;
 
 		if (rule && (rule->after_clk_commit != after_clk_commit))
 			continue;
Index: linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_dbg.c
===================================================================
--- linux-3.14.43.orig/drivers/platform/msm/msm_bus/msm_bus_dbg.c
+++ linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_dbg.c
@@ -323,6 +323,7 @@ struct dentry *msm_bus_dbg_create(const
 		&client_data_fops);
 }
 
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
 static int msm_bus_dbg_record_client(const struct msm_bus_scale_pdata *pdata,
 	int index, uint32_t clid, struct dentry *file)
 {
@@ -425,6 +426,7 @@ static int msm_bus_dbg_fill_cl_buffer(co
 	cldata->size = i;
 	return i;
 }
+#endif
 
 static int msm_bus_dbg_update_request(struct msm_bus_cldata *cldata, int index)
 {
@@ -452,10 +454,14 @@ static ssize_t  msm_bus_dbg_update_reque
 		MSM_BUS_ERR("Memory allocation for buffer failed\n");
 		return -ENOMEM;
 	}
-	if (cnt == 0)
+	if (cnt == 0) {
+		kfree(buf);
 		return 0;
-	if (copy_from_user(buf, ubuf, cnt))
+	}
+	if (copy_from_user(buf, ubuf, cnt)) {
+		kfree(buf);
 		return -EFAULT;
+	}
 	buf[cnt] = '\0';
 	chid = buf;
 	MSM_BUS_DBG("buffer: %s\n size: %zu\n", buf, sizeof(ubuf));
@@ -543,6 +549,7 @@ static const struct file_operations rule
 	.read		= rules_dbg_read,
 };
 
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
 static int msm_bus_dbg_record_fabric(const char *fabname, struct dentry *file)
 {
 	struct msm_bus_fab_list *fablist;
@@ -626,6 +633,7 @@ static int msm_bus_dbg_fill_fab_buffer(c
 	mutex_unlock(&msm_bus_dbg_fablist_lock);
 	return 0;
 }
+#endif
 
 static const struct file_operations msm_bus_dbg_update_request_fops = {
 	.open = client_data_open,
Index: linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_fabric_adhoc.c
===================================================================
--- linux-3.14.43.orig/drivers/platform/msm/msm_bus/msm_bus_fabric_adhoc.c
+++ linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_fabric_adhoc.c
@@ -225,8 +225,8 @@ static int flush_bw_data(struct device *
 
 	node_info = node_device->platform_data;
 	if (!node_info) {
-		MSM_BUS_ERR("%s: Unable to find bus device for device %d",
-			__func__, node_info->node_info->id);
+		MSM_BUS_ERR("%s: Unable to find bus device for device",
+			__func__);
 		ret = -ENODEV;
 		goto exit_flush_bw_data;
 	}
Index: linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_noc.c
===================================================================
--- linux-3.14.43.orig/drivers/platform/msm/msm_bus/msm_bus_noc.c
+++ linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_noc.c
@@ -466,6 +466,7 @@ static void *msm_bus_noc_allocate_noc_da
 		GFP_KERNEL);
 	if (!ninfo->mas_modes) {
 		MSM_BUS_DBG("Couldn't alloc mem for noc master-modes\n");
+		kfree(ninfo);
 		return NULL;
 	}
 
Index: linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_of.c
===================================================================
--- linux-3.14.43.orig/drivers/platform/msm/msm_bus/msm_bus_of.c
+++ linux-3.14.43/drivers/platform/msm/msm_bus/msm_bus_of.c
@@ -41,6 +41,7 @@ static int get_num(const char *const str
 	return -EINVAL;
 }
 
+#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
 static struct msm_bus_scale_pdata *get_pdata(struct platform_device *pdev,
 	struct device_node *of_node)
 {
@@ -148,7 +149,6 @@ err:
 	return NULL;
 }
 
-#if defined(CONFIG_DEBUG_FS) && defined(CONFIG_MSM_BUS_SCALING)
 /**
  * msm_bus_cl_get_pdata() - Generate bus client data from device tree
  * provided by clients.
Index: linux-3.14.43/drivers/regulator/ipq40xx-regulator.c
===================================================================
--- linux-3.14.43.orig/drivers/regulator/ipq40xx-regulator.c
+++ linux-3.14.43/drivers/regulator/ipq40xx-regulator.c
@@ -170,7 +170,7 @@ static int ipq40xx_regulator_probe(struc
 	struct device_node *np = pdev->dev.of_node;
 	struct ipq40xx_regulator_data *drvdata;
 	struct regulator_config cfg = { };
-	int ret;
+	int ret = -1;
 	struct resource *res;
 
 	if (np) {
@@ -204,8 +204,10 @@ static int ipq40xx_regulator_probe(struc
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	drvdata->config->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(drvdata->config->base))
+	if (IS_ERR(drvdata->config->base)) {
+		ret = PTR_ERR(drvdata->config->base);
 		goto err_state;
+	}
 
 	cfg.dev = &pdev->dev;
 	cfg.init_data = config->init_data;
Index: linux-3.14.43/drivers/regulator/qcom_rpm-regulator.c
===================================================================
--- linux-3.14.43.orig/drivers/regulator/qcom_rpm-regulator.c
+++ linux-3.14.43/drivers/regulator/qcom_rpm-regulator.c
@@ -655,12 +655,15 @@ static int rpm_reg_probe(struct platform
 	struct regulator_dev *rdev;
 	struct qcom_rpm_reg *vreg;
 	const char *key;
-	u32 force_mode;
+	int force_mode;
 	bool pwm;
 	u32 val;
 	int ret;
 
 	match = of_match_device(rpm_of_match, &pdev->dev);
+	if (!match)
+		return -EINVAL;
+
 	template = match->data;
 
 	initdata = of_get_regulator_init_data(&pdev->dev, pdev->dev.of_node);
Index: linux-3.14.43/drivers/soc/qcom/qcom_tcsr.c
===================================================================
--- linux-3.14.43.orig/drivers/soc/qcom/qcom_tcsr.c
+++ linux-3.14.43/drivers/soc/qcom/qcom_tcsr.c
@@ -25,6 +25,10 @@
 #define TCSR_ESS_INTERFACE_SEL_OFFSET   0x0
 #define TCSR_ESS_INTERFACE_SEL_MASK     0xf
 
+#define TCSR_WIFI0_GLB_CFG_OFFSET	0x0
+#define TCSR_WIFI1_GLB_CFG_OFFSET	0x4
+#define TCSR_PNOC_SNOC_MEMTYPE_M0_M2	0x4
+
 static int tcsr_probe(struct platform_device *pdev)
 {
 	struct resource *res;
@@ -56,6 +60,18 @@ static int tcsr_probe(struct platform_de
 		writel(tmp, base + TCSR_ESS_INTERFACE_SEL_OFFSET);
         }
 
+	if (!of_property_read_u32(node, "qcom,wifi_glb_cfg", &val)) {
+		dev_info(&pdev->dev, "setting wifi_glb_cfg = %x\n", val);
+		writel(val, base + TCSR_WIFI0_GLB_CFG_OFFSET);
+		writel(val, base + TCSR_WIFI1_GLB_CFG_OFFSET);
+	}
+
+	if (!of_property_read_u32(node, "qcom,wifi_noc_memtype_m0_m2", &val)) {
+		dev_info(&pdev->dev,
+			"setting wifi_noc_memtype_m0_m2 = %x\n", val);
+		writel(val, base + TCSR_PNOC_SNOC_MEMTYPE_M0_M2);
+	}
+
 	return 0;
 }
 
Index: linux-3.14.43/drivers/spi/spi_qsd.c
===================================================================
--- linux-3.14.43.orig/drivers/spi/spi_qsd.c
+++ linux-3.14.43/drivers/spi/spi_qsd.c
@@ -164,6 +164,7 @@ static inline void msm_spi_free_gpios(st
 
 		for (i = 0; i < ARRAY_SIZE(spi_cs_rsrcs); ++i) {
 			if (dd->cs_gpios[i].valid) {
+				gpio_set_value((dd->cs_gpios[i].gpio_num), 1);
 				gpio_free(dd->cs_gpios[i].gpio_num);
 				dd->cs_gpios[i].valid = 0;
 			}
@@ -224,6 +225,7 @@ static inline void msm_spi_free_cs_gpio(
 	cs_num = dd->cur_msg->spi->chip_select;
 	if (!dd->pdata->use_pinctrl) {
 		if (dd->cs_gpios[cs_num].valid) {
+			gpio_set_value((dd->cs_gpios[cs_num].gpio_num), 1);
 			gpio_free(dd->cs_gpios[cs_num].gpio_num);
 			dd->cs_gpios[cs_num].valid = 0;
 		}
@@ -1416,10 +1418,10 @@ msm_spi_use_dma(struct msm_spi *dd, stru
 		dd->multi_xfr && !dd->read_len && !dd->write_len)
 		return false;
 
-	if (is_vmalloc_addr(rx) &&
+	if (is_vmalloc_addr((void *)rx) &&
 		(rx & PAGE_MASK) != ((rx + tr->len) & PAGE_MASK))
 		return false;
-	else if (is_vmalloc_addr(tx) &&
+	else if (is_vmalloc_addr((void *)tx) &&
 		(tx & PAGE_MASK) != ((tx + tr->len) & PAGE_MASK))
 		return false;
 
@@ -1736,6 +1738,7 @@ static void msm_spi_process_message(stru
 {
 	int xfrs_grped = 0;
 	int rc;
+	int cs_num;
 
 	dd->num_xfrs_grped = 0;
 	dd->bam.curr_rx_bytes_recvd = dd->bam.curr_tx_bytes_sent = 0;
@@ -1803,6 +1806,14 @@ static void msm_spi_process_message(stru
 	}
 	if (dd->qup_ver)
 		write_force_cs(dd, 0);
+
+	cs_num = dd->cur_msg->spi->chip_select;
+
+	if ((dd->cs_gpios[cs_num].valid) &&
+		(dd->cs_gpios[cs_num].gpio_num >= 0)) {
+		gpio_set_value(dd->cs_gpios[cs_num].gpio_num, 1);
+	}
+
 	return;
 error:
 	msm_spi_free_cs_gpio(dd);
Index: linux-3.14.43/drivers/staging/mt29f_spinand/giga_spinand.c
===================================================================
--- linux-3.14.43.orig/drivers/staging/mt29f_spinand/giga_spinand.c
+++ linux-3.14.43/drivers/staging/mt29f_spinand/giga_spinand.c
@@ -57,6 +57,12 @@ void macronix_read_data(struct spinand_c
 	cmd->addr[1] = (u8)(column);
 }
 
+void winbond_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+{
+	cmd->addr[0] = (u8)(column >> 8);
+	cmd->addr[1] = (u8)(column);
+}
+
 void gigadevice_write_cmd(struct spinand_cmd *cmd, u32 page_id)
 {
 	cmd->addr[0] = (u8)(page_id >> 16);
@@ -76,6 +82,12 @@ void macronix_write_data(struct spinand_
 	cmd->addr[1] = (u8)(column);
 }
 
+void winbond_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+{
+	cmd->addr[0] = (u8)(column >> 8);
+	cmd->addr[1] = (u8)(column);
+}
+
 void gigadevice_erase_blk(struct spinand_cmd *cmd, u32 page_id)
 {
 	cmd->addr[0] = (u8)(page_id >> 16);
@@ -134,4 +146,13 @@ int macronix_parse_id(struct spi_device
 	return 0;
 }
 
+int winbond_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id)
+{
+	if (nand_id[1] != NAND_MFR_WINBOND)
+		return -EINVAL;
+
+	return 0;
+}
+
+
 MODULE_DESCRIPTION("SPI NAND driver for Gigadevice and Macronix");
Index: linux-3.14.43/drivers/staging/mt29f_spinand/giga_spinand.h
===================================================================
--- linux-3.14.43.orig/drivers/staging/mt29f_spinand/giga_spinand.h
+++ linux-3.14.43/drivers/staging/mt29f_spinand/giga_spinand.h
@@ -46,6 +46,12 @@ int macronix_parse_id(struct spi_device
 
 int macronix_verify_ecc(u8 status);
 
+void winbond_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+
+void winbond_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+
+int winbond_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id);
+
 /* Macronix Specfic defines */
 #define MACRONIX_NORM_RW_MASK	0x0F
 #endif /* __GIGA_SPI_NAND_H */
Index: linux-3.14.43/drivers/staging/mt29f_spinand/mt29f_spinand.c
===================================================================
--- linux-3.14.43.orig/drivers/staging/mt29f_spinand/mt29f_spinand.c
+++ linux-3.14.43/drivers/staging/mt29f_spinand/mt29f_spinand.c
@@ -79,6 +79,18 @@ struct spinand_ops spinand_dev[] = {
 		macronix_parse_id,
 		macronix_verify_ecc,
 	},
+	{
+		NAND_MFR_WINBOND,
+		0xaa21,
+		gigadevice_set_defaults,
+		gigadevice_read_cmd,
+		winbond_read_data,
+		gigadevice_write_cmd,
+		winbond_write_data,
+		gigadevice_erase_blk,
+		winbond_parse_id,
+		macronix_verify_ecc,
+	},
 	{ },
 };
 
@@ -268,11 +280,11 @@ static int spinand_cmd(struct spi_device
 static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 {
 	int retval;
-	u8 nand_id[3];
+	u8 nand_id[4];
 	struct spinand_cmd cmd = {0};
 
 	cmd.cmd = CMD_READ_ID;
-	cmd.n_rx = 3;
+	cmd.n_rx = 4;
 	cmd.rx_buf = &nand_id[0];
 
 	retval = spinand_cmd(spi_nand, &cmd);
@@ -282,6 +294,7 @@ static int spinand_read_id(struct spi_de
 	}
 	id[0] = nand_id[1];
 	id[1] = nand_id[2];
+	id[2] = nand_id[3];
 	spinand_parse_id(spi_nand, nand_id, id);
 	return retval;
 }
@@ -519,7 +532,7 @@ static int spinand_read_from_cache(struc
 static int spinand_read_page(struct spi_device *spi_nand, u16 page_id,
 		u16 offset, u16 len, u8 *rbuf)
 {
-	int ret, ecc_error, ecc_corrected;
+	int ret, ecc_error = 0, ecc_corrected = 0;
 	u8 status = 0;
 	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 	struct mtd_info *mtd = (struct mtd_info *)
@@ -652,14 +665,17 @@ static int spinand_program_execute(struc
 static int spinand_program_page(struct spi_device *spi_nand,
 		u16 page_id, u16 offset, u16 len, u8 *buf)
 {
-	int retval;
+	int retval = 0;
 	u8 status = 0;
 	uint8_t *wbuf;
 #ifdef CONFIG_MTD_SPINAND_ONDIEECC
 	unsigned int i, j;
 
 	enable_read_hw_ecc = 0;
-	wbuf = devm_kzalloc(&spi_nand->dev, CACHE_BUF, GFP_KERNEL);
+	wbuf = kzalloc(CACHE_BUF, GFP_KERNEL);
+	if (!wbuf)
+		return -ENOMEM;
+
 	spinand_read_page(spi_nand, page_id, 0, CACHE_BUF, wbuf);
 
 	for (i = offset, j = 0; i < len; i++, j++)
@@ -669,7 +685,7 @@ static int spinand_program_page(struct s
 		retval = spinand_enable_ecc(spi_nand);
 		if (retval < 0) {
 			dev_err(&spi_nand->dev, "enable ecc failed!!\n");
-			return retval;
+			goto exit;
 		}
 	}
 #else
@@ -678,7 +694,7 @@ static int spinand_program_page(struct s
 	retval = spinand_write_enable(spi_nand);
 	if (retval < 0) {
 		dev_err(&spi_nand->dev, "write enable failed!!\n");
-		return retval;
+		goto exit;
 	}
 	if (wait_till_ready(spi_nand))
 		dev_err(&spi_nand->dev, "wait timedout!!!\n");
@@ -686,24 +702,27 @@ static int spinand_program_page(struct s
 	retval = spinand_program_data_to_cache(spi_nand, page_id,
 			offset, len, wbuf);
 	if (retval < 0)
-		return retval;
+		goto exit;
+
 	retval = spinand_program_execute(spi_nand, page_id);
 	if (retval < 0)
-		return retval;
+		goto exit;
+
 	while (1) {
 		retval = spinand_read_status(spi_nand, &status);
 		if (retval < 0) {
 			dev_err(&spi_nand->dev,
 					"error %d reading status register\n",
 					retval);
-			return retval;
+			goto exit;
 		}
 
 		if ((status & STATUS_OIP_MASK) == STATUS_READY) {
 			if ((status & STATUS_P_FAIL_MASK) == STATUS_P_FAIL) {
 				dev_err(&spi_nand->dev,
 					"program error, page %d\n", page_id);
-				return -1;
+				retval = -1;
+				goto exit;
 			} else
 				break;
 		}
@@ -713,7 +732,7 @@ static int spinand_program_page(struct s
 		retval = spinand_disable_ecc(spi_nand);
 		if (retval < 0) {
 			dev_err(&spi_nand->dev, "disable ecc failed!!\n");
-			return retval;
+			goto exit;
 		}
 		enable_hw_ecc = 0;
 	}
@@ -721,12 +740,16 @@ static int spinand_program_page(struct s
 	retval = spinand_write_disable(spi_nand);
 	if (retval < 0) {
 		dev_err(&spi_nand->dev, "write disable failed!!\n");
-		return retval;
+		goto exit;
 	}
 	if (wait_till_ready(spi_nand))
 		dev_err(&spi_nand->dev, "wait timedout!!!\n");
 
-	return 0;
+exit:
+#ifdef CONFIG_MTD_SPINAND_ONDIEECC
+	kfree(wbuf);
+#endif
+	return retval;
 }
 
 /**
@@ -821,7 +844,7 @@ static int spinand_write_page_hwecc(stru
 static int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
 		uint8_t *buf, int oob_required, int page)
 {
-	u8 retval, status;
+	u8 retval, status = 0;
 	uint8_t *p = buf;
 	int eccsize = chip->ecc.size;
 	int eccsteps = chip->ecc.steps;
@@ -875,7 +898,7 @@ static int spinand_wait(struct mtd_info
 
 	unsigned long timeo = jiffies;
 	int retval, state = chip->state;
-	u8 status;
+	u8 status = 0;
 
 	if (state == FL_ERASING)
 		timeo += (HZ * 400) / 1000;
Index: linux-3.14.43/drivers/staging/mt29f_spinand/mt29f_spinand.h
===================================================================
--- linux-3.14.43.orig/drivers/staging/mt29f_spinand/mt29f_spinand.h
+++ linux-3.14.43/drivers/staging/mt29f_spinand/mt29f_spinand.h
@@ -97,7 +97,7 @@ struct spinand_cmd {
 
 struct spinand_ops {
 	u8   maf_id;
-	u8   dev_id;
+	u16   dev_id;
 	void (*spinand_set_defaults)(struct spi_device *spi_nand);
 	void (*spinand_read_cmd)(struct spinand_cmd *cmd, u32 page_id);
 	void (*spinand_read_data)(struct spinand_cmd *cmd, u16 column,
@@ -108,7 +108,7 @@ struct spinand_ops {
 	void (*spinand_erase_blk)(struct spinand_cmd *cmd, u32 page_id);
 	int (*spinand_parse_id)(struct spi_device *spi_nand, u8 *nand_id,
 								u8 *id);
-	int (*spinand_verify_ecc)(int status);
+	int (*spinand_verify_ecc)(u8 status);
 };
 
 struct spinand_info {
Index: linux-3.14.43/drivers/thermal/msm_thermal.c
===================================================================
--- linux-3.14.43.orig/drivers/thermal/msm_thermal.c
+++ linux-3.14.43/drivers/thermal/msm_thermal.c
@@ -285,7 +285,7 @@ static int __cpuinit set_enabled(const c
 
 	ret = param_set_bool(val, kp);
 	if (!enabled) {
-		ktm_status == false;
+		ktm_status = false;
 		disable_msm_thermal();
 	} else {
 		if (ktm_status == false) {
Index: linux-3.14.43/drivers/thermal/qcom-tsens.c
===================================================================
--- linux-3.14.43.orig/drivers/thermal/qcom-tsens.c
+++ linux-3.14.43/drivers/thermal/qcom-tsens.c
@@ -467,17 +467,18 @@ static int tsens_tz_notify(struct therma
 }
 
 static int tsens_tz_set_trip_temp(struct thermal_zone_device *thermal,
-				   int trip, long temp)
+				   int trip, unsigned long temp)
 {
 	struct tsens_tm_device_sensor *tm_sensor = thermal->devdata;
 	unsigned int reg_th, reg_cntl;
 	int code, hi_code, lo_code, code_err_chk;
 
-	code_err_chk = code = tsens_tz_degC_to_code(temp,
-					tm_sensor->sensor_num);
 	if (!tm_sensor || trip < 0)
 		return -EINVAL;
 
+	code_err_chk = code = tsens_tz_degC_to_code(temp,
+					tm_sensor->sensor_num);
+
 	lo_code = TSENS_THRESHOLD_MIN_CODE;
 	hi_code = TSENS_THRESHOLD_MAX_CODE;
 
Index: linux-3.14.43/drivers/thermal/thermal_core.c
===================================================================
--- linux-3.14.43.orig/drivers/thermal/thermal_core.c
+++ linux-3.14.43/drivers/thermal/thermal_core.c
@@ -552,7 +552,7 @@ type_show(struct device *dev, struct dev
 {
 	struct thermal_zone_device *tz = to_thermal_zone(dev);
 
-	return sprintf(buf, "%s\n", tz->type);
+	return snprintf(buf, PAGE_SIZE, "%s\n", tz->type);
 }
 
 static ssize_t
@@ -567,7 +567,7 @@ temp_show(struct device *dev, struct dev
 	if (ret)
 		return ret;
 
-	return sprintf(buf, "%ld\n", temperature);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", temperature);
 }
 
 static ssize_t
@@ -584,8 +584,8 @@ mode_show(struct device *dev, struct dev
 	if (result)
 		return result;
 
-	return sprintf(buf, "%s\n", mode == THERMAL_DEVICE_ENABLED ? "enabled"
-		       : "disabled");
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+		mode == THERMAL_DEVICE_ENABLED ? "enabled" : "disabled");
 }
 
 static ssize_t
@@ -598,9 +598,9 @@ mode_store(struct device *dev, struct de
 	if (!tz->ops->set_mode)
 		return -EPERM;
 
-	if (!strncmp(buf, "enabled", sizeof("enabled") - 1))
+	if (!strncmp(buf, "enabled", strlen("enabled") - 1))
 		result = tz->ops->set_mode(tz, THERMAL_DEVICE_ENABLED);
-	else if (!strncmp(buf, "disabled", sizeof("disabled") - 1))
+	else if (!strncmp(buf, "disabled", strlen("disabled") - 1))
 		result = tz->ops->set_mode(tz, THERMAL_DEVICE_DISABLED);
 	else
 		result = -EINVAL;
@@ -631,22 +631,22 @@ trip_point_type_show(struct device *dev,
 
 	switch (type) {
 	case THERMAL_TRIP_CRITICAL:
-		return sprintf(buf, "critical\n");
+		return snprintf(buf, PAGE_SIZE, "critical\n");
 	case THERMAL_TRIP_HOT:
-		return sprintf(buf, "hot\n");
+		return snprintf(buf, PAGE_SIZE, "hot\n");
 	case THERMAL_TRIP_PASSIVE:
-		return sprintf(buf, "passive\n");
+		return snprintf(buf, PAGE_SIZE, "passive\n");
 	case THERMAL_TRIP_ACTIVE:
-		return sprintf(buf, "active\n");
+		return snprintf(buf, PAGE_SIZE, "active\n");
 	case THERMAL_TRIP_CONFIGURABLE_HI:
-		return sprintf(buf, "configurable_hi\n");
+		return snprintf(buf, PAGE_SIZE, "configurable_hi\n");
 	case THERMAL_TRIP_CONFIGURABLE_LOW:
-		return sprintf(buf, "configurable_low\n");
+		return snprintf(buf, PAGE_SIZE, "configurable_low\n");
 	case THERMAL_TRIP_CRITICAL_LOW:
-		return sprintf(buf, "critical_low\n");
+		return snprintf(buf, PAGE_SIZE, "critical_low\n");
 
 	default:
-		return sprintf(buf, "unknown\n");
+		return snprintf(buf, PAGE_SIZE, "unknown\n");
 	}
 }
 
@@ -665,10 +665,10 @@ trip_point_type_activate(struct device *
 	if (!sscanf(attr->attr.name, "trip_point_%d_type", &trip))
 		return -EINVAL;
 
-	if (!strncmp(buf, enabled, sizeof(enabled)))
+	if (!strncmp(buf, enabled, strlen(enabled)))
 		result = tz->ops->activate_trip_type(tz, trip,
 					THERMAL_TRIP_ACTIVATION_ENABLED);
-	else if (!strncmp(buf, disabled, sizeof(disabled)))
+	else if (!strncmp(buf, disabled, strlen(disabled)))
 		result = tz->ops->activate_trip_type(tz, trip,
 					THERMAL_TRIP_ACTIVATION_DISABLED);
 	else
@@ -721,7 +721,7 @@ trip_point_temp_show(struct device *dev,
 	if (ret)
 		return ret;
 
-	return sprintf(buf, "%ld\n", temperature);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", temperature);
 }
 
 static ssize_t
@@ -767,7 +767,7 @@ trip_point_hyst_show(struct device *dev,
 
 	ret = tz->ops->get_trip_hyst(tz, trip, &temperature);
 
-	return ret ? ret : sprintf(buf, "%ld\n", temperature);
+	return ret ? ret : snprintf(buf, PAGE_SIZE, "%ld\n", temperature);
 }
 
 static ssize_t
@@ -826,7 +826,7 @@ passive_show(struct device *dev, struct
 {
 	struct thermal_zone_device *tz = to_thermal_zone(dev);
 
-	return sprintf(buf, "%d\n", tz->forced_passive);
+	return snprintf(buf, PAGE_SIZE, "%d\n", tz->forced_passive);
 }
 
 static ssize_t
@@ -854,7 +854,7 @@ policy_show(struct device *dev, struct d
 {
 	struct thermal_zone_device *tz = to_thermal_zone(dev);
 
-	return sprintf(buf, "%s\n", tz->governor->name);
+	return snprintf(buf, PAGE_SIZE, "%s\n", tz->governor->name);
 }
 
 static ssize_t
@@ -867,8 +867,9 @@ available_policies_show(struct device *d
 	mutex_lock(&thermal_governor_lock);
 
 	list_for_each_entry(pos, &thermal_governor_list, governor_list)
-		count += sprintf(buf + count, "%s ", pos->name);
-	count += sprintf(buf + count, "\n");
+		count += snprintf(buf + count, PAGE_SIZE - count,
+							"%s ", pos->name);
+	count += snprintf(buf + count, PAGE_SIZE - count, "\n");
 
 	mutex_unlock(&thermal_governor_lock);
 
@@ -920,7 +921,7 @@ thermal_cooling_device_type_show(struct
 {
 	struct thermal_cooling_device *cdev = to_cooling_device(dev);
 
-	return sprintf(buf, "%s\n", cdev->type);
+	return snprintf(buf, PAGE_SIZE, "%s\n", cdev->type);
 }
 
 static ssize_t
@@ -934,7 +935,7 @@ thermal_cooling_device_max_state_show(st
 	ret = cdev->ops->get_max_state(cdev, &state);
 	if (ret)
 		return ret;
-	return sprintf(buf, "%ld\n", state);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", state);
 }
 
 static ssize_t
@@ -948,7 +949,7 @@ thermal_cooling_device_cur_state_show(st
 	ret = cdev->ops->get_cur_state(cdev, &state);
 	if (ret)
 		return ret;
-	return sprintf(buf, "%ld\n", state);
+	return snprintf(buf, PAGE_SIZE, "%ld\n", state);
 }
 
 static ssize_t
@@ -960,7 +961,7 @@ thermal_cooling_device_cur_state_store(s
 	unsigned long state;
 	int result;
 
-	if (!sscanf(buf, "%ld\n", &state))
+	if (!sscanf(buf, "%lu\n", &state))
 		return -EINVAL;
 
 	if ((long)state < 0)
@@ -990,9 +991,9 @@ thermal_cooling_device_trip_point_show(s
 	    container_of(attr, struct thermal_instance, attr);
 
 	if (instance->trip == THERMAL_TRIPS_NONE)
-		return sprintf(buf, "-1\n");
+		return snprintf(buf, PAGE_SIZE, "-1\n");
 	else
-		return sprintf(buf, "%d\n", instance->trip);
+		return snprintf(buf, PAGE_SIZE, "%d\n", instance->trip);
 }
 
 /* Device management */
@@ -1052,8 +1053,8 @@ int thermal_zone_bind_cooling_device(str
 	if (lower > upper || upper > max_state)
 		return -EINVAL;
 
-	dev =
-	    kzalloc(sizeof(struct thermal_instance), GFP_KERNEL);
+	dev = devm_kzalloc(&cdev->device,
+			sizeof(struct thermal_instance), GFP_KERNEL);
 	if (!dev)
 		return -ENOMEM;
 	dev->tz = tz;
@@ -1067,13 +1068,14 @@ int thermal_zone_bind_cooling_device(str
 	if (result)
 		goto free_mem;
 
-	sprintf(dev->name, "cdev%d", dev->id);
+	snprintf(dev->name, THERMAL_NAME_LENGTH - 1, "cdev%d", dev->id);
 	result =
 	    sysfs_create_link(&tz->device.kobj, &cdev->device.kobj, dev->name);
 	if (result)
 		goto release_idr;
 
-	sprintf(dev->attr_name, "cdev%d_trip_point", dev->id);
+	snprintf(dev->attr_name, THERMAL_NAME_LENGTH - 1,
+					"cdev%d_trip_point", dev->id);
 	sysfs_attr_init(&dev->attr.attr);
 	dev->attr.attr.name = dev->attr_name;
 	dev->attr.attr.mode = 0444;
@@ -1261,6 +1263,7 @@ __thermal_cooling_device_register(struct
 unregister:
 	release_idr(&thermal_cdev_idr, &thermal_idr_lock, cdev->id);
 	device_unregister(&cdev->device);
+	kfree(cdev);
 	return ERR_PTR(result);
 }
 
@@ -1365,6 +1368,8 @@ void thermal_cooling_device_unregister(s
 
 	release_idr(&thermal_cdev_idr, &thermal_idr_lock, cdev->id);
 	device_unregister(&cdev->device);
+	kfree(cdev);
+
 	return;
 }
 EXPORT_SYMBOL_GPL(thermal_cooling_device_unregister);
@@ -1693,6 +1698,7 @@ unregister:
 	tz->governor = NULL;
 	release_idr(&thermal_tz_idr, &thermal_idr_lock, tz->id);
 	device_unregister(&tz->device);
+	kfree(tz);
 	return ERR_PTR(result);
 }
 EXPORT_SYMBOL_GPL(thermal_zone_device_register);
@@ -1764,6 +1770,8 @@ void thermal_zone_device_unregister(stru
 	idr_destroy(&tz->idr);
 	mutex_destroy(&tz->lock);
 	device_unregister(&tz->device);
+	kfree(tz);
+
 	return;
 }
 EXPORT_SYMBOL_GPL(thermal_zone_device_unregister);
@@ -1974,8 +1982,6 @@ static int __init thermal_init(void)
 
 	return 0;
 
-exit_netlink:
-	genetlink_exit();
 unregister_class:
 	class_unregister(&thermal_class);
 unregister_governors:
Index: linux-3.14.43/drivers/tty/serial/msm_serial_hs.c
===================================================================
--- linux-3.14.43.orig/drivers/tty/serial/msm_serial_hs.c
+++ linux-3.14.43/drivers/tty/serial/msm_serial_hs.c
@@ -67,8 +67,11 @@
 #include <linux/msm-sps.h>
 #include <linux/platform_data/msm_serial_hs.h>
 #include <linux/msm-bus.h>
+#include <soc/qcom/scm.h>
 
 #include "msm_serial_hs_hwreg.h"
+#include "linux/dma-mapping.h"
+
 #define UART_SPS_CONS_PERIPHERAL 0
 #define UART_SPS_PROD_PERIPHERAL 1
 
@@ -243,6 +246,10 @@ struct msm_hs_port {
 	bool is_shutdown;
 	bool termios_in_progress;
 	int rx_buf_size;
+	/* adm crci mux cfg */
+	uint16_t tcsr_adm_mux_sel_reg;
+	uint32_t tcsr_adm_mux_sel_reg_mask;
+	uint16_t tcsr_adm_mux_sel_reg_value;
 };
 
 #define MSM_UARTDM_BURST_SIZE 16   /* DM burst size (in bytes) */
@@ -280,6 +287,45 @@ static struct of_device_id msm_hs_match_
 	{}
 };
 
+/* scm call to pass CRCI mux configuration for GSBI */
+static void adm_crci_mux_cfg(uint16_t tcsr_adm_mux_sel_reg, uint32_t tcsr_adm_mux_sel_reg_mask, uint16_t tcsr_adm_mux_sel_reg_value)
+{
+	uint32_t *ret_status = kzalloc(sizeof(uint32_t), GFP_KERNEL);
+	int ret;
+
+	struct tcsr {
+		uint32_t tcsr_adm_mux_sel_reg_mask;
+		uint32_t status;
+		uint16_t tcsr_adm_mux_sel_reg;
+		uint16_t tcsr_adm_mux_sel_reg_value;
+	} tcsr_cmd;
+
+	tcsr_cmd.tcsr_adm_mux_sel_reg = tcsr_adm_mux_sel_reg;
+	tcsr_cmd.tcsr_adm_mux_sel_reg_mask = tcsr_adm_mux_sel_reg_mask;
+	tcsr_cmd.tcsr_adm_mux_sel_reg_value = tcsr_adm_mux_sel_reg_value;
+	tcsr_cmd.status = dma_map_single(NULL, ret_status,
+		sizeof(*ret_status), DMA_FROM_DEVICE);
+	ret = dma_mapping_error(NULL, tcsr_cmd.status);
+	if (ret) {
+		pr_err("DMA Mapping Error(api_status)\n");
+		goto exit_err;
+	}
+
+	ret = scm_call(SCM_SVC_INFO, SCM_GSBI_ADM_MUX_SEL_CMD,
+		&tcsr_cmd, sizeof(tcsr_cmd), NULL, 0);
+
+	dma_unmap_single(NULL, tcsr_cmd.status,
+		sizeof(*ret_status), DMA_FROM_DEVICE);
+
+	if (ret || *(ret_status)) {
+		pr_err("%s: Error in CRCI_MUX write (%d, 0x%x)\n",
+			__func__, ret, *(ret_status));
+	}
+exit_err:
+	kfree(ret_status);
+	return;
+}
+
 static int msm_hs_ioctl(struct uart_port *uport, unsigned int cmd,
 						unsigned long arg)
 {
@@ -2933,7 +2979,10 @@ struct msm_serial_hs_platform_data
 	int rx_to_inject, ret, uartdm_rx_buf_size;
 
 	match = of_match_device(msm_hs_match_table, &pdev->dev);
-
+	if (!match) {
+		pr_err("Plaform device ID mismatch = %d\n", pdev->id);
+		return -EINVAL;
+	}
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata) {
 		pr_err("unable to allocate memory for platform data\n");
@@ -3156,7 +3205,7 @@ static int msm_hs_sps_init(struct msm_hs
 {
 	int rc = 0;
 	struct sps_bam_props bam = {0};
-	u32 bam_handle;
+	unsigned long bam_handle;
 
 	rc = sps_phy2h(msm_uport->bam_mem, &bam_handle);
 	if (rc || !bam_handle) {
@@ -3276,6 +3325,10 @@ static int msm_hs_probe(struct platform_
 
 	if (pdev->dev.of_node) {
 		match = of_match_device(msm_hs_match_table, &pdev->dev);
+		if (!match) {
+			pr_err("Plaform device ID mismatch = %d\n", pdev->id);
+			return -EINVAL;
+		}
 		if (!(match->data))
 			msm_uport->uart_type = GSBI_HSUART;
 		else
@@ -3406,6 +3459,20 @@ static int msm_hs_probe(struct platform_
 					&msm_uport->dma_tx_crci);
 		if (err != 0)
 			return -ENXIO;
+		/* adm crci mux cfg*/
+		if (of_property_read_u32(node, "qcom,tcsr_adm_mux_sel_reg",
+					&msm_uport->tcsr_adm_mux_sel_reg) ||
+		   of_property_read_u32(node, "qcom,tcsr_adm_mux_sel_reg_mask",
+					&msm_uport->tcsr_adm_mux_sel_reg_mask) ||
+		   of_property_read_u32(node, "qcom,tcsr_adm_mux_sel_reg_value",
+					&msm_uport->tcsr_adm_mux_sel_reg_value)) {
+			dev_err(msm_uport->uport.dev,
+				"adm crici mux configuration not done\n");
+		} else {
+			adm_crci_mux_cfg(msm_uport->tcsr_adm_mux_sel_reg,
+				msm_uport->tcsr_adm_mux_sel_reg_mask,
+				msm_uport->tcsr_adm_mux_sel_reg_value);
+		}
 	}
 
 	uport->iotype = UPIO_MEM;
Index: linux-3.14.43/drivers/tty/serial/msm_serial_hs_hwreg.h
===================================================================
--- linux-3.14.43.orig/drivers/tty/serial/msm_serial_hs_hwreg.h
+++ linux-3.14.43/drivers/tty/serial/msm_serial_hs_hwreg.h
@@ -36,6 +36,8 @@
 #define MSM_DISABLE_UART_CLOCK TIOCPMPUT
 #define MSM_GET_UART_CLOCK_STATUS TIOCPMACT
 
+#define SCM_GSBI_ADM_MUX_SEL_CMD        0x5
+
 enum msm_hsl_regs {
 	UARTDM_MR1,
 	UARTDM_MR2,
Index: linux-3.14.43/drivers/tty/serial/msm_serial_hs_lite.c
===================================================================
--- linux-3.14.43.orig/drivers/tty/serial/msm_serial_hs_lite.c
+++ linux-3.14.43/drivers/tty/serial/msm_serial_hs_lite.c
@@ -1683,8 +1683,7 @@ static int msm_serial_hsl_probe(struct p
 	struct uart_port *port;
 	struct msm_serial_hslite_platform_data *pdata;
 	const struct of_device_id *match;
-	u32 line;
-	int ret;
+	int line, ret;
 
 	if (pdev->id == -1)
 		pdev->id = atomic_inc_return(&msm_serial_hsl_next_id) - 1;
Index: linux-3.14.43/drivers/tty/serial/qca_serial_hs.c
===================================================================
--- linux-3.14.43.orig/drivers/tty/serial/qca_serial_hs.c
+++ linux-3.14.43/drivers/tty/serial/qca_serial_hs.c
@@ -85,12 +85,13 @@ enum {
 };
 
 /* Default IPC log level INFO */
-static int hs_serial_debug_mask = INFO_LEV;
+static int hs_serial_debug_mask = WARN_LEV;
 module_param_named(debug_mask, hs_serial_debug_mask,
 		   int, S_IRUGO | S_IWUSR | S_IWGRP);
 
 #define MSM_HS_DBG(x...) do { \
 	if (hs_serial_debug_mask >= DBG_LEV) { \
+		pr_debug(x); \
 		if (ipc_msm_hs_log_ctxt) \
 			ipc_log_string(ipc_msm_hs_log_ctxt, x); \
 	} \
@@ -98,6 +99,7 @@ module_param_named(debug_mask, hs_serial
 
 #define MSM_HS_INFO(x...) do { \
 	if (hs_serial_debug_mask >= INFO_LEV) {\
+		pr_info(x); \
 		if (ipc_msm_hs_log_ctxt) \
 			ipc_log_string(ipc_msm_hs_log_ctxt, x); \
 	} \
@@ -386,7 +388,6 @@ static void qca_hs_clk_bus_unvote(struct
  /* Remove vote for resources when done */
 static void qca_hs_resource_unvote(struct msm_hs_port *msm_uport)
 {
-	struct uart_port *uport = &(msm_uport->uport);
 	int rc = atomic_read(&msm_uport->clk_count);
 
 	MSM_HS_DBG("%s(): power usage count %d", __func__, rc);
@@ -401,7 +402,6 @@ static void qca_hs_resource_unvote(struc
  /* Vote for resources before accessing them */
 static void qca_hs_resource_vote(struct msm_hs_port *msm_uport)
 {
-	struct uart_port *uport = &(msm_uport->uport);
 	atomic_inc(&msm_uport->clk_count);
 }
 
@@ -3191,7 +3191,6 @@ static int qca_hs_probe(struct platform_
 		uport->line = pdata->userid;
 	ret = uart_add_one_port(&msm_hs_driver, uport);
 	if (!ret) {
-		qca_hs_clk_bus_unvote(msm_uport);
 		return ret;
 	}
 
@@ -3224,9 +3223,10 @@ static int __init qca_serial_hs_init(voi
 
 	ipc_msm_hs_log_ctxt = ipc_log_context_create(IPC_MSM_HS_LOG_PAGES,
 							"qca_serial_hs", 0);
+#if defined(CONFIG_IPC_LOGGING)
 	if (!ipc_msm_hs_log_ctxt)
 		MSM_HS_WARN("%s: error creating logging context", __func__);
-
+#endif
 	ret = uart_register_driver(&msm_hs_driver);
 	if (unlikely(ret)) {
 		MSM_HS_ERR("%s failed to load\n", __func__);
Index: linux-3.14.43/drivers/usb/core/hub.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/core/hub.c
+++ linux-3.14.43/drivers/usb/core/hub.c
@@ -4952,8 +4952,16 @@ static void hub_events(void)
 					status = hub_port_reset(hub, i,
 							NULL, HUB_BH_RESET_TIME,
 							true);
-					if (status < 0)
+					if (status < 0) {
 						hub_port_disable(hub, i, 1);
+					} else {
+						hub_port_status(hub, i,
+							&portstatus,
+							&portchange);
+						dev_err(hub_dev,
+							"force connect change port %d\n", i);
+						connect_change = 1;
+					}
 				} else {
 					usb_lock_device(udev);
 					status = usb_reset_device(udev);
Index: linux-3.14.43/drivers/usb/dwc3/core.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/dwc3/core.c
+++ linux-3.14.43/drivers/usb/dwc3/core.c
@@ -152,7 +152,9 @@ static void dwc3_core_soft_reset(struct
 
 	/* Enable Suspend USB3.0 SS PHY (Suspend_en) */
 	reg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
-	reg &= ~DWC3_GUSB3PIPECTL_SUSPHY;
+	reg |= DWC3_GUSB3PIPECTL_SUSPHY;
+	if (dwc->dis_u3_susphy_quirk)
+		reg &= ~DWC3_GUSB3PIPECTL_SUSPHY;
 	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);
 }
 
@@ -475,6 +477,8 @@ static int dwc3_probe(struct platform_de
 		}
 
 		dwc->dr_mode = of_usb_get_dr_mode(node);
+		dwc->dis_u3_susphy_quirk =  of_property_read_bool(node,
+							"dis_u3_susphy_quirk");
 	} else if (pdata) {
 		dwc->maximum_speed = pdata->maximum_speed;
 
Index: linux-3.14.43/drivers/usb/dwc3/core.h
===================================================================
--- linux-3.14.43.orig/drivers/usb/dwc3/core.h
+++ linux-3.14.43/drivers/usb/dwc3/core.h
@@ -709,6 +709,7 @@ struct dwc3 {
 	unsigned		pullups_connected:1;
 	unsigned		enable_usb2susphy_quirk:1;
 	unsigned		enable_usb2_host_discon_quirk:1;
+	unsigned		dis_u3_susphy_quirk:1;
 
 	enum dwc3_ep0_next	ep0_next_event;
 	enum dwc3_ep0_state	ep0state;
Index: linux-3.14.43/drivers/usb/dwc3/dwc3-ipq40xx.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/dwc3/dwc3-ipq40xx.c
+++ linux-3.14.43/drivers/usb/dwc3/dwc3-ipq40xx.c
@@ -38,8 +38,6 @@ struct dwc3_ipq40xx {
 	struct clk *master_clk;
 	struct clk *mock_utmi_clk;
 	struct clk *sleep_clk;
-	struct clk *srif_ahb_clk;
-	struct clk *srif_25m_clk;
 
 	unsigned int host;
 };
@@ -107,7 +105,7 @@ static int dwc3_ipq40xx_probe(struct pla
 
 	mdwc = devm_kzalloc(&pdev->dev, sizeof(*mdwc), GFP_KERNEL);
 	if (!mdwc) {
-		dev_err(mdwc->dev, "failed to get memory\n");
+		pr_err("%s: failed to get memory\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -140,18 +138,6 @@ static int dwc3_ipq40xx_probe(struct pla
 		return PTR_ERR(mdwc->sleep_clk);
 	}
 
-	mdwc->srif_ahb_clk = devm_clk_get(mdwc->dev, "srif_ahb");
-	if (IS_ERR(mdwc->srif_ahb_clk)) {
-		dev_err(mdwc->dev, "failed to get srif_ahb clock\n");
-		return PTR_ERR(mdwc->srif_ahb_clk);
-	}
-
-	mdwc->srif_25m_clk = devm_clk_get(mdwc->dev, "srif_25m");
-	if (IS_ERR(mdwc->srif_25m_clk)) {
-		dev_err(mdwc->dev, "failed to get srif_25m clock\n");
-		return PTR_ERR(mdwc->srif_25m_clk);
-	}
-
 	np = of_node_get(pdev->dev.of_node);
 	if (of_property_read_u32(np, "qca,host", &mdwc->host)) {
 		dev_err(mdwc->dev,
@@ -165,8 +151,6 @@ static int dwc3_ipq40xx_probe(struct pla
 	clk_prepare_enable(mdwc->master_clk);
 	clk_prepare_enable(mdwc->mock_utmi_clk);
 	clk_prepare_enable(mdwc->sleep_clk);
-	clk_prepare_enable(mdwc->srif_ahb_clk);
-	clk_prepare_enable(mdwc->srif_25m_clk);
 
 	ret = of_platform_populate(node, NULL, NULL, mdwc->dev);
 	if (ret) {
@@ -178,8 +162,6 @@ static int dwc3_ipq40xx_probe(struct pla
 
 dis_clks:
 	dev_err(mdwc->dev, "disabling clocks\n");
-	clk_disable_unprepare(mdwc->srif_ahb_clk);
-	clk_disable_unprepare(mdwc->srif_25m_clk);
 	clk_disable_unprepare(mdwc->sleep_clk);
 	clk_disable_unprepare(mdwc->mock_utmi_clk);
 	clk_disable_unprepare(mdwc->master_clk);
@@ -200,8 +182,6 @@ static int dwc3_ipq40xx_remove(struct pl
 	int ret = 0;
 	struct dwc3_ipq40xx *mdwc = platform_get_drvdata(pdev);
 
-	clk_disable_unprepare(mdwc->srif_ahb_clk);
-	clk_disable_unprepare(mdwc->srif_25m_clk);
 	clk_disable_unprepare(mdwc->sleep_clk);
 	clk_disable_unprepare(mdwc->mock_utmi_clk);
 	clk_disable_unprepare(mdwc->master_clk);
Index: linux-3.14.43/drivers/usb/dwc3/dwc3-qcom.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/dwc3/dwc3-qcom.c
+++ linux-3.14.43/drivers/usb/dwc3/dwc3-qcom.c
@@ -134,8 +134,6 @@ static int dwc3_qcom_remove_core(struct
 static int dwc3_qcom_remove(struct platform_device *pdev)
 {
 	int ret = 0;
-	struct device_node *node = pdev->dev.of_node;
-
 	struct dwc3_qcom *mdwc = platform_get_drvdata(pdev);
 
 	if (mdwc->sleep_clk)
Index: linux-3.14.43/drivers/usb/phy/phy-qca-uniphy.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/phy/phy-qca-uniphy.c
+++ linux-3.14.43/drivers/usb/phy/phy-qca-uniphy.c
@@ -76,6 +76,10 @@ struct qca_uni_ss_phy {
 	unsigned int emulation;
 };
 
+struct qf_read {
+	uint32_t value;
+};
+
 #define	phy_to_dw_phy(x)	container_of((x), struct qca_uni_ss_phy, phy)
 
 /**
@@ -244,14 +248,11 @@ int qca_uni_ss_read_otp(uint32_t *otp_re
 {
 	int ret;
 	uint32_t *otp_value = kzalloc(sizeof(uint32_t), GFP_KERNEL);
+	struct qf_read rdip;
 
 	if (!otp_value)
 		return -ENOMEM;
 
-	struct qf_read {
-		uint32_t value;
-	} rdip;
-
 	rdip.value = dma_map_single(NULL, otp_value,
 			sizeof(uint32_t), DMA_FROM_DEVICE);
 
@@ -278,7 +279,7 @@ err_write:
 	return ret;
 }
 
-int qca_uni_ss_phy_usb_los_calibration(uint32_t base)
+int qca_uni_ss_phy_usb_los_calibration(void __iomem *base)
 {
 	uint32_t data, otp_val = 0;
 
Index: linux-3.14.43/drivers/usb/phy/phy-qcom-hsusb.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/phy/phy-qcom-hsusb.c
+++ linux-3.14.43/drivers/usb/phy/phy-qcom-hsusb.c
@@ -129,27 +129,27 @@ static void qcom_dwc3_hs_phy_shutdown(st
 
 	ret = regulator_set_voltage(phy->v3p3, 0, PHY_3P3_VOL_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for v3p3\n");
+		dev_dbg(phy->dev, "cannot set voltage for v3p3\n");
 
 	ret = regulator_set_voltage(phy->v1p8, 0, PHY_1P8_VOL_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for v1p8\n");
+		dev_dbg(phy->dev, "cannot set voltage for v1p8\n");
 
 	ret = regulator_disable(phy->v1p8);
 	if (ret)
-		dev_err(phy->dev, "cannot disable v1p8\n");
+		dev_dbg(phy->dev, "cannot disable v1p8\n");
 
 	ret = regulator_disable(phy->v3p3);
 	if (ret)
-		dev_err(phy->dev, "cannot disable v3p3\n");
+		dev_dbg(phy->dev, "cannot disable v3p3\n");
 
 	ret = regulator_set_voltage(phy->vddcx, USB_VDDCX_NO, USB_VDDCX_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for vddcx\n");
+		dev_dbg(phy->dev, "cannot set voltage for vddcx\n");
 
 	ret = regulator_disable(phy->vddcx);
 	if (ret)
-		dev_err(phy->dev, "cannot enable vddcx\n");
+		dev_dbg(phy->dev, "cannot enable vddcx\n");
 
 	if (!of_device_is_compatible(np, "qcom,dwc3-hsphy-ipq8064")) {
 		clk_disable_unprepare(phy->utmi_clk);
@@ -166,37 +166,37 @@ static int qcom_dwc3_hs_phy_init(struct
 
 	ret = regulator_set_voltage(phy->vddcx, USB_VDDCX_MIN, USB_VDDCX_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for vddcx\n");
+		dev_dbg(phy->dev, "cannot set voltage for vddcx\n");
 
 	ret = regulator_enable(phy->vddcx);
 	if (ret)
-		dev_err(phy->dev, "cannot enable vddcx\n");
+		dev_dbg(phy->dev, "cannot enable vddcx\n");
 
 	ret = regulator_set_voltage(phy->v3p3, PHY_3P3_VOL_MIN,
 				    PHY_3P3_VOL_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for v3p3\n");
+		dev_dbg(phy->dev, "cannot set voltage for v3p3\n");
 
 	ret = regulator_set_voltage(phy->v1p8, PHY_1P8_VOL_MIN,
 				    PHY_1P8_VOL_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for v1p8\n");
+		dev_dbg(phy->dev, "cannot set voltage for v1p8\n");
 
 	ret = regulator_set_optimum_mode(phy->v1p8, PHY_1P8_HPM_LOAD);
 	if (ret < 0)
-		dev_err(phy->dev, "cannot set HPM of regulator v1p8\n");
+		dev_dbg(phy->dev, "cannot set HPM of regulator v1p8\n");
 
 	ret = regulator_enable(phy->v1p8);
 	if (ret)
-		dev_err(phy->dev, "cannot enable v1p8\n");
+		dev_dbg(phy->dev, "cannot enable v1p8\n");
 
 	ret = regulator_set_optimum_mode(phy->v3p3, PHY_3P3_HPM_LOAD);
 	if (ret < 0)
-		dev_err(phy->dev, "cannot set HPM of regulator v3p3\n");
+		dev_dbg(phy->dev, "cannot set HPM of regulator v3p3\n");
 
 	ret = regulator_enable(phy->v3p3);
 	if (ret)
-		dev_err(phy->dev, "cannot enable v3p3\n");
+		dev_dbg(phy->dev, "cannot enable v3p3\n");
 
 	/*
 	 * HSPHY Initialization: Enable UTMI clock and clamp enable HVINTs,
Index: linux-3.14.43/drivers/usb/phy/phy-qcom-ssusb.c
===================================================================
--- linux-3.14.43.orig/drivers/usb/phy/phy-qcom-ssusb.c
+++ linux-3.14.43/drivers/usb/phy/phy-qcom-ssusb.c
@@ -202,13 +202,13 @@ static void qcom_dwc3_ss_phy_shutdown(st
 
 	ret = regulator_set_voltage(phy->vddcx, USB_VDDCX_NO, USB_VDDCX_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set voltage for vddcx\n");
+		dev_dbg(phy->dev, "cannot set voltage for vddcx\n");
 
 	regulator_disable(phy->vddcx);
 
 	ret = regulator_set_voltage(phy->v1p8, 0, PHY_1P8_VOL_MAX);
 	if (ret)
-		dev_err(phy->dev, "cannot set v1p8\n");
+		dev_dbg(phy->dev, "cannot set v1p8\n");
 
 	regulator_disable(phy->v1p8);
 }
Index: linux-3.14.43/drivers/video/msm/Kconfig
===================================================================
--- linux-3.14.43.orig/drivers/video/msm/Kconfig
+++ linux-3.14.43/drivers/video/msm/Kconfig
@@ -7,6 +7,7 @@ config FB_MSM
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
+	select FB_SYS_FOPS
 	select SYNC
 	select SW_SYNC
 	---help---
@@ -33,10 +34,9 @@ config FB_MSM_LCDC_HW
 config FB_MSM_MDSS_COMMON
 	bool
 
-choice
-
 config FB_MSM_MDSS
 	bool "MDSS HW"
+	default n
 	select FB_MSM_MDSS_COMMON
 	---help---
 	The Mobile Display Sub System (MDSS) driver supports devices which
@@ -46,8 +46,6 @@ config FB_MSM_MDSS
 	the display hardware and provide a way for users to display graphics
 	on connected display panels.
 
-endchoice
-
 config FB_MSM_QPIC
 	bool
 	select FB_MSM_MDSS_COMMON
Index: linux-3.14.43/drivers/video/msm/mdss/Makefile
===================================================================
--- linux-3.14.43.orig/drivers/video/msm/mdss/Makefile
+++ linux-3.14.43/drivers/video/msm/mdss/Makefile
@@ -1,7 +1,6 @@
 ccflags-y += -I$(src)
 ccflags-y += -I$(srctree)/arch/arm/mach-qcom/include
 ccflags-y += -I$(srctree)/arch/arm/mach-qcom
-ccflags-y += -I$(srctree)/drivers/staging/android
 
 mdss-qpic-objs := mdss_qpic.o mdss_fb.o mdss_qpic_panel.o
 obj-$(CONFIG_FB_MSM_QPIC) += mdss-qpic.o
Index: linux-3.14.43/drivers/video/msm/mdss/mdss_fb.c
===================================================================
--- linux-3.14.43.orig/drivers/video/msm/mdss/mdss_fb.c
+++ linux-3.14.43/drivers/video/msm/mdss/mdss_fb.c
@@ -349,7 +349,7 @@ static ssize_t mdss_fb_store_split(struc
 	struct fb_info *fbi = dev_get_drvdata(dev);
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
 
-	if (2 != sscanf(buf, "%d %d", &data[0], &data[1])) {
+	if (2 != sscanf(buf, "%u %u", &data[0], &data[1])) {
 		pr_debug("Not able to read split values\n");
 	} else if (!mdss_fb_validate_split(data[0], data[1], mfd)) {
 		mfd->mdss_fb_split_stored = 1;
@@ -1740,7 +1740,9 @@ static int mdss_fb_physical_mmap(struct
 
 static int mdss_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
 {
+#ifdef CONFIG_ION
 	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+#endif
 	int rc = 0;
 
 #ifdef CONFIG_ION
@@ -1756,6 +1758,66 @@ static int mdss_fb_mmap(struct fb_info *
 	return rc;
 }
 
+static void mdss_fb_kthread_notify(struct msm_fb_data_type *mfd)
+{
+	atomic_inc(&mfd->commits_pending);
+	wake_up_all(&mfd->commit_wait_q);
+}
+
+static ssize_t mdss_fb_write(struct fb_info *info, const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	unsigned long total_size;
+	unsigned long p = *ppos;
+	u8 __iomem *dst;
+
+	total_size = info->fix.smem_len;
+
+	if (p > total_size)
+		return -EINVAL;
+
+	if (count + p > total_size)
+		count = total_size - p;
+
+	if (!count)
+		return -EINVAL;
+
+	dst = (u8 __force __iomem *) (info->screen_base + p);
+
+	if (copy_from_user(dst, buf, count))
+		return -EFAULT;
+
+	mdss_fb_kthread_notify(mfd);
+	*ppos += count;
+
+	return count;
+}
+
+static void mdss_fb_fillrect(struct fb_info *info,
+		const struct fb_fillrect *rect)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	cfb_fillrect(info, rect);
+	mdss_fb_kthread_notify(mfd);
+}
+
+static void mdss_fb_copyarea(struct fb_info *info,
+		const struct fb_copyarea *area)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	cfb_copyarea(info, area);
+	mdss_fb_kthread_notify(mfd);
+}
+
+static void mdss_fb_imageblit(struct fb_info *info,
+		const struct fb_image *image)
+{
+	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	cfb_imageblit(info, image);
+	mdss_fb_kthread_notify(mfd);
+}
+
 static struct fb_ops mdss_fb_ops = {
 	.owner = THIS_MODULE,
 	.fb_open = mdss_fb_open,
@@ -1769,6 +1831,11 @@ static struct fb_ops mdss_fb_ops = {
 	.fb_compat_ioctl = mdss_fb_compat_ioctl,
 #endif
 	.fb_mmap = mdss_fb_mmap,
+	.fb_read	= fb_sys_read,
+	.fb_write	= mdss_fb_write,
+	.fb_fillrect	= mdss_fb_fillrect,
+	.fb_copyarea	= mdss_fb_copyarea,
+	.fb_imageblit	= mdss_fb_imageblit,
 };
 
 static int mdss_fb_alloc_fbmem_iommu(struct msm_fb_data_type *mfd, int dom)
Index: linux-3.14.43/drivers/video/msm/mdss/mdss_qpic.h
===================================================================
--- linux-3.14.43.orig/drivers/video/msm/mdss/mdss_qpic.h
+++ linux-3.14.43/drivers/video/msm/mdss/mdss_qpic.h
@@ -72,8 +72,8 @@ struct qpic_data_type {
 	size_t qpic_reg_size;
 	u32 qpic_phys;
 	char __iomem *qpic_base;
-	u32 irq;
-	u32 bam_irq;
+	int irq;
+	int bam_irq;
 	u32 irq_ena;
 	u32 res_init;
 	void *fb_virt;
Index: linux-3.14.43/drivers/video/msm/mdss/qpic_panel_er_ssd1963.c
===================================================================
--- linux-3.14.43.orig/drivers/video/msm/mdss/qpic_panel_er_ssd1963.c
+++ linux-3.14.43/drivers/video/msm/mdss/qpic_panel_er_ssd1963.c
@@ -40,7 +40,6 @@ void ertft_off(struct qpic_panel_io_desc
 int ertft_on(struct qpic_panel_io_desc *qpic_panel_io)
 {
 	u8 param[8];
-	int ret;
 
 	/* Set PLL MN */
 	param[0] = 0x23;
@@ -170,18 +169,17 @@ int ertft_on(struct qpic_panel_io_desc *
 	return 0;
 }
 
-static int mdss_qpic_ertft_panel_init(void)
+static int __init mdss_qpic_ertft_panel_init(void)
 {
 	qpic_panel_on = ertft_on;
 	qpic_panel_off = ertft_off;
 	return 0;
 }
 
-static int mdss_qpic_ertft_panel_exit(void)
+static void __exit mdss_qpic_ertft_panel_exit(void)
 {
 	qpic_panel_on = NULL;
 	qpic_panel_off = NULL;
-	return;
 }
 module_init(mdss_qpic_ertft_panel_init);
 module_exit(mdss_qpic_ertft_panel_exit);
Index: linux-3.14.43/include/dt-bindings/reset/qcom,gcc-ipq806x.h
===================================================================
--- linux-3.14.43.orig/include/dt-bindings/reset/qcom,gcc-ipq806x.h
+++ linux-3.14.43/include/dt-bindings/reset/qcom,gcc-ipq806x.h
@@ -171,5 +171,11 @@
 #define NSS_CAL_PRBS_RST_N_RESET			154
 #define NSS_LCKDT_RST_N_RESET				155
 #define NSS_SRDS_N_RESET				156
+#define CRYPTO_ENG1_RESET				157
+#define CRYPTO_ENG2_RESET				158
+#define CRYPTO_ENG3_RESET				159
+#define CRYPTO_ENG4_RESET				160
+#define CRYPTO_AHB_RESET				161
+
 
 #endif
Index: linux-3.14.43/include/dt-bindings/soc/qcom,gsbi.h
===================================================================
--- linux-3.14.43.orig/include/dt-bindings/soc/qcom,gsbi.h
+++ linux-3.14.43/include/dt-bindings/soc/qcom,gsbi.h
@@ -23,4 +23,14 @@
 #define GSBI_CRCI_QUP		0
 #define GSBI_CRCI_UART		1
 
+/* Masks for GSBI ADM MUX SEL */
+#define IPQ806X_GSBI1_ADM_CRCI_MUX_SEL_MASK     0x1800
+#define IPQ806X_GSBI2_ADM_CRCI_MUX_SEL_MASK     0x6000
+#define IPQ806X_GSBI3_ADM_CRCI_MUX_SEL_MASK     0x0030
+#define IPQ806X_GSBI4_ADM_CRCI_MUX_SEL_MASK     0x00C0
+#define IPQ806X_GSBI5_ADM_CRCI_MUX_SEL_MASK     0x0300
+#define IPQ806X_GSBI6_ADM_CRCI_MUX_RX_SEL_MASK  0x0400
+#define IPQ806X_GSBI6_ADM_CRCI_MUX_TX_SEL_MASK  0x0020
+#define IPQ806X_GSBI7_ADM_CRCI_MUX_SEL_MASK     0x00C0
+
 #endif
Index: linux-3.14.43/include/dt-bindings/soc/qcom,tcsr.h
===================================================================
--- linux-3.14.43.orig/include/dt-bindings/soc/qcom,tcsr.h
+++ linux-3.14.43/include/dt-bindings/soc/qcom,tcsr.h
@@ -28,4 +28,21 @@
 #define TCSR_ESS_PSGMII_RMII0_RMII1  6
 #define TCSR_ESS_PSGMII_RGMII4       9
 
+/*
+ * IPQ40xx WiFi Global Config
+ * Bit 30:AXID_EN
+ * Enable AXI master bus Axid translating to confirm all txn submitted by order
+ * Bit 24: Use locally generated socslv_wxi_bvalid
+ * 1:  use locally generate socslv_wxi_bvalid for performance.
+ * 0:  use SNOC socslv_wxi_bvalid.
+ */
+#define TCSR_WIFI_GLB_CFG		0x41000000
+
+/* IPQ40xx MEM_TYPE_SEL_M0_M2 Select Bit 26:24 - 2 NORMAL */
+#define TCSR_WIFI_NOC_MEMTYPE_M0_M2	0x02222222
+
+/* TCSR A/B REG */
+#define IPQ806X_TCSR_REG_A_ADM_CRCI_MUX_SEL     0
+#define IPQ806X_TCSR_REG_B_ADM_CRCI_MUX_SEL     1
+
 #endif
Index: linux-3.14.43/include/linux/debugobjects.h
===================================================================
--- linux-3.14.43.orig/include/linux/debugobjects.h
+++ linux-3.14.43/include/linux/debugobjects.h
@@ -64,6 +64,7 @@ extern void debug_object_init      (void
 extern void
 debug_object_init_on_stack(void *addr, struct debug_obj_descr *descr);
 extern int debug_object_activate  (void *addr, struct debug_obj_descr *descr);
+extern int debug_object_get_state(void *addr);
 extern void debug_object_deactivate(void *addr, struct debug_obj_descr *descr);
 extern void debug_object_destroy   (void *addr, struct debug_obj_descr *descr);
 extern void debug_object_free      (void *addr, struct debug_obj_descr *descr);
@@ -81,6 +82,7 @@ debug_object_active_state(void *addr, st
 extern void debug_objects_early_init(void);
 extern void debug_objects_mem_init(void);
 #else
+static inline int debug_object_get_state(void *addr) { return 0; }
 static inline void
 debug_object_init      (void *addr, struct debug_obj_descr *descr) { }
 static inline void
Index: linux-3.14.43/include/linux/fab_scaling.h
===================================================================
--- /dev/null
+++ linux-3.14.43/include/linux/fab_scaling.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef __FAB_SCALING_H
+#define __FAB_SCALING_H
+
+struct fab_scaling_info {
+	struct clk *clk;
+	u32 idle_freq;
+};
+
+/**
+ * fab_scaling_register - Register for APPS and DDR FABRICS scaling
+ * @data: FABRIC scaling info
+ *
+ * This registers the clock source which needs to be monitored.
+ *
+ */
+int fab_scaling_register(struct fab_scaling_info *data);
+
+/**
+ * scale_fabrics - Scale DDR and APPS FABRICS
+ *
+ * This function monitors all the registered clocks and does APPS
+ * and DDR FABRIC scaling based on the idle frequencies with which
+ * it was registered.
+ *
+ */
+int scale_fabrics(void);
+
+/**
+ * fab_scaling_unregister - Unregister for APPS and DDR FABRICS scaling
+ * @clk: Clock pointer which needs to be unregistered.
+ *
+ * This unregisters the clock source and is no longer monitored.
+ *
+ */
+int fab_scaling_unregister(struct clk *clk);
+
+#endif
Index: linux-3.14.43/include/linux/if_bridge.h
===================================================================
--- linux-3.14.43.orig/include/linux/if_bridge.h
+++ linux-3.14.43/include/linux/if_bridge.h
@@ -56,4 +56,12 @@ struct br_fdb_event {
 };
 extern void br_fdb_register_notify(struct notifier_block *nb);
 extern void br_fdb_unregister_notify(struct notifier_block *nb);
+
+typedef struct net_bridge_port *br_get_dst_hook_t(
+		const struct net_bridge_port *src,
+		struct sk_buff **skb);
+extern br_get_dst_hook_t __rcu *br_get_dst_hook;
+
+typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
+extern br_notify_hook_t __rcu *br_notify_hook;
 #endif
Index: linux-3.14.43/include/linux/if_pppol2tp.h
===================================================================
--- linux-3.14.43.orig/include/linux/if_pppol2tp.h
+++ linux-3.14.43/include/linux/if_pppol2tp.h
@@ -18,4 +18,27 @@
 #include <linux/in6.h>
 #include <uapi/linux/if_pppol2tp.h>
 
+/*
+ * Holds L2TP channel info
+ */
+struct  pppol2tp_common_addr {
+	int tunnel_version;				/* v2 or v3 */
+	__u32 local_tunnel_id, remote_tunnel_id;	/* tunnel id */
+	__u32 local_session_id, remote_session_id;	/* session id */
+	struct sockaddr_in local_addr, remote_addr;	/* ip address and port */
+};
+
+/*
+ * L2TP channel operations
+ */
+struct pppol2tp_channel_ops {
+	struct ppp_channel_ops ops; /* ppp channel ops */
+};
+
+/*
+ * exported function which calls pppol2tp channel's get addressing
+ * function
+ */
+extern int pppol2tp_channel_addressing_get(struct ppp_channel *, struct pppol2tp_common_addr *);
+
 #endif
Index: linux-3.14.43/include/linux/mroute.h
===================================================================
--- linux-3.14.43.orig/include/linux/mroute.h
+++ linux-3.14.43/include/linux/mroute.h
@@ -104,4 +104,41 @@ struct rtmsg;
 extern int ipmr_get_route(struct net *net, struct sk_buff *skb,
 			  __be32 saddr, __be32 daddr,
 			  struct rtmsg *rtm, int nowait);
+
+#define IPMR_MFC_EVENT_UPDATE   1
+#define IPMR_MFC_EVENT_DELETE   2
+
+/*
+ * Callback to registered modules in the event of updates to a multicast group
+ */
+typedef void (*ipmr_mfc_event_offload_callback_t)(__be32 origin, __be32 group,
+						  uint32_t max_dest_dev,
+						  uint32_t dest_dev_idx[],
+						  uint8_t op);
+
+/*
+ * Register the callback used to inform offload modules when updates occur to
+ * MFC. The callback is registered by offload modules
+ */
+extern bool ipmr_register_mfc_event_offload_callback(ipmr_mfc_event_offload_callback_t mfc_offload_cb);
+
+/*
+ * De-Register the callback used to inform offload modules when updates occur
+ * to MFC
+ */
+extern void ipmr_unregister_mfc_event_offload_callback(void);
+
+/*
+ * Find the destination interface list, given a multicast group and source
+ */
+extern int ipmr_find_mfc_entry(struct net *net, __be32 origin, __be32 group,
+				 uint32_t max_dst_cnt, uint32_t dest_dev[]);
+
+/*
+ * Out-of-band multicast statistics update for flows that are offloaded from
+ * Linux
+ */
+extern int ipmr_mfc_stats_update(struct net *net, __be32 origin, __be32 group,
+				 uint64_t pkts_in, uint64_t bytes_in,
+				 uint64_t pkts_out, uint64_t bytes_out);
 #endif
Index: linux-3.14.43/include/linux/mroute6.h
===================================================================
--- linux-3.14.43.orig/include/linux/mroute6.h
+++ linux-3.14.43/include/linux/mroute6.h
@@ -113,10 +113,50 @@ struct mfc6_cache {
 
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
 
+#define IP6MR_MFC_EVENT_UPDATE   1
+#define IP6MR_MFC_EVENT_DELETE   2
+
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
 			   struct rtmsg *rtm, int nowait);
 
+/*
+ * Callback to registered modules in the event of updates to a multicast group
+ */
+typedef void (*ip6mr_mfc_event_offload_callback_t)(struct in6_addr *origin,
+						   struct in6_addr *group,
+						   uint32_t max_dest_dev,
+						   uint32_t dest_dev_idx[],
+						   uint8_t op);
+
+/*
+ * Register the callback used to inform offload modules when updates occur
+ * to MFC. The callback is registered by offload modules
+ */
+extern bool ip6mr_register_mfc_event_offload_callback(ip6mr_mfc_event_offload_callback_t mfc_offload_cb);
+
+/*
+ * De-Register the callback used to inform offload modules when updates occur
+ * to MFC
+ */
+extern void ip6mr_unregister_mfc_event_offload_callback(void);
+
+/*
+ * Find the destination interface list given a multicast group and source
+ */
+extern int ip6mr_find_mfc_entry(struct net *net, struct in6_addr *origin,
+				struct in6_addr *group, uint32_t max_dst_cnt,
+				uint32_t dest_dev[]);
+
+/*
+ * Out-of-band multicast statistics update for flows that are offloaded from
+ * Linux
+ */
+extern int ip6mr_mfc_stats_update(struct net *net, struct in6_addr *origin,
+				  struct in6_addr *group, uint64_t pkts_in,
+				  uint64_t bytes_in, uint64_t pkts_out,
+				  uint64_t bytes_out);
+
 #ifdef CONFIG_IPV6_MROUTE
 extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);
 extern int ip6mr_sk_done(struct sock *sk);
Index: linux-3.14.43/include/linux/mtd/nand.h
===================================================================
--- linux-3.14.43.orig/include/linux/mtd/nand.h
+++ linux-3.14.43/include/linux/mtd/nand.h
@@ -637,6 +637,7 @@ struct nand_chip {
 #define NAND_MFR_INTEL		0x89
 #define NAND_MFR_GIGA		0xc8
 #define NAND_MFR_ATO		0x9b
+#define NAND_MFR_WINBOND	0xef
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8
Index: linux-3.14.43/include/linux/platform_data/qcom-serial_hs_lite.h
===================================================================
--- linux-3.14.43.orig/include/linux/platform_data/qcom-serial_hs_lite.h
+++ linux-3.14.43/include/linux/platform_data/qcom-serial_hs_lite.h
@@ -30,11 +30,11 @@
  * @line: Used to set UART Port number.
  */
 struct msm_serial_hslite_platform_data {
-	unsigned config_gpio;
-	unsigned uart_tx_gpio;
-	unsigned uart_rx_gpio;
-	unsigned uart_cts_gpio;
-	unsigned uart_rfr_gpio;
+	int config_gpio;
+	int uart_tx_gpio;
+	int uart_rx_gpio;
+	int uart_cts_gpio;
+	int uart_rfr_gpio;
 	bool set_uart_clk_zero;
 	bool use_pm;
 	int line;
Index: linux-3.14.43/include/linux/ppp_channel.h
===================================================================
--- linux-3.14.43.orig/include/linux/ppp_channel.h
+++ linux-3.14.43/include/linux/ppp_channel.h
@@ -39,6 +39,7 @@
 #include <linux/skbuff.h>
 #include <linux/poll.h>
 #include <net/net_namespace.h>
+#include <linux/ppp_defs.h>
 
 typedef void (*ppp_channel_destroy_method_t)(void *, uint16_t, uint8_t *);
 
@@ -95,13 +96,22 @@ extern void ppp_release_channels(struct
 /* Hold PPP channels for the PPP device */
 extern int ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[], unsigned int chan_sz);
 
+/* Hold PPP channels for the PPP device */
+extern int __ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[], unsigned int chan_sz);
+
 /* Test if the ppp device is a multi-link ppp device */
 extern int ppp_is_multilink(struct net_device *dev);
 
+/* Test if the ppp device is a multi-link ppp device */
+extern int __ppp_is_multilink(struct net_device *dev);
+
 /* Update statistics of the PPP net_device by incrementing related
    statistics field value with corresponding parameter */
 extern void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
-		unsigned long rx_bytes, unsigned long tx_packets, unsigned long tx_bytes);
+		unsigned long rx_bytes, unsigned long tx_packets,
+		unsigned long tx_bytes, unsigned long rx_errors,
+		unsigned long tx_errors, unsigned long rx_dropped,
+		unsigned long tx_dropped);
 
 /* Called by the channel when it can send some more data. */
 extern void ppp_output_wakeup(struct ppp_channel *);
@@ -126,6 +136,9 @@ extern void ppp_unregister_channel(struc
 /* Get the channel number for a channel */
 extern int ppp_channel_index(struct ppp_channel *);
 
+/* Get the device index  associated with a channel, or 0, if none */
+extern int ppp_dev_index(struct ppp_channel *);
+
 /* Get the unit number associated with a channel, or -1 if none */
 extern int ppp_unit_number(struct ppp_channel *);
 
Index: linux-3.14.43/include/linux/skbuff.h
===================================================================
--- linux-3.14.43.orig/include/linux/skbuff.h
+++ linux-3.14.43/include/linux/skbuff.h
@@ -548,6 +548,9 @@ struct sk_buff {
 				*data;
 	unsigned int		truesize;
 	atomic_t		users;
+#ifdef CONFIG_DEBUG_OBJECTS_SKBUFF
+	void *			free_addr;
+#endif
 };
 
 #ifdef __KERNEL__
Index: linux-3.14.43/include/uapi/linux/if_bonding.h
===================================================================
--- linux-3.14.43.orig/include/uapi/linux/if_bonding.h
+++ linux-3.14.43/include/uapi/linux/if_bonding.h
@@ -116,6 +116,19 @@ struct ad_info {
 	__u8 partner_system[ETH_ALEN];
 };
 
+#ifdef __KERNEL__
+struct bond_cb {
+	void (*bond_cb_link_up)(struct net_device *slave);
+	void (*bond_cb_link_down)(struct net_device *slave);
+	void (*bond_cb_enslave)(struct net_device *slave);
+	void (*bond_cb_release)(struct net_device *slave);
+};
+
+extern void bond_register_cb(struct bond_cb *cb);
+extern void bond_unregister_cb(void);
+extern int bond_get_id(struct net_device *bond_dev);
+#endif /* __KERNEL__ */
+
 #endif /* _LINUX_IF_BONDING_H */
 
 /*
Index: linux-3.14.43/lib/Kconfig.debug
===================================================================
--- linux-3.14.43.orig/lib/Kconfig.debug
+++ linux-3.14.43/lib/Kconfig.debug
@@ -384,6 +384,12 @@ config DEBUG_OBJECTS_PERCPU_COUNTER
 	  percpu counter routines to track the life time of percpu counter
 	  objects and validate the percpu counter operations.
 
+config DEBUG_OBJECTS_SKBUFF
+	bool "Debug sk_buff allocations"
+	depends on DEBUG_OBJECTS
+	help
+	  Enable this to turn on debugging of sk_buff's (incl. recycler)
+
 config DEBUG_OBJECTS_ENABLE_DEFAULT
 	int "debug_objects bootup default value (0-1)"
         range 0 1
Index: linux-3.14.43/lib/debugobjects.c
===================================================================
--- linux-3.14.43.orig/lib/debugobjects.c
+++ linux-3.14.43/lib/debugobjects.c
@@ -14,6 +14,7 @@
 #include <linux/debugfs.h>
 #include <linux/slab.h>
 #include <linux/hash.h>
+#include <linux/module.h>
 
 #define ODEBUG_HASH_BITS	14
 #define ODEBUG_HASH_SIZE	(1 << ODEBUG_HASH_BITS)
@@ -245,6 +246,29 @@ static struct debug_bucket *get_bucket(u
 	return &obj_hash[hash];
 }
 
+/*
+ * debug_object_get_state():
+ *   returns the state of an object given an address
+ */
+int debug_object_get_state(void *addr)
+{
+	struct debug_bucket *db;
+	struct debug_obj *obj;
+	unsigned long flags;
+	enum debug_obj_state state = ODEBUG_STATE_NOTAVAILABLE;
+
+	db = get_bucket((unsigned long) addr);
+
+	raw_spin_lock_irqsave(&db->lock, flags);
+	obj = lookup_object(addr, db);
+	if (obj)
+		state = obj->state;
+	raw_spin_unlock_irqrestore(&db->lock, flags);
+
+	return state;
+}
+EXPORT_SYMBOL(debug_object_get_state);
+
 static void debug_print_object(struct debug_obj *obj, char *msg)
 {
 	struct debug_obj_descr *descr = obj->descr;
Index: linux-3.14.43/net/Kconfig
===================================================================
--- linux-3.14.43.orig/net/Kconfig
+++ linux-3.14.43/net/Kconfig
@@ -307,6 +307,24 @@ config SKB_RECYCLER_MULTI_CPU
 	depends on SMP && SKB_RECYCLER
 	default n
 
+config SKB_RECYCLER_PREALLOC
+	bool "Enable preallocation of SKBs"
+	depends on SKB_RECYCLER
+	default n
+	---help---
+	 Preallocates SKBs in recycling lists and the number of
+	 SKBs are configured through CONFIG_SKB_RECYCLE_MAX_PREALLOC_SKBS.
+	 This needs SKB_RECYCLER to be enabled.
+	 The number of preallocated SKBs can be passed using
+	 SKB_RECYCLE_MAX_PREALLOC_SKBS.
+
+config SKB_RECYCLE_MAX_PREALLOC_SKBS
+	int "Number of SKBs to be preallocated"
+	depends on SKB_RECYCLER_PREALLOC
+	default 16384
+	---help---
+	 Number of SKBs each of 4K size to be preallocated for recycling
+
 menu "Network testing"
 
 config NET_PKTGEN
Index: linux-3.14.43/net/bridge/br.c
===================================================================
--- linux-3.14.43.orig/net/bridge/br.c
+++ linux-3.14.43/net/bridge/br.c
@@ -115,6 +115,10 @@ static void __exit br_deinit(void)
 	br_fdb_fini();
 }
 
+/* Hook for bridge event notifications */
+br_notify_hook_t __rcu *br_notify_hook __read_mostly;
+EXPORT_SYMBOL_GPL(br_notify_hook);
+
 module_init(br_init)
 module_exit(br_deinit)
 MODULE_LICENSE("GPL");
Index: linux-3.14.43/net/bridge/br_fdb.c
===================================================================
--- linux-3.14.43.orig/net/bridge/br_fdb.c
+++ linux-3.14.43/net/bridge/br_fdb.c
@@ -700,6 +700,7 @@ static void fdb_notify(struct net_bridge
 		kfree_skb(skb);
 		goto errout;
 	}
+	__br_notify(RTNLGRP_NEIGH, type, fdb);
 	rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
 	return;
 errout:
Index: linux-3.14.43/net/bridge/br_forward.c
===================================================================
--- linux-3.14.43.orig/net/bridge/br_forward.c
+++ linux-3.14.43/net/bridge/br_forward.c
@@ -30,7 +30,8 @@ static int deliver_clone(const struct ne
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
-	return ((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&
+	const unsigned char *dest = eth_hdr(skb)->h_dest;
+	return ((skb->dev != p->dev) || ((p->flags & BR_HAIRPIN_MODE) && (!is_multicast_ether_addr(dest)))) &&
 		br_allowed_egress(p->br, nbp_get_vlan_info(p), skb) &&
 		p->state == BR_STATE_FORWARDING;
 }
Index: linux-3.14.43/net/bridge/br_input.c
===================================================================
--- linux-3.14.43.orig/net/bridge/br_input.c
+++ linux-3.14.43/net/bridge/br_input.c
@@ -30,6 +30,10 @@ EXPORT_SYMBOL(br_should_route_hook);
 br_multicast_handle_hook_t __rcu *br_multicast_handle_hook __read_mostly;
 EXPORT_SYMBOL_GPL(br_multicast_handle_hook);
 
+/* Hook for external forwarding logic */
+br_get_dst_hook_t __rcu *br_get_dst_hook __read_mostly;
+EXPORT_SYMBOL_GPL(br_get_dst_hook);
+
 int br_pass_frame_up(struct sk_buff *skb)
 {
 	struct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;
@@ -132,6 +136,8 @@ int br_handle_frame_finish(struct sk_buf
 	struct net_bridge_fdb_entry *dst;
 	struct net_bridge_mdb_entry *mdst;
 	struct sk_buff *skb2;
+	struct net_bridge_port *pdst = NULL;
+	br_get_dst_hook_t *get_dst_hook = rcu_dereference(br_get_dst_hook);
 	bool unicast = true;
 	u16 vid = 0;
 
@@ -190,6 +196,9 @@ int br_handle_frame_finish(struct sk_buf
 
 		unicast = false;
 		br->dev->stats.multicast++;
+	} else if ((pdst = __br_get(get_dst_hook, NULL, p, &skb))) {
+		if (!skb)
+			goto out;
 	} else if ((p->flags & BR_ISOLATE_MODE) ||
 		   ((dst = __br_fdb_get(br, dest, vid)) && dst->is_local)) {
 		skb2 = skb;
@@ -200,8 +209,12 @@ int br_handle_frame_finish(struct sk_buf
 	if (skb) {
 		if (dst) {
 			dst->used = jiffies;
-			br_forward(dst->dst, skb, skb2);
-		} else
+			pdst = dst->dst;
+		}
+
+		if (pdst)
+			br_forward(pdst, skb, skb2);
+		else
 			br_flood_forward(br, skb, skb2, unicast);
 	}
 
Index: linux-3.14.43/net/bridge/br_netfilter.c
===================================================================
--- linux-3.14.43.orig/net/bridge/br_netfilter.c
+++ linux-3.14.43/net/bridge/br_netfilter.c
@@ -46,12 +46,17 @@
 				 (skb->nf_bridge->data))->daddr.ipv4)
 #define store_orig_dstaddr(skb)	 (skb_origaddr(skb) = ip_hdr(skb)->daddr)
 #define dnat_took_place(skb)	 (skb_origaddr(skb) != ip_hdr(skb)->daddr)
+#define store_orig_srcaddr(skb, offset) \
+	((skb)->nf_bridge->data[(offset)/sizeof(unsigned long)] = ip_hdr(skb)->saddr)
+#define snat_took_place(skb, offset) \
+	((skb)->nf_bridge->data[(offset)/sizeof(unsigned long)] != ip_hdr(skb)->saddr)
 
 #ifdef CONFIG_SYSCTL
 static struct ctl_table_header *brnf_sysctl_header;
 static int brnf_call_iptables __read_mostly = 1;
 static int brnf_call_ip6tables __read_mostly = 1;
 static int brnf_call_arptables __read_mostly = 1;
+static int brnf_call_custom __read_mostly;
 static int brnf_filter_vlan_tagged __read_mostly = 0;
 static int brnf_filter_pppoe_tagged __read_mostly = 0;
 static int brnf_pass_vlan_indev __read_mostly = 0;
@@ -59,6 +64,7 @@ static int brnf_pass_vlan_indev __read_m
 #define brnf_call_iptables 1
 #define brnf_call_ip6tables 1
 #define brnf_call_arptables 1
+#define brnf_call_custom 1
 #define brnf_filter_vlan_tagged 0
 #define brnf_filter_pppoe_tagged 0
 #define brnf_pass_vlan_indev 0
@@ -79,7 +85,7 @@ EXPORT_SYMBOL_GPL(brnf_call_ebtables);
 bool br_netfilter_run_hooks(void)
 {
 	return brnf_call_iptables | brnf_call_ip6tables | brnf_call_arptables |
-	       brnf_call_ebtables;
+	       brnf_call_ebtables | brnf_call_custom;
 }
 
 static inline __be16 vlan_proto(const struct sk_buff *skb)
@@ -246,12 +252,15 @@ static inline void nf_bridge_pull_encap_
 	skb->network_header += len;
 }
 
-static inline void nf_bridge_save_header(struct sk_buff *skb)
+static inline void nf_bridge_save_header(struct sk_buff *skb, u_int8_t pf)
 {
 	int header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
 
 	skb_copy_from_linear_data_offset(skb, -header_size,
 					 skb->nf_bridge->data, header_size);
+
+	if (pf == NFPROTO_IPV4)
+		store_orig_srcaddr(skb, ALIGN(header_size, sizeof(unsigned long)));
 }
 
 static inline void nf_bridge_update_protocol(struct sk_buff *skb)
@@ -336,6 +345,8 @@ int nf_bridge_copy_header(struct sk_buff
 {
 	int err;
 	unsigned int header_size;
+	u_int8_t protocol = skb->protocol;
+	struct net_device *br = bridge_parent(skb->dev);
 
 	nf_bridge_update_protocol(skb);
 	header_size = ETH_HLEN + nf_bridge_encap_header_len(skb);
@@ -345,6 +356,11 @@ int nf_bridge_copy_header(struct sk_buff
 
 	skb_copy_to_linear_data_offset(skb, -header_size,
 				       skb->nf_bridge->data, header_size);
+
+	if ((protocol == htons(ETH_P_IP)) && br &&
+	    snat_took_place(skb, ALIGN(header_size, sizeof(unsigned long))))
+		skb_copy_to_linear_data_offset(skb, ETH_ALEN - header_size, br->dev_addr, ETH_ALEN);
+
 	__skb_push(skb, nf_bridge_encap_header_len(skb));
 	return 0;
 }
@@ -924,7 +940,7 @@ static unsigned int br_nf_post_routing(c
 	}
 
 	nf_bridge_pull_encap_header(skb);
-	nf_bridge_save_header(skb);
+	nf_bridge_save_header(skb, pf);
 	if (pf == NFPROTO_IPV4)
 		skb->protocol = htons(ETH_P_IP);
 	else
@@ -1063,6 +1079,13 @@ static struct ctl_table brnf_table[] = {
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
 		.proc_handler	= brnf_sysctl_call_tables,
+	},
+	{
+		.procname	= "bridge-nf-call-custom",
+		.data		= &brnf_call_custom,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= brnf_sysctl_call_tables,
 	},
 	{ }
 };
Index: linux-3.14.43/net/bridge/br_netlink.c
===================================================================
--- linux-3.14.43.orig/net/bridge/br_netlink.c
+++ linux-3.14.43/net/bridge/br_netlink.c
@@ -195,6 +195,7 @@ void br_ifinfo_notify(int event, struct
 		kfree_skb(skb);
 		goto errout;
 	}
+	__br_notify(RTNLGRP_LINK, event, port);
 	rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
 	return;
 errout:
Index: linux-3.14.43/net/bridge/br_private.h
===================================================================
--- linux-3.14.43.orig/net/bridge/br_private.h
+++ linux-3.14.43/net/bridge/br_private.h
@@ -19,6 +19,7 @@
 #include <linux/u64_stats_sync.h>
 #include <net/route.h>
 #include <linux/if_vlan.h>
+#include <linux/export.h>
 
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
@@ -815,4 +816,12 @@ static inline void br_sysfs_delbr(struct
 #define __br_get(__hook, __default, __args ...) \
 		(__hook ? (__hook(__args)) : (__default))
 
+static inline void __br_notify(int group, int type, const void *data)
+{
+	br_notify_hook_t *notify_hook = rcu_dereference(br_notify_hook);
+
+	if (notify_hook)
+		notify_hook(group, type, data);
+}
+
 #endif
Index: linux-3.14.43/net/core/Makefile
===================================================================
--- linux-3.14.43.orig/net/core/Makefile
+++ linux-3.14.43/net/core/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_NETWORK_PHY_TIMESTAMPING) +
 obj-$(CONFIG_CGROUP_NET_PRIO) += netprio_cgroup.o
 obj-$(CONFIG_CGROUP_NET_CLASSID) += netclassid_cgroup.o
 obj-$(CONFIG_SKB_RECYCLER) += skbuff_recycle.o
+obj-$(CONFIG_DEBUG_OBJECTS_SKBUFF) += skbuff_debug.o
Index: linux-3.14.43/net/core/dev.c
===================================================================
--- linux-3.14.43.orig/net/core/dev.c
+++ linux-3.14.43/net/core/dev.c
@@ -134,6 +134,7 @@
 #include <linux/if_macvlan.h>
 
 #include "net-sysfs.h"
+#include "skbuff_debug.h"
 
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
@@ -4062,9 +4063,10 @@ static gro_result_t napi_skb_finish(gro_
 		break;
 
 	case GRO_MERGED_FREE:
-		if (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD)
+		if (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD) {
 			kmem_cache_free(skbuff_head_cache, skb);
-		else
+			skbuff_debugobj_deactivate(skb);
+		} else
 			__kfree_skb(skb);
 		break;
 
Index: linux-3.14.43/net/core/skbuff.c
===================================================================
--- linux-3.14.43.orig/net/core/skbuff.c
+++ linux-3.14.43/net/core/skbuff.c
@@ -78,6 +78,7 @@
 
 
 #include "skbuff_recycle.h"
+#include "skbuff_debug.h"
 
 struct kmem_cache *skbuff_head_cache __read_mostly;
 static struct kmem_cache *skbuff_fclone_cache __read_mostly;
@@ -178,6 +179,7 @@ struct sk_buff *__alloc_skb_head(gfp_t g
 	atomic_set(&skb->users, 1);
 
 	skb->mac_header = (typeof(skb->mac_header))~0U;
+	skbuff_debugobj_init_and_activate(skb);
 out:
 	return skb;
 }
@@ -272,6 +274,7 @@ struct sk_buff *__alloc_skb(unsigned int
 		child->fclone = SKB_FCLONE_UNAVAILABLE;
 		child->pfmemalloc = pfmemalloc;
 	}
+	skbuff_debugobj_init_and_activate(skb);
 out:
 	return skb;
 nodata:
@@ -328,6 +331,8 @@ struct sk_buff *__build_skb(void *data,
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
+	skbuff_debugobj_init_and_activate(skb);
+
 	return skb;
 }
 
@@ -583,13 +588,16 @@ void kfree_skbmem(struct sk_buff *skb)
 
 	switch (skb->fclone) {
 	case SKB_FCLONE_UNAVAILABLE:
+		skbuff_debugobj_deactivate(skb);
 		kmem_cache_free(skbuff_head_cache, skb);
 		break;
 
 	case SKB_FCLONE_ORIG:
 		fclone_ref = (atomic_t *) (skb + 2);
-		if (atomic_dec_and_test(fclone_ref))
+		if (atomic_dec_and_test(fclone_ref)) {
+			skbuff_debugobj_deactivate(skb);
 			kmem_cache_free(skbuff_fclone_cache, skb);
+		}
 		break;
 
 	case SKB_FCLONE_CLONE:
@@ -601,8 +609,10 @@ void kfree_skbmem(struct sk_buff *skb)
 		 */
 		skb->fclone = SKB_FCLONE_UNAVAILABLE;
 
-		if (atomic_dec_and_test(fclone_ref))
+		if (atomic_dec_and_test(fclone_ref)) {
+			skbuff_debugobj_deactivate(other);
 			kmem_cache_free(skbuff_fclone_cache, other);
+		}
 		break;
 	}
 }
@@ -957,6 +967,7 @@ struct sk_buff *skb_clone(struct sk_buff
 		kmemcheck_annotate_bitfield(n, flags1);
 		kmemcheck_annotate_bitfield(n, flags2);
 		n->fclone = SKB_FCLONE_UNAVAILABLE;
+		skbuff_debugobj_init_and_activate(n);
 	}
 
 	return __skb_clone(n, skb);
@@ -3914,6 +3925,7 @@ void kfree_skb_partial(struct sk_buff *s
 	if (head_stolen) {
 		skb_release_head_state(skb);
 		kmem_cache_free(skbuff_head_cache, skb);
+		skbuff_debugobj_deactivate(skb);
 	} else {
 		__kfree_skb(skb);
 	}
Index: linux-3.14.43/net/core/skbuff_debug.c
===================================================================
--- /dev/null
+++ linux-3.14.43/net/core/skbuff_debug.c
@@ -0,0 +1,150 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <asm/stacktrace.h>
+#include <linux/module.h>
+
+#include "skbuff_debug.h"
+
+static int skbuff_debugobj_enabled __read_mostly = 1;
+
+/*
+ * skbuff_debugobj_fixup():
+ *      Called when an error is detected in the state machine for
+ *	the objects
+ */
+static int skbuff_debugobj_fixup(void *addr, enum debug_obj_state state)
+{
+	struct sk_buff *skb = (struct sk_buff *)addr;
+	ftrace_dump(DUMP_ALL);
+	pr_emerg("skbuff_debug: state = %d, skb = 0x%p last free = %pS\n",
+			state, skb, skb->free_addr);
+	BUG();
+
+	return 0;
+}
+
+static struct debug_obj_descr skbuff_debug_descr = {
+	.name		= "sk_buff_struct",
+	.fixup_init	= skbuff_debugobj_fixup,
+	.fixup_activate	= skbuff_debugobj_fixup,
+	.fixup_destroy	= skbuff_debugobj_fixup,
+	.fixup_free	= skbuff_debugobj_fixup,
+};
+
+inline void skbuff_debugobj_activate(struct sk_buff *skb)
+{
+	int ret;
+
+	if (!skbuff_debugobj_enabled)
+		return;
+
+	ret = debug_object_activate(skb, &skbuff_debug_descr);
+
+	if (ret) {
+		ftrace_dump(DUMP_ALL);
+		pr_emerg("skb_debug: failed to activate err = %d skb = 0x%p last free=%pS\n",
+				ret, skb, skb->free_addr);
+		BUG();
+	}
+}
+
+inline void skbuff_debugobj_init_and_activate(struct sk_buff *skb)
+{
+	if (!skbuff_debugobj_enabled)
+		return;
+
+	debug_object_init(skb, &skbuff_debug_descr);
+	skbuff_debugobj_activate(skb);
+}
+
+static int skbuff_debugobj_walkstack(struct stackframe *frame, void *d)
+{
+	u32 *pc = d;
+
+	*pc = frame->pc;
+
+	/* walk to outside kernel address space (e.g. module)
+	 * for the time being, need a whitelist here in the
+	 * future most likely */
+	if (is_module_text_address(*pc))
+		return -1;
+
+	return 0;
+}
+
+#ifdef CONFIG_ARM
+static void *skbuff_debugobj_get_free_addr(void)
+{
+	struct stackframe frame;
+	register unsigned long current_sp asm ("sp");
+	void *ret = NULL;
+
+	frame.fp = (unsigned long)__builtin_frame_address(0);
+	frame.sp = current_sp;
+	frame.lr = (unsigned long)__builtin_return_address(0);
+	frame.pc = (unsigned long)skbuff_debugobj_get_free_addr;
+
+	walk_stackframe(&frame, skbuff_debugobj_walkstack, &ret);
+
+	return ret;
+}
+#else
+#error
+static void *skbuff_debugobj_get_free_addr(void)
+{
+	/* not supported */
+	return 0xdeadbeef;
+}
+#endif
+
+inline void skbuff_debugobj_deactivate(struct sk_buff *skb)
+{
+	int obj_state;
+
+	if (!skbuff_debugobj_enabled)
+		return;
+
+	obj_state = debug_object_get_state(skb);
+
+	if (obj_state == ODEBUG_STATE_ACTIVE) {
+		debug_object_deactivate(skb, &skbuff_debug_descr);
+		skb->free_addr = skbuff_debugobj_get_free_addr();
+		return;
+	}
+
+	ftrace_dump(DUMP_ALL);
+	pr_emerg("skbuff_debug: deactivating inactive object skb=0x%p state=%d last free=%pS\n",
+			skb, obj_state, skb->free_addr);
+	BUG();
+}
+
+inline void skbuff_debugobj_destroy(struct sk_buff *skb)
+{
+	if (!skbuff_debugobj_enabled)
+		return;
+
+	debug_object_destroy(skb, &skbuff_debug_descr);
+}
+
+static int __init disable_object_debug(char *str)
+{
+	skbuff_debugobj_enabled = 0;
+
+	pr_info("skbuff_debug: debug objects is disabled\n");
+	return 0;
+}
+
+early_param("no_skbuff_debug_objects", disable_object_debug);
Index: linux-3.14.43/net/core/skbuff_debug.h
===================================================================
--- /dev/null
+++ linux-3.14.43/net/core/skbuff_debug.h
@@ -0,0 +1,34 @@
+/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/debugobjects.h>
+
+#ifndef _LINUX_SKBBUFF_DEBUG_OBJECTS
+#define _LINUX_SKBBUFF_DEBUG_OBJECTS
+
+#ifdef CONFIG_DEBUG_OBJECTS_SKBUFF
+void skbuff_debugobj_init_and_activate(struct sk_buff *skb);
+void skbuff_debugobj_activate(struct sk_buff *skb);
+void skbuff_debugobj_deactivate(struct sk_buff *skb);
+void skbuff_debugobj_destroy(struct sk_buff *skb);
+#else
+static inline void skbuff_debugobj_init_and_activate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_activate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_deactivate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_destroy(struct sk_buff *skb) { }
+#endif
+
+#endif /* _LINUX_SKBBUFF_DEBUG_OBJECTS */
Index: linux-3.14.43/net/core/skbuff_recycle.c
===================================================================
--- linux-3.14.43.orig/net/core/skbuff_recycle.c
+++ linux-3.14.43/net/core/skbuff_recycle.c
@@ -21,6 +21,8 @@
 #include <linux/proc_fs.h>
 #include <linux/string.h>
 
+#include "skbuff_debug.h"
+
 static struct proc_dir_entry *proc_net_skbrecycler;
 
 static DEFINE_PER_CPU(struct sk_buff_head, recycle_list);
@@ -89,9 +91,8 @@ inline struct sk_buff *skb_recycler_allo
 		skb->data = skb->head + NET_SKB_PAD;
 		skb_reset_tail_pointer(skb);
 
-		if (dev) {
-			skb->dev = dev;
-		}
+		skb->dev = dev;
+		skbuff_debugobj_activate(skb);
 	}
 
 	return skb;
@@ -116,6 +117,7 @@ inline bool skb_recycler_consume(struct
 	/* Attempt to enqueue the CPU hot recycle list first */
 	if (likely(skb_queue_len(h) < skb_recycle_max_skbs)) {
 		__skb_queue_head(h, skb);
+		skbuff_debugobj_deactivate(skb);
 		local_irq_restore(flags);
 		preempt_enable();
 		return true;
@@ -146,6 +148,7 @@ inline bool skb_recycler_consume(struct
 			 * Intialize and enqueue skb into spare
 			 */
 			__skb_queue_head(h, skb);
+			skbuff_debugobj_deactivate(skb);
 
 			local_irq_restore(flags);
 			preempt_enable();
@@ -156,6 +159,7 @@ inline bool skb_recycler_consume(struct
 	} else {
 		/* We have room in the spare list; enqueue to spare list */
 		__skb_queue_head(h, skb);
+		skbuff_debugobj_deactivate(skb);
 		local_irq_restore(flags);
 		preempt_enable();
 		return true;
@@ -174,6 +178,7 @@ static void skb_recycler_free_skb(struct
 
 	while ((skb = skb_dequeue(list)) != NULL) {
 		skb_release_data(skb);
+		skbuff_debugobj_activate(skb);
 		kfree_skbmem(skb);
 	}
 
@@ -195,6 +200,26 @@ static int skb_cpu_callback(struct notif
 	return NOTIFY_OK;
 }
 
+#ifdef CONFIG_SKB_RECYCLER_PREALLOC
+static int __init skb_prealloc_init_list(void)
+{
+	int i;
+	struct sk_buff *skb;
+
+	for (i = 0; i < SKB_RECYCLE_MAX_PREALLOC_SKBS; i++) {
+		skb = __alloc_skb(SKB_RECYCLE_MAX_SIZE + NET_SKB_PAD,
+				  GFP_KERNEL, 0, NUMA_NO_NODE);
+		if (unlikely(skb == NULL))
+			return -ENOMEM;
+
+		skb_reserve(skb, NET_SKB_PAD);
+
+		skb_recycler_consume(skb);
+	}
+	return 0;
+}
+#endif
+
 /* procfs: count
  * Show skb counts
  */
@@ -454,6 +479,11 @@ void __init skb_recycler_init()
 	}
 #endif
 
+#ifdef CONFIG_SKB_RECYCLER_PREALLOC
+	if (skb_prealloc_init_list())
+		pr_err("Failed to preallocate SKBs for recycle list\n");
+#endif
+
 	hotcpu_notifier(skb_cpu_callback, 0);
 	skb_recycler_init_procfs();
 }
Index: linux-3.14.43/net/core/skbuff_recycle.h
===================================================================
--- linux-3.14.43.orig/net/core/skbuff_recycle.h
+++ linux-3.14.43/net/core/skbuff_recycle.h
@@ -48,7 +48,16 @@
 #define SKB_RECYCLE_MAX_SKBS	1024
 
 #define SKB_RECYCLE_SPARE_MAX_SKBS		256
-#define SKB_RECYCLE_MAX_SHARED_POOLS		8
+
+#ifdef CONFIG_SKB_RECYCLER_PREALLOC
+#define SKB_RECYCLE_MAX_PREALLOC_SKBS CONFIG_SKB_RECYCLE_MAX_PREALLOC_SKBS
+#define SKB_RECYCLE_MAX_SHARED_POOLS \
+	DIV_ROUND_UP(SKB_RECYCLE_MAX_PREALLOC_SKBS, \
+			SKB_RECYCLE_SPARE_MAX_SKBS)
+#else
+#define SKB_RECYCLE_MAX_SHARED_POOLS            8
+#endif
+
 #define SKB_RECYCLE_MAX_SHARED_POOLS_MASK	(SKB_RECYCLE_MAX_SHARED_POOLS - 1)
 
 #ifdef CONFIG_SKB_RECYCLER_MULTI_CPU
Index: linux-3.14.43/net/ipv4/ipmr.c
===================================================================
--- linux-3.14.43.orig/net/ipv4/ipmr.c
+++ linux-3.14.43/net/ipv4/ipmr.c
@@ -138,6 +138,9 @@ static void mroute_netlink_event(struct
 				 int cmd);
 static void mroute_clean_tables(struct mr_table *mrt);
 static void ipmr_expire_process(unsigned long arg);
+static struct mfc_cache *ipmr_cache_find(struct mr_table *mrt, __be32 origin,
+					 __be32 mcastgrp);
+static ipmr_mfc_event_offload_callback_t __rcu ipmr_mfc_event_offload_callback;
 
 #ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
 #define ipmr_for_each_table(mrt, net) \
@@ -228,6 +231,75 @@ static int ipmr_rule_fill(struct fib_rul
 	return 0;
 }
 
+/*
+ * ipmr_sync_entry_update()
+ * Call the registered offload callback to report an update to a multicast
+ * route entry. The callback receives the list of destination interfaces and
+ * the interface count
+ */
+static void ipmr_sync_entry_update(struct mr_table *mrt, struct mfc_cache *cache)
+{
+	int vifi, dest_if_count = 0;
+	uint32_t dest_dev[MAXVIFS];
+	__be32  origin;
+	__be32  group;
+	ipmr_mfc_event_offload_callback_t offload_update_cb_f;
+
+	memset(dest_dev, 0, sizeof(dest_dev));
+
+	origin = cache->mfc_origin;
+	group = cache->mfc_mcastgrp;
+
+	read_lock(&mrt_lock);
+	for (vifi = 0; vifi < cache->mfc_un.res.maxvif; vifi++) {
+		if (!((cache->mfc_un.res.ttls[vifi] > 0) &&
+					(cache->mfc_un.res.ttls[vifi] < 255))) {
+			continue;
+		}
+		if (dest_if_count == MAXVIFS) {
+			read_unlock(&mrt_lock);
+			return;
+		}
+
+		if (!VIF_EXISTS(mrt, vifi)) {
+			read_unlock(&mrt_lock);
+			return;
+		}
+		dest_dev[dest_if_count] = mrt->vif_table[vifi].dev->ifindex;
+		dest_if_count++;
+	}
+	read_unlock(&mrt_lock);
+
+	rcu_read_lock();
+	offload_update_cb_f = rcu_dereference(ipmr_mfc_event_offload_callback);
+	rcu_read_unlock();
+
+	if (!offload_update_cb_f)
+		return;
+
+	offload_update_cb_f(group, origin, dest_if_count, dest_dev,
+				IPMR_MFC_EVENT_UPDATE);
+}
+
+/*
+ * ipmr_sync_entry_delete()
+ * Call the registered offload callback to inform of a multicast route entry
+ * delete event
+ */
+static void ipmr_sync_entry_delete(uint32_t origin, uint32_t group)
+{
+	ipmr_mfc_event_offload_callback_t offload_update_cb_f;
+
+	rcu_read_lock();
+	offload_update_cb_f = rcu_dereference(ipmr_mfc_event_offload_callback);
+	rcu_read_unlock();
+
+	if (!offload_update_cb_f)
+		return;
+
+	offload_update_cb_f(group, origin, 0, NULL, IPMR_MFC_EVENT_DELETE);
+}
+
 static const struct fib_rules_ops __net_initconst ipmr_rules_ops_template = {
 	.family		= RTNL_FAMILY_IPMR,
 	.rule_size	= sizeof(struct ipmr_rule),
@@ -243,6 +315,148 @@ static const struct fib_rules_ops __net_
 	.owner		= THIS_MODULE,
 };
 
+/*
+ * ipmr_register_mfc_event_offload_callback()
+ * Register the IPv4 Multicast update offload callback with IPMR
+ */
+bool ipmr_register_mfc_event_offload_callback(ipmr_mfc_event_offload_callback_t mfc_offload_cb)
+{
+	ipmr_mfc_event_offload_callback_t offload_update_cb_f;
+
+	rcu_read_lock();
+	offload_update_cb_f = rcu_dereference(ipmr_mfc_event_offload_callback);
+	rcu_read_unlock();
+
+	if (offload_update_cb_f)
+		return false;
+
+	rcu_assign_pointer(ipmr_mfc_event_offload_callback, mfc_offload_cb);
+	return true;
+}
+EXPORT_SYMBOL(ipmr_register_mfc_event_offload_callback);
+
+/*
+ * ipmr_unregister_mfc_event_offload_callback()
+ * De-register the IPv4 Multicast update offload callback with IPMR
+ */
+void ipmr_unregister_mfc_event_offload_callback(void)
+{
+	rcu_assign_pointer(ipmr_mfc_event_offload_callback, NULL);
+}
+EXPORT_SYMBOL(ipmr_unregister_mfc_event_offload_callback);
+
+/*
+ * ipmr_find_mfc_entry()
+ * Returns destination interface list for a particular multicast flow, and
+ * the number of interfaces in the list
+ */
+int ipmr_find_mfc_entry(struct net *net, __be32 origin, __be32 group,
+			uint32_t max_dest_cnt, uint32_t dest_dev[])
+{
+	int vifi, dest_if_count = 0;
+	struct mr_table *mrt;
+	struct mfc_cache *cache;
+
+	mrt = ipmr_get_table(net, RT_TABLE_DEFAULT);
+	if (mrt == NULL)
+		return -ENOENT;
+
+	rcu_read_lock();
+	cache = ipmr_cache_find(mrt, origin, group);
+	if (cache == NULL) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	read_lock(&mrt_lock);
+	for (vifi = 0; vifi < cache->mfc_un.res.maxvif; vifi++) {
+		if (!((cache->mfc_un.res.ttls[vifi] > 0) &&
+					(cache->mfc_un.res.ttls[vifi] < 255))) {
+			continue;
+		}
+
+		/*
+		 * We have another valid destination interface entry. Check if
+		 * the number of the destination interfaces for the route is
+		 * exceeding the size of the array given to us
+		 */
+		if (dest_if_count == max_dest_cnt) {
+			read_unlock(&mrt_lock);
+			rcu_read_unlock();
+			return -EINVAL;
+		}
+
+		if (!VIF_EXISTS(mrt, vifi)) {
+			read_unlock(&mrt_lock);
+			rcu_read_unlock();
+			return -EINVAL;
+		}
+
+		dest_dev[dest_if_count] = mrt->vif_table[vifi].dev->ifindex;
+		dest_if_count++;
+	}
+	read_unlock(&mrt_lock);
+	rcu_read_unlock();
+
+	return dest_if_count;
+}
+EXPORT_SYMBOL(ipmr_find_mfc_entry);
+
+/*
+ * ipmr_mfc_stats_update()
+ * Update the MFC/VIF statistics for offloaded flows
+ */
+int ipmr_mfc_stats_update(struct net *net, __be32 origin, __be32 group,
+			  uint64_t pkts_in, uint64_t bytes_in,
+			  uint64_t pkts_out, uint64_t bytes_out)
+{
+	int vif, vifi;
+	struct mr_table *mrt;
+	struct mfc_cache *cache;
+
+	mrt = ipmr_get_table(net, RT_TABLE_DEFAULT);
+	if (mrt == NULL)
+		return -ENOENT;
+
+	rcu_read_lock();
+	cache = ipmr_cache_find(mrt, origin, group);
+	if (cache == NULL) {
+		rcu_read_unlock();
+		return -ENOENT;
+	}
+
+	vif = cache->mfc_parent;
+
+	read_lock(&mrt_lock);
+	if (!VIF_EXISTS(mrt, vif)) {
+		read_unlock(&mrt_lock);
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
+	mrt->vif_table[vif].pkt_in += pkts_in;
+	mrt->vif_table[vif].bytes_in += bytes_in;
+	cache->mfc_un.res.pkt  += pkts_out;
+	cache->mfc_un.res.bytes += bytes_out;
+
+	for (vifi = cache->mfc_un.res.minvif; vifi < cache->mfc_un.res.maxvif; vifi++) {
+		if ((cache->mfc_un.res.ttls[vifi] > 0) && (cache->mfc_un.res.ttls[vifi] < 255)) {
+			if (!VIF_EXISTS(mrt, vifi)) {
+				read_unlock(&mrt_lock);
+				rcu_read_unlock();
+				return -EINVAL;
+			}
+			mrt->vif_table[vifi].pkt_out += pkts_out;
+			mrt->vif_table[vifi].bytes_out += bytes_out;
+		}
+	}
+	read_unlock(&mrt_lock);
+	rcu_read_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL(ipmr_mfc_stats_update);
+
 static int __net_init ipmr_rules_init(struct net *net)
 {
 	struct fib_rules_ops *ops;
@@ -1113,6 +1327,10 @@ static int ipmr_mfc_delete(struct mr_tab
 		if (c->mfc_origin == mfc->mfcc_origin.s_addr &&
 		    c->mfc_mcastgrp == mfc->mfcc_mcastgrp.s_addr &&
 		    (parent == -1 || parent == c->mfc_parent)) {
+			/*
+			 * Inform offload modules of the delete event
+			 */
+			ipmr_sync_entry_delete(c->mfc_origin, c->mfc_mcastgrp);
 			list_del_rcu(&c->list);
 			mroute_netlink_event(mrt, c, RTM_DELROUTE);
 			ipmr_cache_free(c);
@@ -1151,6 +1369,11 @@ static int ipmr_mfc_add(struct net *net,
 			c->mfc_flags |= MFC_STATIC;
 		write_unlock_bh(&mrt_lock);
 		mroute_netlink_event(mrt, c, RTM_NEWROUTE);
+
+		/*
+		 * Inform offload modules of the update event
+		 */
+		ipmr_sync_entry_update(mrt, c);
 		return 0;
 	}
 
Index: linux-3.14.43/net/ipv6/ip6mr.c
===================================================================
--- linux-3.14.43.orig/net/ipv6/ip6mr.c
+++ linux-3.14.43/net/ipv6/ip6mr.c
@@ -122,6 +122,10 @@ static int ip6mr_rtm_dumproute(struct sk
 			       struct netlink_callback *cb);
 static void mroute_clean_tables(struct mr6_table *mrt);
 static void ipmr_expire_process(unsigned long arg);
+static struct mfc6_cache *ip6mr_cache_find(struct mr6_table *mrt,
+					   const struct in6_addr *origin,
+					   const struct in6_addr *mcastgrp);
+static ip6mr_mfc_event_offload_callback_t __rcu ip6mr_mfc_event_offload_callback;
 
 #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
 #define ip6mr_for_each_table(mrt, net) \
@@ -343,6 +347,84 @@ static void ip6mr_free_table(struct mr6_
 	kfree(mrt);
 }
 
+/*
+ * ip6mr_sync_entry_update()
+ * Call the registered offload callback to report an update to a multicast
+ * route entry. The callback receives the list of destination interfaces and
+ * the interface count
+ */
+static void ip6mr_sync_entry_update(struct mr6_table *mrt, struct mfc6_cache *cache)
+{
+	int vifi, dest_if_count = 0;
+	uint32_t dest_dev[MAXMIFS];
+	struct in6_addr mc_origin, mc_group;
+	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
+
+	memset(dest_dev, 0, sizeof(dest_dev));
+
+	read_lock(&mrt_lock);
+
+	for (vifi = 0; vifi < cache->mfc_un.res.maxvif; vifi++) {
+		if (!((cache->mfc_un.res.ttls[vifi] > 0) &&
+					(cache->mfc_un.res.ttls[vifi] < 255))) {
+			continue;
+		}
+
+		if (dest_if_count == MAXMIFS) {
+			read_unlock(&mrt_lock);
+			return;
+		}
+
+		if (!MIF_EXISTS(mrt, vifi)) {
+			read_unlock(&mrt_lock);
+			return;
+		}
+
+		dest_dev[dest_if_count] = mrt->vif6_table[vifi].dev->ifindex;
+		dest_if_count++;
+	}
+
+	memcpy(&mc_origin, &cache->mf6c_origin, sizeof(struct in6_addr));
+	memcpy(&mc_group, &cache->mf6c_mcastgrp, sizeof(struct in6_addr));
+	read_unlock(&mrt_lock);
+
+	rcu_read_lock();
+	offload_update_cb_f = rcu_dereference(ip6mr_mfc_event_offload_callback);
+	rcu_read_unlock();
+
+	if (!offload_update_cb_f)
+		return;
+
+	offload_update_cb_f(&mc_group, &mc_origin, dest_if_count, dest_dev,
+				IP6MR_MFC_EVENT_UPDATE);
+}
+
+/*
+ * ip6mr_sync_entry_delete()
+ * Call the registered offload callback to inform of a multicast route entry
+ * delete event
+ */
+static void ip6mr_sync_entry_delete(struct mfc6_cache *c)
+{
+	struct in6_addr mc_origin, mc_group;
+	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
+
+	rcu_read_lock();
+	offload_update_cb_f = rcu_dereference(ip6mr_mfc_event_offload_callback);
+	rcu_read_unlock();
+
+	if (!offload_update_cb_f)
+		return;
+
+	read_lock(&mrt_lock);
+	memcpy(&mc_origin, &c->mf6c_origin, sizeof(struct in6_addr));
+	memcpy(&mc_group, &c->mf6c_mcastgrp, sizeof(struct in6_addr));
+	read_unlock(&mrt_lock);
+
+	offload_update_cb_f(&mc_group, &mc_origin, 0, NULL,
+				IP6MR_MFC_EVENT_DELETE);
+}
+
 #ifdef CONFIG_PROC_FS
 
 struct ipmr_mfc_iter {
@@ -775,6 +857,144 @@ failure:
 #endif
 
 /*
+ * ip6mr_register_mfc_event_offload_callback()
+ * Register the IPv6 multicast update callback for offload modules
+ */
+bool ip6mr_register_mfc_event_offload_callback(ip6mr_mfc_event_offload_callback_t mfc_offload_cb)
+{
+	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
+
+	rcu_read_lock();
+	offload_update_cb_f = rcu_dereference(ip6mr_mfc_event_offload_callback);
+	rcu_read_unlock();
+
+	if (offload_update_cb_f)
+		return false;
+
+	rcu_assign_pointer(ip6mr_mfc_event_offload_callback, mfc_offload_cb);
+	return true;
+}
+EXPORT_SYMBOL(ip6mr_register_mfc_event_offload_callback);
+
+/*
+ * ip6mr_unregister_mfc_event_offload_callback()
+ * De-register the IPv6 multicast update callback for offload modules
+ */
+void ip6mr_unregister_mfc_event_offload_callback(void)
+{
+	rcu_assign_pointer(ip6mr_mfc_event_offload_callback, NULL);
+}
+EXPORT_SYMBOL(ip6mr_unregister_mfc_event_offload_callback);
+
+/*
+ * ip6mr_find_mfc_entry()
+ * Return the destination interface list for a particular multicast flow, and
+ * the number of interfaces in the list
+ */
+int ip6mr_find_mfc_entry(struct net *net, struct in6_addr *origin,
+			 struct in6_addr *group, uint32_t max_dest_cnt,
+			 uint32_t dest_dev[])
+{
+	int vifi, dest_if_count = 0;
+	struct mr6_table *mrt;
+	struct mfc6_cache *cache;
+
+	mrt = ip6mr_get_table(net, RT6_TABLE_DFLT);
+	if (mrt == NULL)
+		return -ENOENT;
+
+	read_lock(&mrt_lock);
+	cache = ip6mr_cache_find(mrt, origin, group);
+	if (cache == NULL) {
+		read_unlock(&mrt_lock);
+		return -ENOENT;
+	}
+
+	for (vifi = 0; vifi < cache->mfc_un.res.maxvif; vifi++) {
+		if (!((cache->mfc_un.res.ttls[vifi] > 0) &&
+					(cache->mfc_un.res.ttls[vifi] < 255))) {
+			continue;
+		}
+
+		/*
+		 * We have another valid destination interface entry. Check if
+		 * the number of the destination interfaces for the route is
+		 * exceeding the size of the array given to us
+		 */
+		if (dest_if_count == max_dest_cnt) {
+			read_unlock(&mrt_lock);
+			return -EINVAL;
+		}
+
+		if (!MIF_EXISTS(mrt, vifi)) {
+			read_unlock(&mrt_lock);
+			return -EINVAL;
+		}
+
+		dest_dev[dest_if_count] = mrt->vif6_table[vifi].dev->ifindex;
+		dest_if_count++;
+	}
+	read_unlock(&mrt_lock);
+
+	return dest_if_count;
+}
+EXPORT_SYMBOL(ip6mr_find_mfc_entry);
+
+/*
+ * ip6mr_mfc_stats_update()
+ * Update the MFC/VIF statistics for offloaded flows
+ */
+int ip6mr_mfc_stats_update(struct net *net, struct in6_addr *origin,
+			   struct in6_addr *group, uint64_t pkts_in,
+			   uint64_t bytes_in, uint64_t pkts_out,
+			   uint64_t bytes_out)
+{
+	int vif, vifi;
+	struct mr6_table *mrt;
+	struct mfc6_cache *cache;
+
+	mrt = ip6mr_get_table(net, RT6_TABLE_DFLT);
+
+	if (mrt == NULL)
+		return -ENOENT;
+
+	read_lock(&mrt_lock);
+	cache = ip6mr_cache_find(mrt, origin, group);
+	if (cache == NULL) {
+		read_unlock(&mrt_lock);
+		return -ENOENT;
+	}
+
+	vif = cache->mf6c_parent;
+
+	if (!MIF_EXISTS(mrt, vif)) {
+		read_unlock(&mrt_lock);
+		return -EINVAL;
+	}
+
+	mrt->vif6_table[vif].pkt_in += pkts_in;
+	mrt->vif6_table[vif].bytes_in += bytes_in;
+	cache->mfc_un.res.pkt += pkts_out;
+	cache->mfc_un.res.bytes += bytes_out;
+
+	for (vifi = cache->mfc_un.res.minvif; vifi < cache->mfc_un.res.maxvif; vifi++) {
+		if ((cache->mfc_un.res.ttls[vifi] > 0) &&
+				(cache->mfc_un.res.ttls[vifi] < 255)) {
+			if (!MIF_EXISTS(mrt, vifi)) {
+				read_unlock(&mrt_lock);
+				return -EINVAL;
+			}
+			mrt->vif6_table[vifi].pkt_out += pkts_out;
+			mrt->vif6_table[vifi].bytes_out += bytes_out;
+		}
+	}
+
+	read_unlock(&mrt_lock);
+	return 0;
+}
+EXPORT_SYMBOL(ip6mr_mfc_stats_update);
+
+/*
  *	Delete a VIF entry
  */
 
@@ -1313,6 +1533,11 @@ static int ip6mr_mfc_delete(struct mr6_t
 		    ipv6_addr_equal(&c->mf6c_mcastgrp,
 				    &mfc->mf6cc_mcastgrp.sin6_addr) &&
 		    (parent == -1 || parent == c->mf6c_parent)) {
+			/*
+			 * Inform offload modules of the delete event
+			 */
+			ip6mr_sync_entry_delete(c);
+
 			write_lock_bh(&mrt_lock);
 			list_del(&c->list);
 			write_unlock_bh(&mrt_lock);
@@ -1485,6 +1710,11 @@ static int ip6mr_mfc_add(struct net *net
 			c->mfc_flags |= MFC_STATIC;
 		write_unlock_bh(&mrt_lock);
 		mr6_netlink_event(mrt, c, RTM_NEWROUTE);
+
+		/*
+		 * Inform offload modules of the update event
+		 */
+		ip6mr_sync_entry_update(mrt, c);
 		return 0;
 	}
 
Index: linux-3.14.43/net/l2tp/l2tp_core.c
===================================================================
--- linux-3.14.43.orig/net/l2tp/l2tp_core.c
+++ linux-3.14.43/net/l2tp/l2tp_core.c
@@ -364,6 +364,22 @@ struct l2tp_tunnel *l2tp_tunnel_find_nth
 }
 EXPORT_SYMBOL_GPL(l2tp_tunnel_find_nth);
 
+void l2tp_stats_update(struct l2tp_tunnel *tunnel,
+				struct l2tp_session *session,
+				struct l2tp_stats *stats)
+{
+	atomic_long_add(atomic_long_read(&stats->rx_packets), &tunnel->stats.rx_packets);
+	atomic_long_add(atomic_long_read(&stats->rx_bytes), &tunnel->stats.rx_bytes);
+	atomic_long_add(atomic_long_read(&stats->tx_packets), &tunnel->stats.tx_packets);
+	atomic_long_add(atomic_long_read(&stats->tx_bytes), &tunnel->stats.tx_bytes);
+
+	atomic_long_add(atomic_long_read(&stats->rx_packets), &session->stats.rx_packets);
+	atomic_long_add(atomic_long_read(&stats->rx_bytes), &session->stats.rx_bytes);
+	atomic_long_add(atomic_long_read(&stats->tx_packets), &session->stats.tx_packets);
+	atomic_long_add(atomic_long_read(&stats->tx_bytes), &session->stats.tx_bytes);
+}
+EXPORT_SYMBOL_GPL(l2tp_stats_update);
+
 /*****************************************************************************
  * Receive data handling
  *****************************************************************************/
@@ -1314,7 +1330,6 @@ static void l2tp_tunnel_destruct(struct
 
 	l2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: closing...\n", tunnel->name);
 
-
 	/* Disable udp encapsulation */
 	switch (tunnel->encap) {
 	case L2TP_ENCAPTYPE_UDP:
Index: linux-3.14.43/net/l2tp/l2tp_core.h
===================================================================
--- linux-3.14.43.orig/net/l2tp/l2tp_core.h
+++ linux-3.14.43/net/l2tp/l2tp_core.h
@@ -245,6 +245,9 @@ struct l2tp_session *l2tp_session_find_n
 struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);
 struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
+void l2tp_stats_update(struct l2tp_tunnel *tunnel,
+			      struct l2tp_session *session,
+			      struct l2tp_stats *stats);
 
 int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,
 		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
Index: linux-3.14.43/net/l2tp/l2tp_ppp.c
===================================================================
--- linux-3.14.43.orig/net/l2tp/l2tp_ppp.c
+++ linux-3.14.43/net/l2tp/l2tp_ppp.c
@@ -150,12 +150,11 @@ static int pppol2tp_xmit(struct ppp_chan
 static int pppol2tp_get_channel_protocol(struct ppp_channel *);
 static void pppol2tp_hold_chan(struct ppp_channel *);
 static void pppol2tp_release_chan(struct ppp_channel *);
-
-static const struct ppp_channel_ops pppol2tp_chan_ops = {
-	.start_xmit =  pppol2tp_xmit,
-	.get_channel_protocol = pppol2tp_get_channel_protocol,
-	.hold = pppol2tp_hold_chan,
-	.release = pppol2tp_release_chan,
+static const struct pppol2tp_channel_ops pppol2tp_chan_ops = {
+	.ops.start_xmit =  pppol2tp_xmit,
+	.ops.get_channel_protocol = pppol2tp_get_channel_protocol,
+	.ops.hold = pppol2tp_hold_chan,
+	.ops.release = pppol2tp_release_chan,
 };
 
 static const struct proto_ops pppol2tp_ops;
@@ -274,6 +273,7 @@ static void pppol2tp_recv(struct l2tp_se
 		nf_reset(skb);
 
 		po = pppox_sk(sk);
+		skb->skb_iif = ppp_dev_index(&po->chan);
 		ppp_input(&po->chan, skb);
 	} else {
 		l2tp_dbg(session, PPPOL2TP_MSG_DATA,
@@ -419,6 +419,65 @@ static int pppol2tp_get_channel_protocol
 	return PX_PROTO_OL2TP;
 }
 
+/*
+ * pppol2tp_get_addressing()
+ */
+static int pppol2tp_get_addressing(struct ppp_channel *chan, struct pppol2tp_common_addr *addr)
+{
+
+	struct sock *sk = (struct sock *) chan->private;
+	struct sock *sk_tun;
+	struct l2tp_session *session;
+	struct l2tp_tunnel *tunnel;
+	struct pppol2tp_session *ps;
+	struct inet_sock *isk = NULL;
+	int err = -ENXIO;
+
+	/* Get session and tunnel contexts from the socket */
+	session = pppol2tp_sock_to_session(sk);
+	if (session == NULL)
+		return err;
+
+	ps = l2tp_session_priv(session);
+	sk_tun = ps->tunnel_sock;
+	if (sk_tun == NULL) {
+		sock_put(sk);
+		return err;
+	}
+
+	tunnel = l2tp_sock_to_tunnel(sk_tun);
+	if (tunnel == NULL) {
+		sock_put(sk_tun);
+		sock_put(sk);
+		return err;
+	}
+	isk = inet_sk(ps->tunnel_sock);
+
+	addr->local_tunnel_id = tunnel->tunnel_id;
+	addr->remote_tunnel_id = tunnel->peer_tunnel_id;
+	addr->local_session_id = session->session_id;
+	addr->remote_session_id = session->peer_session_id;
+
+	addr->local_addr.sin_port = isk->inet_sport;
+	addr->remote_addr.sin_port = isk->inet_dport;
+	addr->local_addr.sin_addr.s_addr = isk->inet_saddr;
+	addr->remote_addr.sin_addr.s_addr = isk->inet_daddr;
+
+	sock_put(sk_tun);
+	sock_put(sk);
+	return 0;
+}
+
+/*
+ * pppol2tp_channel_addressing_get()
+ */
+int pppol2tp_channel_addressing_get(struct ppp_channel *chan,
+					    struct pppol2tp_common_addr *addr)
+{
+	return pppol2tp_get_addressing(chan, addr);
+}
+EXPORT_SYMBOL(pppol2tp_channel_addressing_get);
+
 /* Transmit function called by generic PPP driver.  Sends PPP frame
  * over PPPoL2TP socket.
  *
@@ -472,6 +531,9 @@ static int pppol2tp_xmit(struct ppp_chan
 	__skb_push(skb, sizeof(ppph));
 	skb->data[0] = ppph[0];
 	skb->data[1] = ppph[1];
+	/* set incoming interface as the ppp interface */
+	if (skb->skb_iif)
+		skb->skb_iif = ppp_dev_index(chan);
 
 	local_bh_disable();
 	l2tp_xmit_skb(session, skb, session->hdr_len);
@@ -505,7 +567,6 @@ static void pppol2tp_session_close(struc
 
 	BUG_ON(session->magic != L2TP_SESSION_MAGIC);
 
-
 	if (sock) {
 		inet_shutdown(sock, 2);
 		/* Don't let the session go away before our socket does */
@@ -833,7 +894,7 @@ static int pppol2tp_connect(struct socke
 	po->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;
 
 	po->chan.private = sk;
-	po->chan.ops	 = &pppol2tp_chan_ops;
+	po->chan.ops	 = &pppol2tp_chan_ops.ops;
 	po->chan.mtu	 = session->mtu;
 
 	error = ppp_register_net_channel(sock_net(sk), &po->chan);
Index: linux-3.14.43/net/netfilter/nf_conntrack_netlink.c
===================================================================
--- linux-3.14.43.orig/net/netfilter/nf_conntrack_netlink.c
+++ linux-3.14.43/net/netfilter/nf_conntrack_netlink.c
@@ -618,14 +618,14 @@ ctnetlink_conntrack_event(unsigned int e
 	struct nlmsghdr *nlh;
 	struct nfgenmsg *nfmsg;
 	struct nlattr *nest_parms;
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
+#endif
 	struct nf_conn *ct = item->ct;
 	struct sk_buff *skb;
 	unsigned int type;
 	unsigned int flags = 0, group;
 	int err;
-#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
-	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
-#endif
 
 	/* ignore our fake conntrack entry */
 	if (nf_ct_is_untracked(ct))
Index: linux-3.14.43/sound/soc/qca/ipq40xx-adss.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-adss.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-adss.c
@@ -203,175 +203,6 @@ void ipq40xx_glb_rx_framesync_port_en(ui
 }
 EXPORT_SYMBOL(ipq40xx_glb_rx_framesync_port_en);
 
-/* Clock configs for fixed frequency
- * Todo: Dynamic setting of frequency with clock framework
- */
-void ipq40xx_i2s_intf_clk_cfg(uint32_t mode)
-{
-	uint32_t val;
-	uint32_t PLL_Out_Div, PLL_Ref_Div, PLL_Div_Frac, PLL_Div_Int;
-	uint32_t RXM_Src_Sel, RXM_Div, RXM_Misc_Div;
-	uint32_t RXB_Src_Sel, RXB_Misc_Div;
-	uint32_t TXM_Src_Sel, TXM_Div, TXM_Misc_Div;
-	uint32_t TXB_Src_Sel, TXB_Misc_Div;
-	uint32_t Spdif_Misc_Div, Spdif_Misc2_Div;
-	uint32_t Spdif_Src_Sel, Spdif_Src_Div;
-
-	PLL_Out_Div	= 1;	/* ADSS_AUDIO_PLL_CONFIG_REG */
-	PLL_Ref_Div	= 5;
-	PLL_Div_Frac	= 0x9BA5;	/* ADSS_AUDIO_PLL_MODULATION_REG */
-	PLL_Div_Int	= 49;	/* "" */
-
-	if (mode == I2S) {
-		/* Clock Dividers for stereo 48Khz 32bit */
-		TXM_Src_Sel	= 1;	/* ADSS_AUDIO_TXM_CFG_RCGR_REG */
-		TXM_Div		= 1;	/* "" */
-		TXM_Misc_Div	= 15;	/* ADSS_AUDIO_TXM_MISC_REG */
-
-		TXB_Src_Sel	= 1;	/* ADSS_AUDIO_TXB_CFG_MUXR_REG */
-		TXB_Misc_Div	= 63;	/* ADSS_AUDIO_TXB_MISC_REG */
-
-		RXM_Src_Sel	= 1;	/* ADSS_AUDIO_RXM_CFG_RCGR_REG  */
-		RXM_Div		= 1;	/* "" */
-		RXM_Misc_Div	= 15;	/* ADSS_AUDIO_RXM_MISC_REG  */
-
-		RXB_Src_Sel	= 1;	/* ADSS_AUDIO_RXB_CFG_MUXR_REG  */
-		RXB_Misc_Div	= 63;	/* ADSS_AUDIO_RXB_MISC_REG  */
-
-	} else if (mode == TDM) {
-		/* Clock Dividers for 8 channel 96Khz 32bit */
-		TXM_Src_Sel	= 1;	/* ADSS_AUDIO_TXM_CFG_RCGR_REG */
-		TXM_Div		= 1;	/* "" */
-		TXM_Misc_Div	= 7;	/* ADSS_AUDIO_TXM_MISC_REG */
-
-		TXB_Src_Sel	= 1;	/* ADSS_AUDIO_TXB_CFG_MUXR_REG */
-		TXB_Misc_Div	= 7;	/* ADSS_AUDIO_TXB_MISC_REG */
-
-		RXM_Src_Sel	= 1;	/* ADSS_AUDIO_RXM_CFG_RCGR_REG  */
-		RXM_Div		= 1;	/* "" */
-		RXM_Misc_Div	= 7;	/* ADSS_AUDIO_RXM_MISC_REG  */
-
-		RXB_Src_Sel	= 1;	/* ADSS_AUDIO_RXB_CFG_MUXR_REG  */
-		RXB_Misc_Div	= 7;	/* ADSS_AUDIO_RXB_MISC_REG  */
-
-	} else if (mode == SPDIF) {
-		TXM_Src_Sel     = 1;    /* ADSS_AUDIO_TXM_CFG_RCGR_REG */
-		TXM_Div         = 1;    /* "" */
-		TXM_Misc_Div    = 15;   /* ADSS_AUDIO_TXM_MISC_REG */
-
-		TXB_Src_Sel     = 1;    /* ADSS_AUDIO_TXB_CFG_MUXR_REG */
-		TXB_Misc_Div    = 63;   /* ADSS_AUDIO_TXB_MISC_REG */
-
-		RXM_Src_Sel     = 1;    /* ADSS_AUDIO_RXM_CFG_RCGR_REG  */
-		RXM_Div         = 0;    /* "" */
-		RXM_Misc_Div    = 0;    /* ADSS_AUDIO_RXM_MISC_REG  */
-
-		RXB_Src_Sel     = 1;    /* ADSS_AUDIO_RXB_CFG_MUXR_REG  */
-		RXB_Misc_Div    = 0;    /* ADSS_AUDIO_RXB_MISC_REG  */
-
-		Spdif_Misc_Div  = 31;   /* ADSS_AUDIO_SPDIF_MISC_REG */
-		Spdif_Misc2_Div = 63;   /* ADSS_AUDIO_SPDIFDIV2_MISC_REG */
-
-		Spdif_Src_Sel   = 1; /* ADSS_AUDIO_SPDIFINFAST_CFG_RCGR_REG */
-		Spdif_Src_Div   = 3; /* "" */
-	}
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG1_REG);
-	val |= AUDIO_PLL_CONFIG1_SRESET_L(1);
-	writel(val, adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG1_REG);
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG_REG);
-	val &= ~AUDIO_PLL_CONFIG_REFDIV_MASK;
-	val |= AUDIO_PLL_CONFIG_REFDIV(PLL_Ref_Div);
-	writel(val, adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG_REG);
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG_REG);
-	val &= ~(AUDIO_PLL_CONFIG_POSTPLLDIV_MASK);
-	val |= AUDIO_PLL_CONFIG_POSTPLLDIV(PLL_Out_Div);
-	writel(val, adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG_REG);
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG_REG);
-	val &= ~AUDIO_PLL_CONFIG_PLLPWD;
-	writel(val, adss_audio_local_base + ADSS_AUDIO_PLL_CONFIG_REG);
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_PLL_MODULATION_REG);
-	val &= ~(AUDIO_PLL_MODULATION_TGT_DIV_MASK);
-	val |= (AUDIO_PLL_MODULATION_TGT_DIV_FRAC(PLL_Div_Frac) |
-		AUDIO_PLL_MODULATION_TGT_DIV_INT(PLL_Div_Int));
-	writel(val, adss_audio_local_base + ADSS_AUDIO_PLL_MODULATION_REG);
-
-	val = (GLB_CLK_I2S_CTRL_TX_BCLK_OE |
-		GLB_CLK_I2S_CTRL_RX_BCLK_OE |
-		GLB_CLK_I2S_CTRL_RX_MCLK_OE |
-		GLB_CLK_I2S_CTRL_TX_MCLK_OE);
-	writel(val, adss_audio_local_base + ADSS_GLB_CLK_I2S_CTRL_REG);
-
-	val = (AUDIO_RXM_CFG_RCGR_SRC_SEL(RXM_Src_Sel) |
-		AUDIO_RXM_CFG_RCGR_SRC_DIV(RXM_Div));
-	writel(val, adss_audio_local_base + ADSS_AUDIO_RXM_CFG_RCGR_REG);
-	writel(AUDIO_RXM_MISC_AUTO_SCALE_DIV(RXM_Misc_Div),
-			adss_audio_local_base + ADSS_AUDIO_RXM_MISC_REG);
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_RXM_CMD_RCGR_REG);
-	val &= ~(AUDIO_RXM_CMD_RCGR_ROOT_EN);
-	val |= AUDIO_RXM_CMD_RCGR_ROOT_EN;
-	writel(val, adss_audio_local_base + ADSS_AUDIO_RXM_CMD_RCGR_REG);
-
-	val = readl(adss_audio_local_base + ADSS_AUDIO_RXM_CMD_RCGR_REG);
-	val &= ~(AUDIO_RXM_CMD_RCGR_UPDATE);
-	val |= AUDIO_RXM_CMD_RCGR_UPDATE;
-	writel(val, adss_audio_local_base + ADSS_AUDIO_RXM_CMD_RCGR_REG);
-
-	writel(AUDIO_RXB_CFG_MUXR_SRC_SEL(RXB_Src_Sel), adss_audio_local_base
-			+ ADSS_AUDIO_RXB_CFG_MUXR_REG);
-
-	writel(AUDIO_RXB_MISC_AUTO_SCALE_DIV(RXB_Misc_Div),
-			adss_audio_local_base + ADSS_AUDIO_RXB_MISC_REG);
-
-	val = (AUDIO_TXM_CFG_RCGR_SRC_SEL(TXM_Src_Sel) |
-			AUDIO_TXM_CFG_RCGR_SRC_DIV(TXM_Div));
-	writel(val, adss_audio_local_base + ADSS_AUDIO_TXM_CFG_RCGR_REG);
-
-	writel(AUDIO_TXM_MISC_AUTO_SCALE_DIV(TXM_Misc_Div),
-			adss_audio_local_base + ADSS_AUDIO_TXM_MISC_REG);
-
-	val = (AUDIO_TXM_CMD_RCGR_ROOT_EN | AUDIO_TXM_CMD_RCGR_UPDATE);
-	writel(val, adss_audio_local_base + ADSS_AUDIO_TXM_CMD_RCGR_REG);
-
-	writel(AUDIO_TXB_CFG_MUXR_SRC_SEL(TXB_Src_Sel), adss_audio_local_base
-				+ ADSS_AUDIO_TXB_CFG_MUXR_REG);
-
-	writel(AUDIO_TXB_MISC_AUTO_SCALE_DIV(TXB_Misc_Div),
-			adss_audio_local_base + ADSS_AUDIO_TXB_MISC_REG);
-
-	if (mode == SPDIF) {
-		val = readl(adss_audio_local_base +
-					ADSS_AUDIO_SPDIF_MISC_REG);
-		val &= ~AUDIO_SPDIF_MISC_AUTO_SCALE_DIV_MASK;
-		val |= AUDIO_SPDIF_MISC_AUTO_SCALE_DIV(Spdif_Misc_Div);
-		writel(val, adss_audio_local_base + ADSS_AUDIO_SPDIF_MISC_REG);
-
-		val = readl(adss_audio_local_base +
-					ADSS_AUDIO_SPDIFDIV2_MISC_REG);
-		val &= ~AUDIO_SPDIFDIV2_MISC_AUTO_SCALE_DIV_MASK;
-		val |= AUDIO_SPDIFDIV2_MISC_AUTO_SCALE_DIV(Spdif_Misc2_Div);
-		writel(val, adss_audio_local_base +
-				ADSS_AUDIO_SPDIFDIV2_MISC_REG);
-
-		val = (AUDIO_SPDIFINFAST_CFG_RCGR_SRC_SEL(Spdif_Src_Sel) |
-				AUDIO_SPDIFINFAST_CFG_RCGR_SRC_DIV(
-							Spdif_Src_Div));
-		writel(val, adss_audio_local_base +
-				ADSS_AUDIO_SPDIFINFAST_CFG_RCGR_REG);
-
-		val = AUDIO_SPDIFINFAST_CMD_RCGR_ROOT_EN |
-				AUDIO_SPDIFINFAST_CMD_RCGR_UPDATE;
-		writel(val, adss_audio_local_base +
-				ADSS_AUDIO_SPDIFINFAST_CMD_RCGR_REG);
-	}
-}
-EXPORT_SYMBOL(ipq40xx_i2s_intf_clk_cfg);
-
 void ipq40xx_glb_clk_enable_oe(uint32_t dir)
 {
 	uint32_t cfg;
Index: linux-3.14.43/sound/soc/qca/ipq40xx-adss.h
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-adss.h
+++ linux-3.14.43/sound/soc/qca/ipq40xx-adss.h
@@ -569,7 +569,6 @@ extern void ipq40xx_glb_rx_data_port_en(
 extern void ipq40xx_glb_audio_mode_B1K(void);
 extern void ipq40xx_glb_tx_framesync_port_en(uint32_t enable);
 extern void ipq40xx_glb_rx_framesync_port_en(uint32_t enable);
-extern void ipq40xx_i2s_intf_clk_cfg(uint32_t mode);
 extern void ipq40xx_glb_tdm_ctrl_ch_num(uint32_t val, uint32_t dir);
 extern void ipq40xx_glb_tdm_ctrl_sync_num(uint32_t val, uint32_t dir);
 extern void ipq40xx_glb_tdm_ctrl_delay(uint32_t delay, uint32_t dir);
Index: linux-3.14.43/sound/soc/qca/ipq40xx-codec.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-codec.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-codec.c
@@ -438,9 +438,9 @@ static int ipq40xx_codec_i2c_probe(struc
 	return ret;
 }
 
-static int ipq40xx_codec_i2c_remove(struct platform_device *pdev)
+static int ipq40xx_codec_i2c_remove(struct i2c_client *client)
 {
-	snd_soc_unregister_codec(&pdev->dev);
+	snd_soc_unregister_codec(&client->dev);
 	return 0;
 }
 
Index: linux-3.14.43/sound/soc/qca/ipq40xx-cpu-dai.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-cpu-dai.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-cpu-dai.c
@@ -155,7 +155,7 @@ static int ipq40xx_audio_startup(struct
 				struct snd_soc_dai *dai)
 {
 	uint32_t intf = dai->driver->id;
-	int ret;
+	int ret = 0;
 	struct device *dev = &(dai_priv[intf].pdev->dev);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
@@ -397,7 +397,7 @@ static int ipq40xx_spdif_prepare(struct
 static int ipq40xx_spdif_startup(struct snd_pcm_substream *substream,
 					struct snd_soc_dai *dai)
 {
-	int ret;
+	int ret = 0;
 	struct device *dev = &(dai_priv[SPDIF].pdev->dev);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
Index: linux-3.14.43/sound/soc/qca/ipq40xx-mbox.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-mbox.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-mbox.c
@@ -506,7 +506,7 @@ int ipq40xx_mbox_dma_init(struct device
 	index = ipq40xx_convert_id_to_channel(channel_id);
 	dir = ipq40xx_convert_id_to_dir(channel_id);
 
-	if (index  > ADSS_MBOX_NR_CHANNELS)
+	if (index  >= ADSS_MBOX_NR_CHANNELS)
 		return -EINVAL;
 
 	if (!mbox_rtime[index])
@@ -549,7 +549,7 @@ static int ipq40xx_mbox_probe(struct pla
 		goto init_err;
 	}
 
-	if (id > ADSS_MBOX_NR_CHANNELS) {
+	if (id >= ADSS_MBOX_NR_CHANNELS) {
 		rc = -EINVAL;
 		goto init_err;
 	}
Index: linux-3.14.43/sound/soc/qca/ipq40xx-mbox.h
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-mbox.h
+++ linux-3.14.43/sound/soc/qca/ipq40xx-mbox.h
@@ -94,7 +94,7 @@ struct ipq40xx_mbox_rt_dir_priv {
 	unsigned int ndescs;
 	irq_handler_t callback;
 	void *dai_priv;
-	uint32_t status;
+	unsigned long status;
 	uint32_t channel_id;
 	uint32_t err_stats;
 	uint32_t last_played_is_null;
Index: linux-3.14.43/sound/soc/qca/ipq40xx-pcm-i2s.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-pcm-i2s.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-pcm-i2s.c
@@ -194,11 +194,11 @@ static int ipq40xx_pcm_i2s_close(struct
 	pcm_rtpriv = substream->runtime->private_data;
 	ret = ipq40xx_mbox_dma_release(pcm_rtpriv->channel);
 	if (ret) {
-		pr_err("%s: %d: Error in dma release \n",
+		pr_err("%s: %d: Error in dma release\n",
 					__func__, __LINE__);
 	}
-	if (pcm_rtpriv)
-		kfree(pcm_rtpriv);
+
+	kfree(pcm_rtpriv);
 
 	return 0;
 }
@@ -376,7 +376,7 @@ static int ipq40xx_asoc_pcm_i2s_new(stru
 	struct snd_card *card = prtd->card->snd_card;
 	struct snd_pcm *pcm = prtd->pcm;
 
-	int ret;
+	int ret = 0;
 
 	if (!card->dev->coherent_dma_mask)
 		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
Index: linux-3.14.43/sound/soc/qca/ipq40xx-pcm-raw-lb-test.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-pcm-raw-lb-test.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-pcm-raw-lb-test.c
@@ -55,6 +55,11 @@ static void pcm_fill_data(int32_t *tx_bu
 #define PCM_LBTEST_16BIT_16KHZ_4CH_TX_TO_RX	6
 #define PCM_LBTEST_16BIT_16KHZ_4CH_RX_TO_TX	601
 
+/* The max value for loopback test config is 601(3 digits + 1 null byte)
+ * This macro needs to be updated when more configs are added.
+ */
+#define PCM_LBTEST_CFG_MAX_DIG_COUNT		4
+
 #define IS_PCM_LBTEST_RX_TO_TX(config)					\
 		((config == PCM_LBTEST_8BIT_8KHZ_4CH_RX_TO_TX) ||	\
 		(config == PCM_LBTEST_16BIT_8KHZ_2CH_RX_TO_TX) ||	\
@@ -84,13 +89,17 @@ struct ipq_pcm_params cfg_params;
 static ssize_t show_pcm_lb_value(struct device_driver *driver,
 						char *buff)
 {
-	return sprintf(buff, "%d", start);
+	return snprintf(buff, PCM_LBTEST_CFG_MAX_DIG_COUNT, "%d", start);
 }
 
 static ssize_t store_pcm_lb_value(struct device_driver *driver,
 				const char *buff, size_t count)
 {
-	sscanf(buff, "%d", &start);
+	if (sscanf(buff, "%u", &start) != 1) {
+		pr_err("%s: invalid lb value\n", __func__);
+		return -EINVAL;
+	}
+
 	pcm_start_test();
 	return count;
 }
Index: linux-3.14.43/sound/soc/qca/ipq40xx-pcm-spdif.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-pcm-spdif.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-pcm-spdif.c
@@ -122,7 +122,6 @@ static irqreturn_t ipq40xx_pcm_irq(int i
 	uint32_t processed_size;
 	int offset;
 	uint32_t *ptr;
-	uint32_t i;
 
 	struct snd_pcm_substream *substream = data;
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -454,7 +453,7 @@ static int ipq40xx_asoc_pcm_spdif_new(st
 	struct snd_card *card = prtd->card->snd_card;
 	struct snd_pcm *pcm = prtd->pcm;
 
-	int ret;
+	int ret = 0;
 
 	if (!card->dev->coherent_dma_mask)
 		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
Index: linux-3.14.43/sound/soc/qca/ipq40xx-pcm-tdm.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-pcm-tdm.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-pcm-tdm.c
@@ -191,13 +191,16 @@ static int ipq40xx_pcm_tdm_close(struct
 	uint32_t ret;
 
 	pcm_rtpriv = substream->runtime->private_data;
+	if (!pcm_rtpriv)
+		return -EINVAL;
+
 	ret = ipq40xx_mbox_dma_release(pcm_rtpriv->channel);
 	if (ret) {
-		pr_err("%s: %d: Error in dma release \n",
+		pr_err("%s: %d: Error in dma release\n",
 					__func__, __LINE__);
 	}
-	if (pcm_rtpriv)
-		kfree(pcm_rtpriv);
+
+	kfree(pcm_rtpriv);
 
 	return 0;
 }
@@ -368,7 +371,7 @@ static int ipq40xx_asoc_pcm_tdm_new(stru
 	struct snd_card *card = prtd->card->snd_card;
 	struct snd_pcm *pcm = prtd->pcm;
 
-	int ret;
+	int ret = 0;
 
 	if (!card->dev->coherent_dma_mask)
 		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
Index: linux-3.14.43/sound/soc/qca/ipq40xx-stereo.c
===================================================================
--- linux-3.14.43.orig/sound/soc/qca/ipq40xx-stereo.c
+++ linux-3.14.43/sound/soc/qca/ipq40xx-stereo.c
@@ -269,7 +269,7 @@ static int ipq40xx_audio_stereo_probe(st
 
 	np = of_node_get(pdev->dev.of_node);
 	if (!(of_property_read_u32(np, "stereo-index", &stereo_port_id))) {
-		if (stereo_port_id > MAX_STEREO_ENTRIES) {
+		if (stereo_port_id >= MAX_STEREO_ENTRIES) {
 			of_node_put(pdev->dev.of_node);
 			return -EFAULT;
 		}
