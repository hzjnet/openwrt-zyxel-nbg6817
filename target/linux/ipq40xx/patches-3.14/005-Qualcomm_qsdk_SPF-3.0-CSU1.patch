diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/Makefile linux-3.14/arch/arm/boot/dts/Makefile
--- linux/arch/arm/boot/dts/Makefile	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/Makefile	2016-09-01 11:52:02.000000000 +0800
@@ -254,9 +254,12 @@
 	qcom-ipq40xx-ap.dk01.1-c2.dtb \
 	qcom-ipq40xx-ap.dk04.1-c1.dtb \
 	qcom-ipq40xx-ap.dk06.1-c1.dtb \
+	qcom-ipq40xx-ap.dk07.1-c1.dtb \
 	qcom-ipq40xx-ap.dk04.1-c2.dtb \
 	qcom-ipq40xx-ap.dk04.1-c3.dtb \
 	qcom-ipq40xx-ap.dk04.1-c4.dtb \
+	qcom-ipq40xx-ap.dk04.1-c5.dtb \
+	qcom-ipq40xx-ap.dk05.1-c1.dtb \
 	qcom-ipq40xx-db.dk01.1-c1.dtb \
 	qcom-ipq40xx-db.dk02.1-c1.dtb \
 	qcom-ipq8064-ap145.dtb \
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk01.1.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -69,6 +69,16 @@
 					bias-disable;
 				};
 			};
+
+			wps_pins: wps_pinmux {
+				/* In ipq40xx, gpio config 0x2 corresponds to
+				 * internal pull up. In pinctrl driver,
+				 * bias-bus-hold corresponds to 0x2 */
+				mux {
+					pins = "gpio63";
+					bias-bus-hold;
+				};
+			};
 		};
 
 		serial@78af000 {
@@ -137,6 +147,8 @@
 		};
 
 		gpio_keys {
+			pinctrl-0 = <&wps_pins>;
+			pinctrl-names = "default";
 			compatible = "gpio-keys";
 
 			button@1 {
@@ -146,5 +158,12 @@
 				linux,input-type = <1>;
 			};
 		};
+		wifi0: wifi@a000000 {
+			wifi-led-gpios = <&tlmm 58 GPIO_ACTIVE_LOW>;
+		};
+
+		wifi1: wifi@a800000 {
+			wifi-led-gpios = <&tlmm 58 GPIO_ACTIVE_LOW>;
+		};
 
 	};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c2.dts	2016-09-01 11:52:02.000000000 +0800
@@ -22,6 +22,64 @@
 
 	soc {
 		pinctrl@0x01000000 {
+			audio_gpio_pins: audio_gpio_pinmux {
+				mux_1 {
+					pins = "gpio58", "gpio60", "gpio61", "gpio62";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_2 {
+					pins = "gpio54";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_3 {
+					pins = "gpio52", "gpio57";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_4 {
+					pins = "gpio55";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_5 {
+					pins = "gpio56";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_6 {
+					pins = "gpio53", "gpio59";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_7 {
+					pins = "gpio63";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+
+				mux_8 {
+					pins = "gpio48", "gpio49", "gpio50", "gpio51";
+					function = "gpio";
+					bias-pull,up;
+					output-high;
+				};
+			};
+
 			audio_pins: audio_pinmux {
 				mux_1 {
 					pins = "gpio58", "gpio60", "gpio61", "gpio62";
@@ -71,6 +129,27 @@
 					bias-pull,up;
 				};
 			};
+
+			pwm_pins: pwm_pinmux {
+				mux_1 {
+					/* function is audio_pwm0 */
+					pins = "gpio64";
+					function = "audio1";
+				};
+
+				mux_2 {
+					/* function is audio_pwm1 */
+					pins = "gpio65";
+					function = "audio2";
+				};
+
+				mux_3 {
+					/* function is audio_pwm2 */
+					pins = "gpio66";
+					function = "audio_pwm0";
+				};
+			};
+
 		};
 
 		adcc: clock-controller@7700038 {
@@ -120,8 +199,9 @@
 
 		sound: sound@0 {
 			status = "ok";
-			pinctrl-0 = <&audio_pins>;
-			pinctrl-names = "default";
+			pinctrl-0 = <&audio_gpio_pins>;
+			pinctrl-1 = <&audio_pins>;
+			pinctrl-names = "default", "audio";
 		};
 
 		i2c_0: i2c@78b7000 { /* BLSP1 QUP2 */
@@ -141,6 +221,13 @@
 			status = "ok";
 		};
 
+		pwm {
+			pinctrl-0 = <&pwm_pins>;
+			pinctrl-names = "default";
+			used-pwm-indices = <1>, <1>, <1>, <0>;
+			status = "ok";
+		};
+
 		serial@78b0000 {
 			status = "disabled";
 		};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c4.dts linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c4.dts
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c4.dts	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c4.dts	2016-09-01 11:52:02.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -15,105 +15,37 @@
  */
 
 #include "qcom-ipq40xx-ap.dk04.1.dtsi"
+#include "qcom-ipq40xx-lcdc.dtsi"
+#include "qcom-ipq40xx-lcdpanel.dtsi"
 
 / {
 	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK04.1-C4";
 
 	soc {
-		pinctrl@0x01000000 {
-			audio_pins: audio_pinmux {
-				status = "disabled";
-			};
-
-			nhost_int {
-				pins = "gpio6";
-				bias-pull,up;
-			};
-
-			nwake {
-				pins = "gpio7";
-				bias-pull,up;
-			};
-
-			mcu_int_pins: mcu_pin_mux {
-				mux {
-					pins = "gpio18", "gpio41";
-					bias-pull,down;
-				};
-			};
-
-			emmc_reset {
-				pins = "gpio34";
-				bias-pull,up;
-			};
-
-			tpm_davint {
-				pins = "gpio39";
-				bias-pull,up;
-			};
-
-			zb_reset { /* Zigbee reset */
-				pins = "gpio40";
-				bias-pull,up;
-			};
-
-			rx_active {
-				pins = "gpio43";
-				bias-pull,down;
-			};
-
-			spi_1_pins: spi_1_pinmux { /* mapped to Zigbee */
-				mux {
-					pins = "gpio44", "gpio45",
-							 "gpio46", "gpio47";
-					function = "blsp_spi1";
-					bias-pull,down;
-				};
-			};
-
-			host_wake {
-				pins = "gpio48";
-				bias-pull,down;
-			};
+		qcom,nand@7980000 {
+			status = "ok";
+		};
 
-			bt_pins: bt_mux {
-				bt_wake {
-					pins = "gpio49";
-					bias-pull,down;
-				};
-
-				bt_disable {
-					pins = "gpio50";
-					bias-pull,up;
-				};
-
-				bt_reset {
-					pins = "gpio62";
-					bias-pull,down;
-				};
-			};
+		qcom,msm_qpic@7980000 {
+			status = "ok";
+		};
 
-			wlan_active {
-				pins = "gpio57";
-				bias-pull,down;
-			};
+		qcom,mdss_lcd_qpic_panel {
+			status = "ok";
+		};
 
-			i2c_0_pins: i2c_0_pinmux {
-				mux {
-					pins = "gpio58", "gpio59";
-					function = "blsp_i2c0";
-					bias-disable;
-				};
-			};
+		ess-switch@c000000 {
+			switch_lan_bmp = <0xe>; /* lan port bitmap */
+			switch_wan_bmp = <0x30>; /* wan port bitmap */
+		};
 
-			sys_rst_out {
-				pins = "gpio60";
-				bias-pull,down;
+		edma@c080000 {
+			gmac0 {
+				qcom,poll_required = <0>;
+				vlan_tag = <2 0x30>;
 			};
-
-			nssel_int {
-				pins = "gpio61";
-				bias-pull,down;
+			gmac1 {
+				vlan_tag = <1 0xe>;
 			};
 		};
 	};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c5.dts linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c5.dts
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c5.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1-c5.dts	2016-09-01 11:52:02.000000000 +0800
@@ -0,0 +1,36 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq40xx-ap.dk04.1.dtsi"
+/ {
+	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK04.1-C5";
+
+	soc {
+		spi_0: spi@78b5000 { /* BLSP1 QUP1 */
+			status = "ok";
+			qcom,gpio-cs1 = <&tlmm 45 0>;
+
+			mt29f@1 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "spinand,mt29f";
+				reg = <1>;
+				spi-max-frequency = <24000000>;
+			};
+
+		};
+	};
+};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk04.1.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -349,4 +349,13 @@
 			};
 		};
 
+		wifi0: wifi@a000000 {
+			wifi_led_num = <2>;         /* Wifi 2G */
+			wifi_led_source = <0>;      /* source id 0 */
+		};
+
+		wifi1: wifi@a800000 {
+			wifi_led_num = <1>;         /* Wifi 5G */
+			wifi_led_source = <2>;      /* source id 2 */
+		};
 	};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk05.1-c1.dts linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk05.1-c1.dts
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk05.1-c1.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk05.1-c1.dts	2016-09-01 11:52:02.000000000 +0800
@@ -0,0 +1,47 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq40xx-ap.dk01.1.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK05.1-C1";
+
+	aliases {
+		ethernet0 = "/soc/edma/gmac0";
+	};
+	soc {
+		spi_0: spi@78b5000 { /* BLSP1 QUP1 */
+			status = "ok";
+			qcom,gpio-cs1 = <&tlmm 59 0>;
+
+			mt29f@1 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "spinand,mt29f";
+				reg = <1>;
+				spi-max-frequency = <24000000>;
+			};
+
+		};
+		edma@c080000 {
+			qcom,num_gmac = <1>;
+			gmac0 {
+				qcom,poll_required = <0>;
+				vlan_tag = <0 0x3e>;
+			};
+		};
+	};
+};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk06.1-c1.dts	2016-09-01 11:52:02.000000000 +0800
@@ -29,5 +29,26 @@
 			compatible = "qcom,gobi-9x35";
 			status = "ok";
 		};
+
+		qcom: ledc@1937000  {
+			qcom,tcsr_ledc_values = <0x320193 0x1A72004A 0x10 0x0 \
+				0x0 0xFFFFFFFF 0x80 0x6 0x7D0010 0x0 0x10482090 0x3FFFDFC>;
+		};
+
+		gpio_keys {
+			compatible = "gpio-keys";
+			button@1 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&tlmm 52 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+			};
+			button@2 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&tlmm 18 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+			};
+		};
 	};
 };
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1-c1.dts linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1-c1.dts
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1-c1.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1-c1.dts	2016-09-01 11:52:02.000000000 +0800
@@ -0,0 +1,81 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq40xx-ap.dk07.1.dtsi"
+#include "qcom-ipq40xx-lcdc.dtsi"
+#include "qcom-ipq40xx-lcdpanel.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK07.1-C1";
+
+	soc {
+		qcom,nand@7980000 {
+			status = "ok";
+		};
+
+		qcom,msm_qpic@7980000 {
+			status = "ok";
+		};
+
+		qcom,mdss_lcd_qpic_panel {
+			status = "ok";
+		};
+
+		serial@78b0000 {
+			status = "disabled";
+		};
+
+		uart1:uart@78b0000 {
+			status = "ok";
+		};
+
+		pinctrl@0x01000000 {
+			wifi_0_pins: wifi1_pinmux {
+				mux_1 {
+					pins = "gpio37";
+					output-high;
+					function="wcss0_dbg16";
+					bias-pull-up;
+					drive-strength = <6>;
+				};
+				mux_2 {
+					pins = "gpio43";
+					function="wifi_wci1";
+					bias-pull-up;
+					drive-strength = <6>;
+				};
+				mux_3 {
+					pins = "gpio52";
+					output-high;
+					function="gpio";
+					bias-pull-up;
+					drive-strength = <6>;
+				};
+			};
+		};
+
+		wifi0: wifi@a000000 {
+			pinctrl-0 = <&wifi_0_pins>;
+			pinctrl-names = "default";
+			btcoex_support = <1>;
+			wlan_prio_gpio = <52>;
+		};
+
+		wifi1: wifi@a800000 {
+			btcoex_support = <0>;
+		};
+	};
+};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx-ap.dk07.1.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -0,0 +1,291 @@
+/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include "qcom-ipq40xx.dtsi"
+#include "qcom-ipq40xx-hsuart.dtsi"
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Qualcomm Technologies, Inc. IPQ40xx/AP-DK07.1";
+	compatible = "qcom,ipq40xx-apdk04.1", "qcom,ipq40xx";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256MB */
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		rsvd1@87000000 {
+			/* Reserved for other subsystem */
+			reg = <0x87000000 0x500000>;
+			no-map;
+		};
+		wifi_dump@87500000 {
+			reg = <0x87500000 0x600000>;
+			no-map;
+		};
+
+		rsvd2@87B00000 {
+			/* Reserved for other subsystem */
+			reg = <0x87B00000 0x500000>;
+			no-map;
+		};
+	};
+
+	chosen {
+		bootargs-append = " clk_ignore_unused";
+	};
+
+};
+	&soc {
+		pinctrl@0x01000000 {
+			serial_0_pins: serial0_pinmux {
+				mux {
+					pins = "gpio16", "gpio17";
+					function = "blsp_uart0";
+					bias-disable;
+				};
+			};
+
+			serial_1_pins: serial1_pinmux {
+				mux {
+					pins = "gpio8", "gpio9";
+					function = "blsp_uart1";
+					bias-disable;
+				};
+			};
+
+			uart1_pins: uart1_pinmux {
+				mux {
+					pins = "gpio8", "gpio9", "gpio10", "gpio11";
+					function = "blsp_uart1";
+					bias-disable;
+				};
+			};
+
+			spi_0_pins: spi_0_pinmux {
+				mux {
+					pins = "gpio12", "gpio13", "gpio14", "gpio15";
+					function = "blsp_spi0";
+					bias-disable;
+				};
+			};
+
+			i2c_0_pins: i2c_0_pinmux {
+				mux {
+					pins = "gpio20", "gpio21";
+					function = "blsp_i2c0";
+					bias-disable;
+				};
+			};
+			sd_0_pins: sd_0_pinmux {
+				sd0 {
+					pins = "gpio23";
+					function = "sdio0";
+					drive-strength = <10>;
+				};
+				sd1 {
+					pins = "gpio24";
+					function = "sdio1";
+					drive-strength = <10>;
+				};
+				sd2 {
+					pins = "gpio25";
+					function = "sdio2";
+					drive-strength = <10>;
+				};
+				sd3 {
+					pins = "gpio26";
+					function = "sdio3";
+					drive-strength = <10>;
+				};
+				sdclk {
+					pins = "gpio27";
+					function = "sdio_clk";
+					drive-strength = <16>;
+				};
+				sdcmd {
+					pins = "gpio28";
+					function = "sdio_cmd";
+					drive-strength = <10>;
+				};
+			};
+			ts_0_pins: ts_0_pinmux {
+				mux_1 {
+					pins = "gpio34";
+					output-high;
+				};
+				mux_2 {
+					pins= "gpio35";
+					input-enable;
+					bias-pull-up;
+				};
+			};
+		};
+
+		serial@78af000 {
+			pinctrl-0 = <&serial_0_pins>;
+			pinctrl-names = "default";
+			status = "ok";
+		};
+
+		serial@78b0000 {
+			pinctrl-0 = <&serial_1_pins>;
+			pinctrl-names = "default";
+			status = "ok";
+		};
+
+		uart1:uart@78b0000 {
+			pinctrl-0 = <&uart1_pins>;
+			pinctrl-1 = <&uart1_pins>;
+			pinctrl-names = "default", "sleep";
+			status = "disabled";
+		};
+
+		spi_0: spi@78b5000 { /* BLSP1 QUP1 */
+			pinctrl-0 = <&spi_0_pins>;
+			pinctrl-names = "default";
+			status = "ok";
+
+			m25p80@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0>;
+				compatible = "n25q128a11";
+				linux,modalias = "m25p80", "n25q128a11";
+				spi-max-frequency = <24000000>;
+				use-default-sizes;
+			};
+		};
+
+		tcsr: tcsr@194b000 {
+			status = "ok";
+		};
+
+		usb3_ss_phy: ssphy@0 {
+			status = "ok";
+		};
+
+		dummy_ss_phy: ssphy@1 {
+			status = "ok";
+		};
+
+		usb3_hs_phy: hsphy@a6000 {
+			status = "ok";
+		};
+
+		usb2_hs_phy: hsphy@a8000 {
+			status = "ok";
+		};
+
+		usb3: usb3@8a00000 {
+			status = "ok";
+		};
+
+		usb2: usb2@6000000 {
+			status = "ok";
+		};
+
+		i2c_0: i2c@78b7000 { /* BLSP1 QUP2 */
+			pinctrl-0 = <&i2c_0_pins>;
+			pinctrl-1 = <&i2c_0_pins>;
+			pinctrl-names = "i2c_active", "i2c_sleep";
+			status = "ok";
+
+			qca_codec: qca_codec@12 {
+				compatible = "qca,ipq40xx-codec";
+				reg = <0x12>;
+				status = "disabled";
+			};
+
+			lcd_ts: lcd_ts@40 {
+				compatible = "qca,gsl1680_ts";
+				reg = <0x40>;
+				status = "disabled";
+			};
+		};
+
+		qcom_crypto: qcrypto@8e20000 {
+			status = "ok";
+		};
+
+		qcom_cedev: qcedev@8e20000 {
+			status = "ok";
+		};
+
+		pcie0: qcom,pcie@80000 {
+			status = "ok";
+			perst-gpio = <&tlmm 38 0>;
+			wake-gpio = <&tlmm 40 0>;
+			clkreq-gpio = <&tlmm 39 0>;
+		};
+
+		ess-switch@c000000 {
+			switch_mac_mode = <0x0>; /* mac mode for RGMII RMII */
+			switch_initvlas = <
+				0x0007c 0x54 /* PORT0_STATUS */
+			>;
+		};
+
+		vccq_sd0: regulator@0 {
+			compatible = "qcom,regulator-ipq40xx";
+			regulator-name = "SD0 VccQ";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3000000>;
+			states = <3000000 0x3
+				1800000 0x1>;
+			reg = <0x01948000 0x4>;
+			mask = <0x3>;
+		};
+
+		sdhci@7824000 {
+			status = "ok";
+			pinctrl-0 = <&sd_0_pins>;
+			pinctrl-names = "default";
+			vqmmc-supply = <&vccq_sd0>;
+			cd-gpios = <&tlmm 22 0x1>;
+			sd-ldo-gpios = <&tlmm 33 0x1>;
+		};
+
+		qcom,nand@7980000 {
+			status = "disabled";
+		};
+
+		gpio_keys {
+			compatible = "gpio-keys";
+
+			button@1 {
+				label = "wps";
+				linux,code = <KEY_WPS_BUTTON>;
+				gpios = <&tlmm 18 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+			};
+		};
+
+		wifi0: wifi@a000000 {
+			wifi-led-gpios = <&tlmm 32 GPIO_ACTIVE_LOW>;    /* wifi0 led */
+			wifi-rssi-gpios = <&tlmm 36 GPIO_ACTIVE_LOW>;   /* wifi0 signal strength led */
+		};
+
+		wifi1: wifi@a800000 {
+			wifi-led-gpios = <&tlmm 50 GPIO_ACTIVE_LOW>;    /* wifi1 led */
+			wifi-rssi-gpios = <&tlmm 39 GPIO_ACTIVE_LOW>;   /* wifi1 signal strength led */
+		};
+	};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq40xx.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq40xx.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq40xx.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq40xx.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -24,7 +24,9 @@
 
 	aliases {
 		spi0 = &spi_0;
+		spi1 = &spi_1;
 		i2c0 = &i2c_0;
+		i2c1 = &i2c_1;
 		ethernet0 = "/soc/edma/gmac0";
 		ethernet1 = "/soc/edma/gmac1";
 	};
@@ -138,6 +140,8 @@
 		watchdog@b017000 {
 			compatible = "qcom,kpss-wdt-ipq40xx";
 			reg = <0xb017000 0x40>;
+			interrupt-names = "bark_irq";
+			interrupts = <0 3 0>;
 			clocks = <&gcc_sleep_clk_src>;
 			timeout-sec = <10>;
 			wdt_res = <0x4>;
@@ -209,6 +213,27 @@
 			status = "disabled";
 		};
 
+		spi_1: spi@78b6000 { /* BLSP1 QUP2 */
+			compatible = "qcom,spi-qup-v2";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg-names = "spi_physical", "spi_bam_physical";
+			reg = <0x78b6000 0x600>,
+				<0x7884000 0x23000>;
+			interrupt-names = "spi_irq", "spi_bam_irq";
+			interrupts = <0 96 0>, <0 238 0>;
+			spi-max-frequency = <24000000>;
+			clocks = <&gcc GCC_BLSP1_QUP2_SPI_APPS_CLK>,
+				<&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core_clk", "iface_clk";
+			qcom,infinite-mode = <0>;
+			qcom,use-bam;
+			qcom,bam-consumer-pipe-index = <6>;
+			qcom,bam-producer-pipe-index = <7>;
+			qcom,master-id = <0>;
+			status = "disabled";
+		};
+
 		qcom,nand@7980000 {
 			compatible = "qcom,msm-nand";
 			reg = <0x07980000 0x40000>,
@@ -374,6 +399,28 @@
 			status = "disabled";
 		};
 
+		i2c_1: i2c@78b8000 { /* BLSP1 QUP4 */
+			compatible = "qcom,i2c-msm-v2";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg-names = "qup_phys_addr", "bam_phys_addr";
+			reg = <0x78b8000 0x600>,
+				<0x7884000 0x23000>;
+			interrupt-names = "qup_irq", "bam_irq";
+			interrupts = <0 98 0>, <0 238 0>;
+			clocks = <&gcc GCC_BLSP1_AHB_CLK>,
+				<&gcc GCC_BLSP1_QUP2_I2C_APPS_CLK>;
+			clock-names = "iface_clk", "core_clk";
+			qcom,clk-freq-out = <100000>;
+			qcom,clk-freq-in  = <19050000>;
+			qcom,noise-rjct-scl = <0>;
+			qcom,noise-rjct-sda = <0>;
+			qcom,bam-pipe-idx-cons = <10>;
+			qcom,bam-pipe-idx-prod = <11>;
+			qcom,master-id = <0>;
+			status = "disabled";
+		};
+
 		qcom_crypto: qcrypto@8e20000 {
 			compatible = "qcom,qcrypto";
 			reg = <0x8e20000 0x20000>,
@@ -519,12 +566,8 @@
 			reg = <0xc080000 0x8000>;
 			qcom,page-mode = <0>;
 			qcom,rx_head_buf_size = <1540>;
-			qcom,port_id_wan = <0x5>;
+			qcom,num_gmac = <2>;
 			qcom,mdio_supported;
-			qcom,phy_mdio_addr = <4>;
-			qcom,poll_required = <1>;
-			qcom,forced_speed = <1000>;
-			qcom,forced_duplex = <1>;
 
 			interrupts = <0 65 1>,
 					<0 66 1>,
@@ -560,9 +603,15 @@
 					<0 255 1>;
 			gmac0 {
 				local-mac-address = [000000000000];
+				qcom,phy_mdio_addr = <4>;
+				qcom,poll_required = <1>;
+				qcom,forced_speed = <1000>;
+				qcom,forced_duplex = <1>;
+				vlan_tag = <2 0x20>;
 			};
 			gmac1 {
 				local-mac-address = [000000000000];
+				vlan_tag = <1 0x1e>;
 			};
 		};
 
@@ -644,6 +693,15 @@
 			status = "disabled";
 		};
 
+		pwm {
+			compatible = "qca,ipq4019-pwm";
+			clocks = <&gcc GCC_AUDIO_PWM_CLK>;
+			clock-names = "core";
+			pwm-base-index = <0>;
+			used-pwm-indices = <1>, <1>, <1>, <1>;
+			status = "disabled";
+		};
+
 		qcom: ledc@1937000  {
 			compatible = "qca,ledc";
 			reg = <0x1937000 0x20070>;
@@ -674,8 +732,12 @@
 			compatible = "qcom,ess-switch";
 			reg = <0xc000000 0x80000>; /* 512KB */
 			switch_access_mode = "local bus";
-			resets = <&gcc ESS_RESET>;
-			reset-names = "ess_rst";
+			resets = <&gcc ESS_RESET>, <&gcc ESS_MAC1_CLK_DIS>, \
+				<&gcc ESS_MAC2_CLK_DIS>, <&gcc ESS_MAC3_CLK_DIS>, \
+				<&gcc ESS_MAC4_CLK_DIS>, <&gcc ESS_MAC5_CLK_DIS>;
+			reset-names = "ess_rst","ess_mac1_clk_dis", \
+				"ess_mac2_clk_dis","ess_mac3_clk_dis", \
+				"ess_mac4_clk_dis", "ess_mac5_clk_dis";
 			clocks = <&gcc GCC_ESS_CLK>;
 			clock-names = "ess_clk";
 			switch_cpu_bmp = <0x1>;  /* cpu port bitmap */
@@ -723,6 +785,6 @@
 			< 48000 >,
 			< 200000 >,
 			< 500000 >,
-			< 710000 >;
+			< 716000 >;
 		};
 	};
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ak01.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015, 2016 The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -277,8 +277,8 @@
 
 		nss0: nss@40000000 {
 			pinctrl-names = "default";
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -300,6 +300,7 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,map_t_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
 			qcom,pptp_enabled = <1>;
 			qcom,portid_enabled = <1>;
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap145_1xx.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -381,6 +381,13 @@
 			compatible = "gpio-keys";
 
 			button@1 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&qcom_pinmux 24 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+			button@2 {
 				label = "wps";
 				linux,code = <KEY_WPS_BUTTON>;
 				gpios = <&qcom_pinmux 22 GPIO_ACTIVE_LOW>;
@@ -427,8 +434,8 @@
 		nss0: nss@40000000 {
 			pinctrl-0 = <&nss_spi_pins>;
 			pinctrl-names = "default";
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -443,6 +450,9 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <275000000>;
+			qcom,max_frequency = <550000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -463,8 +473,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -477,6 +487,9 @@
 			qcom,rst_addr = <0x40800000>;
 			qcom,load_addr = <0x40800000>;
 			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <275000000>;
+			qcom,max_frequency = <550000000>;
 			qcom,ipv4_enabled = <0>;
 			qcom,ipv6_enabled = <0>;
 			qcom,l2switch_enabled = <0>;
@@ -546,6 +559,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap145.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -153,7 +153,7 @@
 	soc {
 
 		pinmux@800000 {
-			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default>;
+			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default &leds_pins>;
 			pinctrl-names = "default";
 
 			i2c4_pins: i2c4_pinmux {
@@ -272,6 +272,16 @@
 					bias-pull-down;
 				};
 			};
+
+			leds_pins: leds_pins {
+				mux {
+					pins = "gpio23", "gpio26", "gpio33";
+					function = "gpio";
+					drive-strength = <2>;
+					bias-pull-down;
+					output-low;
+				};
+			};
 		};
 
 		gsbi@16300000 {
@@ -394,6 +404,13 @@
 			compatible = "gpio-keys";
 
 			button@1 {
+				label = "reset";
+				linux,code = <KEY_RESTART>;
+				gpios = <&qcom_pinmux 24 GPIO_ACTIVE_LOW>;
+				linux,input-type = <1>;
+				debounce-interval = <60>;
+			};
+			button@2 {
 				label = "wps";
 				linux,code = <KEY_WPS_BUTTON>;
 				gpios = <&qcom_pinmux 22 GPIO_ACTIVE_LOW>;
@@ -440,8 +457,8 @@
 		nss0: nss@40000000 {
 			pinctrl-0 = <&nss_spi_pins>;
 			pinctrl-names = "default";
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -456,6 +473,9 @@
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
 			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <275000000>;
+			qcom,max_frequency = <550000000>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -476,8 +496,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -490,6 +510,9 @@
 			qcom,rst_addr = <0x40800000>;
 			qcom,load_addr = <0x40800000>;
 			qcom,turbo_frequency = <0>;
+			qcom,low_frequency = <110000000>;
+			qcom,mid_frequency = <275000000>;
+			qcom,max_frequency = <550000000>;
 			qcom,ipv4_enabled = <0>;
 			qcom,ipv6_enabled = <0>;
 			qcom,l2switch_enabled = <0>;
@@ -559,6 +582,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap148_1xx.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015, 2016 The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -47,7 +47,7 @@
 
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default &uart2_pins>;
+			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default &uart2_pins &leds_pins>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -160,6 +160,16 @@
 					bias-none;
 				};
 			};
+
+			leds_pins: leds_pins {
+				mux {
+					pins = "gpio7", "gpio8", "gpio9", "gpio26", "gpio53";
+					function = "gpio";
+					drive-strength = <2>;
+					bias-pull-down;
+					output-low;
+				};
+			};
 		};
 
 		gsbi@16300000 {
@@ -328,8 +338,8 @@
 		nss0: nss@40000000 {
 			pinctrl-0 = <&nss_spi_pins>;
 			pinctrl-names = "default";
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -351,6 +361,7 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,map_t_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
 			qcom,pptp_enabled = <1>;
 			qcom,portid_enabled = <1>;
@@ -363,8 +374,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -384,6 +395,7 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,map_t_enabled = <0>;
 			qcom,l2tpv2_enabled = <0>;
 			qcom,pptp_enabled = <0>;
 			qcom,portid_enabled = <0>;
@@ -445,6 +457,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap148.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -1,3 +1,18 @@
+/* Copyright (c) 2015, 2016 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/input/input.h>
@@ -29,7 +44,7 @@
 
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default>;
+			pinctrl-0 = <&mdio0_pins_default &rgmii2_pins_default &leds_pins>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -76,14 +91,22 @@
 
 			spi_pins: spi_pins {
 				mux {
-					pins = "gpio18", "gpio19", "gpio21";
+					pins = "gpio18", "gpio19";
 					function = "gsbi5";
 					drive-strength = <10>;
-					bias-none;
+					bias-pull-down;
+				};
+				clk {
+					pins = "gpio21";
+					function = "gsbi5";
+					drive-strength = <12>;
+					bias-pull-down;
 				};
 				cs {
 					pins = "gpio20";
-					drive-strength = <12>;
+					function = "gpio";
+					drive-strength = <10>;
+					bias-pull-up;
 				};
 			};
 			nand_pins: nand_pins {
@@ -133,6 +156,16 @@
 					bias-disable;
 				};
 			};
+
+			leds_pins: leds_pins {
+				mux {
+					pins = "gpio7", "gpio8", "gpio9", "gpio26", "gpio53";
+					function = "gpio";
+					drive-strength = <2>;
+					bias-pull-down;
+					output-low;
+				};
+			};
 		};
 
 		gsbi@16300000 {
@@ -293,8 +326,8 @@
 		nss0: nss@40000000 {
 			pinctrl-0 = <&nss_spi_pins>;
 			pinctrl-names = "default";
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -316,6 +349,7 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,map_t_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
 			qcom,portid_enabled = <1>;
 			qcom,pptp_enabled = <1>;
@@ -329,8 +363,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -350,6 +384,7 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,map_t_enabled = <0>;
 			qcom,l2tpv2_enabled = <0>;
 			qcom,pptp_enabled = <0>;
 			qcom,portid_enabled = <0>;
@@ -412,6 +447,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap160_2xx.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -324,8 +324,8 @@
 		};
 
 		nss0: nss@40000000 {
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-					GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>,  <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -360,8 +360,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -517,6 +517,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap160.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -46,7 +46,7 @@
 
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&rgmii2_pins_default &pcie_2g_pwrdwn_default &pcie_5g_pwrdwn_default>;
+			pinctrl-0 = <&rgmii2_pins_default &pcie_2g_pwrdwn_default &pcie_5g_pwrdwn_default &leds_pins>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -160,6 +160,16 @@
 					bias-pull-none;
 				};
 			};
+
+			leds_pins: leds_pins {
+				mux {
+					pins = "gpio7", "gpio53";
+					function = "gpio";
+					drive-strength = <2>;
+					bias-pull-down;
+					output-low;
+				};
+			};
 		};
 
 		gsbi@16300000 {
@@ -360,8 +370,8 @@
 		};
 
 		nss0: nss@40000000 {
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>,  <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -375,7 +385,7 @@
 			qcom,num_irq = <2>;
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
-			qcom,turbo_frequency = <0>;
+			qcom,turbo_frequency = <1>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -383,6 +393,7 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,map_t_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
 			qcom,pptp_enabled = <1>;
 			qcom,portid_enabled = <1>;
@@ -396,8 +407,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -417,6 +428,7 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,map_t_enabled = <0>;
 			qcom,l2tpv2_enabled = <0>;
 			qcom,pptp_enabled = <0>;
 			qcom,portid_enabled = <0>;
@@ -500,6 +512,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-ap161.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, 2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015, 2016 The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -46,7 +46,7 @@
 
 	soc {
 		pinmux@800000 {
-			pinctrl-0 = <&rgmii2_pins_default>;
+			pinctrl-0 = <&rgmii2_pins_default &leds_pins>;
 			pinctrl-names = "default";
 
 			rpm_i2c_pinmux: rpm_i2c_pinmux {
@@ -148,6 +148,15 @@
 				};
 			};
 
+			leds_pins: leds_pins {
+				mux {
+					pins = "gpio7", "gpio8", "gpio9", "gpio26";
+					function = "gpio";
+					drive-strength = <2>;
+					bias-pull-down;
+					output-low;
+				};
+			};
 		};
 
 		gsbi1: gsbi@12440000 {
@@ -156,7 +165,7 @@
 			i2c@12460000 {
 				pinctrl-0 = <&i2c_pins>;
 				pinctrl-names = "default";
-				status = "ok";
+				status = "disabled";
 			};
 		};
 
@@ -344,8 +353,8 @@
 		};
 
 		nss0: nss@40000000 {
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -359,7 +368,7 @@
 			qcom,num_irq = <2>;
 			qcom,rst_addr = <0x40000000>;
 			qcom,load_addr = <0x40000000>;
-			qcom,turbo_frequency = <0>;
+			qcom,turbo_frequency = <1>;
 			qcom,ipv4_enabled = <1>;
 			qcom,ipv6_enabled = <1>;
 			qcom,l2switch_enabled = <1>;
@@ -367,6 +376,7 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <1>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,map_t_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
 			qcom,pptp_enabled = <1>;
 			qcom,portid_enabled = <1>;
@@ -380,8 +390,8 @@
 		};
 
 		nss1: nss@40800000 {
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
@@ -401,6 +411,7 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,map_t_enabled = <0>;
 			qcom,l2tpv2_enabled = <0>;
 			qcom,pptp_enabled = <0>;
 			qcom,portid_enabled = <0>;
@@ -484,6 +495,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-db149.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015, 2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015, 2016 The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -388,8 +388,8 @@
 		};
 
 		nss0: nss@40000000 {
-			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36000000 0x1000 0x39000000 0x20000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>, <&nss_fabric0_clk>, <&nss_fabric1_clk>;
@@ -414,6 +414,7 @@
 			qcom,ipsec_enabled = <0>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <1>;
+			qcom,map_t_enabled = <1>;
 			qcom,l2tpv2_enabled = <1>;
 			qcom,pptp_enabled = <1>;
 			qcom,portid_enabled = <1>;
@@ -428,8 +429,8 @@
 
 		nss1: nss@40800000 {
 			compatible = "qcom,nss1";
-			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH
-				      GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
 			reg = <0x36400000 0x1000 0x39010000 0x10000>;
 			reg-names = "nphys", "vphys";
 			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>, <&gcc NSSTCM_CLK>;
@@ -454,6 +455,7 @@
 			qcom,ipsec_enabled = <1>;
 			qcom,wlanredirect_enabled = <0>;
 			qcom,tun6rd_enabled = <0>;
+			qcom,map_t_enabled = <0>;
 			qcom,l2tpv2_enabled = <0>;
 			qcom,portid_enabled = <0>;
 			qcom,tunipip6_enabled = <0>;
@@ -573,6 +575,8 @@
                         resets = <&gcc CRYPTO_ENG1_RESET>,
                                  <&gcc CRYPTO_AHB_RESET>;
                         reset-names = "rst_eng", "rst_ahb";
+			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
+			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
 			qcom,ee = <0>;
 		};
 
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -347,7 +347,7 @@
 				compatible = "qcom,rpm-clk";
 				reg = <QCOM_RPM_NSS_FABRIC_1_CLK>;
 				qcom,rpm-clk-name = "nss-fabric1";
-				qcom,rpm-clk-freq = <266000000>;
+				qcom,rpm-clk-freq = <266500000>;
 				qcom,rpm-clk-active-only;
 			};
 		};
@@ -965,13 +965,14 @@
 				clocks          = <&gcc SDC1_CLK>, <&gcc SDC1_H_CLK>;
 				clock-names     = "mclk", "apb_pclk";
 				bus-width       = <8>;
-				max-frequency   = <48000000>;
+				max-frequency   = <96000000>;
 				non-removable;
 				cap-sd-highspeed;
 				cap-mmc-highspeed;
+				mmc-ddr-1_8v;
 				vmmc-supply = <&vsdcc_fixed>;
-				#dmas = <&sdcc1bam 2>, <&sdcc1bam 1>;
-				#dma-names = "tx", "rx";
+				dmas = <&sdcc1bam 2>, <&sdcc1bam 1>;
+				dma-names = "tx", "rx";
 			};
 
 			sdcc3: sdcc@12180000 {
@@ -991,9 +992,13 @@
 				sd-uhs-sdr104;
 				sd-uhs-ddr50;
 				vqmmc-supply = <&vsdcc_fixed>;
-				#dmas = <&sdcc3bam 2>, <&sdcc3bam 1>;
-				#dma-names = "tx", "rx";
+				dmas = <&sdcc3bam 2>, <&sdcc3bam 1>;
+				dma-names = "tx", "rx";
 			};
 		};
 	};
+
+	chosen {
+		bootargs-append = " console=ttyMSM0,115200n8";
+	};
 };
diff -Naur -x .git --no-dereference linux/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi linux-3.14/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi
--- linux/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/boot/dts/qcom-ipq8064-v3.0.dtsi	2016-09-01 11:52:02.000000000 +0800
@@ -155,6 +155,10 @@
 			smb208_s2a: smb208-s2a {
 				regulator-max-microvolt = <1275000>;
 			};
+
+			smb208_s2b: smb208-s2b {
+				regulator-max-microvolt = <1275000>;
+			};
 		};
 
 		nss0: nss@40000000 {
diff -Naur -x .git --no-dereference linux/arch/arm/include/asm/ftrace.h linux-3.14/arch/arm/include/asm/ftrace.h
--- linux/arch/arm/include/asm/ftrace.h	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/include/asm/ftrace.h	2016-09-01 11:52:02.000000000 +0800
@@ -45,7 +45,7 @@
 
 #else
 
-extern inline void *return_address(unsigned int level)
+static inline void *return_address(unsigned int level)
 {
 	return NULL;
 }
diff -Naur -x .git --no-dereference linux/arch/arm/include/asm/glue-cache.h linux-3.14/arch/arm/include/asm/glue-cache.h
--- linux/arch/arm/include/asm/glue-cache.h	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/include/asm/glue-cache.h	2016-09-01 11:52:02.000000000 +0800
@@ -130,22 +130,22 @@
 #endif
 
 #ifndef __ASSEMBLER__
-extern inline void nop_flush_icache_all(void) { }
-extern inline void nop_flush_kern_cache_all(void) { }
-extern inline void nop_flush_kern_cache_louis(void) { }
-extern inline void nop_flush_user_cache_all(void) { }
-extern inline void nop_flush_user_cache_range(unsigned long a,
+static inline void nop_flush_icache_all(void) { }
+static inline void nop_flush_kern_cache_all(void) { }
+static inline void nop_flush_kern_cache_louis(void) { }
+static inline void nop_flush_user_cache_all(void) { }
+static inline void nop_flush_user_cache_range(unsigned long a,
 		unsigned long b, unsigned int c) { }
 
-extern inline void nop_coherent_kern_range(unsigned long a, unsigned long b) { }
-extern inline int nop_coherent_user_range(unsigned long a,
+static inline void nop_coherent_kern_range(unsigned long a, unsigned long b) { }
+static inline int nop_coherent_user_range(unsigned long a,
 		unsigned long b) { return 0; }
-extern inline void nop_flush_kern_dcache_area(void *a, size_t s) { }
+static inline void nop_flush_kern_dcache_area(void *a, size_t s) { }
 
-extern inline void nop_dma_flush_range(const void *a, const void *b) { }
+static inline void nop_dma_flush_range(const void *a, const void *b) { }
 
-extern inline void nop_dma_map_area(const void *s, size_t l, int f) { }
-extern inline void nop_dma_unmap_area(const void *s, size_t l, int f) { }
+static inline void nop_dma_map_area(const void *s, size_t l, int f) { }
+static inline void nop_dma_unmap_area(const void *s, size_t l, int f) { }
 #endif
 
 #ifndef MULTI_CACHE
diff -Naur -x .git --no-dereference linux/arch/arm/kernel/return_address.c linux-3.14/arch/arm/kernel/return_address.c
--- linux/arch/arm/kernel/return_address.c	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/kernel/return_address.c	2016-09-01 11:52:02.000000000 +0800
@@ -63,11 +63,6 @@
 #warning "TODO: return_address should use unwind tables"
 #endif
 
-void *return_address(unsigned int level)
-{
-	return NULL;
-}
-
 #endif /* if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND) / else */
 
 EXPORT_SYMBOL_GPL(return_address);
diff -Naur -x .git --no-dereference linux/arch/arm/mach-qcom/pcie.c linux-3.14/arch/arm/mach-qcom/pcie.c
--- linux/arch/arm/mach-qcom/pcie.c	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/arch/arm/mach-qcom/pcie.c	2016-09-01 11:52:02.000000000 +0800
@@ -453,7 +453,7 @@
 
 static int msm_pcie_gpio_init(struct msm_pcie_dev_t *dev)
 {
-	int rc, i;
+	int rc = 0, i;
 	struct msm_pcie_gpio_info_t *info;
 
 	PCIE_DBG(dev, "RC%d\n", dev->rc_idx);
@@ -1861,7 +1861,9 @@
 static int __init pcie_init(void)
 {
 	int ret = 0, i;
+#ifdef CONFIG_IPC_LOGGING
 	char rc_name[MAX_RC_NAME_LEN];
+#endif
 
 	pr_debug("pcie:%s.\n", __func__);
 
@@ -1870,6 +1872,7 @@
 	mutex_init(&pcie_drv.drv_lock);
 
 	for (i = 0; i < MAX_RC_NUM; i++) {
+#ifdef CONFIG_IPC_LOGGING
 		snprintf(rc_name, MAX_RC_NAME_LEN, "pcie%d-short", i);
 		msm_pcie_dev[i].ipc_log =
 			ipc_log_context_create(PCIE_LOG_PAGES, rc_name, 0);
@@ -1890,6 +1893,7 @@
 			PCIE_DBG(&msm_pcie_dev[i],
 				"PCIe IPC logging %s is enable for RC%d\n",
 				rc_name, i);
+#endif
 
 		spin_lock_init(&msm_pcie_dev[i].cfg_lock);
 		msm_pcie_dev[i].cfg_access = true;
diff -Naur -x .git --no-dereference linux/block/partitions/efi.c linux-3.14/block/partitions/efi.c
--- linux/block/partitions/efi.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/block/partitions/efi.c	2016-09-01 11:52:03.000000000 +0800
@@ -110,6 +110,7 @@
  * the partition tables happens after init too.
  */
 static int force_gpt;
+static char saved_rootfs_name[64] __initdata;
 static int __init
 force_gpt_fn(char *str)
 {
@@ -118,6 +119,12 @@
 }
 __setup("gpt", force_gpt_fn);
 
+static int __init rootfs_name_setup(char *line)
+{
+	strlcpy(saved_rootfs_name, line, sizeof(saved_rootfs_name));
+	return 1;
+}
+__setup("rootfsname=", rootfs_name_setup);
 
 /**
  * efi_crc32() - EFI version of crc32 function
@@ -688,6 +695,9 @@
 	u32 i;
 	unsigned ssz = bdev_logical_block_size(state->bdev) / 512;
 
+	if (!saved_rootfs_name[0])
+		strlcpy(saved_rootfs_name, "rootfs", sizeof("rootfs"));
+
 	if (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {
 		kfree(gpt);
 		kfree(ptes);
@@ -728,7 +738,8 @@
 			label_count++;
 		}
 
-		if (ROOT_DEV == 0 && !strcmp(info->volname, "rootfs") &&
+		if (ROOT_DEV == 0 &&
+		    !strcmp(info->volname, saved_rootfs_name) &&
 		    config_enabled(CONFIG_MTD_ROOTFS_ROOT_DEV)) {
 			ROOT_DEV = MKDEV(MAJOR(state->bdev->bd_dev), i + 1);
 			pr_notice("GPT: device [%d:%d] (%s) set to be root filesystem\n",
diff -Naur -x .git --no-dereference linux/crypto/ablkcipher.c linux-3.14/crypto/ablkcipher.c
--- linux/crypto/ablkcipher.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/crypto/ablkcipher.c	2016-09-01 11:52:03.000000000 +0800
@@ -589,6 +589,11 @@
 	if (IS_ERR(inst))
 		goto put_tmpl;
 
+	/*
+	 * copy flags from registered algorithm
+	 */
+	inst->alg.cra_flags |= (alg->cra_flags & CRYPTO_ALG_NOSUPP_SG);
+
 	if ((err = crypto_register_instance(tmpl, inst))) {
 		tmpl->free(inst);
 		goto put_tmpl;
diff -Naur -x .git --no-dereference linux/crypto/authenc.c linux-3.14/crypto/authenc.c
--- linux/crypto/authenc.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/crypto/authenc.c	2016-09-01 11:52:03.000000000 +0800
@@ -656,6 +656,7 @@
 
 	inst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;
 	inst->alg.cra_flags |= enc->cra_flags & CRYPTO_ALG_ASYNC;
+	inst->alg.cra_flags |= (enc->cra_flags & CRYPTO_ALG_NOSUPP_SG);
 	inst->alg.cra_priority = enc->cra_priority *
 				 10 + auth_base->cra_priority;
 	inst->alg.cra_blocksize = enc->cra_blocksize;
diff -Naur -x .git --no-dereference linux/Documentation/devicetree/bindings/pwm/pwm-ipq4019.txt linux-3.14/Documentation/devicetree/bindings/pwm/pwm-ipq4019.txt
--- linux/Documentation/devicetree/bindings/pwm/pwm-ipq4019.txt	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/Documentation/devicetree/bindings/pwm/pwm-ipq4019.txt	2016-09-01 11:52:02.000000000 +0800
@@ -0,0 +1,13 @@
+Qualcomm Atheros, Inc Pulse Width Modulation (PWM)
+
+Required properties:
+- compatible : Should contain "qca,ipq4019-pwm".
+- clock : Should contain the input clock.
+- clock-names : Should contain "core".
+- pwm-base-index : The base index to be used for the pwm device.
+	Should contain any unsigned integer.
+- used-pwm-indices : Vector specifying the devices that are being used.
+	Should contain a boolean entry for each pwm device in the chip
+	specifying whether the device is being used or not.
+		Example: used-pwm-indices = <1>, <1>, <0>, <1>;
+	This chip has 4 pwm devices of which the third one is not used.
diff -Naur -x .git --no-dereference linux/Documentation/devicetree/bindings/soc/qcom/qca,scm_restart_reason.txt linux-3.14/Documentation/devicetree/bindings/soc/qcom/qca,scm_restart_reason.txt
--- linux/Documentation/devicetree/bindings/soc/qcom/qca,scm_restart_reason.txt	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/Documentation/devicetree/bindings/soc/qcom/qca,scm_restart_reason.txt	2016-09-01 11:52:02.000000000 +0800
@@ -4,8 +4,18 @@
 During panic/assert the notifiers registered in this driver will be kicked in
 and the magic cookie is set, the crashdumps are collected in apps bootloader.
 
+Required properties:
+ - compatible: must contain "qca,scm_restart_reason" for IPQ40xx
+
+Optional properties:
+ - dload_status: indicate whether memory is reserved for crashdump.
+ - dload_sec_status: indicate whether crashdump is enabled for
+   secure boot.
+
 Example for ipq40xx:
 
 	qca,scm_restart_reason {
 		compatible = "qca,scm_restart_reason";
+		dload_status = <0>;
+		dload_sec_status = <0>;
 	};
diff -Naur -x .git --no-dereference linux/Documentation/networking/bonding.txt linux-3.14/Documentation/networking/bonding.txt
--- linux/Documentation/networking/bonding.txt	2016-04-18 10:49:04.000000000 +0800
+++ linux-3.14/Documentation/networking/bonding.txt	2016-09-01 11:52:02.000000000 +0800
@@ -620,6 +620,92 @@
 		swapped with the new curr_active_slave that was
 		chosen.
 
+	l2da or 7
+
+		L2 Destination Address (L2DA) based mode allows bonding to
+		send packets using different slaves according to L2 Destination
+		Address of the packets.
+
+		In L2DA mode, the bonding maintains a default slave and
+		DA/slave map.
+
+		Upon a packet transmission, the bonding examines the DA of the
+		packet and searches for a slave assigned to the DA within the
+		DA/slave map. If such mapping exists, the bonding uses this
+		slave for sending of the packet.Otherwise, it uses default
+		slave.
+
+		For multicast packet, if BOND_L2DA_OPT_DUP_MC_TX is set,
+		L2DA mode duplicates it to all slaves upon transmission.
+
+		For RX packets, if BOND_L2DA_OPT_DEDUP_RX is set, L2DA examines
+		L2 source address and search for slave interface assigned to
+		the transmitting STA. L2DA then implements following logic based
+		on the interface that the packet was received on:
+		1. RX EAPOLs are unconditionally allowed
+		2. if DA/slave map has an entry for the transmitting STA, allow
+		the RX packet if received from the assigned slave interface.
+		Drop the RX packet if received from other interface.
+		3. else (no slave interface assigned to the transmitting STA),
+		if default slave configured (l2da_default_slave), allow the Rx
+		packet if it was received from it.
+		4. else (slave interface not assigned and default slave not
+		configured), allow the RX packet unconditionally.
+
+		In case BOND_L2DA_OPT_DEDUP_RX is not set, L2DA allows all Rx packets.
+
+		L2DA mode implements packet forwarding for received packets
+		according to the following logic:
+		1. for Rx multicast packets: clone and send to all slaves
+		(except the one it came from) and also deliver to local network
+		stack.
+		2. for Rx unicast packets: search packet's destination address
+		in L2DA map. If found, send the packet to the corresponding
+		slave; otherwise - deliver to local network stack.
+		L2DA packet forwarding functionality is disabled by default and
+		can be enabled with BOND_L2DA_OPT_FORWARD_RX bond L2DA option.
+
+		New sysfs entries added - l2da_default_slave, l2da_table and
+		l2da_opts. Here is their usage:
+
+		l2da_default_slave entry - set an interface as default:
+		echo interface_name > l2da_default_slave
+
+		l2da_default_slave entry - show the default interface:
+		cat l2da_default_slave
+
+		l2da_table entry - add a new entry into the table:
+		echo "+xx:xx:xx:xx:xx:xx@interface_name" > l2da_table
+
+		l2da_table entry - remove an entry from the table:
+		echo "-xx:xx:xx:xx:xx:xx" > l2da_table
+
+		l2da_table entry - remove all entries from the table:
+		echo "-*" > l2da_table
+
+		l2da_table entry - show the table:
+		cat l2da_table
+
+		l2da_opts entry - set options:
+		echo options > l2da_opts
+
+		l2da_opts entry - show enabled options:
+		cat l2da_opts
+
+		New bonding specific GENL family ("bond") added. It can be used
+		to add custom GENL commands (rather than extend the standard
+		rtnl_link_ops's changelink and fill_info callbacks).
+
+		Following list of GENL commands introduced for L2DA:
+		BOND_GENL_CMD_L2DA_SET_DEFAULT
+		BOND_GENL_CMD_L2DA_GET_DEFAULT
+		BOND_GENL_CMD_L2DA_ADD_MAP_ENTRY
+		BOND_GENL_CMD_L2DA_DEL_MAP_ENTRY
+		BOND_GENL_CMD_L2DA_GET_MAP_ENTRY
+		BOND_GENL_CMD_L2DA_RESET_MAP
+		BOND_GENL_CMD_L2DA_SET_OPTS
+		BOND_GENL_CMD_L2DA_GET_OPTS
+
 num_grat_arp
 num_unsol_na
 
diff -Naur -x .git --no-dereference linux/drivers/base/regmap/Kconfig linux-3.14/drivers/base/regmap/Kconfig
--- linux/drivers/base/regmap/Kconfig	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/base/regmap/Kconfig	2016-09-01 11:52:03.000000000 +0800
@@ -10,7 +10,7 @@
 
 config REGMAP_I2C
 	select REGMAP
-	tristate "Regmap I2C
+	tristate "Regmap I2C"
 
 config REGMAP_SPI
 	select REGMAP
diff -Naur -x .git --no-dereference linux/drivers/clk/qcom/clk-rcg2.c linux-3.14/drivers/clk/qcom/clk-rcg2.c
--- linux/drivers/clk/qcom/clk-rcg2.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/clk/qcom/clk-rcg2.c	2016-09-01 11:52:03.000000000 +0800
@@ -717,7 +717,7 @@
 static int clk_cdiv_rcg2_configure(struct clk_cdiv_rcg2 *rcg,
 						const struct freq_tbl *f)
 {
-	u32 cfg, mask;
+	u32 cfg = -1, mask;
 	u32 i;
 	int ret;
 
@@ -751,6 +751,10 @@
 			if (f->pre_div % i == 0)
 				cfg = i;
 		}
+		if (cfg == -1) {
+			pr_err("%s: invalid divider\n", __func__);
+			return -EINVAL;
+		}
 
 		if (f->pre_div/cfg > 16)
 			return -EINVAL;
diff -Naur -x .git --no-dereference linux/drivers/clk/qcom/gcc-ipq40xx.c linux-3.14/drivers/clk/qcom/gcc-ipq40xx.c
--- linux/drivers/clk/qcom/gcc-ipq40xx.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/clk/qcom/gcc-ipq40xx.c	2016-09-01 11:52:03.000000000 +0800
@@ -815,18 +815,18 @@
 static const struct freq_tbl ftbl_gcc_apps_clk[] = {
 	{48000000, P_XO,          1, 0, 0},
 	{200000000, FE_PLL_200,   1, 0, 0},
-	{380000000, DDRC_PLL_666, 0xD, 0},
-	{409000000, DDRC_PLL_666, 0xC, 0, 0},
-	{444000000, DDRC_PLL_666, 0xB, 0, 0},
-	{484000000, DDRC_PLL_666, 0xA, 0, 0},
+	{384000000, DDRC_PLL_666, 0xD, 0},
+	{413000000, DDRC_PLL_666, 0xC, 0, 0},
+	{448000000, DDRC_PLL_666, 0xB, 0, 0},
+	{488000000, DDRC_PLL_666, 0xA, 0, 0},
 	{500000000, FE_PLL_500,   1, 0, 0},
-	{507000000, DDRC_PLL_666, 0x9, 0, 0},
-	{532000000, DDRC_PLL_666, 0x8, 0, 0},
-	{560000000, DDRC_PLL_666, 0x7, 0, 0},
-	{592000000, DDRC_PLL_666, 0x6, 0, 0},
-	{626000000, DDRC_PLL_666, 0x5, 0, 0},
-	{666000000, DDRC_PLL_666, 0x4, 0, 0},
-	{710000000, DDRC_PLL_666, 0x3, 0, 0},
+	{512000000, DDRC_PLL_666, 0x9, 0, 0},
+	{537000000, DDRC_PLL_666, 0x8, 0, 0},
+	{565000000, DDRC_PLL_666, 0x7, 0, 0},
+	{597000000, DDRC_PLL_666, 0x6, 0, 0},
+	{632000000, DDRC_PLL_666, 0x5, 0, 0},
+	{672000000, DDRC_PLL_666, 0x4, 0, 0},
+	{716000000, DDRC_PLL_666, 0x3, 0, 0},
 	{761000000, DDRC_PLL_666, 0x2, 0, 0},
 	{819000000, DDRC_PLL_666, 0x1, 0, 0},
 	{888000000, DDRC_PLL_666, 0x0, 0, 0},
@@ -1702,7 +1702,7 @@
 	clk_register_fixed_rate(dev, "ddrpllsdcc1", NULL, CLK_IS_ROOT,
 				      409800000);
 	clk_register_fixed_rate(dev, "ddrpllapss", NULL, CLK_IS_ROOT,
-				      666000000);
+				      672000000);
 	clk_register_fixed_rate(dev, "pcnoc_clk_src", NULL, CLK_IS_ROOT,
 				      100000000);
 
diff -Naur -x .git --no-dereference linux/drivers/clk/qcom/gcc-ipq806x.c linux-3.14/drivers/clk/qcom/gcc-ipq806x.c
--- linux/drivers/clk/qcom/gcc-ipq806x.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/clk/qcom/gcc-ipq806x.c	2016-09-01 11:52:03.000000000 +0800
@@ -245,6 +245,22 @@
 	},
 };
 
+static struct clk_pll pll11 = {
+	.l_reg = 0x3184,
+	.m_reg = 0x3188,
+	.n_reg = 0x318c,
+	.config_reg = 0x3194,
+	.mode_reg = 0x3180,
+	.status_reg = 0x3198,
+	.status_bit = 16,
+	.clkr.hw.init = &(struct clk_init_data){
+		.name = "pll11",
+		.parent_names = (const char *[]){ "pxo" },
+		.num_parents = 1,
+		.ops = &clk_pll_ops,
+	},
+};
+
 #define P_PXO	0
 #define P_PLL8	1
 #define P_PLL3	1
@@ -252,6 +268,7 @@
 #define P_CXO	2
 #define P_PLL14	3
 #define P_PLL18	4
+#define P_PLL11	5
 
 static const u8 gcc_pxo_pll8_map[] = {
 	[P_PXO]		= 0,
@@ -318,6 +335,42 @@
 	"pll18",
 };
 
+static const u8 gcc_pxo_pll8_pll0_pll14_pll18_pll11_map[] = {
+	[P_PXO]		= 0,
+	[P_PLL8]	= 4,
+	[P_PLL0]	= 2,
+	[P_PLL14]	= 5,
+	[P_PLL18]	= 1,
+	[P_PLL11]	= 3,
+};
+
+static const char *gcc_pxo_pll8_pll0_pll14_pll18_pll11[] = {
+	"pxo",
+	"pll8_vote",
+	"pll0_vote",
+	"pll14",
+	"pll18",
+	"pll11"
+};
+
+static const u8 gcc_pxo_pll3_pll0_pll14_pll18_pll11_map[] = {
+	[P_PXO]		= 0,
+	[P_PLL3]	= 6,
+	[P_PLL0]	= 2,
+	[P_PLL14]	= 5,
+	[P_PLL18]	= 1,
+	[P_PLL11]	= 3,
+};
+
+static const char *gcc_pxo_pll3_pll0_pll14_pll18_pll11[] = {
+	"pxo",
+	"pll3",
+	"pll0_vote",
+	"pll14",
+	"pll18",
+	"pll11"
+};
+
 static struct freq_tbl clk_tbl_gsbi_uart[] = {
 	{  1843200, P_PLL8, 2,  6, 625 },
 	{  3686400, P_PLL8, 2, 12, 625 },
@@ -2762,6 +2815,186 @@
 	},
 };
 
+static const struct freq_tbl clk_tbl_ce5_core[] = {
+	{ 150000000, P_PLL3, 8, 1, 1 },
+	{ 213200000, P_PLL11, 5, 1, 1 },
+	{ }
+};
+
+static struct clk_dyn_rcg ce5_core_src = {
+	.ns_reg[0] = 0x36C4,
+	.ns_reg[1] = 0x36C8,
+	.bank_reg = 0x36C0,
+	.s[0] = {
+		.src_sel_shift = 0,
+		.parent_map = gcc_pxo_pll3_pll0_pll14_pll18_pll11_map,
+	},
+	.s[1] = {
+		.src_sel_shift = 0,
+		.parent_map = gcc_pxo_pll3_pll0_pll14_pll18_pll11_map,
+	},
+	.p[0] = {
+		.pre_div_shift = 3,
+		.pre_div_width = 4,
+	},
+	.p[1] = {
+		.pre_div_shift = 3,
+		.pre_div_width = 4,
+	},
+	.mux_sel_bit = 0,
+	.freq_tbl = clk_tbl_ce5_core,
+	.clkr = {
+		.enable_reg = 0x36C0,
+		.enable_mask = BIT(1),
+		.hw.init = &(struct clk_init_data){
+			.name = "ce5_core_src",
+			.parent_names = gcc_pxo_pll3_pll0_pll14_pll18_pll11,
+			.num_parents = 6,
+			.ops = &clk_dyn_rcg_ops,
+		},
+	},
+};
+
+static struct clk_branch ce5_core_clk = {
+	.halt_reg = 0x2FDC,
+	.halt_bit = 5,
+	.hwcg_reg = 0x36CC,
+	.hwcg_bit = 6,
+	.clkr = {
+		.enable_reg = 0x36CC,
+		.enable_mask = BIT(4),
+		.hw.init = &(struct clk_init_data){
+			.name = "ce5_core_clk",
+			.parent_names = (const char *[]){
+				"ce5_core_src",
+			},
+			.num_parents = 1,
+			.ops = &clk_branch_ops,
+			.flags = CLK_SET_RATE_PARENT,
+		},
+	},
+};
+
+static const struct freq_tbl clk_tbl_ce5_a_clk[] = {
+	{ 160000000, P_PLL0, 5, 1, 1 },
+	{ 213200000, P_PLL11, 5, 1, 1 },
+	{ }
+};
+
+static struct clk_dyn_rcg ce5_a_clk_src = {
+	.ns_reg[0] = 0x3d84,
+	.ns_reg[1] = 0x3d88,
+	.bank_reg = 0x3d80,
+	.s[0] = {
+		.src_sel_shift = 0,
+		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
+	},
+	.s[1] = {
+		.src_sel_shift = 0,
+		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
+	},
+	.p[0] = {
+		.pre_div_shift = 3,
+		.pre_div_width = 4,
+	},
+	.p[1] = {
+		.pre_div_shift = 3,
+		.pre_div_width = 4,
+	},
+	.mux_sel_bit = 0,
+	.freq_tbl = clk_tbl_ce5_a_clk,
+	.clkr = {
+		.enable_reg = 0x3d80,
+		.enable_mask = BIT(1),
+		.hw.init = &(struct clk_init_data){
+			.name = "ce5_a_clk_src",
+			.parent_names = gcc_pxo_pll8_pll0_pll14_pll18_pll11,
+			.num_parents = 6,
+			.ops = &clk_dyn_rcg_ops,
+		},
+	},
+};
+
+static struct clk_branch ce5_a_clk = {
+	.halt_reg = 0x3c20,
+	.halt_bit = 12,
+	.hwcg_reg = 0x3d8c,
+	.hwcg_bit = 6,
+	.clkr = {
+		.enable_reg = 0x3d8c,
+		.enable_mask = BIT(4),
+		.hw.init = &(struct clk_init_data){
+			.name = "ce5_a_clk",
+			.parent_names = (const char *[]){
+				"ce5_a_clk_src",
+			},
+			.num_parents = 1,
+			.ops = &clk_branch_ops,
+			.flags = CLK_SET_RATE_PARENT,
+		},
+	},
+};
+
+static const struct freq_tbl clk_tbl_ce5_h_clk[] = {
+	{ 160000000, P_PLL0, 5, 1, 1 },
+	{ 213200000, P_PLL11, 5, 1, 1 },
+	{ }
+};
+
+static struct clk_dyn_rcg ce5_h_clk_src = {
+	.ns_reg[0] = 0x3c64,
+	.ns_reg[1] = 0x3c68,
+	.bank_reg = 0x3c60,
+	.s[0] = {
+		.src_sel_shift = 0,
+		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
+	},
+	.s[1] = {
+		.src_sel_shift = 0,
+		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
+	},
+	.p[0] = {
+		.pre_div_shift = 3,
+		.pre_div_width = 4,
+	},
+	.p[1] = {
+		.pre_div_shift = 3,
+		.pre_div_width = 4,
+	},
+	.mux_sel_bit = 0,
+	.freq_tbl = clk_tbl_ce5_h_clk,
+	.clkr = {
+		.enable_reg = 0x3c60,
+		.enable_mask = BIT(1),
+		.hw.init = &(struct clk_init_data){
+			.name = "ce5_h_clk_src",
+			.parent_names = gcc_pxo_pll8_pll0_pll14_pll18_pll11,
+			.num_parents = 6,
+			.ops = &clk_dyn_rcg_ops,
+		},
+	},
+};
+
+static struct clk_branch ce5_h_clk = {
+	.halt_reg = 0x3c20,
+	.halt_bit = 11,
+	.hwcg_reg = 0x3c6c,
+	.hwcg_bit = 6,
+	.clkr = {
+		.enable_reg = 0x3c6c,
+		.enable_mask = BIT(4),
+		.hw.init = &(struct clk_init_data){
+			.name = "ce5_h_clk",
+			.parent_names = (const char *[]){
+				"ce5_h_clk_src",
+			},
+			.num_parents = 1,
+			.ops = &clk_branch_ops,
+			.flags = CLK_SET_RATE_PARENT,
+		},
+	},
+};
+
 static int nss_core_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 				 unsigned long parent_rate)
 {
@@ -2904,6 +3137,7 @@
 	[PLL3] = &pll3.clkr,
 	[PLL8] = &pll8.clkr,
 	[PLL8_VOTE] = &pll8_vote,
+	[PLL11] = &pll11.clkr,
 	[PLL14] = &pll14.clkr,
 	[PLL14_VOTE] = &pll14_vote,
 	[PLL18] = &pll18.clkr,
@@ -3017,6 +3251,12 @@
 	[PLL9] = &hfpll0.clkr,
 	[PLL10] = &hfpll1.clkr,
 	[PLL12] = &hfpll_l2.clkr,
+	[CE5_A_CLK_SRC] = &ce5_a_clk_src.clkr,
+	[CE5_A_CLK] = &ce5_a_clk.clkr,
+	[CE5_H_CLK_SRC] = &ce5_h_clk_src.clkr,
+	[CE5_H_CLK] = &ce5_h_clk.clkr,
+	[CE5_CORE_CLK_SRC] = &ce5_core_src.clkr,
+	[CE5_CORE_CLK] = &ce5_core_clk.clkr,
 };
 
 static const struct qcom_reset_map gcc_ipq806x_resets[] = {
diff -Naur -x .git --no-dereference linux/drivers/crypto/msm/qce50.c linux-3.14/drivers/crypto/msm/qce50.c
--- linux/drivers/crypto/msm/qce50.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/crypto/msm/qce50.c	2016-09-01 11:52:03.000000000 +0800
@@ -5266,7 +5266,7 @@
 			pr_err("Unable to get CE core src clk\n");
 			return rc;
 		} else {
-			pr_warn("Unable to get CE core src clk, set to NULL\n");
+			pr_info("Unable to get CE core src clk, set to NULL\n");
 			pce_dev->ce_core_src_clk = NULL;
 		}
 	}
diff -Naur -x .git --no-dereference linux/drivers/crypto/msm/qcedev.c linux-3.14/drivers/crypto/msm/qcedev.c
--- linux/drivers/crypto/msm/qcedev.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/crypto/msm/qcedev.c	2016-09-01 11:52:03.000000000 +0800
@@ -863,6 +863,7 @@
 	handle->sha_ctxt.init_done = false;
 	memset(&handle->sha_ctxt.trailing_buf[0], 0, 64);
 
+	qcedev_areq->sha_req.sreq.src = NULL;
 	kzfree(k_buf_src);
 	return err;
 }
@@ -1048,6 +1049,7 @@
 
 	handle->sha_ctxt.last_blk = 0;
 	handle->sha_ctxt.first_blk = 0;
+	qcedev_areq->sha_req.sreq.src = NULL;
 
 	kzfree(k_src);
 	return err;
@@ -1204,8 +1206,10 @@
 			if (err == 0 && __copy_to_user(
 				(void __user *)creq->vbuf.dst[dst_i].vaddr,
 					(k_align_dst + byteoffset),
-					creq->vbuf.dst[dst_i].len))
-					return -EFAULT;
+					creq->vbuf.dst[dst_i].len)) {
+					err =  -EFAULT;
+					goto out;
+			}
 
 			k_align_dst += creq->vbuf.dst[dst_i].len +
 						byteoffset;
@@ -1215,8 +1219,10 @@
 				if (err == 0 && __copy_to_user(
 				(void __user *)creq->vbuf.dst[dst_i].vaddr,
 				(k_align_dst + byteoffset),
-				creq->data_len))
-					return -EFAULT;
+				creq->data_len)) {
+					err =  -EFAULT;
+					goto out;
+				}
 
 			k_align_dst += creq->data_len;
 			creq->vbuf.dst[dst_i].len -= creq->data_len;
@@ -1226,6 +1232,10 @@
 	}
 	*di = dst_i;
 
+out:
+	areq->cipher_req.creq.src = NULL;
+	areq->cipher_req.creq.dst = NULL;
+
 	return err;
 };
 
@@ -1928,7 +1938,7 @@
 			(struct msm_bus_scale_pdata *)
 					msm_bus_cl_get_pdata(pdev);
 		if (!podev->platform_support.bus_scale_table)
-			pr_err("bus_scale_table is NULL\n");
+			pr_info("bus_scale_table is NULL\n");
 	} else {
 		platform_support =
 			(struct msm_ce_hw_support *)pdev->dev.platform_data;
diff -Naur -x .git --no-dereference linux/drivers/crypto/msm/qcrypto.c linux-3.14/drivers/crypto/msm/qcrypto.c
--- linux/drivers/crypto/msm/qcrypto.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/crypto/msm/qcrypto.c	2016-09-01 11:52:03.000000000 +0800
@@ -3287,7 +3287,7 @@
 	sg_last = req->src;
 
 	while (len < nbytes) {
-		if ((len + sg_last->length) > nbytes)
+		if (!sg_last || (len + sg_last->length) > nbytes)
 			break;
 		len += sg_last->length;
 		sg_last = scatterwalk_sg_next(sg_last);
@@ -4529,7 +4529,7 @@
 			(struct msm_bus_scale_pdata *)
 					msm_bus_cl_get_pdata(pdev);
 		if (!cp->platform_support.bus_scale_table)
-			pr_warn("bus_scale_table is NULL\n");
+			pr_info("bus_scale_table is NULL\n");
 
 		pengine->ce_device = cp->ce_support.ce_device;
 
diff -Naur -x .git --no-dereference linux/drivers/i2c/busses/i2c-msm-v2.c linux-3.14/drivers/i2c/busses/i2c-msm-v2.c
--- linux/drivers/i2c/busses/i2c-msm-v2.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/i2c/busses/i2c-msm-v2.c	2016-09-01 11:52:03.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -11,7 +11,7 @@
  *
  */
 /*
- * I2C controller driver for Qualcomm MSM platforms
+ * I2C controller driver for Qualcomm Technologies Inc platforms
  */
 
 #define pr_fmt(fmt) "#%d " fmt "\n", __LINE__
@@ -32,11 +32,10 @@
 #include <linux/dma-mapping.h>
 #include <linux/i2c.h>
 #include <linux/of.h>
-#include <linux/debugfs.h>
 #include <linux/msm-sps.h>
 #include <linux/msm-bus.h>
 #include <linux/msm-bus-board.h>
-#include "i2c-msm-v2.h"
+#include <linux/i2c/i2c-msm-v2.h>
 
 #ifdef DEBUG
 static const enum msm_i2_debug_level DEFAULT_DBG_LVL = MSM_DBG;
@@ -44,15 +43,21 @@
 static const enum msm_i2_debug_level DEFAULT_DBG_LVL = MSM_ERR;
 #endif
 
+/* Forward declarations */
+static bool i2c_msm_xfer_next_buf(struct i2c_msm_ctrl *ctrl);
+static int i2c_msm_xfer_wait_for_completion(struct i2c_msm_ctrl *ctrl,
+						struct completion *complete);
+static int  i2c_msm_pm_resume(struct device *dev);
+static void i2c_msm_pm_suspend(struct device *dev);
+static void i2c_msm_qup_init(struct i2c_msm_ctrl *ctrl);
+static void i2c_msm_clk_path_init(struct i2c_msm_ctrl *ctrl);
+
 /* string table for enum i2c_msm_xfer_mode_id */
-static const char * const i2c_msm_mode_str_tbl[] = {
+const char * const i2c_msm_mode_str_tbl[] = {
 	"FIFO", "BLOCK", "BAM", "None",
 };
 
-/* string table for qup_io_modes register */
-static const char * const i2c_msm_qup_mode_str_tbl[] = {
-	"FIFO", "Block", "Reserved", "BAM",
-};
+static const u32 i2c_msm_fifo_block_sz_tbl[] = {16, 16 , 32, 0};
 
 /* from enum i2c_msm_xfer_mode_id to qup_io_modes register values */
 static const u32 i2c_msm_mode_to_reg_tbl[] = {
@@ -61,87 +66,55 @@
 	0x3  /* map I2C_MSM_XFER_MODE_BAM -> binary 11 */
 };
 
-/* Forward declarations */
-static bool i2c_msm_xfer_next_buf(struct i2c_msm_ctrl *ctrl);
-static int i2c_msm_xfer_wait_for_completion(struct i2c_msm_ctrl *ctrl,
-						struct completion *complete);
-static int  i2c_msm_bam_xfer(struct i2c_msm_ctrl *ctrl);
-static int  i2c_msm_fifo_xfer(struct i2c_msm_ctrl *ctrl);
-static int  i2c_msm_blk_xfer(struct i2c_msm_ctrl *ctrl);
-static int  i2c_msm_pm_resume(struct device *dev);
-static void i2c_msm_pm_suspend(struct device *dev);
-static int  i2c_msm_fifo_create_struct(struct i2c_msm_ctrl *ctrl);
-static int  i2c_msm_bam_create_struct(struct i2c_msm_ctrl *ctrl);
-static int  i2c_msm_blk_create_struct(struct i2c_msm_ctrl *ctrl);
-static void i2c_msm_clk_path_init(struct i2c_msm_ctrl *ctrl);
-
-/* i2c_msm_bam_get_struct: return the bam structure
- * if not created, call i2c_msm_bam_create_struct to create it
- */
-static struct i2c_msm_xfer_mode_bam *i2c_msm_bam_get_struct(
-						struct i2c_msm_ctrl *ctrl)
-{
-	void *ret_ptr = ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BAM];
-	if (!ret_ptr && !i2c_msm_bam_create_struct(ctrl))
-		ret_ptr = ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BAM];
-	return (struct i2c_msm_xfer_mode_bam *) ret_ptr;
-}
+const char *i2c_msm_err_str_table[] = {
+	[I2C_MSM_NO_ERR]     = "NONE",
+	[I2C_MSM_ERR_NACK]   = "NACK: slave not responding, ensure its powered",
+	[I2C_MSM_ERR_ARB_LOST] = "ARB_LOST",
+	[I2C_MSM_ERR_BUS_ERR] = "BUS ERROR:noisy bus/unexpected start/stop tag",
+	[I2C_MSM_ERR_TIMEOUT]  = "TIMEOUT_ERROR",
+	[I2C_MSM_ERR_CORE_CLK] = "CLOCK OFF: Check Core Clock",
+	[I2C_MSM_ERR_OVR_UNDR_RUN] = "OVER_UNDER_RUN_ERROR",
+};
 
-static void i2c_msm_bam_set_struct(struct i2c_msm_ctrl *ctrl,
-					  struct i2c_msm_xfer_mode_bam *bam)
+static void i2c_msm_dbg_dump_diag(struct i2c_msm_ctrl *ctrl,
+				bool use_param_vals, u32 status, u32 qup_op)
 {
-	ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BAM] =
-					(struct i2c_msm_xfer_mode *) bam;
-}
+	struct i2c_msm_xfer *xfer = &ctrl->xfer;
+	const char *str = i2c_msm_err_str_table[xfer->err];
+	char buf[I2C_MSM_REG_2_STR_BUF_SZ];
 
-/* i2c_msm_fifo_get_struct: return the fifo structure
- * if not created, call i2c_msm_fifo_create_struct to create it
- */
-static struct i2c_msm_xfer_mode_fifo *i2c_msm_fifo_get_struct(
-						struct i2c_msm_ctrl *ctrl)
-{
-	void *ret_ptr = ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_FIFO];
-	if (!ret_ptr && !i2c_msm_fifo_create_struct(ctrl))
-		ret_ptr = ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_FIFO];
-	return (struct i2c_msm_xfer_mode_fifo *) ret_ptr;
-}
+	if (!use_param_vals) {
+		void __iomem        *base = ctrl->rsrcs.base;
+		status = readl_relaxed(base + QUP_I2C_STATUS);
+		qup_op = readl_relaxed(base + QUP_OPERATIONAL);
+	}
 
-static void i2c_msm_fifo_set_struct(struct i2c_msm_ctrl *ctrl,
-					  struct i2c_msm_xfer_mode_fifo *fifo)
-{
-	ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_FIFO] =
-					(struct i2c_msm_xfer_mode *) fifo;
-}
+	if (xfer->err == I2C_MSM_ERR_TIMEOUT) {
+		/*
+		 * if we are not the bus master or SDA/SCL is low then it may be
+		 * that slave is pulling the lines low. Otherwise it is likely a
+		 * GPIO issue
+		 */
+		if (!(status & QUP_BUS_MASTER))
+			snprintf(buf, I2C_MSM_REG_2_STR_BUF_SZ,
+				"%s(val:%dmsec) misconfigured GPIO or slave pulling bus line(s) low\n",
+				str, jiffies_to_msecs(xfer->timeout));
+		 else
+			snprintf(buf, I2C_MSM_REG_2_STR_BUF_SZ,
+			"%s(val:%dmsec)", str, jiffies_to_msecs(xfer->timeout));
 
-/* i2c_msm_blk_get_struct: return the blk structure
- * if not created, call i2c_msm_blk_create_struct to create it
- */
-static struct i2c_msm_xfer_mode_blk *i2c_msm_blk_get_struct(
-						struct i2c_msm_ctrl *ctrl)
-{
-	void *ret_ptr = ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BLOCK];
-	if (!ret_ptr && !i2c_msm_blk_create_struct(ctrl))
-		ret_ptr = ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BLOCK];
-	return (struct i2c_msm_xfer_mode_blk *) ret_ptr;
-}
+		str = buf;
+	}
 
-static void i2c_msm_blk_set_struct(struct i2c_msm_ctrl *ctrl,
-					  struct i2c_msm_xfer_mode_blk *blk)
-{
-	ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BLOCK] =
-					(struct i2c_msm_xfer_mode *) blk;
+	/* dump xfer details */
+	dev_err(ctrl->dev,
+		"%s: msgs(n:%d cur:%d %s) bc(rx:%zu tx:%zu) mode:%s slv_addr:0x%0x MSTR_STS:0x%08x OPER:0x%08x\n",
+		str, xfer->msg_cnt, xfer->cur_buf.msg_idx,
+		xfer->cur_buf.is_rx ? "rx" : "tx", xfer->rx_cnt, xfer->tx_cnt,
+		i2c_msm_mode_str_tbl[xfer->mode_id], xfer->msgs->addr,
+		status, qup_op);
 }
 
-static const char * const i2c_msm_mini_core_str_tbl[] = {
-	"null", "SPI", "I2C", "reserved",
-};
-
-static const u32 i2c_msm_fifo_block_sz_tbl[] = {16, 16 , 32, 0};
-static const char * const i2c_msm_fifo_sz_str_tbl[]
-		= {"x2 blk sz", "x4 blk sz" , "x8 blk sz", "x16 blk sz"};
-static const char * const i2c_msm_fifo_block_sz_str_tbl[]
-						= {"16", "16" , "32", "0"};
-
 static u32 i2c_msm_reg_io_modes_out_blk_sz(u32 qup_io_modes)
 {
 	return i2c_msm_fifo_block_sz_tbl[qup_io_modes & 0x3];
@@ -157,7 +130,7 @@
 static void i2c_msm_qup_fifo_calc_size(struct i2c_msm_ctrl *ctrl)
 {
 	u32 reg_data, output_fifo_size, input_fifo_size;
-	struct i2c_msm_xfer_mode_fifo *fifo = i2c_msm_fifo_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
 
 	/* Gurad to read fifo size only once. It hard wired and never changes */
 	if (fifo->input_fifo_sz && fifo->output_fifo_sz)
@@ -177,341 +150,6 @@
 
 }
 
-static const char * const i2c_msm_reg_qup_state_to_str[] = {
-	"Reset", "Run", "Clear", "Pause"
-};
-
-/*
- * i2c_msm_qup_reg_fld: a register field descriptor
- * @name   field name
- * @to_str_tbl  when not null, used to interpret the bits value. The bits value
- *         is the table entry number.
- */
-struct i2c_msm_qup_reg_fld {
-	const char * const name;
-	int                bit_idx;
-	int                n_bits;
-	const char * const *to_str_tbl;
-};
-
-/*
- * i2c_msm_dbg_qup_reg_flds_to_str: format register's fields using a field map
- *
- * @fld an array of fields mapping bits of val to fields/flags values
- * @val the register's value
- * @buf buffer to format the strings into
- * @len buf's len
- */
-static const char *i2c_msm_dbg_qup_reg_flds_to_str(
-	u32 val, char *buf, int len, const struct i2c_msm_qup_reg_fld *fld)
-{
-	char *ptr = buf;
-	int str_len;
-	int str_len_sum = 0;
-	int rem_len     = len;
-	u32 field_val;
-	for ( ; fld->name && (rem_len > 0) ; ++fld) {
-
-		if (fld->n_bits == 1) {
-			field_val = BIT_IS_SET(val, fld->bit_idx);
-			/*
-			 * Only dump interesting flags (skip flags who's value
-			 * is zero).
-			 */
-			if (!field_val)
-				continue;
-
-			str_len = snprintf(ptr, rem_len, "%s ", fld->name);
-		} else {
-			field_val = BITS_AT(val, fld->bit_idx, fld->n_bits);
-
-			/*
-			 * Only dump interesting fields (skip fields who's value
-			 * is zero).
-			 */
-			if (!field_val)
-				continue;
-
-			if (fld->to_str_tbl)
-				str_len = snprintf(ptr, rem_len, "%s:%s ",
-				   fld->name, fld->to_str_tbl[field_val]);
-			else
-				str_len = snprintf(ptr, rem_len, "%s:0x%x ",
-				   fld->name, field_val);
-		}
-
-		if (str_len > rem_len) {
-			pr_err("%s insufficient buffer space\n", __func__);
-			/* snprintf does not guarantee NULL terminator */
-			buf[len - 1] = 0;
-			return buf;
-		}
-
-		rem_len     -= str_len;
-		ptr         += str_len;
-		str_len_sum += str_len;
-	}
-
-	/* snprintf does not guarantee NULL terminator */
-	buf[len - 1] = 0;
-	return buf;
-}
-
-/* QUP_CONFIG register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_config_fields_map[] = {
-	{ "N",               0,   5},
-	{ "MINI_CORE",       8,   2, i2c_msm_mini_core_str_tbl},
-	{ "NO_OUTPUT",       6,   1},
-	{ "NO_INPUT",        7,   1},
-	{ "EN_EXT_OUT",     16,   1},
-	{ NULL,              0,   1},
-};
-
-/* QUP_OPERATIONAL register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_op_fields_map[] = {
-	{ "OUT_FF_N_EMPTY",  4,   1},
-	{ "IN_FF_N_EMPTY",   5,   1},
-	{ "OUT_FF_FUL",      6,   1},
-	{ "IN_FF_FUL",       7,   1},
-	{ "OUT_SRV_FLG",     8,   1},
-	{ "IN_SRV_FLG",      9,   1},
-	{ "MX_OUT_DN",      10,   1},
-	{ "MX_IN_DN",       11,   1},
-	{ "OUT_BLK_WR",     12,   1},
-	{ "IN_BLK_RD",      13,   1},
-	{ "DONE_TGL",       14,   1},
-	{ "NWD",            15,   1},
-	{ NULL,              0,   1},
-};
-
-/* QUP_I2C_STATUS (a.k.a I2C_MASTER_STATUS) register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_i2c_stat_fields_map[] = {
-	{ "BUS_ERR",        2,   1},
-	{ "NACK",           3,   1},
-	{ "ARB_LOST",       4,   1},
-	{ "INVLD_WR",       5,   1},
-	{ "FAIL",           6,   2},
-	{ "BUS_ACTV",       8,   1},
-	{ "BUS_MSTR",       9,   1},
-	{ "DAT_STATE",     10,   3},
-	{ "CLK_STATE",     13,   3},
-	{ "O_FSM_STAT",    16,   3},
-	{ "I_FSM_STAT",    19,   3},
-	{ "INVLD_TAG",     23,   1},
-	{ "INVLD_RD_ADDR", 24,   1},
-	{ "INVLD_RD_SEQ",  25,   1},
-	{ "SDA",           26,   1},
-	{ "SCL",           27,   1},
-	{ NULL,             0,   1},
-};
-
-/* QUP_ERROR_FLAGS register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_err_flags_fields_map[] = {
-	{ "IN_OVR_RUN",        2,   1},
-	{ "OUT_UNDR_RUN",      3,   1},
-	{ "IN_UNDR_RUN",       4,   1},
-	{ "OUT_OVR_RUN",       5,   1},
-	{ NULL,                0,   1},
-};
-
-/* QUP_OPERATIONAL_MASK register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_op_mask_fields_map[] = {
-	{ "OUT_SRVC_MASK",     8,   1},
-	{ "IN_SRVC_MASK",      9,   1},
-	{ NULL,                0,   1},
-};
-
-/* QUP_I2C_MASTER_CLK_CTL register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_master_clk_fields_map[] = {
-	{ "FS_DIV",            0,   8},
-	{ "HS_DIV",            8,   3},
-	{ "HI_TM_DIV",        16,   8},
-	{ "SCL_NS_RJCT",      24,   2},
-	{ "SDA_NS_RJCT",      26,   2},
-	{ "SCL_EXT_FRC_L",    28,   1},
-	{ NULL,                0,   1},
-};
-
-/* QUP_STATE register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_state_fields_map[] = {
-	{ "STATE",             0,   2, i2c_msm_reg_qup_state_to_str},
-	{ "VALID",             2,   1},
-	{ "MAST_GEN",          4,   1},
-	{ "WAIT_EOT",          5,   1},
-	{ "FLUSH",             6,   1},
-	{ NULL,                0,   1},
-};
-
-/* QUP_IO_MODES register fields */
-static struct i2c_msm_qup_reg_fld i2c_msm_qup_io_modes_map[] = {
-	{ "IN_BLK_SZ",         5,   2, i2c_msm_fifo_block_sz_str_tbl},
-	{ "IN_FF_SZ",          7,   3, i2c_msm_fifo_sz_str_tbl},
-	{ "OUT_BLK_SZ",        0,   2, i2c_msm_fifo_block_sz_str_tbl},
-	{ "OUT_FF_SZ",         2,   3, i2c_msm_fifo_sz_str_tbl},
-	{ "UNPACK",           14,   1},
-	{ "PACK",             15,   1},
-	{ "INP_MOD",          12,   2, i2c_msm_qup_mode_str_tbl},
-	{ "OUT_MOD",          10,   2, i2c_msm_qup_mode_str_tbl},
-	{ NULL,                0,   1},
-};
-
-/*
- * i2c_msm_qup_reg_dump: desc fmt of reg to dump via i2c_msm_dbg_qup_reg_dump()
- *
- * @offset    the register's offset in the QUP
- * @name      name to dump before value
- * @field_map when set i2c_msm_dbg_qup_reg_flds_to_str() is used. Otherwise
- *            if val_to_str_func() is set, then it is used. When both are NULL
- *            none is used. Only the register's value is dumped.
- */
-struct i2c_msm_qup_reg_dump {
-	u32                          offset;
-	const char                  *name;
-	struct i2c_msm_qup_reg_fld  *field_map;
-};
-
-static const struct i2c_msm_qup_reg_dump i2c_msm_qup_reg_dump_map[] = {
-{QUP_CONFIG,             "QUP_CONFIG",   i2c_msm_qup_config_fields_map    },
-{QUP_STATE,              "QUP_STATE",    i2c_msm_qup_state_fields_map     },
-{QUP_IO_MODES,           "QUP_IO_MDS",   i2c_msm_qup_io_modes_map         },
-{QUP_ERROR_FLAGS,        "QUP_ERR_FLGS", i2c_msm_qup_err_flags_fields_map },
-{QUP_OPERATIONAL,        "QUP_OP",       i2c_msm_qup_op_fields_map        },
-{QUP_OPERATIONAL_MASK,   "QUP_OP_MASK",  i2c_msm_qup_op_mask_fields_map   },
-{QUP_I2C_STATUS,         "QUP_I2C_STAT", i2c_msm_qup_i2c_stat_fields_map  },
-{QUP_I2C_MASTER_CLK_CTL, "QUP_MSTR_CLK", i2c_msm_qup_master_clk_fields_map},
-{QUP_IN_DEBUG,           "QUP_IN_DBG"  },
-{QUP_OUT_DEBUG,          "QUP_OUT_DBG" },
-{QUP_IN_FIFO_CNT,        "QUP_IN_CNT"  },
-{QUP_OUT_FIFO_CNT,       "QUP_OUT_CNT" },
-{QUP_MX_READ_COUNT,      "MX_RD_CNT"   },
-{QUP_MX_WRITE_COUNT,     "MX_WR_CNT"   },
-{QUP_MX_INPUT_COUNT,     "MX_IN_CNT"   },
-{QUP_MX_OUTPUT_COUNT,    "MX_OUT_CNT"  },
-{0,                       NULL         },
-};
-
-const char *i2c_msm_err_str_table[] = {
-	[I2C_MSM_ERR_NACK] =
-		 "NACK: slave not responding, ensure its powered",
-	[I2C_MSM_ERR_ARB_LOST] = "arb_lost",
-	[I2C_MSM_ERR_BUS_ERR] =
-		"BUS ERROR : noisy bus or unexpected start/stop tag",
-	[I2C_MSM_ERR_TIMEOUT] = "",
-	[I2C_MSM_ERR_CORE_CLK] = "CLOCK OFF : Check Core Clock",
-	[I2C_MSM_ERR_OVR_UNDR_RUN] = "OVER_UNDER_RUN_ERROR",
-	[I2C_MSM_ERR_INVALID_WRITE] = "invalid data write",
-	[I2C_MSM_ERR_INVALID_TAG] = "invalid tag",
-	[I2C_MSM_ERR_INVALID_READ_ADDR] = "Invalid slave addr",
-	[I2C_MSM_ERR_INVALID_READ_SEQ] = "start tag error for read",
-	[I2C_MSM_ERR_FAILED] = "I2C transfer failed",
-};
-/*
- * see: struct i2c_msm_qup_reg_dump for more
- */
-static int i2c_msm_dbg_qup_reg_dump(struct i2c_msm_ctrl *ctrl)
-{
-	u32 val;
-	char buf[I2C_MSM_REG_2_STR_BUF_SZ];
-	void __iomem *base = ctrl->rsrcs.base;
-	const struct i2c_msm_qup_reg_dump *itr = i2c_msm_qup_reg_dump_map;
-
-	for (; itr->name ; ++itr) {
-		val = readl_relaxed(base + itr->offset);
-		buf[0] = 0;
-		if (itr->field_map)
-			i2c_msm_dbg_qup_reg_flds_to_str(val, buf, sizeof(buf),
-								itr->field_map);
-		dev_err(ctrl->dev, "%-12s:0x%08x %s\n", itr->name, val, buf);
-	};
-	return 0;
-}
-
-static void i2c_msm_dbg_dump_diag(struct i2c_msm_ctrl *ctrl,
-				bool use_param_vals, u32 status, u32 qup_op)
-{
-	struct i2c_msm_xfer *xfer = &ctrl->xfer;
-	char str[I2C_MSM_MAX_ERR_BUF_SZ] = {'\0'};
-	char *p_str = str;
-	const char **diag_msg = i2c_msm_err_str_table;
-	int err = xfer->err;
-
-	if (!use_param_vals) {
-		void __iomem        *base = ctrl->rsrcs.base;
-		status = readl_relaxed(base + QUP_I2C_STATUS);
-		qup_op = readl_relaxed(base + QUP_OPERATIONAL);
-	}
-	if ((err & BIT(I2C_MSM_ERR_TIMEOUT))) {
-		/*
-		 * if we are not the bus master or SDA/SCL is
-		 * low then it may be that slave is pulling the
-		 * lines low. Otherwise it is likely a GPIO
-		 * issue
-		 */
-		if (!(status & QUP_BUS_MASTER))
-			p_str += snprintf(p_str,
-				I2C_MSM_MAX_ERR_BUF_SZ,
-	"TIMEOUT(val:%dmsec) check GPIO config if SDA/SCL line(s) low, ",
-			jiffies_to_msecs(xfer->timeout));
-		 else
-			p_str += snprintf(p_str,
-				I2C_MSM_MAX_ERR_BUF_SZ,
-			"TIMEOUT(val:%dmsec), ",
-			jiffies_to_msecs(xfer->timeout));
-	}
-
-	for (; err; err >>= 1, ++diag_msg) {
-
-		if (err & 1)
-			p_str += snprintf(p_str,
-			(I2C_MSM_MAX_ERR_BUF_SZ - (p_str - str)),
-			 "%s, ", *diag_msg);
-	}
-
-	/* dump xfer details */
-	dev_err(ctrl->dev,
-		"%s: msgs(n:%d cur:%d %s) bc(rx:%zu tx:%zu) mode:%s "
-		"slv_addr:0x%0x MSTR_STS:0x%08x OPER:0x%08x\n",
-		str, xfer->msg_cnt, xfer->cur_buf.msg_idx,
-		xfer->cur_buf.is_rx ? "rx" : "tx", xfer->rx_cnt, xfer->tx_cnt,
-		i2c_msm_mode_str_tbl[xfer->mode_id], xfer->msgs->addr,
-		status, qup_op);
-}
-
-static const char * const i2c_msm_dbg_tag_val_to_str_tbl[] = {
-	"NOP_WAIT",		/* 0x80 */
-	"START",		/* 0x81 */
-	"DATAWRITE",		/* 0x82 */
-	"DATAWRT_and_STOP",	/* 0x83 */
-	NULL,			/* 0x84 */
-	"DATAREAD",		/* 0x85 */
-	"DATARD_and_NACK",	/* 0x86 */
-	"DATARD_and_STOP",	/* 0x87 */
-	"STOP_TAG",		/* 0x88 */
-	NULL,			/* 0x89 */
-	NULL,			/* 0x8A */
-	NULL,			/* 0x8B */
-	NULL,			/* 0x8C */
-	NULL,			/* 0x8D */
-	NULL,			/* 0x8E */
-	NULL,			/* 0x8F */
-	"NOP_MARK",		/* 0x90 */
-	"NOP_ID",		/* 0x91 */
-	"TIME_STAMP",		/* 0x92 */
-	"INPUT_EOT",		/* 0x93 */
-	"INPUT_EOT_FLUSH",	/* 0x94 */
-	"NOP_LOCAL",		/* 0x95 */
-	"FLUSH STOP",		/* 0x96 */
-};
-
-static const char *i2c_msm_dbg_tag_val_to_str(u8 tag_val)
-{
-	if ((tag_val < 0x80) || (tag_val > 0x96) || (tag_val == 0x84) ||
-	   ((tag_val > 0x88) && (0x90 > tag_val)))
-		return "Invalid_tag";
-
-	return i2c_msm_dbg_tag_val_to_str_tbl[tag_val - 0x80];
-}
-
 /*
  * i2c_msm_tag_byte: accessor for tag as four bytes array
  */
@@ -520,63 +158,6 @@
 	return ((u8 *)tag) + byte_n;
 }
 
-static const char *i2c_msm_dbg_tag_to_str(const struct i2c_msm_tag *tag,
-						char *buf, size_t buf_len)
-{
-	/* cast const away. t is read-only here */
-	struct i2c_msm_tag *t = (struct i2c_msm_tag *) tag;
-	switch (tag->len) {
-	case 6:
-		snprintf(buf, buf_len, "val:0x%012llx %s:0x%x %s:0x%x %s:%d",
-			tag->val,
-			i2c_msm_dbg_tag_val_to_str(*i2c_msm_tag_byte(t, 0)),
-			*i2c_msm_tag_byte(t, 1),
-			i2c_msm_dbg_tag_val_to_str(*i2c_msm_tag_byte(t, 2)),
-			*i2c_msm_tag_byte(t, 3),
-			i2c_msm_dbg_tag_val_to_str(*i2c_msm_tag_byte(t, 4)),
-			*i2c_msm_tag_byte(t, 5));
-		break;
-	case 4:
-		snprintf(buf, buf_len, "val:0x%08llx %s:0x%x %s:%d",
-			(tag->val & 0xffffffff),
-			i2c_msm_dbg_tag_val_to_str(*i2c_msm_tag_byte(t, 0)),
-			*i2c_msm_tag_byte(t, 1),
-			i2c_msm_dbg_tag_val_to_str(*i2c_msm_tag_byte(t, 2)),
-			*i2c_msm_tag_byte(t, 3));
-		break;
-	default: /* 2 bytes tag */
-		snprintf(buf, buf_len, "val:0x%04llx %s:%d",
-			(tag->val & 0xffff),
-			i2c_msm_dbg_tag_val_to_str(*i2c_msm_tag_byte(t, 0)),
-			*i2c_msm_tag_byte(t, 1));
-	}
-
-	return buf;
-}
-
-static const char *
-i2c_msm_dbg_bam_tag_to_str(const struct i2c_msm_bam_tag *bam_tag, char *buf,
-								size_t buf_len)
-{
-	const char *ret;
-	u32        *val;
-	struct i2c_msm_tag tag;
-
-	val = phys_to_virt(bam_tag->buf);
-	if (!val) {
-		pr_err("Failed phys_to_virt(0x%llx)", (u64) bam_tag->buf);
-		return "Error";
-	}
-
-	tag = (struct i2c_msm_tag) {
-		.val = *val,
-		.len = bam_tag->len,
-	};
-
-	ret = i2c_msm_dbg_tag_to_str(&tag, buf, buf_len);
-	return ret;
-}
-
 /*
  * i2c_msm_buf_to_ptr: translates a xfer buf to a pointer into the i2c_msg data
  */
@@ -589,320 +170,45 @@
 }
 
 /*
- * i2c_msm_prof_evnt_add: pushes event into end of event array
- *
- * @dump_now log a copy immediately to kernel log
- *
- * Implementation of i2c_msm_prof_evnt_add().When array overflows, the last
- * entry is overwritten as many times as it overflows.
- */
-static void i2c_msm_prof_evnt_add(struct i2c_msm_ctrl *ctrl,
-				enum msm_i2_debug_level dbg_level,
-				i2c_msm_prof_dump_func_func_t dump_func,
-				u64 data0, u32 data1, u32 data2)
-{
-	struct i2c_msm_xfer       *xfer  = &ctrl->xfer;
-	struct i2c_msm_prof_event *event;
-	int idx;
-
-	if (ctrl->dbgfs.dbg_lvl < dbg_level)
-		return;
-
-	atomic_add_unless(&xfer->event_cnt, 1, I2C_MSM_PROF_MAX_EVNTS - 1);
-	idx = atomic_read(&xfer->event_cnt) - 1;
-	if (idx > (I2C_MSM_PROF_MAX_EVNTS - 1))
-		dev_err(ctrl->dev, "error event index:%d max:%d\n",
-						idx, I2C_MSM_PROF_MAX_EVNTS);
-	event = &xfer->event[idx];
-
-	getnstimeofday(&event->time);
-	event->dump_func = dump_func;
-	event->data0 = data0;
-	event->data1 = data1;
-	event->data2 = data2;
-}
-
-void i2c_msm_prof_dump_xfer_beg(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev,
-		"-->.%03zums XFER_BEG msg_cnt:%llx addr:0x%x\n",
-		usec, event->data0, event->data1);
-}
-
-/* string table for enum i2c_msm_err_bit_field */
-static const char * const i2c_msm_err_str_tbl[] = {
-	"NONE", "NACK", "ARB_LOST" , "ARB_LOST + NACK", "BUS_ERR",
-	"BUS_ERR + NACK", "BUS_ERR + ARB_LOST", "BUS_ERR + ARB_LOST + NACK",
-	"TIMEOUT", "TIMEOUT + NACK", "TIMEOUT + ARB_LOST",
-	"TIMEOUT + ARB_LOST + NACK", "TIMEOUT + BUS_ERR",
-	"TIMEOUT + BUS_ERR + NACK" , "TIMEOUT + BUS_ERR + ARB_LOST",
-	"TIMEOUT + BUS_ERR + ARB_LOST + NACK",
-};
-
-void i2c_msm_prof_dump_xfer_end(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	int ret = event->data0;
-	int err = event->data1;
-	int bc  = ctrl->xfer.rx_cnt + ctrl->xfer.rx_ovrhd_cnt +
-		  ctrl->xfer.tx_cnt + ctrl->xfer.tx_ovrhd_cnt;
-	int bc_sec = (bc * 1000000) / (msec * 1000 + usec);
-	const char *status = (!err && (ret == ctrl->xfer.msg_cnt)) ?
-								"OK" : "FAIL";
-
-	dev_info(ctrl->dev,
-		"%3zu.%03zums XFER_END "
-		"ret:%d err:[%s] msgs_sent:%d BC:%d B/sec:%d i2c-stts:%s\n" ,
-		msec, usec, ret, i2c_msm_err_str_tbl[err], event->data2,
-		bc, bc_sec, status);
-}
-
-void i2c_msm_prof_dump_irq_begn(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev, "%3zu.%03zums  IRQ_BEG irq:%lld\n",
-						msec, usec, event->data0);
-}
-
-void i2c_msm_prof_dump_irq_end(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	char str[I2C_MSM_REG_2_STR_BUF_SZ];
-	u32 mstr_stts = event->data0;
-	u32 qup_oper  = event->data1;
-	u32 err_flgs  = event->data2;
-	dev_info(ctrl->dev,
-		"%3zu.%03zums  IRQ_END "
-		"MSTR_STTS:0x%x QUP_OPER:0x%x ERR_FLGS:0x%x\n",
-		msec, usec, mstr_stts, qup_oper, err_flgs);
-
-	/*
-	 * Dump fields and flags only of registers with interesting info
-	 * (i.e. errors).
-	 */
-	 /* register I2C_MASTER_STATUS */
-	if (mstr_stts & QUP_MSTR_STTS_ERR_MASK) {
-		i2c_msm_dbg_qup_reg_flds_to_str(
-				mstr_stts, str, sizeof(str),
-				i2c_msm_qup_i2c_stat_fields_map);
-
-		dev_info(ctrl->dev, "            |->MSTR_STTS:0x%llx %s\n",
-						event->data0, str);
-	}
-	/* register QUP_OPERATIONAL */
-	if (qup_oper &
-	   (QUP_OUTPUT_SERVICE_FLAG | QUP_INPUT_SERVICE_FLAG)) {
-
-		i2c_msm_dbg_qup_reg_flds_to_str(
-				qup_oper, str, sizeof(str),
-				i2c_msm_qup_op_fields_map);
-
-		dev_info(ctrl->dev, "            |-> QUP_OPER:0x%x %s\n",
-						event->data1, str);
-	}
-	/* register ERR_FLAGS */
-	if (err_flgs) {
-		i2c_msm_dbg_qup_reg_flds_to_str(
-				err_flgs, str, sizeof(str),
-				i2c_msm_qup_err_flags_fields_map);
-
-		dev_info(ctrl->dev, "            |-> ERR_FLGS:0x%x %s\n",
-						event->data2, str);
-	}
-}
-
-void i2c_msm_prof_dump_next_buf(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	struct i2c_msg *msg = ctrl->xfer.msgs + event->data0;
-	dev_info(ctrl->dev,
-		"%3zu.%03zums XFER_BUF msg[%lld] pos:%d adr:0x%x "
-		"len:%d is_rx:0x%x last:0x%x\n",
-		msec, usec, event->data0, event->data1, msg->addr, msg->len,
-		(msg->flags & I2C_M_RD),
-		event->data0 == (ctrl->xfer.msg_cnt - 1));
-
-}
-
-void i2c_msm_prof_dump_scan_sum(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	u32 bc_rx       = (event->data0 & 0xff);
-	u32 bc_rx_ovrhd = (event->data0 >> 16);
-	u32 bc_tx       = (event->data1 & 0xff);
-	u32 bc_tx_ovrhd = (event->data1 >> 16);
-	u32 timeout     = (event->data2 & 0xfff);
-	u32 mode        = (event->data2 >> 24);
-	u32 bc      = bc_rx + bc_rx_ovrhd + bc_tx + bc_tx_ovrhd;
-	dev_info(ctrl->dev,
-		"%3zu.%03zums SCN_SMRY BC:%u rx:%u+ovrhd:%u tx:%u+ovrhd:%u "
-		"timeout:%umsec mode:%s\n",
-		msec, usec, bc, bc_rx, bc_rx_ovrhd, bc_tx, bc_tx_ovrhd,
-		jiffies_to_msecs(timeout), i2c_msm_mode_str_tbl[mode]);
-}
-
-void i2c_msm_prof_dump_cmplt_ok(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev,
-		"%3zu.%03zums  DONE_OK timeout-used:%umsec time_left:%umsec\n",
-		msec, usec, jiffies_to_msecs(event->data0),
-		jiffies_to_msecs(event->data1));
-}
-
-void i2c_msm_prof_dump_cmplt_fl(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev,
-		"%3zu.%03zums  TIMEOUT-error timeout-used:%umsec. "
-		"Check GPIOs configuration\n",
-		msec, usec, jiffies_to_msecs(event->data0));
-}
-
-void i2c_msm_prof_dump_vlid_end(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	int  ret        = (int)(event->data0 & 0xff);
-	enum i2c_msm_qup_state state = ((event->data0 << 16) & 0xf);
-	u32  status     = event->data2;
-
-	dev_info(ctrl->dev,
-	"%3zu.%03zums SET_STTE set:%s ret:%d rd_cnt:%u reg_val:0x%x vld:%d\n",
-	msec, usec, i2c_msm_reg_qup_state_to_str[state], ret,
-	event->data1, status, BIT_IS_SET(status, 2));
-}
-
-void i2c_msm_prof_dump_actv_end(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev,
-	    "%3zu.%03zums ACTV_END ret:%lld jiffies_left:%u/%u read_cnt:%u\n",
-	    msec, usec, event->data0, event->data1,
-	    I2C_MSM_MAX_POLL_MSEC, event->data2);
-}
-
-void i2c_msm_prof_dump_bam_flsh(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev, "%3zu.%03zums  BAM_FLSH\n", msec, usec);
-}
-
-void i2c_msm_prof_dump_pip_dscn(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	struct i2c_msm_bam_pipe *pipe =
-			(struct i2c_msm_bam_pipe *) ((ulong) event->data0);
-	int ret = event->data1;
-	dev_info(ctrl->dev,
-		"%3zu.%03zums PIP_DCNCT sps_disconnect(hndl:0x%p %s):%d\n",
-		msec, usec, pipe->handle, pipe->name, ret);
-}
-
-void i2c_msm_prof_dump_pip_cnct(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	struct i2c_msm_bam_pipe *pipe =
-			(struct i2c_msm_bam_pipe *) ((ulong) event->data0);
-	int ret = event->data1;
-	dev_info(ctrl->dev,
-		"%3zu.%03zums PIP_CNCT sps_connect(hndl:0x%p %s):%d\n",
-		msec, usec, pipe->handle, pipe->name, ret);
-}
-
-void i2c_msm_prof_reset(struct i2c_msm_ctrl *ctrl,
-		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
-{
-	dev_info(ctrl->dev, "%3zu.%03zums  QUP_RSET\n", msec, usec);
-}
-
-/*
- * i2c_msm_prof_evnt_dump: post processing, msg formatting and dumping of events
- */
-static void i2c_msm_prof_evnt_dump(struct i2c_msm_ctrl *ctrl)
-{
-	size_t                     cnt   = atomic_read(&ctrl->xfer.event_cnt);
-	struct i2c_msm_prof_event *event = ctrl->xfer.event;
-	struct timespec            time0 = event->time;
-	struct timespec            time_diff;
-	size_t                     diff_usec;
-	size_t                     diff_msec;
-
-	for (; cnt ; --cnt, ++event) {
-		time_diff = timespec_sub(event->time, time0);
-		diff_usec = time_diff.tv_sec  * USEC_PER_SEC +
-			    time_diff.tv_nsec / NSEC_PER_USEC;
-		diff_msec  = diff_usec / USEC_PER_MSEC;
-		diff_usec -= diff_msec * USEC_PER_MSEC;
-
-		(event->dump_func)(ctrl, event, diff_msec, diff_usec);
-	}
-}
-
-/*
- * tag_lookup_table[is_high_speed][start_req][is_last][is_rx]
- * @start_req   start or repeated-start
+ * tag_lookup_table[is_new_addr][is_last][is_rx]
+ * @is_new_addr Is start tag required? (which requires two more bytes.)
  * @is_last     Use the XXXXX_N_STOP tag varient
  * @is_rx       READ/WRITE
- * is_high_speed Requires a post-fix of a start-tag and the reserved
- *               high-speed address.
- *
- * workaround! Due to an HW issues, a stop is issued after every read.
- *    QUP_TAG2_DATA_READ is replaced by QUP_TAG2_DATA_READ_N_STOP.
  */
-static const struct i2c_msm_tag tag_lookup_table[2][2][2][2] = {
-	{{{{QUP_TAG2_DATA_WRITE                                   , 2},
-	   {QUP_TAG2_DATA_READ                                    , 2} },
+static const struct i2c_msm_tag tag_lookup_table[2][2][2] = {
+	{{{QUP_TAG2_DATA_WRITE                                   , 2},
+	   {QUP_TAG2_DATA_READ                                   , 2} },
 	/* last buffer */
 	  {{QUP_TAG2_DATA_WRITE_N_STOP                            , 2},
-	   {QUP_TAG2_DATA_READ_N_STOP                             , 2} } },
+	   {QUP_TAG2_DATA_READ_N_STOP                             , 2} } } ,
 	/* new addr */
 	 {{{QUP_TAG2_START | (QUP_TAG2_DATA_WRITE           << 16), 4},
 	   {QUP_TAG2_START | (QUP_TAG2_DATA_READ            << 16), 4} },
 	/* last buffer + new addr */
 	  {{QUP_TAG2_START | (QUP_TAG2_DATA_WRITE_N_STOP    << 16), 4},
-	   {QUP_TAG2_START | (QUP_TAG2_DATA_READ_N_STOP     << 16), 4} } } },
-	/* high speed */
-	{{{{QUP_TAG2_DATA_WRITE                                   , 2},
-	   {QUP_TAG2_DATA_READ_N_STOP                             , 2} },
-	/* high speed + last buffer */
-	  {{QUP_TAG2_DATA_WRITE_N_STOP                            , 2},
-	   {QUP_TAG2_DATA_READ_N_STOP                             , 2} } },
-	/* high speed + new addr */
-	 {{{QUP_TAG2_START_HS | (QUP_TAG2_DATA_WRITE        << 32), 6},
-	   {QUP_TAG2_START_HS | (QUP_TAG2_DATA_READ_N_STOP  << 32), 6} },
-	/* high speed + last buffer + new addr */
-	  {{QUP_TAG2_START_HS | (QUP_TAG2_DATA_WRITE_N_STOP << 32), 6},
-	   {QUP_TAG2_START_HS | (QUP_TAG2_DATA_READ_N_STOP  << 32), 6} } } },
+	   {QUP_TAG2_START | (QUP_TAG2_DATA_READ_N_STOP     << 16), 4} } },
 };
 
 /*
  * i2c_msm_tag_create: format a qup tag ver2
  */
-static struct i2c_msm_tag i2c_msm_tag_create(bool is_high_speed,
-	bool start_req, bool is_last_buf, bool is_rx, u8 buf_len,
-	u8 slave_addr)
+static struct i2c_msm_tag i2c_msm_tag_create(bool is_new_addr, bool is_last_buf,
+					bool is_rx, u8 buf_len, u8 slave_addr)
 {
 	struct i2c_msm_tag tag;
 	/* Normalize booleans to 1 or 0 */
-	start_req = start_req ? 1 : 0;
+	is_new_addr = is_new_addr ? 1 : 0;
 	is_last_buf = is_last_buf ? 1 : 0;
 	is_rx = is_rx ? 1 : 0;
 
-	tag = tag_lookup_table[is_high_speed][start_req][is_last_buf][is_rx];
+	tag = tag_lookup_table[is_new_addr][is_last_buf][is_rx];
 	/* fill in the non-const value: the address and the length */
-	switch (tag.len) {
-	case 6:
-		*i2c_msm_tag_byte(&tag, 3) = slave_addr;
-		*i2c_msm_tag_byte(&tag, 5) = buf_len;
-		break;
-	case 4:
+	if (tag.len == I2C_MSM_TAG2_MAX_LEN) {
 		*i2c_msm_tag_byte(&tag, 1) = slave_addr;
 		*i2c_msm_tag_byte(&tag, 3) = buf_len;
-		break;
-	default:
+	} else {
 		*i2c_msm_tag_byte(&tag, 1) = buf_len;
-	};
+	}
 
 	return tag;
 }
@@ -913,9 +219,6 @@
 {
 	u32 status;
 	void __iomem  *base     = ctrl->rsrcs.base;
-	unsigned long  start   = jiffies;
-	unsigned long  timeout = start +
-				 msecs_to_jiffies(I2C_MSM_MAX_POLL_MSEC);
 	int ret      = 0;
 	int read_cnt = 0;
 
@@ -937,7 +240,14 @@
 				goto poll_valid_end;
 		}
 
-	} while (time_before_eq(jiffies, timeout));
+		/*
+		 * Sleeping for 1-1.5 ms for every 100 iterations and break if
+		 * iterations crosses the 1500 marks allows roughly 10-15 msec
+		 * of time to get the core to valid state.
+		 */
+		if (!(read_cnt % 100))
+			usleep_range(1000, 1500);
+	} while (read_cnt <= 1500);
 
 	ret = -ETIMEDOUT;
 	dev_err(ctrl->dev,
@@ -945,7 +255,7 @@
 
 poll_valid_end:
 	if (!only_valid)
-		i2c_msm_prof_evnt_add(ctrl, MSM_DBG, i2c_msm_prof_dump_vlid_end,
+		i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_VALID_END,
 				/* aggregate ret and state */
 				(((-ret) & 0xff) | ((state & 0xf) << 16)),
 				read_cnt, status);
@@ -980,7 +290,7 @@
 	ret = i2c_msm_qup_state_wait_valid(ctrl, QUP_STATE_RESET, false);
 	if (ret) {
 		if (atomic_read(&ctrl->xfer.is_active))
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_CORE_CLK);
+			ctrl->xfer.err = I2C_MSM_ERR_CORE_CLK;
 		dev_err(ctrl->dev, "error on issuing QUP software-reset\n");
 	}
 	return ret;
@@ -1081,11 +391,6 @@
 	wmb();
 }
 
-bool i2c_msm_xfer_is_high_speed(struct i2c_msm_ctrl *ctrl)
-{
-	return ctrl->rsrcs.clk_freq_out > I2C_MSM_CLK_FAST_MAX_FREQ;
-}
-
 /*
  * i2c_msm_clk_div_fld:
  * @clk_freq_out output clock frequency
@@ -1172,31 +477,18 @@
 	}
 }
 
-static void i2c_msm_fifo_destroy_struct(struct i2c_msm_ctrl *ctrl)
-{
-	struct i2c_msm_xfer_mode_fifo *fifo = (struct i2c_msm_xfer_mode_fifo *)
-				ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_FIFO];
-	kfree(fifo);
-	i2c_msm_fifo_set_struct(ctrl, NULL);
-}
-
 static void i2c_msm_fifo_wr_word(struct i2c_msm_ctrl *ctrl, u32 data)
 {
-	struct i2c_msm_xfer_mode_fifo *fifo = i2c_msm_fifo_get_struct(ctrl);
-
 	writel_relaxed(data, ctrl->rsrcs.base + QUP_OUT_FIFO_BASE);
 	i2c_msm_dbg(ctrl, MSM_DBG, "OUT-FIFO:0x%08x", data);
-	fifo->tx_bc += 4;
 }
 
 static u32 i2c_msm_fifo_rd_word(struct i2c_msm_ctrl *ctrl, u32 *data)
 {
-	struct i2c_msm_xfer_mode_fifo *fifo = i2c_msm_fifo_get_struct(ctrl);
 	u32 val;
 
 	val = readl_relaxed(ctrl->rsrcs.base + QUP_IN_FIFO_BASE);
 	i2c_msm_dbg(ctrl, MSM_DBG, "IN-FIFO :0x%08x", val);
-	fifo->rx_bc += 4;
 
 	if (data)
 		*data = val;
@@ -1209,7 +501,7 @@
  */
 static void i2c_msm_fifo_wr_buf_flush(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_fifo *fifo = i2c_msm_fifo_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
 	u32 *word;
 
 	if (!fifo->out_buf_idx)
@@ -1231,7 +523,7 @@
 static size_t
 i2c_msm_fifo_wr_buf(struct i2c_msm_ctrl *ctrl, u8 *buf, size_t len)
 {
-	struct i2c_msm_xfer_mode_fifo *fifo = i2c_msm_fifo_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
 	int i;
 
 	for (i = 0 ; i < len; ++i, ++buf) {
@@ -1435,71 +727,19 @@
 	return ret;
 }
 
-static void i2c_msm_fifo_teardown(struct i2c_msm_ctrl *ctrl) {}
-
-static int i2c_msm_fifo_create_struct(struct i2c_msm_ctrl *ctrl)
-{
-	struct i2c_msm_xfer_mode_fifo *fifo =
-					kmalloc(sizeof(*fifo), GFP_KERNEL);
-	if (!fifo) {
-		dev_err(ctrl->dev,
-		  "error on allocating memory for fifo mode. malloc(size:%zu\n)",
-		  sizeof(*fifo));
-		return -ENOMEM;
-	}
-
-	*fifo = (struct i2c_msm_xfer_mode_fifo) {
-		.ops = (struct i2c_msm_xfer_mode) {
-			.xfer     = i2c_msm_fifo_xfer,
-			.teardown = i2c_msm_fifo_teardown,
-		},
-	};
-	i2c_msm_fifo_set_struct(ctrl, fifo);
-
-	return 0;
-}
-
-static void i2c_msm_blk_teardown(struct i2c_msm_ctrl *ctrl) {}
-
-static void i2c_msm_blk_destroy_struct(struct i2c_msm_ctrl *ctrl)
-{
-	struct i2c_msm_xfer_mode_blk *blk = (struct i2c_msm_xfer_mode_blk *)
-				ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BLOCK];
-	if (blk) {
-		kfree(blk->tx_cache);
-		kfree(blk->rx_cache);
-		kfree(blk);
-		i2c_msm_blk_set_struct(ctrl, NULL);
-	}
-}
-
 /*
- * i2c_msm_blk_create_struct: Allocate memory and initialize blk structure
+ * i2c_msm_blk_init_struct: Allocate memory and initialize blk structure
  *
  * @return 0 on success or error code
  */
-static int i2c_msm_blk_create_struct(struct i2c_msm_ctrl *ctrl)
+static int i2c_msm_blk_init_struct(struct i2c_msm_ctrl *ctrl)
 {
-	u32 reg_data;
+	u32 reg_data = readl_relaxed(ctrl->rsrcs.base + QUP_IO_MODES);
 	int ret;
-	struct i2c_msm_xfer_mode_blk *blk = kmalloc(sizeof(*blk), GFP_KERNEL);
-	if (!blk) {
-		dev_err(ctrl->dev,
-		"error on allocating memory for block mode. malloc(size:%zu)\n",
-		 sizeof(*blk));
-		return -ENOMEM;
-	}
-
-	reg_data = readl_relaxed(ctrl->rsrcs.base + QUP_IO_MODES);
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 
-	*blk = (struct i2c_msm_xfer_mode_blk) {
-		.in_blk_sz  = i2c_msm_reg_io_modes_in_blk_sz(reg_data),
-		.out_blk_sz = i2c_msm_reg_io_modes_out_blk_sz(reg_data),
-		.ops = (struct i2c_msm_xfer_mode) {
-			.xfer     = i2c_msm_blk_xfer,
-			.teardown = i2c_msm_blk_teardown,
-		},
-	};
+	blk->in_blk_sz  = i2c_msm_reg_io_modes_in_blk_sz(reg_data),
+	blk->out_blk_sz = i2c_msm_reg_io_modes_out_blk_sz(reg_data),
 
 	blk->tx_cache = kmalloc(blk->out_blk_sz, GFP_KERNEL);
 	if (!blk->tx_cache) {
@@ -1519,13 +759,12 @@
 		goto in_buf_err;
 	}
 
-	i2c_msm_blk_set_struct(ctrl, blk);
+	blk->is_init = true;
 	return 0;
 
 in_buf_err:
 	kfree(blk->tx_cache);
 out_buf_err:
-	kfree(blk);
 
 	return ret;
 }
@@ -1539,7 +778,7 @@
 {
 	int byte_num;
 	int ret = 0;
-	struct i2c_msm_xfer_mode_blk *blk = i2c_msm_blk_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 	u32 *buf_u32_ptr;
 
 	if (!blk->tx_cache_idx)
@@ -1584,10 +823,10 @@
  * @return number of bytes from buf which have been processed (written to
  *         FIFO or kept in out buffer and will be written later)
  */
-static size_t
-i2c_msm_blk_wr_buf(struct i2c_msm_ctrl *ctrl, const u8 *buf, size_t len)
+static int
+i2c_msm_blk_wr_buf(struct i2c_msm_ctrl *ctrl, const u8 *buf, int len)
 {
-	struct i2c_msm_xfer_mode_blk *blk = i2c_msm_blk_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 	int byte_num;
 	int ret = 0;
 
@@ -1612,8 +851,7 @@
 static int i2c_msm_blk_xfer_wr_tag(struct i2c_msm_ctrl *ctrl)
 {
 	struct i2c_msm_xfer_buf *buf = &ctrl->xfer.cur_buf;
-	size_t len = 0;
-
+	int len = 0;
 	if (!buf->out_tag.len)
 		return 0;
 
@@ -1634,19 +872,17 @@
 static int i2c_msm_blk_wr_xfer_buf(struct i2c_msm_ctrl *ctrl)
 {
 	struct i2c_msm_xfer_buf *buf  = &ctrl->xfer.cur_buf;
-	size_t len;
-	size_t buf_has_bc = buf->len - buf->byte_idx;
+	int len;
 	int ret;
 	ret = i2c_msm_blk_xfer_wr_tag(ctrl);
 	if (ret)
 		return ret;
 
-	len = i2c_msm_blk_wr_buf(ctrl, i2c_msm_buf_to_ptr(buf), buf_has_bc);
-	if (len < buf_has_bc)
+	len = i2c_msm_blk_wr_buf(ctrl, i2c_msm_buf_to_ptr(buf), buf->len);
+	if (len < buf->len)
 		return -EFAULT;
 
 	buf->byte_idx += len;
-	buf->prcsed_bc = len;
 	return 0;
 }
 
@@ -1659,13 +895,13 @@
  * uses internal counter to keep track of number of available blocks. When
  * zero, waits for interrupt.
  */
-static int i2c_msm_blk_rd_blk(struct i2c_msm_ctrl *ctrl, size_t need_bc)
+static int i2c_msm_blk_rd_blk(struct i2c_msm_ctrl *ctrl, int need_bc)
 {
 	int byte_num;
 	int ret = 0;
-	struct i2c_msm_xfer_mode_blk *blk = i2c_msm_blk_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 	u32 *cache_ptr = (u32 *) blk->rx_cache;
-	int read_bc    = min_t(size_t, blk->in_blk_sz, need_bc);
+	int read_bc    = min_t(int, blk->in_blk_sz, need_bc);
 
 	/* wait for block avialble interrupt */
 	ret = i2c_msm_xfer_wait_for_completion(ctrl, &blk->wait_rx_blk);
@@ -1692,12 +928,11 @@
  */
 static int i2c_msm_blk_rd_xfer_buf(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_blk *blk = i2c_msm_blk_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 	struct i2c_msm_xfer_buf *buf      = &ctrl->xfer.cur_buf;
-	size_t bc_to_prcs                 = buf->len - buf->byte_idx;
 	struct i2c_msg *msg               = ctrl->xfer.msgs + buf->msg_idx;
-	size_t copy_bc;         /* number of bytes to copy to user's buffer */
-	int cache_avail_bc;
+	int    copy_bc;         /* number of bytes to copy to user's buffer */
+	int    cache_avail_bc;
 	int    ret = 0;
 
 	/* write tag to out FIFO */
@@ -1706,9 +941,9 @@
 		return ret;
 	i2c_msm_blk_wr_flush(ctrl);
 
-	while (bc_to_prcs || buf->in_tag.len) {
+	while (buf->len || buf->in_tag.len) {
 		cache_avail_bc = i2c_msm_blk_rd_blk(ctrl,
-						bc_to_prcs + buf->in_tag.len);
+						buf->len + buf->in_tag.len);
 
 		i2c_msm_dbg(ctrl, MSM_DBG, "IN-BLK:%*phC\n", cache_avail_bc,
 					blk->rx_cache + blk->rx_cache_idx);
@@ -1718,7 +953,7 @@
 
 		/* discard tag from input FIFO */
 		if (buf->in_tag.len) {
-			size_t discard_bc = min_t(size_t, cache_avail_bc,
+			int discard_bc = min_t(int, cache_avail_bc,
 							buf->in_tag.len);
 			blk->rx_cache_idx += discard_bc;
 			buf->in_tag.len   -= discard_bc;
@@ -1726,12 +961,12 @@
 		}
 
 		/* copy bytes from cached block to user's buffer */
-		copy_bc = min_t(size_t, cache_avail_bc, bc_to_prcs);
+		copy_bc = min_t(int, cache_avail_bc, buf->len);
 		memcpy(msg->buf + buf->byte_idx,
 			blk->rx_cache + blk->rx_cache_idx, copy_bc);
 
 		blk->rx_cache_idx += copy_bc;
-		bc_to_prcs        -= copy_bc;
+		buf->len          -= copy_bc;
 		buf->byte_idx     += copy_bc;
 	}
 	return ret;
@@ -1744,13 +979,12 @@
 {
 	int ret = 0;
 	struct i2c_msm_xfer_buf      *buf = &ctrl->xfer.cur_buf;
-	struct i2c_msm_xfer_mode_blk *blk = i2c_msm_blk_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 
-	if (!blk) {
-		ret = i2c_msm_blk_create_struct(ctrl);
-		if (ret)
+	if (!blk->is_init) {
+		ret = i2c_msm_blk_init_struct(ctrl);
+		if (!blk->is_init)
 			return ret;
-		blk = i2c_msm_blk_get_struct(ctrl);
 	}
 
 	init_completion(&blk->wait_rx_blk);
@@ -1758,7 +992,7 @@
 
 	/* tx_cnt > 0 always */
 	blk->complete_mask = QUP_MAX_OUTPUT_DONE_FLAG;
-	if (&ctrl->xfer.rx_cnt)
+	if (ctrl->xfer.rx_cnt)
 		blk->complete_mask |= QUP_MAX_INPUT_DONE_FLAG;
 
 	/* initialize block mode for new transfer */
@@ -1810,7 +1044,7 @@
  */
 static int i2c_msm_bam_xfer_prepare(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_bam *bam  = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	struct i2c_msm_xfer_buf      *buf  = &ctrl->xfer.cur_buf;
 	struct i2c_msm_bam_pipe      *cons = &bam->pipe[I2C_MSM_BAM_CONS];
 	struct i2c_msm_bam_pipe      *prod = &bam->pipe[I2C_MSM_BAM_PROD];
@@ -1855,8 +1089,7 @@
 
 		if (dma_mapping_error(ctrl->dev, data.phy_addr)) {
 			dev_err(ctrl->dev,
-			  "error DMA mapping BAM buffers. err:%lld "
-			  "buf_vrtl:0x%p data_len:%zu dma_dir:%s\n",
+			  "error DMA mapping BAM buffers, err:%lld buf_vrtl:0x%p data_len:%d dma_dir:%s\n",
 			  (u64) data.phy_addr, data.vrtl_addr, buf->len,
 			  ((buf_dma_dirctn == DMA_FROM_DEVICE)
 				? "DMA_FROM_DEVICE" : "DMA_TO_DEVICE"));
@@ -1898,7 +1131,7 @@
 static void i2c_msm_bam_xfer_unprepare(struct i2c_msm_ctrl *ctrl)
 {
 	int i;
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	struct i2c_msm_bam_buf *buf_itr;
 
 	buf_itr = bam->buf_arr;
@@ -1916,7 +1149,7 @@
 static int i2c_msm_bam_xfer_rmv_inp_fifo_tag(struct i2c_msm_ctrl *ctrl, u32 len)
 {
 	int ret;
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	struct i2c_msm_bam_pipe      *prod;
 
 	prod = &bam->pipe[I2C_MSM_BAM_PROD];
@@ -1944,7 +1177,7 @@
  */
 static int i2c_msm_bam_xfer_process(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	struct i2c_msm_bam_pipe *cons;
 	struct i2c_msm_bam_pipe *prod ;
 	struct i2c_msm_bam_buf  *buf_itr;
@@ -2078,8 +1311,8 @@
 	}
 	ret = sps_disconnect(pipe->handle);
 	if (ret) {
-		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, i2c_msm_prof_dump_pip_dscn,
-						(ulong) pipe, (u32)ret, 0);
+		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, I2C_MSM_PIP_DSCN,
+		(ulong) pipe, (u32)ret, 0);
 		return ret;
 	}
 	pipe->is_init = false;
@@ -2098,8 +1331,8 @@
 
 	ret = sps_connect(pipe->handle, config);
 	if (ret) {
-		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, i2c_msm_prof_dump_pip_cnct,
-						(ulong) pipe, (u32)ret, 0);
+		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, I2C_MSM_PIP_CNCT,
+		(ulong) pipe, (u32)ret, 0);
 		return ret;
 	}
 
@@ -2119,7 +1352,7 @@
 static void i2c_msm_bam_pipe_teardown(struct i2c_msm_ctrl *ctrl,
 				      enum i2c_msm_bam_pipe_dir pipe_dir)
 {
-	struct i2c_msm_xfer_mode_bam *bam  = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	struct i2c_msm_bam_pipe      *pipe = &bam->pipe[pipe_dir];
 
 	i2c_msm_dbg(ctrl, MSM_DBG, "tearing down the BAM %s pipe. is_init:%d",
@@ -2144,7 +1377,7 @@
 	int ret = 0;
 	struct i2c_msm_bam_pipe  *pipe;
 	struct sps_connect       *config;
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 
 	pipe   = &bam->pipe[pipe_dir];
 	config = &pipe->config;
@@ -2221,7 +1454,7 @@
 {
 	u8         *tags_space_virt_addr;
 	dma_addr_t  tags_space_phy_addr;
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 
 	if (!bam->is_core_init)
 		return;
@@ -2247,7 +1480,6 @@
 
 static int i2c_msm_bam_init_pipes(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
 	int ret;
 
 	ret = i2c_msm_bam_pipe_init(ctrl, I2C_MSM_BAM_PROD);
@@ -2260,7 +1492,7 @@
 	if (ret)
 		dev_err(ctrl->dev, "error Failed to init consumer BAM-pipe\n");
 
-	bam->is_init = true;
+	ctrl->xfer.bam.is_init = true;
 
 pipe_error:
 	return ret;
@@ -2269,12 +1501,13 @@
 static int i2c_msm_bam_reg_dev(struct i2c_msm_ctrl *ctrl, ulong *bam_handle)
 {
 	int                  ret;
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	resource_size_t phy_addr = bam->mem->start;
 	size_t          mem_size = resource_size(bam->mem);
 	struct sps_bam_props props = {
 		.phys_addr = phy_addr,
 		.irq       = bam->irq,
+		.manage    = SPS_BAM_MGR_LOCAL,
 		.summing_threshold = 0x10,
 	};
 
@@ -2306,7 +1539,7 @@
 
 static int i2c_msm_bam_init(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 	ulong           bam_handle;
 	int             ret;
 	u8             *tags_space_virt_addr;
@@ -2390,14 +1623,14 @@
 static int i2c_msm_bam_xfer(struct i2c_msm_ctrl *ctrl)
 {
 	int ret;
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
-
 	i2c_msm_dbg(ctrl, MSM_DBG, "Starting BAM transfer");
 
-	if (!bam->is_init) {
+	if (!ctrl->xfer.bam.is_init) {
 		ret = i2c_msm_bam_init(ctrl);
-		if (ret)
+		if (ret) {
+			dev_err(ctrl->dev, "BAM init failed: %d\n", ret);
 			return ret;
+		}
 	}
 
 	if (ctrl->xfer.last_is_rx) {
@@ -2432,7 +1665,7 @@
 	if (ret)
 		dev_err(ctrl->dev,
 			"error i2c_msm_bam_xfer_process(n_bufs:%zu):%d\n",
-			bam->buf_arr_cnt, ret);
+			ctrl->xfer.bam.buf_arr_cnt, ret);
 
 err_bam_xfer:
 	i2c_msm_bam_xfer_unprepare(ctrl);
@@ -2440,36 +1673,6 @@
 	return ret;
 }
 
-static void i2c_msm_bam_destroy_struct(struct i2c_msm_ctrl *ctrl)
-{
-	struct i2c_msm_xfer_mode_bam *bam = (struct i2c_msm_xfer_mode_bam *)
-				ctrl->ver.xfer_mode[I2C_MSM_XFER_MODE_BAM];
-	kfree(bam);
-	i2c_msm_bam_set_struct(ctrl, NULL);
-}
-
-static int i2c_msm_bam_create_struct(struct i2c_msm_ctrl *ctrl)
-{
-	struct i2c_msm_xfer_mode_bam *bam = kmalloc(sizeof(*bam), GFP_KERNEL);
-
-	if (!bam) {
-		dev_err(ctrl->dev,
-		   "error on allocating memory for bam mode. malloc(size:%zu)\n",
-		   sizeof(*bam));
-		return -ENOMEM;
-	}
-
-	*bam = (struct i2c_msm_xfer_mode_bam) {
-		.ops = (struct i2c_msm_xfer_mode) {
-			.xfer     = i2c_msm_bam_xfer,
-			.teardown = i2c_msm_bam_teardown,
-		},
-	};
-
-	i2c_msm_bam_set_struct(ctrl, bam);
-	return 0;
-}
-
 /*
  * i2c_msm_qup_rsrcs_init: init resources values in probe() time
  *
@@ -2479,13 +1682,13 @@
 static int i2c_msm_qup_rsrcs_init(struct platform_device *pdev,
 						struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_bam *bam = i2c_msm_bam_get_struct(ctrl);
+	struct i2c_msm_xfer_mode_bam *bam = &ctrl->xfer.bam;
 
 	bam->mem = platform_get_resource_byname(pdev, IORESOURCE_MEM,
 							"bam_phys_addr");
-	if (!bam->mem) {
+	if (!ctrl->xfer.bam.mem) {
 		i2c_msm_dbg(ctrl, MSM_PROF,
-				"Missing 'qup_phys_addr' resource entry");
+				"Missing 'bam_phys_addr' resource entry");
 		return -ENODEV;
 	}
 
@@ -2541,7 +1744,7 @@
 
 poll_active_end:
 	/* second logged value is time-left before timeout or zero if expired */
-	i2c_msm_prof_evnt_add(ctrl, MSM_DBG, i2c_msm_prof_dump_actv_end,
+	i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_ACTV_END,
 				ret, (ret ? 0 : (timeout - jiffies)), read_cnt);
 
 	return ret;
@@ -2719,7 +1922,7 @@
 	struct i2c_msm_ctrl *ctrl = devid;
 	void __iomem        *base = ctrl->rsrcs.base;
 	struct i2c_msm_xfer *xfer = &ctrl->xfer;
-	struct i2c_msm_xfer_mode_blk *blk;
+	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
 	u32  i2c_status = 0;
 	u32  err_flags  = 0;
 	u32  qup_op     = 0;
@@ -2728,8 +1931,7 @@
 	bool signal_complete = false;
 	bool need_wmb        = false;
 
-	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, i2c_msm_prof_dump_irq_begn,
-								irq, 0, 0);
+	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_IRQ_BGN, irq, 0, 0);
 
 	if (!atomic_read(&ctrl->xfer.is_active)) {
 		dev_info(ctrl->dev, "irq:%d when no active transfer\n", irq);
@@ -2743,35 +1945,23 @@
 	if (i2c_status & QUP_MSTR_STTS_ERR_MASK) {
 		signal_complete = true;
 		log_event       = true;
-
-		if (i2c_status & QUP_PACKET_NACKED)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_NACK);
-
+		/*
+		 * If there is more than 1 error here, last one sticks.
+		 * The order of the error set here matters.
+		 */
 		if (i2c_status & QUP_ARB_LOST)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_ARB_LOST);
+			ctrl->xfer.err = I2C_MSM_ERR_ARB_LOST;
 
 		if (i2c_status & QUP_BUS_ERROR)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_BUS_ERR);
-
-		if (i2c_status & QUP_INVALID_WRITE)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_INVALID_WRITE);
-
-		if (i2c_status & QUP_INVALID_TAG)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_INVALID_TAG);
+			ctrl->xfer.err = I2C_MSM_ERR_BUS_ERR;
 
-		if (i2c_status & QUP_INVALID_READ_ADDR)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_INVALID_READ_ADDR);
-
-		if (i2c_status & QUP_INVALID_READ_SEQ)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_INVALID_READ_SEQ);
-
-		if (i2c_status & QUP_FAILED)
-			ctrl->xfer.err |= BIT(I2C_MSM_ERR_FAILED);
+		if (i2c_status & QUP_PACKET_NACKED)
+			ctrl->xfer.err = I2C_MSM_ERR_NACK;
 	}
 
 	/* check for FIFO over/under runs error */
 	if (err_flags & QUP_ERR_FLGS_MASK)
-		ctrl->xfer.err |= BIT(I2C_MSM_ERR_OVR_UNDR_RUN);
+		ctrl->xfer.err = I2C_MSM_ERR_OVR_UNDR_RUN;
 
 	/* Dump the register values before reset the core */
 	if (ctrl->xfer.err && ctrl->dbgfs.dbg_lvl >= MSM_DBG)
@@ -2796,22 +1986,33 @@
 		need_wmb = true;
 	}
 
+	if (need_wmb)
+		/*
+		 * flush writes that clear the interrupt flags before changing
+		 * state to reset.
+		 */
+		wmb();
+
 	/* Reset and bail out on error */
 	if (ctrl->xfer.err) {
-
 		/* Flush for the tags in case of an error and BAM Mode*/
-		if (ctrl->xfer.mode_id == I2C_MSM_XFER_MODE_BAM)
+		if (ctrl->xfer.mode_id == I2C_MSM_XFER_MODE_BAM) {
 			writel_relaxed(QUP_I2C_FLUSH, ctrl->rsrcs.base
 								+ QUP_STATE);
+			/*
+			 * Ensure that QUP_I2C_FLUSH is written before
+			 * State reset
+			 */
+			wmb();
+		}
 
 		/* HW workaround: when interrupt is level triggerd, more
 		 * than one interrupt may fire in error cases. Thus we
-		 * reset the core immidiatly in the ISR to ward off the
-		 * next interrupt.
+		 * change the QUP core state to Reset immediately in the
+		 * ISR to ward off the next interrupt.
 		 */
-		i2c_msm_qup_sw_reset(ctrl);
+		writel_relaxed(QUP_STATE_RESET, ctrl->rsrcs.base + QUP_STATE);
 
-		need_wmb        = true;
 		signal_complete = true;
 		log_event       = true;
 		goto isr_end;
@@ -2819,9 +2020,6 @@
 
 	/* handle data completion */
 	if (xfer->mode_id == I2C_MSM_XFER_MODE_BLOCK) {
-		/*For Block Mode */
-		blk = i2c_msm_blk_get_struct(ctrl);
-
 		/* block ready for writing */
 		if (qup_op & QUP_OUTPUT_SERVICE_FLAG) {
 			log_event = true;
@@ -2872,16 +2070,12 @@
 	}
 
 isr_end:
-	/* Ensure that QUP configuration is written before leaving this func */
-	if (need_wmb)
-		wmb();
-
 	if (ctrl->xfer.err || (ctrl->dbgfs.dbg_lvl >= MSM_DBG))
 		i2c_msm_dbg_dump_diag(ctrl, true, i2c_status, qup_op);
 
 	if (log_event || (ctrl->dbgfs.dbg_lvl >= MSM_DBG))
 		i2c_msm_prof_evnt_add(ctrl, MSM_PROF,
-					i2c_msm_prof_dump_irq_end,
+					I2C_MSM_IRQ_END,
 					i2c_status, qup_op, err_flags);
 
 	if (signal_complete)
@@ -2890,44 +2084,23 @@
 	return IRQ_HANDLED;
 }
 
-static int i2c_msm_qup_mini_core_init(struct i2c_msm_ctrl *ctrl)
-{
-	void __iomem *base = ctrl->rsrcs.base;
-	u32 val = readl_relaxed(base + QUP_STATE);
-
-	if (!(val & QUP_I2C_MAST_GEN))
-		dev_err(ctrl->dev,
-			"error on verifying HW support (I2C_MAST_GEN=0)\n");
-
-	writel_relaxed(QUP_MINI_CORE_I2C_VAL, base + QUP_CONFIG);
-	writel_relaxed(QUP_EN_VERSION_TWO_TAG, base + QUP_I2C_MASTER_CONFIG);
-
-	val = readl_relaxed(base + QUP_CONFIG);
-	writel_relaxed(val | QUP_N_VAL, base + QUP_CONFIG);
-
-	return 0;
-}
-
-static void i2c_msm_qup_destroy_struct(struct i2c_msm_ctrl *ctrl)
+static void i2x_msm_blk_free_cache(struct i2c_msm_ctrl *ctrl)
 {
-	i2c_msm_fifo_destroy_struct(ctrl);
-	i2c_msm_bam_destroy_struct(ctrl);
-	i2c_msm_blk_destroy_struct(ctrl);
+	kfree(ctrl->xfer.blk.tx_cache);
+	kfree(ctrl->xfer.blk.rx_cache);
 }
 
-static int i2c_msm_qup_init(struct i2c_msm_ctrl *ctrl)
+static void i2c_msm_qup_init(struct i2c_msm_ctrl *ctrl)
 {
-	int ret;
+	u32 state;
 	void __iomem *base = ctrl->rsrcs.base;
 
-	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, i2c_msm_prof_reset, 0, 0, 0);
+	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_PROF_RESET, 0, 0, 0);
 
 	i2c_msm_qup_sw_reset(ctrl);
 	i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
 
-	writel_relaxed(QUP_APP_CLK_ON_EN | QUP_CORE_CLK_ON_EN |
-				QUP_FIFO_CLK_GATE_EN,
-				base + QUP_CONFIG);
+	writel_relaxed(QUP_N_VAL | QUP_MINI_CORE_I2C_VAL, base + QUP_CONFIG);
 
 	writel_relaxed(QUP_OUTPUT_OVER_RUN_ERR_EN | QUP_INPUT_UNDER_RUN_ERR_EN
 		     | QUP_OUTPUT_UNDER_RUN_ERR_EN | QUP_INPUT_OVER_RUN_ERR_EN,
@@ -2936,18 +2109,7 @@
 	writel_relaxed(QUP_INPUT_SERVICE_MASK | QUP_OUTPUT_SERVICE_MASK,
 					base + QUP_OPERATIONAL_MASK);
 
-	writel_relaxed(0, base + QUP_CONFIG);
-	writel_relaxed(0, base + QUP_TEST_CTRL);
-	writel_relaxed(0, base + QUP_IO_MODES);
-
-	ret = i2c_msm_qup_mini_core_init(ctrl);
-	if (ret)
-		return ret;
-
-	/* Initialize the xfer mode structures */
-	i2c_msm_fifo_get_struct(ctrl);
-	i2c_msm_blk_get_struct(ctrl);
-	i2c_msm_bam_get_struct(ctrl);
+	writel_relaxed(QUP_EN_VERSION_TWO_TAG, base + QUP_I2C_MASTER_CONFIG);
 
 	i2c_msm_qup_fifo_calc_size(ctrl);
 	/*
@@ -2956,7 +2118,11 @@
 	 */
 	mb();
 
-	return ret;
+	state = readl_relaxed(base + QUP_STATE);
+
+	if (!(state & QUP_I2C_MAST_GEN))
+		dev_err(ctrl->dev,
+			"error on verifying HW support (I2C_MAST_GEN=0)\n");
 }
 
 /*
@@ -2968,9 +2134,7 @@
 	ulong min_sleep_usec;
 
 	/* call i2c_msm_qup_init() to set core in idle state */
-	ret = i2c_msm_qup_init(ctrl);
-	if (ret)
-		return ret;
+	i2c_msm_qup_init(ctrl);
 
 	/* must be in run state for bus clear */
 	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
@@ -3020,25 +2184,13 @@
 	return 0;
 }
 
-static void i2c_msm_qup_teardown(struct i2c_msm_ctrl *ctrl)
-{
-	int i;
-	i2c_msm_dbg(ctrl, MSM_PROF, "Teardown the QUP and BAM");
-
-	for (i = 0; i < I2C_MSM_XFER_MODE_NONE; ++i) {
-		/* teardown the xfer mode structure if they exist */
-		if (ctrl->ver.xfer_mode[i])
-			(*ctrl->ver.xfer_mode[i]->teardown)(ctrl);
-	}
-}
-
 static int i2c_msm_qup_post_xfer(struct i2c_msm_ctrl *ctrl, int err)
 {
 	/* poll until bus is released */
 	if (i2c_msm_qup_poll_bus_active_unset(ctrl)) {
-		if ((ctrl->xfer.err & BIT(I2C_MSM_ERR_ARB_LOST)) ||
-		    (ctrl->xfer.err & BIT(I2C_MSM_ERR_BUS_ERR)) ||
-		    (ctrl->xfer.err & BIT(I2C_MSM_ERR_TIMEOUT))) {
+		if ((ctrl->xfer.err == I2C_MSM_ERR_ARB_LOST) ||
+		    (ctrl->xfer.err == I2C_MSM_ERR_BUS_ERR)  ||
+		    (ctrl->xfer.err == I2C_MSM_ERR_TIMEOUT)) {
 			if (i2c_msm_qup_slv_holds_bus(ctrl))
 				qup_i2c_recover_bus_busy(ctrl);
 
@@ -3048,27 +2200,28 @@
 		}
 	}
 
+	/*
+	* Disable the IRQ before change to reset state to avoid
+	* spurious interrupts.
+	*
+	*/
+	disable_irq(ctrl->rsrcs.irq);
+
 	/* flush bam data and reset the qup core in timeout error.
 	 * for other error case, its handled by the ISR
 	 */
-	if (ctrl->xfer.err & BIT(I2C_MSM_ERR_TIMEOUT)) {
+	if (ctrl->xfer.err == I2C_MSM_ERR_TIMEOUT) {
 		/* Flush for the BAM registers */
 		if (ctrl->xfer.mode_id == I2C_MSM_XFER_MODE_BAM)
 			writel_relaxed(QUP_I2C_FLUSH, ctrl->rsrcs.base
 								+ QUP_STATE);
 
-		/* reset the sw core */
-		i2c_msm_qup_sw_reset(ctrl);
+		/* reset the qup core */
+		i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
 		err = -ETIMEDOUT;
-	}
-
-	if (ctrl->xfer.err & BIT(I2C_MSM_ERR_BUS_ERR)) {
-		if (!err)
-			err = -EIO;
-	}
-
-	if (ctrl->xfer.err & BIT(I2C_MSM_ERR_NACK))
+	} else if (ctrl->xfer.err == I2C_MSM_ERR_NACK) {
 		err = -ENOTCONN;
+	}
 
 	return err;
 }
@@ -3076,12 +2229,11 @@
 static enum i2c_msm_xfer_mode_id
 i2c_msm_qup_choose_mode(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_fifo *fifo;
+	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
 	struct i2c_msm_xfer           *xfer = &ctrl->xfer;
 	size_t rx_cnt_sum = xfer->rx_cnt + xfer->rx_ovrhd_cnt;
 	size_t tx_cnt_sum = xfer->tx_cnt + xfer->tx_ovrhd_cnt;
 
-	fifo = i2c_msm_fifo_get_struct(ctrl);
 
 	if (ctrl->dbgfs.force_xfer_mode != I2C_MSM_XFER_MODE_NONE)
 		return ctrl->dbgfs.force_xfer_mode;
@@ -3097,54 +2249,6 @@
 }
 
 /*
- * i2c_msm_qup_set_version: set version parameters to QUP-2.x.x
- */
-static void i2c_msm_qup_set_version(struct i2c_msm_ctrl *ctrl)
-{
-	ctrl->ver = (struct i2c_msm_ctrl_ver) {
-		.destroy              = i2c_msm_qup_destroy_struct,
-		.init                 = i2c_msm_qup_init,
-		.reset                = i2c_msm_qup_sw_reset,
-		.teardown             = i2c_msm_qup_teardown,
-		.init_rsrcs           = i2c_msm_qup_rsrcs_init,
-		.choose_mode          = i2c_msm_qup_choose_mode,
-		.post_xfer            = i2c_msm_qup_post_xfer,
-		.max_rx_cnt           = 0xFFFF,
-		.max_tx_cnt           = 0xFFFF,
-		.max_buf_size         = 0xFF,
-		.msg_ovrhd_bc         = I2C_MSM_TAG2_MAX_LEN,
-		.buf_ovrhd_bc         = 2, /* rd/wr tag + byte count */
-	};
-}
-
-/*
- * @return zero on success
- */
-static const int
-i2c_msm_ctrl_ver_detect_and_set(struct i2c_msm_ctrl *ctrl)
-{
-	enum i2c_msm_ctrl_ver_num ver_family;
-	u32 ver_num = readl_relaxed(ctrl->rsrcs.base + QUP_HW_VERSION);
-
-	if (ver_num < I2C_MSM_CTRL_VER_B_MIN)
-		ver_family = I2C_MSM_CTRL_VER_A;
-	else if (ver_num < I2C_MSM_CTRL_VER_B_MAX)
-		ver_family = I2C_MSM_CTRL_VER_B;
-	else
-		ver_family = I2C_MSM_CTRL_VER_UNKNOWN;
-
-	if (ver_family ==  I2C_MSM_CTRL_VER_B) {
-		i2c_msm_dbg(ctrl, MSM_PROF,
-				"B-family HW detected (ver:0x%x)...", ver_num);
-		i2c_msm_qup_set_version(ctrl);
-		return 0;
-	}
-
-	dev_err(ctrl->dev,
-		"unsupported hardware version detected ver#:0x%x", ver_num);
-	return -ENODEV;
-}
-/*
  * i2c_msm_xfer_calc_timeout: calc maximum xfer time in jiffies
  *
  * Basically timeout = (bit_count / frequency) * safety_coefficient.
@@ -3173,13 +2277,16 @@
 
 	time_left = wait_for_completion_timeout(complete, xfer->timeout);
 	if (!time_left) {
-		xfer->err |= BIT(I2C_MSM_ERR_TIMEOUT);
+		xfer->err = I2C_MSM_ERR_TIMEOUT;
 		i2c_msm_dbg_dump_diag(ctrl, false, 0, 0);
 		ret = -EIO;
-		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, i2c_msm_prof_dump_cmplt_fl,
-					xfer->timeout, time_left, 0);
+		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, I2C_MSM_COMPLT_FL,
+						xfer->timeout, time_left, 0);
 	} else {
-		i2c_msm_prof_evnt_add(ctrl, MSM_DBG, i2c_msm_prof_dump_cmplt_ok,
+		/* return an error if one detected by ISR */
+		if (xfer->err)
+			ret = -(xfer->err);
+		i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_COMPLT_OK,
 					xfer->timeout, time_left, 0);
 	}
 
@@ -3202,7 +2309,7 @@
 
 /*
  * @return true when the current transfer's buffer points to the last
- *    transferable buffer (size =< ver.max_buf_size) of the last message of the
+ *    transferable buffer (size =< QUP_MAX_BUF_SZ) of the last message of the
  *    user's request.
  */
 static bool i2c_msm_xfer_buf_is_last(struct i2c_msm_ctrl *ctrl)
@@ -3211,7 +2318,7 @@
 	struct i2c_msg *cur_msg = ctrl->xfer.msgs + cur_buf->msg_idx;
 
 	return i2c_msm_xfer_msg_is_last(ctrl) &&
-		((cur_buf->byte_idx + ctrl->ver.max_buf_size) >= cur_msg->len);
+		((cur_buf->byte_idx + QUP_MAX_BUF_SZ) >= cur_msg->len);
 }
 
 static void i2c_msm_xfer_create_cur_tag(struct i2c_msm_ctrl *ctrl,
@@ -3219,13 +2326,11 @@
 {
 	struct i2c_msm_xfer_buf *cur_buf = &ctrl->xfer.cur_buf;
 
-	cur_buf->out_tag = i2c_msm_tag_create(
-					i2c_msm_xfer_is_high_speed(ctrl),
-					start_req, cur_buf->is_last,
+	cur_buf->out_tag = i2c_msm_tag_create(start_req, cur_buf->is_last,
 					cur_buf->is_rx, cur_buf->len,
 					cur_buf->slv_addr);
 
-	cur_buf->in_tag.len = cur_buf->is_rx ? ctrl->ver.buf_ovrhd_bc : 0;
+	cur_buf->in_tag.len = cur_buf->is_rx ? QUP_BUF_OVERHD_BC : 0;
 }
 
 /*
@@ -3237,17 +2342,17 @@
 {
 	struct i2c_msm_xfer_buf *cur_buf = &ctrl->xfer.cur_buf;
 	struct i2c_msg          *cur_msg = ctrl->xfer.msgs + cur_buf->msg_idx;
-	bool is_first_msg = !cur_buf->msg_idx;
-	size_t bc_rem     = cur_msg->len - cur_buf->prcsed_bc;
+	int bc_rem = cur_msg->len - cur_buf->end_idx;
 
-	if (cur_buf->is_init && cur_buf->prcsed_bc && bc_rem) {
+	if (cur_buf->is_init && cur_buf->end_idx && bc_rem) {
 		/* not the first buffer in a message */
-		cur_buf->byte_idx = cur_buf->prcsed_bc;
-		cur_buf->is_last  = i2c_msm_xfer_buf_is_last(ctrl);
-		cur_buf->len    = min_t(size_t, bc_rem, ctrl->ver.max_buf_size);
-		cur_buf->prcsed_bc += cur_buf->len;
 
-		/* No start is required if it is not a first buffer in msg */
+		cur_buf->byte_idx  = cur_buf->end_idx;
+		cur_buf->is_last   = i2c_msm_xfer_buf_is_last(ctrl);
+		cur_buf->len       = min_t(int, bc_rem, QUP_MAX_BUF_SZ);
+		cur_buf->end_idx  += cur_buf->len;
+
+		/* No Start is required if it is not a first buffer in msg */
 		i2c_msm_xfer_create_cur_tag(ctrl, false);
 	} else {
 		/* first buffer in a new message */
@@ -3257,23 +2362,21 @@
 			} else {
 				++cur_buf->msg_idx;
 				++cur_msg;
-				is_first_msg = false;
 			}
 		} else {
 			cur_buf->is_init = true;
 		}
 		cur_buf->byte_idx  = 0;
 		cur_buf->is_last   = i2c_msm_xfer_buf_is_last(ctrl);
-		cur_buf->len       = min_t(size_t, cur_msg->len,
-							ctrl->ver.max_buf_size);
+		cur_buf->len       = min_t(int, cur_msg->len, QUP_MAX_BUF_SZ);
 		cur_buf->is_rx     = (cur_msg->flags & I2C_M_RD);
-		cur_buf->prcsed_bc = cur_buf->len;
-		cur_buf->slv_addr = i2c_msm_slv_rd_wr_addr(cur_msg->addr,
+		cur_buf->end_idx   = cur_buf->len;
+		cur_buf->slv_addr  = i2c_msm_slv_rd_wr_addr(cur_msg->addr,
 								cur_buf->is_rx);
 		i2c_msm_xfer_create_cur_tag(ctrl, true);
 	}
-	i2c_msm_prof_evnt_add(ctrl, MSM_DBG, i2c_msm_prof_dump_next_buf,
-					cur_buf->msg_idx, cur_buf->byte_idx, 0);
+	i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_NEXT_BUF, cur_buf->msg_idx,
+							cur_buf->byte_idx, 0);
 	return  true;
 }
 
@@ -3309,7 +2412,7 @@
 	mutex_lock(&ctrl->xfer.mtx);
 
 	/* if system is suspended just bail out */
-	if (ctrl->pwr_state == MSM_I2C_PM_SYS_SUSPENDED) {
+	if (ctrl->pwr_state == I2C_MSM_PM_SYS_SUSPENDED) {
 		struct i2c_msg *msgs = xfer->msgs + xfer->cur_buf.msg_idx;
 		dev_err(ctrl->dev,
 				"slave:0x%x is calling xfer when system is suspended\n",
@@ -3323,7 +2426,7 @@
 	 * if runtime PM callback was not invoked (when both runtime-pm
 	 * and systme-pm are in transition concurrently)
 	 */
-	if (ctrl->pwr_state != MSM_I2C_PM_ACTIVE) {
+	if (ctrl->pwr_state != I2C_MSM_PM_RT_ACTIVE) {
 		dev_info(ctrl->dev, "Runtime PM-callback was not invoked.\n");
 		i2c_msm_pm_resume(ctrl->dev);
 	}
@@ -3333,7 +2436,7 @@
 		mutex_unlock(&ctrl->xfer.mtx);
 		return ret;
 	}
-	ctrl->ver.init(ctrl);
+	i2c_msm_qup_init(ctrl);
 
 	/* Set xfer to active state (efectively enabling our ISR)*/
 	atomic_set(&ctrl->xfer.is_active, 1);
@@ -3344,11 +2447,8 @@
 
 static void i2c_msm_pm_xfer_end(struct i2c_msm_ctrl *ctrl)
 {
-	struct i2c_msm_xfer_mode_bam *bam  = i2c_msm_bam_get_struct(ctrl);
-	struct i2c_msm_bam_pipe      *prod = &bam->pipe[I2C_MSM_BAM_PROD];
-	struct i2c_msm_bam_pipe      *cons = &bam->pipe[I2C_MSM_BAM_CONS];
-
-	disable_irq(ctrl->rsrcs.irq);
+	struct i2c_msm_bam_pipe *prod = &ctrl->xfer.bam.pipe[I2C_MSM_BAM_PROD];
+	struct i2c_msm_bam_pipe *cons = &ctrl->xfer.bam.pipe[I2C_MSM_BAM_CONS];
 
 	atomic_set(&ctrl->xfer.is_active, 0);
 
@@ -3373,8 +2473,7 @@
 static void i2c_msm_xfer_scan(struct i2c_msm_ctrl *ctrl)
 {
 	struct i2c_msm_xfer     *xfer      = &ctrl->xfer;
-	struct i2c_msm_xfer_buf  first_buf = ctrl->xfer.cur_buf;
-	struct i2c_msm_xfer_buf *cur_buf   = &ctrl->xfer.cur_buf;
+	struct i2c_msm_xfer_buf *cur_buf   = &xfer->cur_buf;
 
 	while (i2c_msm_xfer_next_buf(ctrl)) {
 
@@ -3389,7 +2488,7 @@
 		if (i2c_msm_xfer_msg_is_last(ctrl))
 			xfer->last_is_rx = cur_buf->is_rx;
 	}
-	ctrl->xfer.cur_buf = first_buf;
+	xfer->cur_buf = (struct i2c_msm_xfer_buf){0};
 }
 
 static int
@@ -3398,7 +2497,11 @@
 	int ret = 0;
 	struct i2c_msm_ctrl      *ctrl = i2c_get_adapdata(adap);
 	struct i2c_msm_xfer      *xfer = &ctrl->xfer;
-	struct i2c_msm_xfer_mode *xfer_mode;
+
+	if (IS_ERR_OR_NULL(msgs)) {
+		dev_err(ctrl->dev, " error on msgs Accessing invalid  pointer location\n");
+		return PTR_ERR(msgs);
+	}
 
 	ret = i2c_msm_pm_xfer_start(ctrl);
 	if (ret)
@@ -3418,28 +2521,42 @@
 	xfer->cur_buf.is_init = false;
 	xfer->cur_buf.msg_idx = 0;
 
-	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, i2c_msm_prof_dump_xfer_beg,
-							num, msgs->addr, 0);
+	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_XFER_BEG, num,
+								msgs->addr, 0);
 
 	i2c_msm_xfer_scan(ctrl);
 	i2c_msm_xfer_calc_timeout(ctrl);
-	xfer->mode_id = (*ctrl->ver.choose_mode)(ctrl);
+	xfer->mode_id = i2c_msm_qup_choose_mode(ctrl);
 
-	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, i2c_msm_prof_dump_scan_sum,
+	dev_dbg(ctrl->dev, "xfer() mode:%d msg_cnt:%d rx_cbt:%zu tx_cnt:%zu\n",
+		xfer->mode_id, xfer->msg_cnt, xfer->rx_cnt, xfer->tx_cnt);
+
+	switch (xfer->mode_id) {
+	case I2C_MSM_XFER_MODE_FIFO:
+		ret = i2c_msm_fifo_xfer(ctrl);
+		break;
+	case I2C_MSM_XFER_MODE_BLOCK:
+		ret = i2c_msm_blk_xfer(ctrl);
+		break;
+	case I2C_MSM_XFER_MODE_BAM:
+		ret = i2c_msm_bam_xfer(ctrl);
+		break;
+	default:
+		ret = -EINTR;
+	};
+
+	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_SCAN_SUM,
 		((xfer->rx_cnt & 0xff) | ((xfer->rx_ovrhd_cnt & 0xff) << 16)),
 		((xfer->tx_cnt & 0xff) | ((xfer->tx_ovrhd_cnt & 0xff) << 16)),
 		((ctrl->xfer.timeout & 0xfff) | ((xfer->mode_id & 0xf) << 24)));
 
-	xfer_mode = ctrl->ver.xfer_mode[xfer->mode_id];
-	ret = (*xfer_mode->xfer)(ctrl);
-	ret = (*ctrl->ver.post_xfer)(ctrl, ret);
-
+	ret = i2c_msm_qup_post_xfer(ctrl, ret);
 	/* on success, return number of messages sent (which is index + 1)*/
 	if (!ret)
 		ret = xfer->cur_buf.msg_idx + 1;
 
-	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, i2c_msm_prof_dump_xfer_end,
-				ret, xfer->err, xfer->cur_buf.msg_idx + 1);
+	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_XFER_END, ret, xfer->err,
+						xfer->cur_buf.msg_idx + 1);
 	/* process and dump profiling data */
 	if (xfer->err || (ctrl->dbgfs.dbg_lvl >= MSM_PROF))
 		i2c_msm_prof_evnt_dump(ctrl);
@@ -3524,8 +2641,6 @@
 
 /*
  * i2c_msm_rsrcs_process_dt: copy data from DT to platform data
- *
- * @pdata out parameter
  * @return zero on success or negative error code
  */
 static int i2c_msm_rsrcs_process_dt(struct i2c_msm_ctrl *ctrl,
@@ -3720,7 +2835,7 @@
 	int ret = 0;
 
 	if ((ctrl->rsrcs.clk_freq_out <= 0) ||
-	    (ctrl->rsrcs.clk_freq_out > I2C_MSM_CLK_HIGH_MAX_FREQ)) {
+	    (ctrl->rsrcs.clk_freq_out > I2C_MSM_CLK_FAST_PLUS_FREQ)) {
 		dev_err(ctrl->dev,
 			"error clock frequency %dKHZ is not supported\n",
 			(ctrl->rsrcs.clk_freq_out / 1000));
@@ -3763,168 +2878,31 @@
 	i2c_msm_clk_path_teardown(ctrl);
 }
 
-#ifdef CONFIG_DEBUG_FS
-/*
- * i2c_msm_dbgfs_clk_wrapper: take care of clocks before calling func
- *
- * this function will verify that clocks are voted for the func if that they are
- * not. This is required for functionality which touches registers from debugfs.
- */
-static int i2c_msm_dbgfs_clk_wrapper(struct i2c_msm_ctrl *ctrl,
-					int (*func)(struct i2c_msm_ctrl *))
-{
-	int ret;
-	pm_runtime_get_sync(ctrl->dev);
-	/*
-	 * if runtime PM callback was not invoked (when both runtime-pm
-	 * and systme-pm are in transition concurrently)
-	 */
-	if (ctrl->pwr_state != MSM_I2C_PM_ACTIVE) {
-		dev_info(ctrl->dev, "Runtime PM-callback was not invoked.\n");
-		i2c_msm_pm_resume(ctrl->dev);
-	}
-	ret = i2c_msm_pm_clk_prepare_enable(ctrl);
-	if (ret)
-		return ret;
-
-	ret = func(ctrl);
-
-	i2c_msm_pm_clk_disable_unprepare(ctrl);
-	if (pm_runtime_enabled(ctrl->dev)) {
-		pm_runtime_mark_last_busy(ctrl->dev);
-		pm_runtime_put_autosuspend(ctrl->dev);
-	} else {
-		i2c_msm_pm_suspend(ctrl->dev);
-	}
-	return ret;
-}
-
-static int i2c_msm_dbgfs_reg_dump(void *data, u64 val)
-{
-	struct i2c_msm_ctrl *ctrl = data;
-	return i2c_msm_dbgfs_clk_wrapper(ctrl, i2c_msm_dbg_qup_reg_dump);
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(i2c_msm_dbgfs_reg_dump_fops,
-			NULL,
-			i2c_msm_dbgfs_reg_dump,
-			"0x%llx");
-
-static int i2c_msm_dbgfs_do_bus_clear(void *data, u64 val)
-{
-	struct i2c_msm_ctrl *ctrl = data;
-	return i2c_msm_dbgfs_clk_wrapper(ctrl, qup_i2c_recover_bus_busy);
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(i2c_msm_dbgfs_do_bus_clear_fops,
-			NULL,
-			i2c_msm_dbgfs_do_bus_clear,
-			"0x%llx");
-
-static const umode_t I2C_MSM_DFS_MD_R  = S_IRUSR | S_IRGRP;
-static const umode_t I2C_MSM_DFS_MD_W    = S_IWUSR | S_IWGRP;
-static const umode_t I2C_MSM_DFS_MD_RW = S_IRUSR | S_IRGRP |
-					   S_IWUSR | S_IWGRP;
-
-enum i2c_msm_dbgfs_file_type {
-	I2C_MSM_DFS_U8,
-	I2C_MSM_DFS_U32,
-	I2C_MSM_DFS_FILE,
-};
-/*
- * i2c_msm_dbgfs_file: entry in a table of debugfs files
- *
- * @name      debugfs file name
- * @mode      file permissions
- * @fops      used when type == I2C_MSM_DFS_FILE
- * @value_ptr used when type != I2C_MSM_DFS_FILE
- */
-struct i2c_msm_dbgfs_file {
-	const char                   *name;
-	const umode_t                 mode;
-	enum i2c_msm_dbgfs_file_type  type;
-	const struct file_operations *fops;
-	u32                          *value_ptr;
-};
-
-static void i2c_msm_dbgfs_create(struct i2c_msm_ctrl *ctrl,
-				struct i2c_msm_dbgfs_file *itr)
-{
-	struct dentry *file;
-
-	ctrl->dbgfs.root = debugfs_create_dir(dev_name(ctrl->dev), NULL);
-	if (!ctrl->dbgfs.root) {
-		dev_err(ctrl->dev, "error on creating debugfs root\n");
-		return;
-	}
-
-	for ( ; itr->name ; ++itr) {
-		switch (itr->type) {
-		case I2C_MSM_DFS_FILE:
-			file = debugfs_create_file(itr->name,
-						   itr->mode,
-						   ctrl->dbgfs.root,
-						   ctrl, itr->fops);
-			break;
-		case I2C_MSM_DFS_U8:
-			file = debugfs_create_u8(itr->name,
-						 itr->mode,
-						 ctrl->dbgfs.root,
-						 (u8 *) itr->value_ptr);
-			break;
-		default: /* I2C_MSM_DFS_U32 */
-			file = debugfs_create_u32(itr->name,
-						 itr->mode,
-						 ctrl->dbgfs.root,
-						 (u32 *) itr->value_ptr);
-			break;
-		}
-
-		if (!file)
-			dev_err(ctrl->dev,
-				"error on creating debugfs entry:%s\n",
-				itr->name);
-	}
-}
-
-static void i2c_msm_dbgfs_init(struct i2c_msm_ctrl *ctrl)
-{
-	struct i2c_msm_dbgfs_file i2c_msm_dbgfs_map[] = {
-		{"dbg-lvl",         I2C_MSM_DFS_MD_RW, I2C_MSM_DFS_U8,
-				NULL, &ctrl->dbgfs.dbg_lvl},
-		{"xfer-force-mode", I2C_MSM_DFS_MD_RW, I2C_MSM_DFS_U8,
-				NULL, &ctrl->dbgfs.force_xfer_mode},
-		{"dump-regs",       I2C_MSM_DFS_MD_W, I2C_MSM_DFS_FILE,
-				&i2c_msm_dbgfs_reg_dump_fops,      NULL},
-		{"bus-clear",       I2C_MSM_DFS_MD_W, I2C_MSM_DFS_FILE,
-				&i2c_msm_dbgfs_do_bus_clear_fops,  NULL},
-		{NULL, 0, 0, NULL , NULL}, /* null terminator */
-	};
-	return i2c_msm_dbgfs_create(ctrl, i2c_msm_dbgfs_map);
-}
 
-static void i2c_msm_dbgfs_teardown(struct i2c_msm_ctrl *ctrl)
-{
-	if (ctrl->dbgfs.root)
-		debugfs_remove_recursive(ctrl->dbgfs.root);
-}
-#else
-static void i2c_msm_dbgfs_init(struct i2c_msm_ctrl *ctrl) {}
-static void i2c_msm_dbgfs_teardown(struct i2c_msm_ctrl *ctrl) {}
-#endif
 
 static void i2c_msm_pm_suspend(struct device *dev)
 {
 	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
 
-	if (ctrl->pwr_state == MSM_I2C_PM_SUSPENDED) {
+	if (ctrl->pwr_state == I2C_MSM_PM_RT_SUSPENDED) {
 		dev_err(ctrl->dev, "attempt to suspend when suspended\n");
 		return;
 	}
 	i2c_msm_dbg(ctrl, MSM_DBG, "suspending...");
 	i2c_msm_pm_pinctrl_state(ctrl, false);
 	i2c_msm_clk_path_unvote(ctrl);
-	ctrl->pwr_state = MSM_I2C_PM_SUSPENDED;
+
+	/*
+	 * We implement system and runtime suspend in the same way. However
+	 * it is important for us to distinguish between them in when servicing
+	 * a transfer requests. If we get transfer request while in runtime
+	 * suspend we want to simply wake up and service that request. But if we
+	 * get a transfer request while system is suspending we want to bail
+	 * out on that request. This is why if we marked that we are in system
+	 * suspend, we do not want to override that state with runtime suspend.
+	 */
+	if (ctrl->pwr_state != I2C_MSM_PM_SYS_SUSPENDED)
+		ctrl->pwr_state = I2C_MSM_PM_RT_SUSPENDED;
 	return;
 }
 
@@ -3932,14 +2910,14 @@
 {
 	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
 
-	if (ctrl->pwr_state == MSM_I2C_PM_ACTIVE)
+	if (ctrl->pwr_state == I2C_MSM_PM_RT_ACTIVE)
 		return 0;
 
 	i2c_msm_dbg(ctrl, MSM_DBG, "resuming...");
 
 	i2c_msm_clk_path_vote(ctrl);
 	i2c_msm_pm_pinctrl_state(ctrl, true);
-	ctrl->pwr_state = MSM_I2C_PM_ACTIVE;
+	ctrl->pwr_state = I2C_MSM_PM_RT_ACTIVE;
 	return 0;
 }
 
@@ -3951,15 +2929,16 @@
 {
 	int ret = 0;
 	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
-	enum msm_i2c_power_state prev_state = ctrl->pwr_state;
+	enum i2c_msm_power_state prev_state = ctrl->pwr_state;
 	i2c_msm_dbg(ctrl, MSM_DBG, "pm_sys_noirq: suspending...");
 
 	/* Acquire mutex to ensure current transaction is over */
 	mutex_lock(&ctrl->xfer.mtx);
-	ctrl->pwr_state = MSM_I2C_PM_SYS_SUSPENDED;
+	ctrl->pwr_state = I2C_MSM_PM_SYS_SUSPENDED;
 	mutex_unlock(&ctrl->xfer.mtx);
+	i2c_msm_dbg(ctrl, MSM_DBG, "pm_sys_noirq: suspending...");
 
-	if (prev_state == MSM_I2C_PM_ACTIVE) {
+	if (prev_state == I2C_MSM_PM_RT_ACTIVE) {
 		i2c_msm_pm_suspend(dev);
 		/*
 		 * Synchronize runtime-pm and system-pm states:
@@ -3985,7 +2964,7 @@
 	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
 	i2c_msm_dbg(ctrl, MSM_DBG, "pm_sys_noirq: resuming...");
 	mutex_lock(&ctrl->xfer.mtx);
-	ctrl->pwr_state = MSM_I2C_PM_SUSPENDED;
+	ctrl->pwr_state = I2C_MSM_PM_RT_SUSPENDED;
 	mutex_unlock(&ctrl->xfer.mtx);
 	return  0;
 }
@@ -4030,13 +3009,10 @@
 #endif
 
 static const struct dev_pm_ops i2c_msm_pm_ops = {
-#ifdef CONFIG_PM_SLEEP
 	.suspend_noirq		= i2c_msm_pm_sys_suspend_noirq,
 	.resume_noirq		= i2c_msm_pm_sys_resume_noirq,
-#endif
-	SET_RUNTIME_PM_OPS(i2c_msm_pm_rt_suspend,
-			   i2c_msm_pm_rt_resume,
-			   NULL)
+	.runtime_suspend	= i2c_msm_pm_rt_suspend,
+	.runtime_resume		= i2c_msm_pm_rt_resume,
 };
 
 static u32 i2c_msm_frmwrk_func(struct i2c_adapter *adap)
@@ -4094,7 +3070,7 @@
 	ctrl->dbgfs.dbg_lvl         = DEFAULT_DBG_LVL;
 	ctrl->dbgfs.force_xfer_mode = I2C_MSM_XFER_MODE_NONE;
 	mutex_init(&ctrl->xfer.mtx);
-	ctrl->pwr_state = MSM_I2C_PM_SUSPENDED;
+	ctrl->pwr_state = I2C_MSM_PM_RT_SUSPENDED;
 
 	if (!pdev->dev.of_node) {
 		dev_err(&pdev->dev, "error: null device-tree node");
@@ -4124,18 +3100,11 @@
 		goto clk_err;
 	}
 
-	ret = i2c_msm_ctrl_ver_detect_and_set(ctrl);
-	if (ret) {
-		i2c_msm_pm_clk_disable_unprepare(ctrl);
-		i2c_msm_clk_path_unvote(ctrl);
-		goto ver_err;
-	}
-
 	/*
 	 * reset the core before registering for interrupts. This solves an
 	 * interrupt storm issue when the bootloader leaves a pending interrupt.
 	 */
-	ret = (*ctrl->ver.reset)(ctrl);
+	ret = i2c_msm_qup_sw_reset(ctrl);
 	if (ret)
 		dev_err(ctrl->dev, "error error on qup software reset\n");
 
@@ -4152,7 +3121,7 @@
 	if (ret)
 		goto irq_err;
 
-	ret = (*ctrl->ver.init_rsrcs)(pdev, ctrl);
+	ret = i2c_msm_qup_rsrcs_init(pdev, ctrl);
 	if (ret)
 		goto rcrcs_err;
 
@@ -4170,9 +3139,8 @@
 rcrcs_err:
 	i2c_msm_rsrcs_irq_teardown(ctrl);
 irq_err:
-	(*ctrl->ver.destroy)(ctrl);
+	i2x_msm_blk_free_cache(ctrl);
 err_no_pinctrl:
-ver_err:
 	i2c_msm_rsrcs_clk_teardown(ctrl);
 clk_err:
 	i2c_msm_rsrcs_mem_teardown(ctrl);
@@ -4188,7 +3156,7 @@
 
 	/* Grab mutex to ensure ongoing transaction is over */
 	mutex_lock(&ctrl->xfer.mtx);
-	ctrl->pwr_state = MSM_I2C_PM_SYS_SUSPENDED;
+	ctrl->pwr_state = I2C_MSM_PM_SYS_SUSPENDED;
 	pm_runtime_disable(ctrl->dev);
 	/* no one can call a xfer after the next line */
 	i2c_msm_frmwrk_unreg(ctrl);
@@ -4196,15 +3164,13 @@
 	mutex_destroy(&ctrl->xfer.mtx);
 
 	/*
-	 * free version related resources.
 	 * Currently only BAM resources need to be freed
 	 */
-	(*ctrl->ver.teardown)(ctrl);
 	i2c_msm_dbgfs_teardown(ctrl);
 	i2c_msm_rsrcs_irq_teardown(ctrl);
 	i2c_msm_rsrcs_clk_teardown(ctrl);
 	i2c_msm_rsrcs_mem_teardown(ctrl);
-	(*ctrl->ver.destroy)(ctrl);
+	i2x_msm_blk_free_cache(ctrl);
 	return 0;
 }
 
diff -Naur -x .git --no-dereference linux/drivers/i2c/busses/i2c-msm-v2.h linux-3.14/drivers/i2c/busses/i2c-msm-v2.h
--- linux/drivers/i2c/busses/i2c-msm-v2.h	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/i2c/busses/i2c-msm-v2.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,679 +0,0 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-/*
- * I2C controller driver for Qualcomm MSM platforms
- */
-
-#ifndef _I2C_MSM_V2_H
-#define _I2C_MSM_V2_H
-
-#include <linux/bitops.h>
-
-enum msm_i2_debug_level {
-	MSM_ERR,	/* Error messages only. Always on */
-	MSM_PROF,	/* High level events. Use for profiling */
-	MSM_DBG,	/* Low level details. Use for debugging */
-};
-
-#define i2c_msm_dbg(ctrl, dbg_level, fmt, ...) do {\
-		if (ctrl->dbgfs.dbg_lvl >= dbg_level)\
-			dev_info(ctrl->dev, pr_fmt(fmt), ##__VA_ARGS__);\
-	} while (0)
-
-#define BIT_IS_SET(val, idx)        ((val >> idx) & 0x1)
-#define BITS_AT(val, idx, n_bits)(((val) & (((1 << n_bits) - 1) << idx)) >> idx)
-#define MASK_IS_SET(val, mask)      ((val & mask) == mask)
-#define MASK_IS_SET_BOOL(val, mask) (MASK_IS_SET(val, mask) ? 1 : 0)
-#define KHz(freq) (1000 * freq)
-
-/* QUP Registers */
-enum {
-	QUP_CONFIG              = 0x0,
-	QUP_STATE               = 0x4,
-	QUP_IO_MODES            = 0x8,
-	QUP_SW_RESET            = 0xC,
-	QUP_OPERATIONAL         = 0x18,
-	QUP_ERROR_FLAGS         = 0x1C,
-	QUP_ERROR_FLAGS_EN      = 0x20,
-	QUP_TEST_CTRL           = 0x24,
-	QUP_OPERATIONAL_MASK    = 0x28,
-	QUP_HW_VERSION          = 0x30,
-	QUP_MX_READ_COUNT       = 0x208,
-	QUP_MX_WRITE_COUNT      = 0x150,
-	QUP_MX_OUTPUT_COUNT     = 0x100,
-	QUP_MX_INPUT_COUNT      = 0x200,
-	QUP_MX_WR_CNT           = 0x100,
-	QUP_OUT_DEBUG           = 0x108,
-	QUP_OUT_FIFO_CNT        = 0x10C,
-	QUP_OUT_FIFO_BASE       = 0x110,
-	QUP_IN_READ_CUR         = 0x20C,
-	QUP_IN_DEBUG            = 0x210,
-	QUP_IN_FIFO_CNT         = 0x214,
-	QUP_IN_FIFO_BASE        = 0x218,
-	QUP_I2C_MASTER_CLK_CTL  = 0x400,
-	QUP_I2C_STATUS          = 0x404,
-	QUP_I2C_MASTER_CONFIG   = 0x408,
-	QUP_I2C_MASTER_BUS_CLR  = 0x40C,
-};
-
-/* Register:QUP_STATE state field values */
-enum i2c_msm_qup_state {
-	QUP_STATE_RESET         = 0,
-	QUP_STATE_RUN           = 1U,
-	QUP_STATE_PAUSE         = 3U,
-};
-
-/* Register:QUP_STATE fields */
-enum {
-	QUP_STATE_MASK          = 3U,
-	QUP_STATE_VALID         = 1U << 2,
-	QUP_I2C_MAST_GEN        = 1U << 4,
-	QUP_I2C_FLUSH           = 1U << 6,
-	QUP_I2C_STATUS_RESET    = 0x42,
-};
-
-
-/* Register:QUP_CONFIG fields */
-enum {
-	QUP_MINI_CORE_MASK      = 0xF00,
-	QUP_MINI_CORE_I2C_VAL   = 0x200,
-	QUP_N_MASK              = 0x1F,
-	QUP_N_VAL               = 0x7, /* 0xF for A family */
-	QUP_NO_OUPUT            = 1U << 6,
-	QUP_NO_INPUT            = 1U << 7,
-	QUP_APP_CLK_ON_EN       = 1U << 12,
-	QUP_CORE_CLK_ON_EN      = 1U << 13,
-	QUP_FIFO_CLK_GATE_EN    = 1U << 14,
-};
-
-/* Register:QUP_OPERATIONAL fields */
-enum {
-	QUP_INPUT_FIFO_NOT_EMPTY = 1U << 5,
-	QUP_OUTPUT_SERVICE_FLAG  = 1U << 8,
-	QUP_INPUT_SERVICE_FLAG   = 1U << 9,
-	QUP_MAX_OUTPUT_DONE_FLAG = 1U << 10,
-	QUP_MAX_INPUT_DONE_FLAG  = 1U << 11,
-	QUP_OUT_BLOCK_WRITE_REQ  = BIT(12),
-	QUP_IN_BLOCK_READ_REQ    = BIT(13),
-};
-
-/* Register:QUP_OPERATIONAL_MASK fields */
-enum {
-	QUP_INPUT_SERVICE_MASK  = 1U << 9,
-	QUP_OUTPUT_SERVICE_MASK = 1U << 8,
-};
-
-/* Register:QUP_IO_MODES fields */
-enum {
-	QUP_OUTPUT_MODE         = 3U << 10,
-	QUP_INPUT_MODE          = 3U << 12,
-	QUP_UNPACK_EN           = 1U << 14,
-	QUP_PACK_EN             = 1U << 15,
-	QUP_OUTPUT_BIT_SHIFT_EN = 1U << 16,
-};
-
-/* Register:QUP_I2C_STATUS (a.k.a I2C_MASTER_STATUS) fields */
-enum {
-	QUP_BUS_ERROR           = 1U << 2,
-	QUP_PACKET_NACKED       = 1U << 3,
-	QUP_ARB_LOST            = 1U << 4,
-	QUP_INVALID_WRITE	= 1U << 5,
-	QUP_FAILED		= 3U << 6,
-	QUP_BUS_ACTIVE          = 1U << 8,
-	QUP_BUS_MASTER          = 1U << 9,
-	QUP_INVALID_TAG         = 1U << 23,
-	QUP_INVALID_READ_ADDR   = 1U << 24,
-	QUP_INVALID_READ_SEQ    = 1U << 25,
-	QUP_I2C_SDA             = 1U << 26,
-	QUP_I2C_SCL             = 1U << 27,
-	QUP_MSTR_STTS_ERR_MASK  = 0x38000FC,
-};
-
-/* Register:QUP_I2C_MASTER_CONFIG fields */
-enum {
-	QUP_EN_VERSION_TWO_TAG  = 1U,
-};
-
-enum {
-	I2C_MSM_CLK_FAST_MAX_FREQ    = 1000000,
-	I2C_MSM_CLK_HIGH_MAX_FREQ    = 3400000,
-};
-
-/* Register:QUP_I2C_MASTER_CLK_CTL field setters */
-#define I2C_MSM_SCL_NOISE_REJECTION(reg_val, noise_rej_val) \
-		(((reg_val) & ~(0x3 << 24)) | (((noise_rej_val) & 0x3) << 24))
-#define I2C_MSM_SDA_NOISE_REJECTION(reg_val, noise_rej_val) \
-		(((reg_val) & ~(0x3 << 26)) | (((noise_rej_val) & 0x3) << 26))
-
-/* Register:QUP_ERROR_FLAGS_EN flags */
-enum {
-	QUP_OUTPUT_OVER_RUN_ERR_EN  = 1U << 5,
-	QUP_INPUT_UNDER_RUN_ERR_EN  = 1U << 4,
-	QUP_OUTPUT_UNDER_RUN_ERR_EN = 1U << 3,
-	QUP_INPUT_OVER_RUN_ERR_EN   = 1U << 2,
-};
-
-/* Status, Error flags */
-enum {
-	I2C_STATUS_WR_BUFFER_FULL  = 1U << 0,
-	I2C_STATUS_BUS_ACTIVE      = 1U << 8,
-	I2C_STATUS_BUS_MASTER      = 1U << 9,
-	I2C_STATUS_ERROR_MASK      = 0x38000FC,
-	QUP_I2C_NACK_FLAG          = 1U << 3,
-	QUP_IN_NOT_EMPTY           = 1U << 5,
-	QUP_ERR_FLGS_MASK           = 0x3C,
-};
-
-/* Master status clock states */
-enum {
-	I2C_CLK_RESET_BUSIDLE_STATE = 0,
-	I2C_CLK_FORCED_LOW_STATE    = 5,
-};
-
-/* Controller's hardware versions */
-enum i2c_msm_ctrl_ver_num {
-	/* Values local to this driver */
-	I2C_MSM_CTRL_VER_UNKNOWN = 0,
-	I2C_MSM_CTRL_VER_A,
-	I2C_MSM_CTRL_VER_B,
-	/* Values to compare against HW registers */
-	I2C_MSM_CTRL_VER_B_MIN   = 0X20010000,
-	I2C_MSM_CTRL_VER_B_V1    = 0X20010001,
-	I2C_MSM_CTRL_VER_B_V2    = 0X20020000,
-	I2C_MSM_CTRL_VER_B_MAX   = 0X30000000,
-};
-
-/* Controller's power state */
-enum msm_i2c_power_state {
-	MSM_I2C_PM_ACTIVE,
-	MSM_I2C_PM_SUSPENDED,
-	MSM_I2C_PM_SYS_SUSPENDED
-};
-
-/*
- * The max buffer size required for tags is for holding the following sequence:
- * [start | hs-addr] + [start | slv-addr] + [ rd/wr | len]
- * which sum up to 6 bytes. However, we use u64 to hold the value, thus we say
- * that max length is 8 bytes.
- */
-#define I2C_MSM_TAG2_MAX_LEN            (8)
-#define I2C_MSM_BAM_CONS_SZ             (64) /* consumer pipe n entries */
-#define I2C_MSM_BAM_PROD_SZ             (32) /* producer pipe n entries */
-#define I2C_MSM_BAM_DESC_ARR_SIZ  (I2C_MSM_BAM_CONS_SZ + I2C_MSM_BAM_PROD_SZ)
-#define I2C_MSM_REG_2_STR_BUF_SZ        (128)
-/* Optimal value to hold the error strings */
-#define I2C_MSM_MAX_ERR_BUF_SZ		(256)
-#define I2C_MSM_BUF_DUMP_MAX_BC         (20)
-#define I2C_MSM_MAX_POLL_MSEC           (100)
-#define I2C_MSM_TIMEOUT_SAFTY_COEF      (10)
-#define I2C_MSM_TIMEOUT_MIN_USEC        (500000)
-#define I2C_MSM_HS_ADDR                 (0x0f)
-#define I2C_QUP_MAX_BUS_RECOVERY_RETRY  (10)
-
-/* QUP v2 tags */
-#define QUP_TAG2_DATA_WRITE        (0x82ULL)
-#define QUP_TAG2_DATA_WRITE_N_STOP (0x83ULL)
-#define QUP_TAG2_DATA_READ         (0x85ULL)
-#define QUP_TAG2_DATA_READ_N_STOP  (0x87ULL)
-#define QUP_TAG2_START             (0x81ULL)
-#define QUP_TAG2_DATA_READ_N_NACK  (0x86ULL)
-#define QUP_TAG2_START_STOP        (0x8AULL)
-#define QUP_TAG2_INPUT_EOT         (0x93ULL)
-#define QUP_TAG2_FLUSH_STOP        (0x96ULL)
-/* Aggregate the constatnt values of HS start sequence */
-#define QUP_TAG2_START_HS  (QUP_TAG2_START | (I2C_MSM_HS_ADDR << 8) | \
-			   (QUP_TAG2_START << 16))
-
-enum msm_spi_clk_path_vec_idx {
-	I2C_MSM_CLK_PATH_SUSPEND_VEC,
-	I2C_MSM_CLK_PATH_RESUME_VEC,
-};
-#define I2C_MSM_CLK_PATH_AVRG_BW(ctrl) (0)
-#define I2C_MSM_CLK_PATH_BRST_BW(ctrl) (76800000)
-
-static char const * const i2c_msm_gpio_names[] = {"i2c_clk", "i2c_sda"};
-
-enum i2c_msm_gpio_name_idx {
-	I2C_MSM_GPIO_SCL,
-	I2C_MSM_GPIO_SDA,
-};
-
-struct i2c_msm_ctrl;
-
-/*
- * i2c_msm_xfer_mode: transfer modes such as FIFO and BAM define these callbacks
- */
-struct i2c_msm_xfer_mode {
-	void                     (*teardown)(struct i2c_msm_ctrl *);
-	int                      (*xfer)    (struct i2c_msm_ctrl *);
-};
-
-/*
- *  i2c_msm_dma_mem: utility struct which holds both physical and virtual addr
- */
-struct i2c_msm_dma_mem {
-	dma_addr_t               phy_addr;
-	void                    *vrtl_addr;
-};
-
-/*
- * i2c_msm_tag: tag's data and its length.
- *
- * @len tag len can be two, four or six bytes.
- */
-struct i2c_msm_tag {
-	u64                    val;
-	int                    len;
-};
-
-/*
- * i2c_msm_bam_tag: similar to struct i2c_msm_tag but holds physical address.
- *
- * @buf physical address of entry in the tag_arr of
- *          struct i2c_msm_xfer_mode_bam
- * @len tag len.
- *
- * Hold the information from i2c_msm_bam_xfer_prepare() which is used by
- * i2c_msm_bam_xfer_process() and freed by i2c_msm_bam_xfer_unprepare()
- */
-struct i2c_msm_bam_tag {
-	dma_addr_t             buf;
-	size_t                 len;
-};
-
-/*
- * i2c_msm_bam_buf: dma mapped pointer to i2c_msg data buffer and related tag
- * @vir_addr ptr to i2c_msg buf beginning or with offset (when buf len > 256)
- */
-struct i2c_msm_bam_buf {
-	struct i2c_msm_dma_mem   ptr;
-	enum dma_data_direction  dma_dir;
-	size_t                   len;
-	bool                     is_rx;
-	bool                     is_last;
-	struct i2c_msm_bam_tag   tag;
-};
-
-/*
- * i2c_msm_bam_pipe: per pipe info
- *
- * @is_init true when the pipe is initialized and requires eventual teardown.
- * @name pipe name (consumer/producer) for debugging.
- * @desc_cnt_max size of descriptors space
- * @desc_cnt_cur number of occupied descriptors
- */
-struct i2c_msm_bam_pipe {
-	bool                     is_init;
-	struct sps_pipe         *handle;
-	struct sps_connect       config;
-	const char              *name;
-	size_t                   desc_cnt_max;
-	size_t                   desc_cnt_cur;
-};
-
-enum i2c_msm_bam_pipe_dir {
-	I2C_MSM_BAM_CONS = 0,
-	I2C_MSM_BAM_PROD = 1,
-};
-
-static const char * const i2c_msm_bam_pipe_name[] = {"consumer", "producer"};
-
-/*
- * struct i2c_msm_xfer_mode_bam: bam mode configuration and work space
- *
- * @is_init true when BAM and its pipes are fully initialized.
- * @is_core_init true when BAM core is initialised.
- * @ops     "base class" of i2c_msm_xfer_mode_bam. Contains the operations while
- *          the rest of the fields contain the data.
- * @deregister_required deregister is required when this driver has registerd
- *          the BAM device. When another kernel module has registered BAM
- *          prior to this driver, then deregister is not required.
- * @buf_arr_cnt current number of vaid buffers in buf_arr. The valid buffers
- *          are at index 0..buf_arr_cnt excluding buf_arr_cnt.
- * @buf_arr array of descriptors which point to the user's buffer
- *     virtual and physical address, and hold meta data about the buffer
- *     and respective tag.
- * @tag_arr array of tags in DMAable memory. Holds a tag per buffer of the same
- *          index, that is tag_arr[i] is related to buf_arr[i]. Also, tag_arr[i]
- *          is queued in the consumer pipe just befor buf_arr[i] is queued in
- *          the consumer (output buf) or producer pipe (input buffer).
- * @eot_n_flush_stop_tags EOT and flush-stop tags to be queued to the consumer
- *          bam pipe after the last transfer when it is a read.
- * @input_tag hw is placing input tags in the producer pipe on read operations.
- *          The value of these tags is "don't care" from bam transfer
- *          perspective. Thus, this single buffer is used for all the input
- *          tags. The field is used as write only.
- * @mem pointer to platform data describing the BAM's register space.
- */
-struct i2c_msm_xfer_mode_bam {
-	struct i2c_msm_xfer_mode ops;
-	bool                     is_init;
-	bool                     is_core_init;
-	bool                     deregister_required;
-
-	size_t                   buf_arr_cnt;
-	struct i2c_msm_bam_buf   buf_arr[I2C_MSM_BAM_DESC_ARR_SIZ];
-	struct i2c_msm_dma_mem   tag_arr;
-	struct i2c_msm_dma_mem   eot_n_flush_stop_tags;
-	struct i2c_msm_dma_mem   input_tag;
-
-	struct resource         *mem;
-	void __iomem            *base;
-	ulong                    handle;
-	int                      irq;
-	struct i2c_msm_bam_pipe  pipe[2];
-};
-
-/*
- * I2C_MSM_BAM_TAG_MEM_SZ includes the following fields of
- * struct i2c_msm_xfer_mode_bam (in order):
- *
- * Buffer of DMA memory:
- * +-----------+---------+-----------+-----------+----+-----------+
- * | input_tag | eot_... | tag_arr 0 | tag_arr 1 | .. | tag_arr n |
- * +-----------+---------+-----------+-----------+----+-----------+
- *
- * I2C_MSM_TAG2_MAX_LEN bytes for input_tag
- * I2C_MSM_TAG2_MAX_LEN bytes for eot_n_flush_stop_tags
- * I2C_MSM_BAM_DESC_ARR_SIZ * I2C_MSM_TAG2_MAX_LEN bytes for tag_arr
- */
-#define I2C_MSM_BAM_TAG_MEM_SZ  \
-	((I2C_MSM_BAM_DESC_ARR_SIZ + 2) * I2C_MSM_TAG2_MAX_LEN)
-
-/*
- * i2c_msm_xfer_mode_fifo: operations and state of FIFO mode
- *
- * @ops     "base class" of i2c_msm_xfer_mode_bam. Contains the operations while
- *          the rest of the fields contain the data.
- * @input_fifo_sz input fifo size in bytes
- * @output_fifo_sz output fifo size in bytes
- * @tx_bc   keeps track of number of bytes written to fifo per client request
- * @rx_bc   keeps track of number of bytes read from fifo per client request
- * @in_rem  remaining u32 entries in input FIFO before empty
- * @out_rem remaining u32 entries in output FIFO before full
- * @out_buf buffer for collecting bytes to four bytes groups (u32) before
- *          writing them to the output fifo.
- * @out_buf_idx next free index in out_buf. 0..3
- */
-struct i2c_msm_xfer_mode_fifo {
-	struct i2c_msm_xfer_mode ops;
-	size_t                   input_fifo_sz;
-	size_t                   output_fifo_sz;
-	size_t                   tx_bc;
-	size_t                   rx_bc;
-	size_t                   in_rem;
-	size_t                   out_rem;
-	u8                       out_buf[4];
-	int                      out_buf_idx;
-};
-
-/* i2c_msm_xfer_mode_blk: operations and state of Block mode
- *
- * @in_blk_sz size of input/rx block
- * @out_blk_sz size of output/tx block
- * @tx_cache internal buffer to store tx data
- * @rx_cache internal buffer to store rx data
- * @rx_cache_idx points to the next unread index in rx cache
- * @tx_cache_idx points to the next unwritten index in tx cache
- * @wait_rx_blk completion object to wait on for end of blk rx transfer.
- * @wait_tx_blk completion object to wait on for end of blk tx transfer.
- * @complete_mask applied to QUP_OPERATIONAL to determine when blk
- *  xfer is complete.
- */
-struct i2c_msm_xfer_mode_blk {
-	struct i2c_msm_xfer_mode ops;
-	size_t                   in_blk_sz;
-	size_t                   out_blk_sz;
-	u8                       *tx_cache;
-	u8                       *rx_cache;
-	int                      rx_cache_idx;
-	int                      tx_cache_idx;
-	struct completion        wait_rx_blk;
-	struct completion        wait_tx_blk;
-	u32                      complete_mask;
-};
-
-/* INPUT_MODE and OUTPUT_MODE filds of QUP_IO_MODES register */
-enum i2c_msm_xfer_mode_id {
-	I2C_MSM_XFER_MODE_FIFO,
-	I2C_MSM_XFER_MODE_BLOCK,
-	I2C_MSM_XFER_MODE_BAM,
-	I2C_MSM_XFER_MODE_NONE, /* keep last as a counter */
-};
-
-/*
- * i2c_msm_ctrl_ver: info that is different between i2c controller versions
- *
- * @destroy  Called once on exit.  Deallocate transfer modes
- * @init     Initialises the controller.
- * @teardown Teardown the controller and the transfer modes.
- * @reset    Reset the controller (SW reset)
- * @choose_mode    Chooses a transfer mode of the xfer_mode[].
- * @post_xfer      Steps to do after data transfer is done. It updates the error
- *                 value if needed, and waits until the HW is truly done.
- * @max_rx_cnt  Max bytes per transfer.
- * @max_tx_cnt Max bytes per transfer.
- * @max_buf_size   Number of bytes max between tags.
- * @msg_ovrhd_bc   Message overhead byte cnt = 4.
- * @buf_ovrhd_bc   Buffer  overhead byte cnt = 2.
- * @xfer_mode      Array of available transfer modes. struct i2c_msm_xfer_mode
- *                 is a "base class" to the particular transfer mode.
- */
-struct i2c_msm_ctrl_ver {
-	void			  (*destroy)    (struct i2c_msm_ctrl *);
-	int			  (*init)       (struct i2c_msm_ctrl *);
-	void			  (*teardown)   (struct i2c_msm_ctrl *);
-	int			  (*reset)      (struct i2c_msm_ctrl *);
-	int			  (*init_rsrcs) (struct platform_device *,
-						 struct i2c_msm_ctrl *);
-	enum i2c_msm_xfer_mode_id (*choose_mode)(struct i2c_msm_ctrl *);
-	int			  (*post_xfer)  (struct i2c_msm_ctrl *,
-								int err);
-
-	int			  max_rx_cnt;
-	int			  max_tx_cnt;
-	int			  max_buf_size;
-	int			  msg_ovrhd_bc;
-	int			  buf_ovrhd_bc;
-
-	struct i2c_msm_xfer_mode *xfer_mode[I2C_MSM_XFER_MODE_NONE];
-};
-
-struct i2c_msm_dbgfs {
-	struct dentry             *root;
-	enum msm_i2_debug_level    dbg_lvl;
-	enum i2c_msm_xfer_mode_id  force_xfer_mode;
-};
-
-/*
- * qup_i2c_clk_path_vote: data to use bus scaling driver for clock path vote
- *
- * @mstr_id master id number of the i2c core or its wrapper (BLSP/GSBI).
- *       When zero, clock path voting is disabled.
- * @client_hdl when zero, client is not registered with the bus scaling driver,
- *      and bus scaling functionality should not be used. When non zero, it
- *      is a bus scaling client id and may be used to vote for clock path.
- * @reg_err when true, registration error was detected and an error message was
- *      logged. i2c will attempt to re-register but will log error only once.
- *      once registration succeed, the flag is set to false.
- * @actv_only when set, votes when system active and removes the vote when
- *       system goes idle (optimises for performance). When unset, voting using
- *       runtime pm (optimizes for power).
- */
-struct qup_i2c_clk_path_vote {
-	u32                         mstr_id;
-	u32                         client_hdl;
-	struct msm_bus_scale_pdata *pdata;
-	bool                        reg_err;
-	bool                        actv_only;
-};
-
-/*
- * i2c_msm_resources: OS resources
- *
- * @mem  I2C controller memory resource from platform data.
- * @base I2C controller virtual base address
- * @clk_freq_in core clock frequency in Hz
- * @clk_freq_out bus clock frequency in Hz
- * @bam_pipe_idx_cons index of BAM's consumer pipe
- * @bam_pipe_idx_prod index of BAM's producer pipe
- */
-struct i2c_msm_resources {
-	struct resource             *mem;
-	void __iomem                *base; /* virtual */
-	struct clk                  *core_clk;
-	struct clk                  *iface_clk;
-	int                          clk_freq_in;
-	int                          clk_freq_out;
-	struct qup_i2c_clk_path_vote clk_path_vote;
-	int                          irq;
-	bool                         disable_dma;
-	u32                          bam_pipe_idx_cons;
-	u32                          bam_pipe_idx_prod;
-	struct pinctrl              *pinctrl;
-	struct pinctrl_state        *gpio_state_active;
-	struct pinctrl_state        *gpio_state_suspend;
-};
-
-#define I2C_MSM_PINCTRL_ACTIVE       "i2c_active"
-#define I2C_MSM_PINCTRL_SUSPEND        "i2c_sleep"
-
-/*
- * i2c_msm_xfer_buf: current xfer position and preprocessed tags
- *
- * @is_init the buf is marked initialized by the first call to
- *          i2c_msm_xfer_next_buf()
- * @msg_idx   index of the message that the buffer is pointing to
- * @byte_idx  index of first byte in the current buffer
- * @prcsed_bc count of bytes processed from the current message. This value
- *            is compared against len to find out if buffer is done processing.
- * @len       number of bytes in current buffer.
- * @is_rx when true, current buffer is pointing to a i2c read operation.
- * @slv_addr 8 bit address. This is the i2c_msg->addr + rd/wr bit.
- *
- * Keep track of current position in the client's transfer request and
- * pre-process a transfer's buffer and tags.
- */
-struct i2c_msm_xfer_buf {
-	bool                       is_init;
-	int                        msg_idx;
-	size_t                     byte_idx;
-	size_t                     prcsed_bc;
-	size_t                     len;
-	bool                       is_rx;
-	bool                       is_last;
-	u16                        slv_addr;
-	struct i2c_msm_tag         in_tag;
-	struct i2c_msm_tag         out_tag;
-};
-
-#ifdef DEBUG
-#define I2C_MSM_PROF_MAX_EVNTS   (64)
-#else
-#define I2C_MSM_PROF_MAX_EVNTS   (16)
-#endif
-
-struct i2c_msm_prof_event;
-typedef void (*i2c_msm_prof_dump_func_func_t)(struct i2c_msm_ctrl *,
-			struct i2c_msm_prof_event *, size_t msec, size_t usec);
-/*
- * i2c_msm_prof_event: profiling event
- *
- * @data Additional data about the event. The interpretation of the data is
- *       dependant on the type field.
- * @type event type (see enum i2c_msm_prof_event_type)
- */
-struct i2c_msm_prof_event {
-	i2c_msm_prof_dump_func_func_t dump_func;
-	struct timespec time;
-	u64             data0;
-	u32             data1;
-	u32             data2;
-	u8              type;
-};
-
-enum i2c_msm_err_bit_field {
-	I2C_MSM_ERR_NACK = 0,
-	I2C_MSM_ERR_ARB_LOST,
-	I2C_MSM_ERR_BUS_ERR,
-	I2C_MSM_ERR_TIMEOUT,
-	I2C_MSM_ERR_CORE_CLK,
-	I2C_MSM_ERR_OVR_UNDR_RUN,
-	I2C_MSM_ERR_INVALID_WRITE,
-	I2C_MSM_ERR_INVALID_TAG,
-	I2C_MSM_ERR_INVALID_READ_ADDR,
-	I2C_MSM_ERR_INVALID_READ_SEQ,
-	I2C_MSM_ERR_FAILED,
-};
-
-/*
- * i2c_msm_xfer: A client transfer request. A list of one or more i2c messages
- *
- * @msgs         NULL when no active xfer. Points to array of i2c_msgs
- *               given by the client.
- * @msg_cnt      number of messages in msgs array.
- * @complete     completion object to wait on for end of transfer.
- * @rx_cnt       number of input  bytes in the client's request.
- * @tx_cnt       number of output bytes in the client's request.
- * @rx_ovrhd_cnt number of input  bytes due to tags.
- * @tx_ovrhd_cnt number of output bytes due to tags.
- * @event        profiling data. An array of timestamps of transfer events
- * @event_cnt    number of items in event array.
- * @is_active    true during xfer process and false after xfer end
- * @mtx          mutex to solve multithreaded problem in xfer
- */
-struct i2c_msm_xfer {
-	struct i2c_msg            *msgs;
-	int                        msg_cnt;
-	enum i2c_msm_xfer_mode_id  mode_id;
-	struct completion          complete;
-	size_t                     rx_cnt;
-	size_t                     tx_cnt;
-	size_t                     rx_ovrhd_cnt;
-	size_t                     tx_ovrhd_cnt;
-	struct i2c_msm_xfer_buf    cur_buf;
-	u32                        timeout;
-	bool                       last_is_rx;
-	enum i2c_msm_err_bit_field err;
-	struct i2c_msm_prof_event  event[I2C_MSM_PROF_MAX_EVNTS];
-	atomic_t                   event_cnt;
-	atomic_t                   is_active;
-	struct mutex               mtx;
-};
-
-/*
- * i2c_msm_ctrl: the driver's main struct
- *
- * @is_init true when
- * @ver info that is different between i2c controller versions
- * @ver_num  ha
- * @xfer     state of the currently processed transfer.
- * @dbgfs    debug-fs root and values that may be set via debug-fs.
- * @rsrcs    resources from platform data including clocks, gpios, irqs, and
- *           memory regions.
- * @pdata    the platform data (values from board-file or from device-tree)
- * @mstr_clk_ctl cached value for programming to mstr_clk_ctl register
- */
-struct i2c_msm_ctrl {
-	struct device             *dev;
-	struct i2c_adapter         adapter;
-	struct i2c_msm_ctrl_ver    ver;
-	struct i2c_msm_xfer        xfer;
-	struct i2c_msm_dbgfs       dbgfs;
-	struct i2c_msm_resources   rsrcs;
-	u32                        mstr_clk_ctl;
-	struct i2c_msm_v2_platform_data *pdata;
-	enum msm_i2c_power_state   pwr_state;
-};
-
-#endif  /* _I2C_MSM_V2_H */
diff -Naur -x .git --no-dereference linux/drivers/leds/leds-ipq40xx.c linux-3.14/drivers/leds/leds-ipq40xx.c
--- linux/drivers/leds/leds-ipq40xx.c	2016-04-18 10:49:05.000000000 +0800
+++ linux-3.14/drivers/leds/leds-ipq40xx.c	2016-09-01 11:52:03.000000000 +0800
@@ -157,7 +157,7 @@
 
 	cg_reg = (led_num / NUM_LED_IN_REG) + 1;
 
-	if (cg_reg > LEDC_CG4_OFFSET)
+	if (cg_reg > LEDC_CG4_OFFSET || !ledc_base_addr)
 		return -EINVAL;
 
 	val = readl(LEDC_ADDR(cg_reg));
diff -Naur -x .git --no-dereference linux/drivers/mmc/core/mmc.c linux-3.14/drivers/mmc/core/mmc.c
--- linux/drivers/mmc/core/mmc.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mmc/core/mmc.c	2016-09-01 11:52:04.000000000 +0800
@@ -293,13 +293,12 @@
 		}
 	}
 
+	/*
+	 * The EXT_CSD format is meant to be forward compatible. As long
+	 * as CSD_STRUCTURE does not change, all values for EXT_CSD_REV
+	 * are authorized, see JEDEC JESD84-B50 section B.8.
+	 */
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if (card->ext_csd.rev > 7) {
-		pr_err("%s: unrecognised EXT_CSD revision %d\n",
-			mmc_hostname(card->host), card->ext_csd.rev);
-		err = -EINVAL;
-		goto out;
-	}
 
 	card->ext_csd.raw_sectors[0] = ext_csd[EXT_CSD_SEC_CNT + 0];
 	card->ext_csd.raw_sectors[1] = ext_csd[EXT_CSD_SEC_CNT + 1];
diff -Naur -x .git --no-dereference linux/drivers/mmc/host/mmci.c linux-3.14/drivers/mmc/host/mmci.c
--- linux/drivers/mmc/host/mmci.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mmc/host/mmci.c	2016-09-01 11:52:04.000000000 +0800
@@ -22,6 +22,7 @@
 #include <linux/highmem.h>
 #include <linux/log2.h>
 #include <linux/mmc/pm.h>
+#include <linux/mmc/mmc.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/slot-gpio.h>
@@ -50,6 +51,10 @@
 
 #define DRIVER_NAME "mmci-pl18x"
 
+#define MMCI_DMA_CTRL_NONE	0x00
+#define MMCI_DMA_CTRL_RELEASE	0x01
+#define MMCI_DMA_CTRL_RESET	0x02
+
 static unsigned int fmax = 515633;
 
 static struct variant_data variant_arm = {
@@ -296,8 +301,8 @@
 
 		clk |= variant->clkreg_enable;
 		clk |= MCI_CLK_ENABLE;
-		/* Enable power save mode (needed for UHS card support) */
-		clk |= MCI_CLK_PWRSAVE;
+		/* This hasn't proven to be worthwhile */
+		/* clk |= MCI_CLK_PWRSAVE; */
 	}
 
 	/* Set actual clock for debug */
@@ -319,6 +324,21 @@
 	}
 
 #ifdef CONFIG_MMC_QCOM_TUNING
+	/*
+	 * Select the controller timing mode according
+	 * to current bus speed mode
+	 */
+	if ((desired > (100 * 1000 * 1000)) &&
+	     (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104)) {
+		/* Card clock frequency must be > 100MHz to enable tuning */
+		clk &= (~(MCI_QCOM_CLK_SELECT_IN_MASK));
+		clk |= MCI_QCOM_CLK_SELECT_IN_UHS;
+	}
+
+	/* Select free running MCLK as input clock of cm_dll_sdc4 */
+	clk &= (~(MCI_QCOM_CLK_SDC4_MCLK_SEL_MASK));
+	clk |= MCI_QCOM_CLK_SDC4_MCLK_SEL_FMCLK;
+
 	if (variant->qcom_uhs_gpio >= 0)
 		clk |= MCI_QCOM_IO_PAD_PWR_SWITCH;
 #endif /* CONFIG_MMC_QCOM_TUNING */
@@ -482,6 +502,28 @@
 	dma_unmap_sg(chan->device->dev, data->sg, data->sg_len, dir);
 }
 
+/**
+ *
+ * This function resets & restores DMA.
+ *
+ * This function should be called to recover from error
+ * conditions encountered during CMD/DATA tranfsers with card.
+ *
+ * @host - Pointer to driver's host structure
+ *
+ */
+static void mmci_dma_reset_and_restore(struct mmci_host *host)
+{
+	dev_dbg(mmc_dev(host->mmc), "Trying to reset & restore dma.\n");
+
+	if (host->dma_control)
+		mmci_dma_release(host);
+	if (host->dma_control == MMCI_DMA_CTRL_RESET)
+		mmci_dma_setup(host);
+
+	host->dma_control = MMCI_DMA_CTRL_NONE;
+}
+
 static void mmci_dma_finalize(struct mmci_host *host, struct mmc_data *data)
 {
 	u32 status;
@@ -516,7 +558,7 @@
 	 */
 	if (status & MCI_RXDATAAVLBLMASK) {
 		dev_err(mmc_dev(host->mmc), "buggy DMA detected. Taking evasive action.\n");
-		mmci_dma_release(host);
+		host->dma_control = MMCI_DMA_CTRL_RELEASE;
 	}
 
 	host->dma_current = NULL;
@@ -749,7 +791,8 @@
 	data->bytes_xfered = 0;
 
 #ifdef CONFIG_MMC_QCOM_TUNING
-	if (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50)
+	if ((host->mmc->ios.timing == MMC_TIMING_UHS_DDR50) ||
+		(host->mmc->ios.timing == MMC_TIMING_MMC_DDR52))
 		clks = (unsigned long long)data->timeout_ns *
 			(host->cclk / 2);
 	else
@@ -857,6 +900,33 @@
 		mmci_reg_delay(host);
 	}
 
+#ifdef CONFIG_MMC_QCOM_TUNING
+	/*
+	 * For open ended block read operation (without CMD23),
+	 * AUTO_CMD19 bit should be set while sending the READ command.
+	 * For close ended block read operation (with CMD23),
+	 * AUTO_CMD19 bit should be set while sending CMD23.
+	 */
+	if (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104) {
+		if ((cmd->opcode == MMC_SET_BLOCK_COUNT &&
+		   host->mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK) ||
+		   (!host->mrq->sbc && (cmd->opcode == MMC_READ_SINGLE_BLOCK ||
+		   cmd->opcode == MMC_READ_MULTIPLE_BLOCK))) {
+			mmci_enable_cdr_cm_sdc4_dll(host);
+			c |= cmd->opcode | MCI_CSPM_AUTO_CMD19;
+		}
+	}
+	if (cmd->mrq && cmd->mrq->data &&
+	    (cmd->mrq->data->flags & MMC_DATA_READ))
+		writel((readl(base + MCIDLL_CONFIG) | MCI_CDR_EN),
+		       base + MCIDLL_CONFIG);
+	else
+		/* Clear CDR_EN bit for non read operations */
+		writel((readl(base + MCIDLL_CONFIG) & ~MCI_CDR_EN),
+		       base + MCIDLL_CONFIG);
+	mmci_reg_delay(host);
+#endif
+
 	c |= cmd->opcode | MCI_CPSM_ENABLE;
 	if (cmd->flags & MMC_RSP_PRESENT) {
 		if (cmd->flags & MMC_RSP_136)
@@ -892,6 +962,13 @@
 		if (dma_inprogress(host)) {
 			mmci_dma_data_error(host);
 			mmci_dma_unmap(host, data);
+
+			/*
+			 * Delay the dma reset in thread context as
+			 * dma channel release APIs can be called
+			 * only from non-atomic context.
+			 */
+			host->dma_control = MMCI_DMA_CTRL_RESET;
 		}
 
 		/*
@@ -1003,6 +1080,7 @@
 			if (dma_inprogress(host)) {
 				mmci_dma_data_error(host);
 				mmci_dma_unmap(host, host->data);
+				host->dma_control = MMCI_DMA_CTRL_RESET;
 			}
 			mmci_stop_data(host);
 		}
@@ -1254,6 +1332,10 @@
 
 	WARN_ON(host->mrq != NULL);
 
+	/* check if dma needs to be reset */
+	if (host->dma_control)
+		mmci_dma_reset_and_restore(host);
+
 	mrq->cmd->error = mmci_validate_data(host, mrq->data);
 	if (mrq->cmd->error) {
 		mmc_request_done(mmc, mrq);
@@ -1366,6 +1448,18 @@
 	if (!ios->clock && variant->pwrreg_clkgate)
 		pwr &= ~MCI_PWR_ON;
 
+	if (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50 ||
+			host->mmc->ios.timing == MMC_TIMING_MMC_DDR52) {
+		u32 clk;
+
+		clk = readl(host->base + MMCICLOCK);
+		clk &= ~(0x7 << 14); /* clear SELECT_IN field */
+		clk |= (3 << 14); /* set DDR timing mode */
+		writel_relaxed(clk, host->base + MMCICLOCK);
+		mmci_reg_delay(host);
+		if (mmc->f_max < (ios->clock * 2))
+			ios->clock = mmc->f_max;
+	}
 	if (host->variant->explicit_mclk_control &&
 	    ios->clock != host->clock_cache) {
 		ret = clk_set_rate(host->clk, ios->clock);
@@ -1478,6 +1572,10 @@
 		mmc->caps |= MMC_CAP_MMC_HIGHSPEED;
 	if (of_get_property(np, "mmc-cap-sd-highspeed", NULL))
 		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
+	if (of_get_property(np, "sd-uhs-sdr104", NULL))
+		mmc->caps |= MMC_CAP_UHS_SDR104;
+	if (of_get_property(np, "mmc-ddr-1_8v", NULL))
+		mmc->caps |= MMC_CAP_1_8V_DDR;
 
 	return 0;
 }
diff -Naur -x .git --no-dereference linux/drivers/mmc/host/mmci.h linux-3.14/drivers/mmc/host/mmci.h
--- linux/drivers/mmc/host/mmci.h	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mmc/host/mmci.h	2016-09-01 11:52:04.000000000 +0800
@@ -48,8 +48,14 @@
 #define MCI_QCOM_IO_PAD_PWR_SWITCH	BIT(21)
 
 /* select in latch data and command in */
+#define MCI_QCOM_CLK_SELECT_IN_MASK	(BIT(16) | BIT(15) | BIT(14))
 #define MCI_QCOM_CLK_SELECT_IN_FBCLK	BIT(15)
 #define MCI_QCOM_CLK_SELECT_IN_DDR_MODE	(BIT(14) | BIT(15))
+#define MCI_QCOM_CLK_SELECT_IN_UHS	BIT(16)
+
+/* Select SDC4_MCLK_SEL */
+#define MCI_QCOM_CLK_SDC4_MCLK_SEL_MASK		(BIT(24) | BIT(23))
+#define MCI_QCOM_CLK_SDC4_MCLK_SEL_FMCLK	BIT(24)
 
 #define MMCIARGUMENT		0x008
 #define MMCICOMMAND		0x00c
@@ -58,6 +64,7 @@
 #define MCI_CPSM_INTERRUPT	(1 << 8)
 #define MCI_CPSM_PENDING	(1 << 9)
 #define MCI_CPSM_ENABLE		(1 << 10)
+#define MCI_CSPM_AUTO_CMD19     (1 << 16)
 /* Argument flag extenstions in the ST Micro versions */
 #define MCI_ST_SDIO_SUSP	(1 << 11)
 #define MCI_ST_ENCMD_COMPL	(1 << 12)
@@ -241,6 +248,7 @@
 
 	struct timer_list	timer;
 	unsigned int		oldstat;
+	unsigned int		dma_control;
 
 	/* pio stuff */
 	struct sg_mapping_iter	sg_miter;
diff -Naur -x .git --no-dereference linux/drivers/mmc/host/mmci_qcom_tuning.c linux-3.14/drivers/mmc/host/mmci_qcom_tuning.c
--- linux/drivers/mmc/host/mmci_qcom_tuning.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mmc/host/mmci_qcom_tuning.c	2016-09-01 11:52:04.000000000 +0800
@@ -190,10 +190,6 @@
 	}
 
 out:
-	/* re-enable PWRSAVE */
-	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
-			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
-	mmci_qtune_sync_reg_wr(host);
 	spin_unlock_irqrestore(&host->lock, flags);
 
 	return rc;
@@ -446,6 +442,52 @@
 	return ret;
 }
 
+/*
+ * Enable a CDR circuit in CM_SDC4_DLL block to enable automatic
+ * calibration sequence. This function should be called before
+ * enabling AUTO_CMD19 bit in MCI_CMD register for block read
+ * commands (CMD17/CMD18).
+ *
+ * This function gets called when host spinlock acquired.
+ */
+int mmci_enable_cdr_cm_sdc4_dll(struct mmci_host *host)
+{
+	int rc;
+	u32 config;
+
+	config = readl_relaxed(host->base + MCIDLL_CONFIG);
+	config |= MCI_CDR_EN;
+	config |= MCI_CDR_EXT_EN;
+	config &= ~MCI_CK_OUT_EN;
+	writel_relaxed(config, host->base + MCIDLL_CONFIG);
+
+	/* Wait until CK_OUT_EN bit of MCI_DLL_CONFIG register becomes '0' */
+	rc = mmci_qtune_dll_poll_ck_out_en(host, 0);
+	if (rc) {
+		pr_err("%s: %s: sdc4_dll config failed\n",
+		       mmc_hostname(host->mmc), __func__);
+		return rc;
+	}
+
+	/* Set CK_OUT_EN bit of MCI_DLL_CONFIG register to 1. */
+	writel_relaxed((readl_relaxed(host->base + MCIDLL_CONFIG)
+			| MCI_CK_OUT_EN), host->base + MCIDLL_CONFIG);
+
+	/* Wait until CK_OUT_EN bit of MCI_DLL_CONFIG register becomes '1' */
+	rc = mmci_qtune_dll_poll_ck_out_en(host, 1);
+	if (rc)
+		goto err_out;
+
+	goto out;
+
+err_out:
+	pr_err("%s: %s: Enabling sdc4_dll failed\n",
+	       mmc_hostname(host->mmc), __func__);
+out:
+	return rc;
+}
+
+
 int mmci_qtune_execute_tuning(struct mmc_host *mmc, u32 opcode)
 {
 	int rc = 0;
@@ -624,6 +666,7 @@
 	/* Wait 5 ms for the voltage regulater in the card to become stable. */
 	usleep_range(5000, 5500);
 
+out:
 	spin_lock_irqsave(&host->lock, flags);
 	/* Disable PWRSAVE would make sure that SD CLK is always running */
 	writel_relaxed((readl_relaxed(host->base + MMCICLOCK)
@@ -639,13 +682,6 @@
 	 */
 	usleep_range(1000, 1500);
 
-	spin_lock_irqsave(&host->lock, flags);
-	/* Enable PWRSAVE */
-	writel_relaxed((readl_relaxed(host->base + MMCICLOCK) |
-			MCI_CLK_PWRSAVE), host->base + MMCICLOCK);
-	udelay(30);
-	spin_unlock_irqrestore(&host->lock, flags);
-out:
 	return rc;
 }
 
diff -Naur -x .git --no-dereference linux/drivers/mmc/host/mmci_qcom_tuning.h linux-3.14/drivers/mmc/host/mmci_qcom_tuning.h
--- linux/drivers/mmc/host/mmci_qcom_tuning.h	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mmc/host/mmci_qcom_tuning.h	2016-09-01 11:52:04.000000000 +0800
@@ -56,5 +56,6 @@
 void mmci_qcom_ddr_tuning(struct mmci_host *host);
 int mmci_qcom_set_uhs_gpio(struct mmc_host *mmc, unsigned int val);
 int mmci_qtune_init(struct mmci_host *host, struct device_node *np);
+int mmci_enable_cdr_cm_sdc4_dll(struct mmci_host *host);
 
 #endif /* __MMCI_QCOM_TUNING_H_ */
diff -Naur -x .git --no-dereference linux/drivers/mtd/devices/m25p80.c linux-3.14/drivers/mtd/devices/m25p80.c
--- linux/drivers/mtd/devices/m25p80.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mtd/devices/m25p80.c	2016-09-01 11:52:04.000000000 +0800
@@ -924,6 +924,7 @@
 	{ "gd25q64", INFO(0xc84017, 0, 64 * 1024, 128, SECT_4K) },
 	{ "gd25q16", INFO(0xc84015, 0, 64 * 1024, 32, SECT_4K) },
 	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, SECT_4K) },
+	{ "gd25q256", INFO(0xc84019, 0, 64 * 1024, 512, SECT_4K) },
 
 	/* Intel/Numonyx -- xxxs33b */
 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
diff -Naur -x .git --no-dereference linux/drivers/mtd/devices/msm_qpic_nand.c linux-3.14/drivers/mtd/devices/msm_qpic_nand.c
--- linux/drivers/mtd/devices/msm_qpic_nand.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mtd/devices/msm_qpic_nand.c	2016-09-01 11:52:04.000000000 +0800
@@ -1444,6 +1444,7 @@
 	loff_t offset;
 	size_t len;
 	size_t actual_len, ret_len;
+	int ecc_status = 0;
 
 	actual_len = ops->len;
 	ret_len = 0;
@@ -1477,7 +1478,22 @@
 
 		ops->datbuf = no_copy ? actual_buf : bounce_buf;
 		err = msm_nand_read_oob(mtd, aligned_from, ops);
+
+		/*
+		 * If current error is EBADMSG or EUCLEAN then store this error
+		 * in ecc_status and continue the reading of data. This
+		 * ecc_status will be checked before returning from this
+		 * function and the same will be returned if it is non zero.
+		 */
+		if ((err == -EBADMSG) || (err == -EUCLEAN)) {
+			if (ecc_status != -EBADMSG)
+				ecc_status = err;
+
+			err = 0;
+		}
+
 		if (err < 0) {
+			ecc_status = 0;
 			ret_len = ops->retlen;
 			break;
 		}
@@ -1499,6 +1515,9 @@
 	ops->retlen = ret_len;
 	kfree(bounce_buf);
 out:
+	if (ecc_status)
+		err = ecc_status;
+
 	return err;
 }
 
@@ -1512,6 +1531,7 @@
 	int ret;
 	struct mtd_oob_ops ops;
 	unsigned char *bounce_buf = NULL;
+	int ecc_status = 0;
 
 	ops.mode = MTD_OPS_AUTO_OOB;
 	ops.retlen = 0;
@@ -1546,8 +1566,26 @@
 					no_copy = true;
 				}
 				ret = msm_nand_read_oob(mtd, from, &ops);
-				if (ret < 0)
+
+				/*
+				 * If current error is EBADMSG or EUCLEAN then
+				 * store this error in ecc_status and continue
+				 * the reading of data. This ecc_status will be
+				 * checked before returning from this function
+				 * and the same will be returned if it is non
+				 * zero.
+				 */
+				if ((ret == -EBADMSG) || (ret == -EUCLEAN)) {
+					if (ecc_status != -EBADMSG)
+						ecc_status = ret;
+
+					ret = 0;
+				}
+
+				if (ret < 0) {
+					ecc_status = 0;
 					break;
+				}
 
 				if (!no_copy)
 					memcpy(buf, bounce_buf, ops.retlen);
@@ -1582,6 +1620,9 @@
 		*retlen = ops.retlen;
 	}
 out:
+	if (ecc_status)
+		ret = ecc_status;
+
 	return ret;
 }
 
@@ -2294,7 +2335,7 @@
 		}
 		dev_found = 1;
 		if (!flashdev->pagesize) {
-			pr_err("missing page size info - extract from NAND ID\n");
+			pr_info("missing page size info - extract from NAND ID\n");
 			supported_flash->widebus = devcfg & (1 << 6) ? 1 : 0;
 			supported_flash->pagesize = 1024 << (devcfg & 0x3);
 			supported_flash->blksize = (64 * 1024) <<
diff -Naur -x .git --no-dereference linux/drivers/mtd/nand/nand_base.c linux-3.14/drivers/mtd/nand/nand_base.c
--- linux/drivers/mtd/nand/nand_base.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mtd/nand/nand_base.c	2016-09-01 11:52:04.000000000 +0800
@@ -92,6 +92,26 @@
 		 .length = 78} }
 };
 
+static struct nand_ecclayout nand_oob_256 = {
+	.eccbytes = 96,
+	.eccpos = {
+		160, 161, 162, 163, 164, 165, 166, 167,
+		168, 169, 170, 171, 172, 173, 174, 175,
+		176, 177, 178, 179, 180, 181, 182, 183,
+		184, 185, 186, 187, 188, 189, 190, 191,
+		192, 193, 194, 195, 196, 197, 198, 199,
+		200, 201, 202, 203, 204, 205, 206, 207,
+		208, 209, 210, 211, 212, 213, 214, 215,
+		216, 217, 218, 219, 220, 221, 222, 223,
+		224, 225, 226, 227, 228, 229, 230, 231,
+		232, 233, 234, 235, 236, 237, 238, 239,
+		240, 241, 242, 243, 244, 245, 246, 247,
+		248, 249, 250, 251, 252, 253, 254, 255},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 158} }
+};
+
 static int nand_get_device(struct mtd_info *mtd, int new_state);
 
 static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
@@ -3732,6 +3752,9 @@
 		case 128:
 			ecc->layout = &nand_oob_128;
 			break;
+		case 256:
+			ecc->layout = &nand_oob_256;
+			break;
 		default:
 			pr_warn("No oob scheme defined for oobsize %d\n",
 				   mtd->oobsize);
diff -Naur -x .git --no-dereference linux/drivers/mtd/nand/nand_ids.c linux-3.14/drivers/mtd/nand/nand_ids.c
--- linux/drivers/mtd/nand/nand_ids.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/mtd/nand/nand_ids.c	2016-09-01 11:52:04.000000000 +0800
@@ -34,8 +34,11 @@
 	{"ATO25D1GA 128MiB 3.3V",
 		{ .id = {0x9b, 0x12} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
 
+	{"GD5F4GQ4UC 512MiB 3.3V",
+		{ .id = {0xc8, 0xB4} }, SZ_4K, 512, SZ_256K, 0, 2, 256},
+
 	{"GD5F1GQ1UC 128MiB 3.3V",
-		{ .id = {0xc8, 0xB1} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
+		{ .id = {0xc8, 0xB1} }, SZ_2K, 128, SZ_128K, 0, 2, 128},
 
 	{"MX35LFxGE4AB 128MiB 3.3V",
 		{ .id = {0xc2, 0x12} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
@@ -43,8 +46,11 @@
 	{"W25N01GV 128MiB 3.3V",
 		{ .id = {0xef, 0xaa} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
 
+	{"W25M02GV 256MiB 3.3V(Dual die)",
+		{ .id = {0xef, 0xab} }, SZ_2K, 256, SZ_128K, 0, 2, 64},
+
 	{"GD5F1GQ1RC 128MiB 1.8V",
-		{ .id = {0xc8, 0xA1} }, SZ_2K, 128, SZ_128K, 0, 2, 64},
+		{ .id = {0xc8, 0xA1} }, SZ_2K, 128, SZ_128K, 0, 2, 128},
 
 	{"TC58NVG2S0F 4G 3.3V 8-bit",
 		{ .id = {0x98, 0xdc, 0x90, 0x26, 0x76, 0x15, 0x01, 0x08} },
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_3ad.c linux-3.14/drivers/net/bonding/bond_3ad.c
--- linux/drivers/net/bonding/bond_3ad.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_3ad.c	2016-09-01 11:52:04.000000000 +0800
@@ -125,18 +125,23 @@
 /*------------------------------- Exported APIs -----------------------------*/
 static struct bond_cb nss_cb;
 struct bond_cb *bond_cb;
+DEFINE_SPINLOCK(bond_cb_lock);
 
 void bond_register_cb(struct bond_cb *cb)
 {
+	spin_lock_bh(&bond_cb_lock);
 	memcpy((void *)&nss_cb, (void *)cb, sizeof(*cb));
 	bond_cb = &nss_cb;
+	spin_unlock_bh(&bond_cb_lock);
 }
 EXPORT_SYMBOL(bond_register_cb);
 
 void bond_unregister_cb(void)
 {
+	spin_lock_bh(&bond_cb_lock);
 	bond_cb = NULL;
 	memset((void *)&nss_cb, 0, sizeof(nss_cb));
+	spin_unlock_bh(&bond_cb_lock);
 }
 EXPORT_SYMBOL(bond_unregister_cb);
 
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_genl.c linux-3.14/drivers/net/bonding/bond_genl.c
--- linux/drivers/net/bonding/bond_genl.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_genl.c	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,458 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <net/genetlink.h>
+#include <linux/if_bonding_genl.h>
+#include <linux/if_ether.h>
+
+#include "bonding.h"
+#include "bond_genl.h"
+#include "bond_l2da.h"
+#include "bond_l2da_ctrl.h"
+
+struct bond_genl_ops_l2da_get_map_ctx {
+	struct sk_buff *msg;
+	int             cnt;
+	int             last_ret;
+};
+
+struct net_device *bond_device_from_info(struct genl_info *info)
+{
+	struct net *net = genl_info_net(info);
+	struct net_device *bond_dev;
+	char *bond_name;
+
+	if (!info->attrs[BOND_GENL_ATTR_BOND_NAME]) {
+		pr_err("BOND_GENL_ATTR_BOND_NAME must be defined\n");
+		return NULL;
+	}
+	bond_name = nla_data(info->attrs[BOND_GENL_ATTR_BOND_NAME]);
+	pr_debug("device_from_info: bond_name = %s\n", bond_name);
+
+	bond_dev = dev_get_by_name(net, bond_name);
+	if (!bond_dev) {
+		pr_err("device_from_info: cannot find bond netdev for %s\n",
+		       bond_name);
+		return NULL;
+	}
+
+	return bond_dev;
+}
+
+static int bond_genl_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
+				struct genl_info *info)
+{
+	struct net_device *bond_dev;
+
+	bond_dev = bond_device_from_info(info);
+	if (!bond_dev)
+		return -EINVAL;
+
+	info->user_ptr[0] = bond_dev;
+	return 0;
+}
+
+static void bond_genl_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
+				struct genl_info *info)
+{
+	BUG_ON(info->user_ptr[0] == NULL);
+	dev_put(info->user_ptr[0]);
+}
+
+static struct genl_family l2da_nl_family = {
+	.id        = GENL_ID_GENERATE,
+	.name      = BOND_GENL_NAME,
+	.version   = BOND_GENL_VERSION,
+	.hdrsize   = 0,
+	.maxattr   = BOND_GENL_ATTR_LAST - 1,
+	.netnsok   = true,
+	.pre_doit  = bond_genl_pre_doit,
+	.post_doit = bond_genl_post_doit,
+};
+
+static inline void *bond_hdr_put(struct sk_buff *skb, u32 portid, u32 seq,
+				int flags, u8 cmd)
+{
+	/* since there is no private header just add the generic one */
+	return genlmsg_put(skb, portid, seq, &l2da_nl_family, flags, cmd);
+}
+
+static int bond_genl_ops_l2da_set_default(struct sk_buff *skb,
+						struct genl_info *info)
+{
+	char *slave_name;
+	struct bonding *bond;
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	if (!info->attrs[BOND_GENL_ATTR_SLAVE_NAME]) {
+		pr_err("l2da_set_default: BOND_GENL_ATTR_SLAVE_NAME must be defined\n");
+		return -EINVAL;
+	}
+
+	slave_name = nla_data(info->attrs[BOND_GENL_ATTR_SLAVE_NAME]);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	return bond_l2da_ctrl_set_default(bond, slave_name);
+}
+
+static int bond_genl_ops_l2da_map_change(struct genl_info *info, int add)
+{
+	char *slave_name = NULL;
+	struct bonding *bond;
+	u8 *da;
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	if (add) {
+		if (!info->attrs[BOND_GENL_ATTR_SLAVE_NAME]) {
+			pr_err("l2da_map_change: BOND_GENL_ATTR_SLAVE_NAME must be defined\n");
+			return -EINVAL;
+		}
+
+		slave_name = nla_data(info->attrs[BOND_GENL_ATTR_SLAVE_NAME]);
+	}
+
+	if (!info->attrs[BOND_GENL_ATTR_MAC]) {
+		pr_err("l2da_map_change: BOND_GENL_ATTR_MAC must be defined\n");
+		return -EINVAL;
+	}
+
+	if (nla_len(info->attrs[BOND_GENL_ATTR_MAC]) != ETH_ALEN) {
+		pr_err("l2da_map_change: BOND_GENL_ATTR_MAC must be of %d bytes long\n",
+		       ETH_ALEN);
+		return -EINVAL;
+	}
+
+	da =  nla_data(info->attrs[BOND_GENL_ATTR_MAC]);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	return bond_l2da_ctrl_change_map_entry(bond, da, slave_name);
+}
+
+static int bond_genl_ops_l2da_add_map(struct sk_buff *skb,
+						struct genl_info *info)
+{
+	return bond_genl_ops_l2da_map_change(info, 1);
+}
+
+static int bond_genl_ops_l2da_del_map(struct sk_buff *skb,
+						struct genl_info *info)
+{
+	return bond_genl_ops_l2da_map_change(info, 0);
+}
+
+static int bond_genl_ops_l2da_get_default(struct sk_buff *skb,
+						struct genl_info *info)
+{
+	struct bonding *bond;
+	struct sk_buff *msg = NULL;
+	void *hdr = NULL;
+	char ifname[IFNAMSIZ + 1];
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	if (bond_l2da_ctrl_get_default(bond, ifname, sizeof(ifname)))
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	hdr = bond_hdr_put(msg, info->snd_portid, info->snd_seq, 0,
+			   BOND_GENL_CMD_L2DA_GET_DEFAULT);
+	if (!hdr)
+		goto out;
+
+	if (nla_put_string(msg, BOND_GENL_ATTR_SLAVE_NAME, ifname))
+		goto out;
+
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+
+out:
+	if (hdr)
+		genlmsg_cancel(msg, hdr);
+
+	nlmsg_free(msg);
+	return -EMSGSIZE;
+}
+
+static int bond_genl_ops_l2da_get_map_clb(const unsigned char *da,
+				struct slave *slave, void *_ctx)
+{
+	int ret = -ENOBUFS;
+	struct bond_genl_ops_l2da_get_map_ctx *ctx = _ctx;
+	struct nlattr *nl_entry;
+
+	nl_entry = nla_nest_start(ctx->msg, ctx->cnt + 1);
+	if (!nl_entry)
+		goto nla_put_failure;
+
+	if (nla_put_string(ctx->msg, BOND_GENL_ATTR_SLAVE_NAME,
+			   netdev_name(slave->dev)))
+		goto nla_put_failure;
+
+	if (nla_put(ctx->msg, BOND_GENL_ATTR_MAC, ETH_ALEN, da))
+		goto nla_put_failure;
+
+	nla_nest_end(ctx->msg, nl_entry);
+
+	++ctx->cnt;
+	ret = 0;
+
+nla_put_failure:
+	ctx->last_ret = ret;
+	return ret;
+}
+
+static int bond_genl_ops_l2da_get_map(struct sk_buff *skb,
+						struct genl_info *info)
+{
+	struct bonding *bond;
+	struct sk_buff *msg = NULL;
+	void *hdr = NULL;
+	struct nlattr *nl_nodes;
+	struct bond_genl_ops_l2da_get_map_ctx ctx;
+	int ret = -ENOMEM;
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	msg = nlmsg_new(4096, GFP_KERNEL);
+	if (!msg)
+		goto out;
+
+	hdr = bond_hdr_put(msg, info->snd_portid, info->snd_seq, 0,
+			   BOND_GENL_CMD_L2DA_GET_MAP);
+	if (!hdr)
+		goto out;
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	nl_nodes = nla_nest_start(msg, BOND_GENL_ATTR_L2DA_MAP);
+	if (!nl_nodes)
+		goto out;
+
+	ret = _bond_l2da_ctrl_try_lock(bond, false);
+	if (ret)
+		goto out;
+
+	bond_l2da_call_foreach(bond, bond_genl_ops_l2da_get_map_clb, &ctx);
+
+	_bond_l2da_ctrl_unlock(bond, false);
+
+	if (ctx.last_ret)
+		goto out;
+
+	nla_nest_end(msg, nl_nodes);
+
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+
+out:
+	if (hdr)
+		genlmsg_cancel(msg, hdr);
+	if (msg)
+		nlmsg_free(msg);
+	return ret;
+}
+
+static int bond_genl_ops_l2da_reset_map(struct sk_buff *skb,
+						struct genl_info *info)
+{
+	struct bonding *bond;
+	int ret;
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	ret = bond_l2da_ctrl_reset_map(bond);
+	if (ret)
+		pr_err("l2da_reset_map: couldn't reset map");
+	else
+		pr_info("l2da_reset_map: map reset successfully");
+
+	return ret;
+}
+
+static int bond_genl_ops_l2da_set_opts(struct sk_buff *skb,
+				       struct genl_info *info)
+{
+	u32 opts;
+	struct bonding *bond;
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	if (!info->attrs[BOND_GENL_ATTR_L2DA_OPTS]) {
+		pr_err("l2da_set_default: BOND_GENL_ATTR_L2DA_OPTS must be defined\n");
+		return -EINVAL;
+	}
+
+	opts = nla_get_u32(info->attrs[BOND_GENL_ATTR_L2DA_OPTS]);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	return bond_l2da_ctrl_set_opts(bond, opts);
+}
+
+static int bond_genl_ops_l2da_get_opts(struct sk_buff *skb,
+				       struct genl_info *info)
+{
+	struct bonding *bond;
+	struct sk_buff *msg = NULL;
+	void *hdr = NULL;
+	u32 opts;
+
+	BUG_ON(info->user_ptr[0] == NULL);
+
+	bond = netdev_priv(info->user_ptr[0]);
+
+	if (bond_l2da_ctrl_get_opts(bond, &opts))
+		return -EINVAL;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	hdr = bond_hdr_put(msg, info->snd_portid, info->snd_seq, 0,
+			   BOND_GENL_CMD_L2DA_GET_OPTS);
+	if (!hdr)
+		goto out;
+
+	if (nla_put_u32(msg, BOND_GENL_ATTR_L2DA_OPTS, opts))
+		goto out;
+
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+
+out:
+	if (hdr)
+		genlmsg_cancel(msg, hdr);
+
+	nlmsg_free(msg);
+	return -EMSGSIZE;
+}
+
+static struct nla_policy l2da_nl_policy[BOND_GENL_ATTR_LAST] = {
+	[BOND_GENL_ATTR_BOND_NAME] = {
+		.type = NLA_STRING,
+		.len = IFNAMSIZ + 1,
+	},
+	[BOND_GENL_ATTR_SLAVE_NAME] = {
+		.type = NLA_STRING,
+		.len = IFNAMSIZ + 1,
+	},
+	[BOND_GENL_ATTR_MAC]     = {
+		.type = NLA_BINARY,
+		.len = ETH_ALEN,
+	},
+	[BOND_GENL_ATTR_L2DA_MAP] = {
+		.type = NLA_NESTED,
+	},
+	[BOND_GENL_ATTR_L2DA_OPTS] = {
+		.type = NLA_U32,
+	},
+};
+
+static const struct genl_ops l2da_nl_ops[] = {
+	{
+		.cmd = BOND_GENL_CMD_L2DA_SET_DEFAULT,
+		.doit = bond_genl_ops_l2da_set_default,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_GET_DEFAULT,
+		.doit = bond_genl_ops_l2da_get_default,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_DEL_MAP_ENTRY,
+		.doit = bond_genl_ops_l2da_del_map,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_ADD_MAP_ENTRY,
+		.doit = bond_genl_ops_l2da_add_map,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_GET_MAP,
+		.doit = bond_genl_ops_l2da_get_map,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_RESET_MAP,
+		.doit = bond_genl_ops_l2da_reset_map,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_SET_OPTS,
+		.doit = bond_genl_ops_l2da_set_opts,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+	{
+		.cmd = BOND_GENL_CMD_L2DA_GET_OPTS,
+		.doit = bond_genl_ops_l2da_get_opts,
+		.policy = l2da_nl_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+};
+
+/**
+ * Initialize bond generic netlink
+ *
+ * Returns: 0 on success, negative error code on failure
+ */
+int bond_genl_initialize(void)
+{
+	int res;
+
+	res = genl_register_family_with_ops(&l2da_nl_family, l2da_nl_ops);
+	if (res) {
+		pr_err("bond_genl registration error (%d)\n", res);
+		return res;
+	}
+
+	pr_debug("bond_genl registered\n");
+	return 0;
+}
+
+/**
+ * Uniniialize bond generic netlink
+ */
+void bond_genl_deinitialize(void)
+{
+	genl_unregister_family(&l2da_nl_family);
+	pr_debug("bond_genl unregistered\n");
+}
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_genl.h linux-3.14/drivers/net/bonding/bond_genl.h
--- linux/drivers/net/bonding/bond_genl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_genl.h	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,22 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __BOND_GENL_H__
+#define __BOND_GENL_H__
+
+int  bond_genl_initialize(void);
+void bond_genl_deinitialize(void);
+
+#endif /* __BOND_GENL_H__ */
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bonding.h linux-3.14/drivers/net/bonding/bonding.h
--- linux/drivers/net/bonding/bonding.h	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bonding.h	2016-09-01 11:52:04.000000000 +0800
@@ -28,6 +28,7 @@
 #include "bond_3ad.h"
 #include "bond_alb.h"
 #include "bond_options.h"
+#include "bond_l2da.h"
 
 #define DRV_VERSION	"3.7.1"
 #define DRV_RELDATE	"April 27, 2011"
@@ -126,6 +127,9 @@
 #define bond_for_each_slave_rcu(bond, pos, iter) \
 	netdev_for_each_lower_private_rcu((bond)->dev, pos, iter)
 
+extern spinlock_t bond_cb_lock;
+extern struct bond_cb *bond_cb;
+
 #ifdef CONFIG_NET_POLL_CONTROLLER
 extern atomic_t netpoll_block_tx;
 
@@ -246,6 +250,7 @@
 	u32      rr_tx_counter;
 	struct   ad_bond_info ad_info;
 	struct   alb_bond_info alb_info;
+	struct	 l2da_bond_info l2da_info;
 	struct   bond_params params;
 	struct   workqueue_struct *wq;
 	struct   delayed_work mii_work;
@@ -289,6 +294,11 @@
 	return BOND_MODE_IS_LB(bond->params.mode);
 }
 
+static inline bool bond_is_l2da(const struct bonding *bond)
+{
+	return bond->params.mode == BOND_MODE_L2DA;
+}
+
 static inline void bond_set_active_slave(struct slave *slave)
 {
 	if (slave->backup) {
@@ -479,6 +489,7 @@
 
 int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond, struct slave *slave);
 void bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
+int bond_xmit_all_slaves(struct bonding *bond, struct sk_buff *skb);
 int bond_create(struct net *net, const char *name);
 int bond_create_sysfs(struct bond_net *net);
 void bond_destroy_sysfs(struct bond_net *net);
@@ -509,7 +520,7 @@
 const char *bond_slave_link_status(s8 link);
 uint32_t bond_xmit_hash_without_skb(uint8_t *src_mac, uint8_t *dst_mac, void *psrc,
                                     void *pdst, uint16_t protocol, struct net_device *bond_dev, __be16 *layer4hdr);
-
+void bond_notify_l2da(uint8_t *slave_mac_addr);
 
 struct bond_net {
 	struct net *		net;	/* Associated network namespace */
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_l2da.c linux-3.14/drivers/net/bonding/bond_l2da.c
--- linux/drivers/net/bonding/bond_l2da.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_l2da.c	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,686 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/etherdevice.h>
+#include <linux/if_bonding_genl.h>
+#include "bonding.h"
+#include "bond_l2da.h"
+
+#define L2DA_OPTS_DEFAULT 0
+
+struct l2da_bond_matrix_entry {
+	struct hlist_node hnode;
+	unsigned char da[ETH_ALEN];
+	struct slave *slave;
+};
+
+#define BOND_L2DA_INFO(bond) ((bond)->l2da_info)
+
+#define SLAVE_CAN_XMIT(slave) (IS_UP((slave)->dev) && \
+				((slave)->link == BOND_LINK_UP) && \
+				bond_is_active_slave(slave))
+
+/**
+ * _bond_l2da_slave_name - returns slave name
+ * @slave: slave struct to work on
+ *
+ * Returns @slave network device name, or "null" if it can't be found.
+ */
+static inline const char *_bond_l2da_slave_name(struct slave *slave)
+{
+	if (slave && slave->dev)
+		return netdev_name(slave->dev);
+	return "null";
+}
+
+/**
+ * _bond_l2da_hash_val - hash function for L2DA map hash table
+ * @da: DA to be used as a hash key
+ *
+ * Returns hash value for @da
+ */
+static inline u32 _bond_l2da_hash_val(const unsigned char *da)
+{
+	return da[ETH_ALEN - 2];
+}
+
+/**
+ * _bond_l2da_find_entry_unsafe - searches for DA:iface mapping within the map
+ * @bond_info: L2DA bonding struct to work on
+ * @da: DA to be used as a key
+ *
+ * Returns map entry for @da, or %NULL if it can't be found.
+ *
+ * The function must be called under the L2DA bonding struct lock.
+ */
+static struct l2da_bond_matrix_entry *
+_bond_l2da_find_entry_unsafe(struct l2da_bond_info *bond_info,
+			     const unsigned char *da)
+{
+	struct l2da_bond_matrix_entry *entry = NULL;
+	u32 hash_val;
+	BUG_ON(da == NULL);
+
+	hash_val = _bond_l2da_hash_val(da);
+	hash_for_each_possible(bond_info->da_matrix, entry, hnode, hash_val)
+		if (ether_addr_equal(entry->da, da))
+			return entry;
+	return NULL;
+}
+
+/**
+ * _bond_l2da_select_default_slave_unsafe - selects default slave
+ * @bond: bonding struct to work on
+ *
+ * The function must be called under the L2DA bonding struct lock.
+ */
+static void
+_bond_l2da_select_default_slave_unsafe(struct bonding *bond)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct slave *slave;
+	struct list_head *iter;
+
+	/* Default slave is OK, so continue to use it */
+	if (bond_info->default_slave &&
+	    SLAVE_CAN_XMIT(bond_info->default_slave))
+		return;
+
+	/* Select new default slave */
+	bond_for_each_slave(bond, slave, iter) {
+		if (slave != bond_info->default_slave &&
+		    SLAVE_CAN_XMIT(slave)) {
+			pr_info("bond_l2da default slave set to %s\n",
+				_bond_l2da_slave_name(slave));
+			bond_info->default_slave = slave;
+			break;
+		}
+	}
+}
+
+/**
+ * _bond_l2da_remove_entries_unsafe - removes all iface mappings from the map
+ * @bond_info: L2DA bonding struct to work on
+ * @slave: slave whose mappings have to be removed
+ *
+ * The function must be called under the L2DA bonding struct lock.
+ */
+static void _bond_l2da_remove_entries_unsafe(struct l2da_bond_info *bond_info,
+					     struct slave *slave)
+{
+	struct l2da_bond_matrix_entry *entry = NULL;
+	struct hlist_node *tmp;
+	int counter;
+	hash_for_each_safe(bond_info->da_matrix, counter, tmp, entry, hnode) {
+		/* NULL slave means "remove all" */
+		if (!slave || entry->slave == slave) {
+			hash_del(&entry->hnode);
+			bond_notify_l2da(entry->da);
+			kfree(entry);
+		}
+	}
+}
+
+/**
+ * _bond_l2da_bridge_clone_and_xmit - clones received packet and sends it to
+ *      specific slave
+ * @bond: bond struct to work on
+ * @slave: slave to send cloned skb to
+ * @skb: received packet to be cloned and sent
+ *
+ * Returns: %true if forwarding succeeded, %false - otherwise
+ */
+static bool _bond_l2da_bridge_clone_and_xmit(struct bonding *bond,
+					     struct slave *slave,
+					     struct sk_buff *skb)
+{
+	struct sk_buff *skb2;
+
+	if (!SLAVE_CAN_XMIT(slave))
+		return false;
+
+	skb2 = skb_clone(skb, GFP_ATOMIC);
+	if (!skb2) {
+		pr_err_ratelimited("%s: Error: _bond_l2da_bridge_clone_and_xmit(): skb_clone() failed\n",
+				   bond->dev->name);
+		return false;
+	}
+
+	skb2->protocol = htons(ETH_P_802_3);
+	skb_forward_csum(skb2);
+	skb_push(skb2, ETH_HLEN);
+	/* bond_dev_queue_xmit always returns 0 */
+	bond_dev_queue_xmit(bond, skb2, slave->dev);
+	return true;
+}
+
+
+/**
+ * _bond_l2da_bridge_flood_multicast - implements L2DA packet forwarding
+ *      functionality for multicast packets. See %BOND_L2DA_OPT_FORWARD_RX for
+ *      more info.
+ * @bond: bond struct to work on
+ * @slave: slave that received the packet
+ * @skb: received multicast packet
+ *
+ * Returns: always %true for consistency with other _bond_l2da_bridge_flood...
+ *      functions.
+ */
+static bool _bond_l2da_bridge_flood_multicast(struct bonding *bond,
+					      struct slave *slave,
+					      struct sk_buff *skb)
+{
+	struct list_head *iter;
+	struct slave *s;
+
+	rcu_read_lock_bh();
+	bond_for_each_slave_rcu(bond, s, iter) {
+		if (s == slave)
+			continue;
+
+		if (_bond_l2da_bridge_clone_and_xmit(bond, s, skb))
+			pr_debug("bond_l2da: bridge: MC (SA=%pM DA=%pM) %s => %s\n",
+				 eth_hdr(skb)->h_source,
+				 eth_hdr(skb)->h_dest,
+				 _bond_l2da_slave_name(slave),
+				 _bond_l2da_slave_name(s));
+	}
+	rcu_read_unlock_bh();
+	/* Multicast packets should also be delivered locally */
+	return true;
+}
+
+/**
+ * _bond_l2da_bridge_flood_unicast - implements L2DA packet forwarding
+ *      functionality for unicast packets. See %BOND_L2DA_OPT_FORWARD_RX for
+ *      more info.
+ * @bond: bond struct to work on
+ * @slave: slave that received the packet
+ * @skb: received unicast packet
+ *
+ * Returns: %true if skb should be delivered locally, %false - otherwise
+ */
+static bool _bond_l2da_bridge_flood_unicast(struct bonding *bond,
+					    struct slave *slave,
+					    struct sk_buff *skb)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct l2da_bond_matrix_entry *entry;
+	struct ethhdr *eth_data;
+	bool res = true;
+
+	eth_data = eth_hdr(skb);
+
+	read_lock_bh(&bond_info->lock);
+	/* There is no flood actually. Packet is sent to only single slave (if
+	 * found in map).
+	 */
+	entry = _bond_l2da_find_entry_unsafe(bond_info, eth_data->h_dest);
+	if (entry && entry->slave && entry->slave != slave) {
+		/* We should not forward packet if entry->slave == slave
+		 * (i.e. back to the slave it arrived from), as this scenario is
+		 * supposed to be handled by underlying slave driver.
+		 */
+		if (_bond_l2da_bridge_clone_and_xmit(bond, entry->slave, skb)) {
+			pr_debug("bond_l2da: bridge: UC (SA=%pM DA=%pM) %s => %s\n",
+				 eth_hdr(skb)->h_source,
+				 eth_hdr(skb)->h_dest,
+				 _bond_l2da_slave_name(slave),
+				 _bond_l2da_slave_name(entry->slave));
+			res = false;
+		}
+	}
+	read_unlock_bh(&bond_info->lock);
+
+	return res;
+}
+
+/**
+ * _bond_l2da_bridge_flood - implements L2DA packet forwarding functionality
+ * @bond: bond struct to work on
+ * @slave: slave that received the packet
+ * @skb: received packet
+ *
+ * Returns: %true if skb should be delivered locally, %false - otherwise
+ */
+static bool _bond_l2da_bridge_flood(struct bonding *bond,
+				    struct slave *slave,
+				    struct sk_buff *skb)
+{
+	struct ethhdr *eth_data;
+
+	if (unlikely(skb->pkt_type == PACKET_LOOPBACK))
+		return true;
+
+	eth_data = eth_hdr(skb);
+
+	return is_multicast_ether_addr(eth_data->h_dest) ?
+			_bond_l2da_bridge_flood_multicast(bond, slave, skb) :
+			_bond_l2da_bridge_flood_unicast(bond, slave, skb);
+}
+
+/**
+ * bond_l2da_initialize - initializes a bond's L2DA context
+ * @bond: bonding struct to work on
+ */
+int bond_l2da_initialize(struct bonding *bond)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+
+	memset(bond_info, 0, sizeof(*bond_info));
+	hash_init(bond_info->da_matrix);
+	rwlock_init(&bond_info->lock);
+	bond_info->default_slave = NULL;
+	atomic_set(&bond_info->opts, L2DA_OPTS_DEFAULT);
+	pr_info("bond_l2da initialized\n");
+	return 0;
+}
+
+/**
+ * bond_l2da_deinitialize - deinitializes a bond's L2DA context
+ * @bond: bonding struct to work on
+ */
+void bond_l2da_deinitialize(struct bonding *bond)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+
+	bond_l2da_purge(bond);
+	BUG_ON(!hash_empty(bond_info->da_matrix));
+	memset(bond_info, 0, sizeof(*bond_info)); /* for debugging purposes */
+	pr_info("bond_l2da de-initialized\n");
+}
+
+/**
+ * bond_l2da_bind_slave - bind slave to L2DA
+ * @bond: bonding struct to work on
+ * @slave: slave struct to work on
+ *
+ * Assigns default slave (if needed).
+ */
+int bond_l2da_bind_slave(struct bonding *bond, struct slave *slave)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	write_lock_bh(&bond_info->lock);
+	if (!bond_info->default_slave) {
+		bond_info->default_slave = slave;
+		pr_info("bond_l2da default slave initially set to %s\n",
+			_bond_l2da_slave_name(slave));
+	}
+	_bond_l2da_select_default_slave_unsafe(bond);
+	write_unlock_bh(&bond_info->lock);
+	return 0;
+}
+
+/**
+ * bond_l2da_unbind_slave - unbind slave from L2DA
+ * @slave: slave struct to work on
+ *
+ * Removes all matrix entries for this slave, re-assigns default slave (if
+ * needed).
+ */
+void bond_l2da_unbind_slave(struct bonding *bond, struct slave *slave)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+
+	write_lock_bh(&bond_info->lock);
+	if (slave == bond_info->default_slave) {
+		/* default slave has gone, so let's use some other slave as
+		* a new default
+		*/
+		bond_info->default_slave = bond_first_slave(bond);
+		pr_info("bond_l2da default slave set to %s\n",
+			_bond_l2da_slave_name(bond_info->default_slave));
+	}
+	_bond_l2da_remove_entries_unsafe(bond_info, slave);
+	_bond_l2da_select_default_slave_unsafe(bond);
+	write_unlock_bh(&bond_info->lock);
+}
+
+/**
+ * bond_l2da_get_tx_dev - Calculate egress interface for a given packet,
+			  for a LAG that is configured in L2DA mode
+ * @dst_mac: pointer to destination L2 address
+ * @bond_dev: pointer to bond master device
+
+ * Returns: Either valid slave device, or NULL otherwise
+ */
+struct net_device *bond_l2da_get_tx_dev(uint8_t *dest_mac,
+					struct net_device *bond_dev)
+{
+	struct bonding *bond = netdev_priv(bond_dev);
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct l2da_bond_matrix_entry *entry;
+	struct net_device *dest_dev = NULL;
+	u32 opts = atomic_read(&bond_info->opts);
+
+	if ((opts & BOND_L2DA_OPT_DUP_MC_TX) &&
+	    (is_multicast_ether_addr(dest_mac)))
+		return NULL;
+
+	read_lock_bh(&bond_info->lock);
+	entry = _bond_l2da_find_entry_unsafe(bond_info, dest_mac);
+	if (entry && entry->slave && SLAVE_CAN_XMIT(entry->slave)) {
+		/* if a slave configured for this DA and it's OK - use it */
+		dest_dev = entry->slave->dev;
+	} else if (bond_info->default_slave &&
+		   SLAVE_CAN_XMIT(bond_info->default_slave)) {
+		/* otherwise, if default slave is configured - use it */
+		dest_dev = bond_info->default_slave->dev;
+	}
+	read_unlock_bh(&bond_info->lock);
+
+	return dest_dev;
+}
+
+/**
+ * bond_l2da_xmit - transmits skb in L2DA mode
+ * @skb: skb to transmit
+ * @dev: bonding net device
+ */
+int bond_l2da_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct bonding *bond = netdev_priv(dev);
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct ethhdr *eth_data;
+	struct l2da_bond_matrix_entry *entry;
+	int no_slave = 0;
+	u32 opts = atomic_read(&bond_info->opts);
+
+	skb_reset_mac_header(skb);
+	eth_data = eth_hdr(skb);
+
+	if ((opts & BOND_L2DA_OPT_DUP_MC_TX) &&
+	    is_multicast_ether_addr(eth_data->h_dest))
+		return bond_xmit_all_slaves(bond, skb);
+
+	read_lock_bh(&bond_info->lock);
+	entry = _bond_l2da_find_entry_unsafe(bond_info, eth_data->h_dest);
+	if (entry && entry->slave && SLAVE_CAN_XMIT(entry->slave)) {
+		/* if a slave configured for this DA and it's OK - use it */
+		bond_dev_queue_xmit(bond, skb, entry->slave->dev);
+	} else if (bond_info->default_slave &&
+		   SLAVE_CAN_XMIT(bond_info->default_slave)) {
+		/* otherwise, if default slave is configured - use it */
+		bond_dev_queue_xmit(bond, skb, bond_info->default_slave->dev);
+	} else {
+		no_slave = 1;
+	}
+	read_unlock_bh(&bond_info->lock);
+
+	if (no_slave) {
+		/* no suitable interface, frame not sent */
+		dev_kfree_skb_any(skb);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+/**
+ * bond_l2da_handle_rx_frame - handles RX packets on L2DA mode
+ * @bond: bonding struct to work on
+ * @slave: slave that received the %skb
+ * @skb: received skb
+ * Returns: %true for allowing this %skb to be delivered to local stack, %false
+ *          for dropping it
+ */
+bool bond_l2da_handle_rx_frame(struct bonding *bond, struct slave *slave,
+			       struct sk_buff *skb)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct ethhdr *eth_data;
+	struct l2da_bond_matrix_entry *entry;
+	bool res = true;
+	u32 opts = atomic_read(&bond_info->opts);
+
+	eth_data = eth_hdr(skb);
+
+	/* if DEDUP disabled, all RX apackets are allowed */
+	/* if DEDUP enabled, EAPOLs are allowed from all the slaves */
+	if ((opts & BOND_L2DA_OPT_DEDUP_RX) &&
+	    eth_data->h_proto != cpu_to_be16(ETH_P_PAE)) {
+		/* if DEDUP enabled, non-EAPOL packets are allowed:
+		 * - if there's a slave configured for this SA - only from it
+		 * - else if default slave configured - only from it
+		 * - else - from any slave
+		 */
+		read_lock_bh(&bond_info->lock);
+		entry = _bond_l2da_find_entry_unsafe(bond_info,
+						     eth_data->h_source);
+		if (entry && entry->slave)
+			res = (entry->slave->dev == skb->dev);
+		else if (bond_info->default_slave)
+			res = (bond_info->default_slave->dev == skb->dev);
+		read_unlock_bh(&bond_info->lock);
+	}
+
+	/* DEDUP takes precedence over FORWARD, i.e. we only flood packets which
+	 * are allowed for RX
+	 */
+	if (res && (opts & BOND_L2DA_OPT_FORWARD_RX))
+		return _bond_l2da_bridge_flood(bond, slave, skb);
+
+	return res;
+}
+
+/**
+ * bond_l2da_set_default_slave - sets default slave
+ * @bond: bonding struct to work on
+ * @slave: slave struct to set default
+ *
+ * Returns: 0 on success, negative error code on failure
+ */
+int bond_l2da_set_default_slave(struct bonding *bond, struct slave *slave)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	int res = -EINVAL;
+
+	write_lock_bh(&bond_info->lock);
+	if (SLAVE_CAN_XMIT(slave)) {
+		bond_info->default_slave = slave;
+		pr_info("bond_l2da default slave set to %s\n",
+			_bond_l2da_slave_name(slave));
+		res = 0;
+	} else {
+		_bond_l2da_select_default_slave_unsafe(bond);
+	}
+	write_unlock_bh(&bond_info->lock);
+	return res;
+}
+
+/**
+ * bond_l2da_get_default_slave_name - gets name of currently configured default
+ * slave
+ * @bond: bonding struct to work on
+ * @buf: destination buffer
+ * @size: destination buffer size
+ */
+int bond_l2da_get_default_slave_name(struct bonding *bond, char *buf, int size)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+
+	if (!buf || size < IFNAMSIZ)
+		return -EINVAL;
+
+	*buf = 0;
+
+	read_lock_bh(&bond_info->lock);
+	if (bond_info->default_slave) {
+		strncpy(buf, netdev_name(bond_info->default_slave->dev),
+			IFNAMSIZ);
+		buf[IFNAMSIZ - 1] = 0;
+	}
+	read_unlock_bh(&bond_info->lock);
+	return 0;
+}
+
+/**
+ * bond_l2da_set_da_slave - adds DA:slave mapping
+ * @bond: bonding struct to work on
+ * @da: desired L2 destination address to map
+ * @slave: slave to be used for sending packets to desired destination address
+ */
+int bond_l2da_set_da_slave(struct bonding *bond, const unsigned char *da,
+			   struct slave *slave)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct l2da_bond_matrix_entry *entry;
+	struct slave *prev_slave = NULL;
+
+	write_lock_bh(&bond_info->lock);
+	entry = _bond_l2da_find_entry_unsafe(bond_info, da);
+	if (entry) {
+		prev_slave = entry->slave;
+		entry->slave = slave;
+	} else {
+		entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+		if (!entry) {
+			pr_err("bond_l2da: pair node cannot be allocated for [%pM:%s]\n",
+			       da, _bond_l2da_slave_name(slave));
+			write_unlock_bh(&bond_info->lock);
+			return -ENOMEM;
+		}
+		entry->slave = slave;
+		ether_addr_copy(entry->da, da);
+		hash_add(bond_info->da_matrix, &entry->hnode,
+			 _bond_l2da_hash_val(da));
+	}
+	write_unlock_bh(&bond_info->lock);
+
+	pr_info("bond_l2da: pair %s [%pM:%s]\n",
+		prev_slave ? "changed" : "added",
+		da, _bond_l2da_slave_name(slave));
+
+	return 0;
+}
+
+/**
+ * bond_l2da_set_opts - sets L2DA options
+ * @bond: bonding struct to work on
+ * @opts: options mask, see enum bond_genl_l2da_opts for details
+ */
+void bond_l2da_set_opts(struct bonding *bond, u32 opts)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	u32 old_opts = atomic_xchg(&bond_info->opts, opts);
+
+	if (old_opts != opts)
+		pr_info("bond_l2da: opts changed 0x%08x => 0x%08x\n",
+			old_opts, opts);
+}
+
+/**
+ * bond_l2da_get_opts - gets L2DA options
+ * @bond: bonding struct to work on
+ *
+ * Returns: L2DA options value, see enum bond_genl_l2da_opts for details
+ */
+u32 bond_l2da_get_opts(struct bonding *bond)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+
+	return atomic_read(&bond_info->opts);
+}
+
+/**
+ * bond_l2da_del_da - removes DA mapping
+ * @bond: bonding struct to work on
+ * @da: L2 destination address whose mapping has to be removed
+ */
+int bond_l2da_del_da(struct bonding *bond, const unsigned char *da)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct l2da_bond_matrix_entry *entry;
+
+	write_lock_bh(&bond_info->lock);
+	entry = _bond_l2da_find_entry_unsafe(bond_info, da);
+	if (entry)
+		hash_del(&entry->hnode);
+	write_unlock_bh(&bond_info->lock);
+
+	if (!entry) {
+		pr_err("bond_l2da: pair node cannot be found for %pM\n", da);
+		return -ENOENT;
+	}
+
+	pr_info("bond_l2da: pair deleted [%pM:%s]\n",
+		da, _bond_l2da_slave_name(entry->slave));
+	kfree(entry);
+	return 0;
+}
+
+/**
+ * bond_l2da_purge - removes all DA mappings
+ * @bond: bonding struct to work on
+ */
+void bond_l2da_purge(struct bonding *bond)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	write_lock_bh(&bond_info->lock);
+	_bond_l2da_remove_entries_unsafe(bond_info, NULL);
+	write_unlock_bh(&bond_info->lock);
+}
+
+/**
+ * bond_l2da_handle_link_change - handle a slave's link status change indication
+ * @bond: bonding struct to work on
+ * @slave: slave struct whose link status changed
+ *
+ * Handle re-selection of default slave (if needed).
+ */
+void bond_l2da_handle_link_change(struct bonding *bond, struct slave *slave)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct slave *prev_default_slave;
+
+	write_lock_bh(&bond_info->lock);
+	prev_default_slave = bond_info->default_slave;
+	_bond_l2da_select_default_slave_unsafe(bond);
+
+	spin_lock_bh(&bond_cb_lock);
+	if (prev_default_slave && bond_cb && bond_cb->bond_cb_delete_by_slave)
+		bond_cb->bond_cb_delete_by_slave(prev_default_slave->dev);
+	spin_unlock_bh(&bond_cb_lock);
+	write_unlock_bh(&bond_info->lock);
+}
+
+/**
+ * bond_l2da_call_foreach - iterates over L2DA map
+ * @bond: bonding struct to work on
+ * @clb: callback function to be called for every mapping entry found
+ * @ctx: user context to be passed to callback
+ *
+ * Callback function can return non-zero value to stop iteration.
+ */
+void bond_l2da_call_foreach(struct bonding *bond,
+			    int (*clb)(const unsigned char *da,
+				       struct slave *slave,
+				       void *ctx),
+			    void *ctx)
+{
+	struct l2da_bond_info *bond_info = &BOND_L2DA_INFO(bond);
+	struct l2da_bond_matrix_entry *entry;
+	int bkt;
+
+	BUG_ON(!clb);
+
+	read_lock_bh(&bond_info->lock);
+	hash_for_each(bond_info->da_matrix, bkt, entry, hnode) {
+		if (clb(entry->da, entry->slave, ctx))
+			break;
+	}
+	read_unlock_bh(&bond_info->lock);
+}
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_l2da_ctrl.c linux-3.14/drivers/net/bonding/bond_l2da_ctrl.c
--- linux/drivers/net/bonding/bond_l2da_ctrl.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_l2da_ctrl.c	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,190 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include "bonding.h"
+#include "bond_l2da.h"
+#include "bond_l2da_ctrl.h"
+
+int  _bond_l2da_ctrl_try_lock(struct bonding *bond, bool set)
+{
+	if (!rtnl_trylock())
+		return restart_syscall();
+
+	if (!bond_is_l2da(bond)) {
+		pr_info("%s: not in L2DA mode\n", netdev_name(bond->dev));
+		rtnl_unlock();
+		return -EINVAL;
+	}
+
+	if (set)
+		block_netpoll_tx();
+
+	read_lock(&bond->lock);
+
+	return 0;
+}
+
+void _bond_l2da_ctrl_unlock(struct bonding *bond, bool set)
+{
+	read_unlock(&bond->lock);
+	if (set)
+		unblock_netpoll_tx();
+	rtnl_unlock();
+}
+
+int bond_l2da_ctrl_set_default(struct bonding *bond, const char *slave_ifname)
+{
+	struct slave *slave;
+	struct list_head *iter;
+	int ret = -EINVAL;
+	struct slave *prev_default_slave;
+	struct l2da_bond_info *bond_info = &bond->l2da_info;
+
+	ret = _bond_l2da_ctrl_try_lock(bond, true);
+	if (ret)
+		return ret;
+
+	prev_default_slave = bond_info->default_slave;
+	bond_for_each_slave(bond, slave, iter) {
+		if (!strncmp(netdev_name(slave->dev), slave_ifname, IFNAMSIZ)) {
+			if (slave->link == BOND_LINK_UP && IS_UP(slave->dev))
+				ret = bond_l2da_set_default_slave(bond, slave);
+			else
+				pr_warn("%s: cannot set %s as default slave\n",
+					netdev_name(bond->dev),
+					netdev_name(slave->dev));
+
+			break;
+		}
+	}
+
+	if (ret < 0)
+		pr_err("%s: Unable to to set %s as default slave\n",
+		       netdev_name(bond->dev), slave_ifname);
+
+	spin_lock_bh(&bond_cb_lock);
+	if (!ret && prev_default_slave && bond_cb &&
+	    bond_cb->bond_cb_delete_by_slave)
+		bond_cb->bond_cb_delete_by_slave(prev_default_slave->dev);
+	spin_unlock_bh(&bond_cb_lock);
+
+	_bond_l2da_ctrl_unlock(bond, true);
+
+	return ret;
+}
+
+int bond_l2da_ctrl_get_default(struct bonding *bond, char *buf, int size)
+{
+	int ret;
+
+	ret = _bond_l2da_ctrl_try_lock(bond, false);
+	if (ret)
+		return ret;
+
+	ret = bond_l2da_get_default_slave_name(bond, buf, size);
+
+	_bond_l2da_ctrl_unlock(bond, false);
+	return ret;
+}
+
+int bond_l2da_ctrl_change_map_entry(struct bonding *bond,
+				const u8 *da,
+				const char *slave_ifname)
+{
+	int ret;
+	struct slave *slave;
+	struct list_head *iter;
+	bool slave_found;
+
+	if (!is_valid_ether_addr(da)) {
+		pr_err("%s: Invalid L2DA MAC address: %pM\n",
+		       netdev_name(bond->dev), da);
+		return -EINVAL;
+	}
+
+	if (slave_ifname && !dev_valid_name(slave_ifname)) {
+		pr_err("%s: Invalid L2DA slave name: '%s'\n",
+		       netdev_name(bond->dev), slave_ifname);
+		return -EINVAL;
+	}
+
+	ret = _bond_l2da_ctrl_try_lock(bond, true);
+	if (ret)
+		return ret;
+
+	if (slave_ifname) {
+		slave_found = false;
+		bond_for_each_slave(bond, slave, iter) {
+			if (!strncmp(netdev_name(slave->dev), slave_ifname,
+				     IFNAMSIZ)) {
+				slave_found = true;
+				ret = bond_l2da_set_da_slave(bond, da, slave);
+				break;
+			}
+		}
+		if (!slave_found) {
+			ret = -EINVAL;
+			pr_err("%s: L2DA cannot find slave: %s\n",
+			       netdev_name(bond->dev), slave_ifname);
+		}
+	} else {
+		ret = bond_l2da_del_da(bond, da);
+	}
+
+	_bond_l2da_ctrl_unlock(bond, true);
+
+	bond_notify_l2da(da);
+
+	return ret;
+}
+
+int bond_l2da_ctrl_reset_map(struct bonding *bond)
+{
+	int ret = _bond_l2da_ctrl_try_lock(bond, true);
+	if (ret)
+		return ret;
+
+	bond_l2da_purge(bond);
+
+	_bond_l2da_ctrl_unlock(bond, true);
+
+	return ret;
+}
+
+int bond_l2da_ctrl_set_opts(struct bonding *bond, u32 opts)
+{
+	int ret = _bond_l2da_ctrl_try_lock(bond, true);
+	if (ret)
+		return ret;
+
+	bond_l2da_set_opts(bond, opts);
+
+	_bond_l2da_ctrl_unlock(bond, true);
+	return 0;
+}
+
+int bond_l2da_ctrl_get_opts(struct bonding *bond, u32 *opts)
+{
+	int ret = _bond_l2da_ctrl_try_lock(bond, false);
+	if (ret)
+		return ret;
+
+	*opts = bond_l2da_get_opts(bond);
+
+	_bond_l2da_ctrl_unlock(bond, false);
+	return 0;
+}
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_l2da_ctrl.h linux-3.14/drivers/net/bonding/bond_l2da_ctrl.h
--- linux/drivers/net/bonding/bond_l2da_ctrl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_l2da_ctrl.h	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,30 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __BOND_L2DA_CTRL_H__
+#define __BOND_L2DA_CTRL_H__
+
+int  _bond_l2da_ctrl_try_lock(struct bonding *bond, bool set);
+void _bond_l2da_ctrl_unlock(struct bonding *bond, bool set);
+
+int bond_l2da_ctrl_set_default(struct bonding *bond, const char *slave_ifname);
+int bond_l2da_ctrl_get_default(struct bonding *bond, char *buf, int size);
+int bond_l2da_ctrl_change_map_entry(struct bonding *bond, const u8 *da,
+				const char *slave_ifname);
+int bond_l2da_ctrl_reset_map(struct bonding *bond);
+int bond_l2da_ctrl_set_opts(struct bonding *bond, u32 opts);
+int bond_l2da_ctrl_get_opts(struct bonding *bond, u32 *opts);
+
+#endif /* __BOND_L2DA_CTRL_H__ */
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_l2da.h linux-3.14/drivers/net/bonding/bond_l2da.h
--- linux/drivers/net/bonding/bond_l2da.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_l2da.h	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,59 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __BOND_L2DA_H__
+#define __BOND_L2DA_H__
+
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/hashtable.h>
+#include <linux/rwlock.h>
+
+#define BOND_L2A_HASHTABLE_BITS 3
+
+/* L2DA Exported structures to the main bonding code */
+struct l2da_bond_info {
+	DECLARE_HASHTABLE(da_matrix, BOND_L2A_HASHTABLE_BITS); /*DA:iface map*/
+	struct slave *default_slave; /* Default slave */
+	rwlock_t lock;
+	atomic_t opts;
+};
+
+/* l2DA Exported functions to the main bonding code */
+int bond_l2da_initialize(struct bonding *bond);
+void bond_l2da_deinitialize(struct bonding *bond);
+int bond_l2da_bind_slave(struct bonding *bond, struct slave *slave);
+void bond_l2da_unbind_slave(struct bonding *bond, struct slave *slave);
+int bond_l2da_xmit(struct sk_buff *skb, struct net_device *dev);
+bool bond_l2da_handle_rx_frame(struct bonding *bond, struct slave *slave,
+			       struct sk_buff *skb);
+void bond_l2da_set_opts(struct bonding *bond, u32 opts);
+u32 bond_l2da_get_opts(struct bonding *bond);
+int bond_l2da_set_default_slave(struct bonding *bond, struct slave *slave);
+int bond_l2da_get_default_slave_name(struct bonding *bond, char *buf, int size);
+int bond_l2da_set_da_slave(struct bonding *bond, const unsigned char *da,
+			   struct slave *slave);
+int bond_l2da_del_da(struct bonding *bond, const unsigned char *da);
+void bond_l2da_purge(struct bonding *bond);
+void bond_l2da_handle_link_change(struct bonding *bond, struct slave *slave);
+void bond_l2da_call_foreach(struct bonding *bond,
+			    int (*clb)(const unsigned char *da,
+				       struct slave *slave,
+				       void *ctx),
+			    void *ctx);
+struct net_device *bond_l2da_get_tx_dev(uint8_t *dest_mac,
+					struct net_device *bond_dev);
+#endif /* __BOND_L2DA_H__ */
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_main.c linux-3.14/drivers/net/bonding/bond_main.c
--- linux/drivers/net/bonding/bond_main.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_main.c	2016-09-01 11:52:04.000000000 +0800
@@ -82,6 +82,7 @@
 #include "bonding.h"
 #include "bond_3ad.h"
 #include "bond_alb.h"
+#include "bond_genl.h"
 
 /*---------------------------- Module parameters ----------------------------*/
 
@@ -133,10 +134,7 @@
 MODULE_PARM_DESC(use_carrier, "Use netif_carrier_ok (vs MII ioctls) in miimon; "
 			      "0 for off, 1 for on (default)");
 module_param(mode, charp, 0);
-MODULE_PARM_DESC(mode, "Mode of operation; 0 for balance-rr, "
-		       "1 for active-backup, 2 for balance-xor, "
-		       "3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, "
-		       "6 for balance-alb");
+MODULE_PARM_DESC(mode, "Mode of operation; 0 for balance-rr, 1 for active-backup, 2 for balance-xor, 3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, 6 for balance-alb, 7 for l2da");
 module_param(primary, charp, 0);
 MODULE_PARM_DESC(primary, "Primary network device to use");
 module_param(primary_reselect, charp, 0);
@@ -208,7 +206,6 @@
 static unsigned long bond_id_mask = 0xFFFFFFF0;
 
 /*-------------------------- External variables -----------------------------*/
-extern struct bond_cb *bond_cb;
 
 /*-------------------------- Forward declarations ---------------------------*/
 
@@ -227,9 +224,10 @@
 		[BOND_MODE_8023AD] = "IEEE 802.3ad Dynamic link aggregation",
 		[BOND_MODE_TLB] = "transmit load balancing",
 		[BOND_MODE_ALB] = "adaptive load balancing",
+		[BOND_MODE_L2DA] = "layer 2 destination address map",
 	};
 
-	if (mode < BOND_MODE_ROUNDROBIN || mode > BOND_MODE_ALB)
+	if (mode < BOND_MODE_ROUNDROBIN || mode > BOND_MODE_L2DA)
 		return "unknown";
 
 	return names[mode];
@@ -273,6 +271,40 @@
 		dev_queue_xmit(skb);
 }
 
+/**
+ * bond_xmit_all_slaves - send packet via all slaves at once.
+ *
+ * @bond: bond device that got this skb for tx.
+ * @skb: hw accel VLAN tagged skb to transmit
+ */
+int bond_xmit_all_slaves(struct bonding *bond, struct sk_buff *skb)
+{
+	struct slave *slave = NULL;
+	struct list_head *iter;
+
+	bond_for_each_slave_rcu(bond, slave, iter) {
+		if (bond_is_last_slave(bond, slave))
+			break;
+		if (IS_UP(slave->dev) && slave->link == BOND_LINK_UP) {
+			struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
+
+			if (!skb2) {
+				pr_err("%s: Error: bond_xmit_all_slaves(): skb_clone() failed\n",
+				       bond->dev->name);
+				continue;
+			}
+			/* bond_dev_queue_xmit always returns 0 */
+			bond_dev_queue_xmit(bond, skb2, slave->dev);
+		}
+	}
+	if (slave && IS_UP(slave->dev) && slave->link == BOND_LINK_UP)
+		bond_dev_queue_xmit(bond, skb, slave->dev);
+	else
+		dev_kfree_skb_any(skb);
+
+	return NETDEV_TX_OK;
+}
+
 /*
  * In the following 2 functions, bond_vlan_rx_add_vid and bond_vlan_rx_kill_vid,
  * We don't protect the slave list iteration with a lock because:
@@ -1158,6 +1190,12 @@
 		return RX_HANDLER_EXACT;
 	}
 
+	if (bond_is_l2da(bond) &&
+	    !bond_l2da_handle_rx_frame(bond, slave, skb)) {
+		consume_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
 	skb->dev = bond->dev;
 
 	if (bond->params.mode == BOND_MODE_ALB &&
@@ -1205,7 +1243,7 @@
 	struct slave *new_slave = NULL, *prev_slave;
 	struct sockaddr addr;
 	int link_reporting;
-	int res = 0, i;
+	int res = 0, i, mac_stolen = 0, same_addr;
 
 	if (!bond->params.use_carrier &&
 	    slave_dev->ethtool_ops->get_link == NULL &&
@@ -1300,6 +1338,9 @@
 		goto err_undo_flags;
 	}
 
+	same_addr = (memcmp(bond_dev->dev_addr, slave_dev->dev_addr,
+			    ETH_ALEN) == 0);
+
 	if (slave_ops->ndo_set_mac_address == NULL) {
 		if (!bond_has_slaves(bond)) {
 			pr_warn("%s: Warning: The first slave device specified does not support setting the MAC address.\n",
@@ -1309,6 +1350,9 @@
 				pr_warn("%s: Setting fail_over_mac to active for active-backup mode.\n",
 					bond_dev->name);
 			}
+		} else if (bond_is_l2da(bond) && same_addr) {
+			pr_warn("%s: Warning: Slave device does not support setting the MAC address. ignore due to same address.\n",
+				bond_dev->name);
 		} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
 			pr_err("%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n",
 			       bond_dev->name);
@@ -1322,8 +1366,10 @@
 	/* If this is the first slave, then we need to set the master's hardware
 	 * address to be the same as the slave's. */
 	if (!bond_has_slaves(bond) &&
-	    bond->dev->addr_assign_type == NET_ADDR_RANDOM)
+	    bond->dev->addr_assign_type == NET_ADDR_RANDOM) {
 		bond_set_dev_addr(bond->dev, slave_dev);
+		mac_stolen = 1;
+	}
 
 	new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);
 	if (!new_slave) {
@@ -1351,8 +1397,12 @@
 	 */
 	memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);
 
-	if (!bond->params.fail_over_mac ||
-	    bond->params.mode != BOND_MODE_ACTIVEBACKUP) {
+	if ((!bond->params.fail_over_mac ||
+	     bond->params.mode != BOND_MODE_ACTIVEBACKUP) &&
+	    /* In l2da mode, skip for first slave and skip if
+	     * slave's address is already same as bond's address.
+	     */
+	    !(bond_is_l2da(bond) && (mac_stolen || same_addr))) {
 		/*
 		 * Set slave to master's mac address.  The application already
 		 * set the master's mac address to that of the first slave
@@ -1523,6 +1573,10 @@
 		bond_set_active_slave(new_slave);
 		bond_set_slave_inactive_flags(new_slave, BOND_SLAVE_NOTIFY_NOW);
 		break;
+	case BOND_MODE_L2DA:
+		bond_set_slave_active_flags(new_slave, BOND_SLAVE_NOTIFY_NOW);
+		bond_l2da_bind_slave(bond, new_slave);
+		break;
 	default:
 		pr_debug("This slave is always active in trunk mode\n");
 
@@ -1750,7 +1804,8 @@
 		 * but before a new active slave is selected.
 		 */
 		bond_alb_deinit_slave(bond, slave);
-	}
+	} else if (bond_is_l2da(bond))
+		bond_l2da_unbind_slave(bond, slave);
 
 	if (all) {
 		RCU_INIT_POINTER(bond->curr_active_slave, NULL);
@@ -1905,7 +1960,6 @@
 
 /*-------------------------------- Monitoring -------------------------------*/
 
-
 static int bond_miimon_inspect(struct bonding *bond)
 {
 	int link_state, commit = 0;
@@ -2050,6 +2104,9 @@
 				slave_dev = slave->dev;
 			}
 
+			if (bond_is_l2da(bond))
+				bond_l2da_handle_link_change(bond, slave);
+
 			if (!bond->curr_active_slave ||
 			    (slave == bond->primary_slave))
 				goto do_failover;
@@ -2078,6 +2135,9 @@
 				bond_alb_handle_link_change(bond, slave,
 							    BOND_LINK_DOWN);
 
+			if (bond_is_l2da(bond))
+				bond_l2da_handle_link_change(bond, slave);
+
 			if (slave == bond->curr_active_slave)
 				goto do_failover;
 
@@ -2210,7 +2270,6 @@
 	arp_xmit(skb);
 }
 
-
 static void bond_arp_send_all(struct bonding *bond, struct slave *slave)
 {
 	struct net_device *upper, *vlan_upper;
@@ -3031,8 +3090,10 @@
 	} else {
 		return false;
 	}
-	if ((bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34) && (layer4hdr != NULL))
-		fk->ports = *layer4hdr;
+	if ((bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34) && (layer4hdr != NULL)) {
+		fk->port16[0] = *layer4hdr;
+		fk->port16[1] = *(layer4hdr + 1);
+	}
 
 	return true;
 }
@@ -3276,7 +3337,6 @@
 		if (!mii)
 			return -EINVAL;
 
-
 		if (mii->reg_num == 1) {
 			mii->val_out = 0;
 			read_lock(&bond->lock);
@@ -3378,7 +3438,6 @@
 	struct list_head *iter;
 	struct slave *slave;
 
-
 	rcu_read_lock();
 	if (USES_PRIMARY(bond->params.mode)) {
 		slave = rcu_dereference(bond->curr_active_slave);
@@ -3538,7 +3597,6 @@
 	if (bond->params.mode == BOND_MODE_ALB)
 		return bond_alb_set_mac_address(bond_dev, addr);
 
-
 	pr_debug("bond=%p, name=%s\n",
 		 bond, bond_dev ? bond_dev->name : "None");
 
@@ -3872,6 +3930,8 @@
 			return bond_xor_get_tx_dev(skb, src_mac, dst_mac, src, dst, protocol, bond_dev, layer4hdr);
 		case BOND_MODE_8023AD:
 			return bond_3ad_get_tx_dev(skb, src_mac, dst_mac, src, dst, protocol, bond_dev, layer4hdr);
+		case BOND_MODE_L2DA:
+			return bond_l2da_get_tx_dev(dst_mac, bond_dev);
 		default:
 			return NULL;
 	}
@@ -3907,30 +3967,7 @@
 static int bond_xmit_broadcast(struct sk_buff *skb, struct net_device *bond_dev)
 {
 	struct bonding *bond = netdev_priv(bond_dev);
-	struct slave *slave = NULL;
-	struct list_head *iter;
-
-	bond_for_each_slave_rcu(bond, slave, iter) {
-		if (bond_is_last_slave(bond, slave))
-			break;
-		if (IS_UP(slave->dev) && slave->link == BOND_LINK_UP) {
-			struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
-
-			if (!skb2) {
-				pr_err("%s: Error: bond_xmit_broadcast(): skb_clone() failed\n",
-				       bond_dev->name);
-				continue;
-			}
-			/* bond_dev_queue_xmit always returns 0 */
-			bond_dev_queue_xmit(bond, skb2, slave->dev);
-		}
-	}
-	if (slave && IS_UP(slave->dev) && slave->link == BOND_LINK_UP)
-		bond_dev_queue_xmit(bond, skb, slave->dev);
-	else
-		dev_kfree_skb_any(skb);
-
-	return NETDEV_TX_OK;
+	return bond_xmit_all_slaves(bond, skb);
 }
 
 /*------------------------- Device initialization ---------------------------*/
@@ -3962,7 +3999,6 @@
 	return 1;
 }
 
-
 static u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb,
 			     void *accel_priv, select_queue_fallback_t fallback)
 {
@@ -4010,6 +4046,8 @@
 	case BOND_MODE_ALB:
 	case BOND_MODE_TLB:
 		return bond_alb_xmit(skb, dev);
+	case BOND_MODE_L2DA:
+		return bond_l2da_xmit(skb, dev);
 	default:
 		/* Should never happen, mode already checked */
 		pr_err("%s: Error: Unknown bonding mode %d\n",
@@ -4208,6 +4246,9 @@
 	list_del(&bond->bond_list);
 
 	bond_debug_unregister(bond);
+
+	if (bond_is_l2da(bond))
+		bond_l2da_deinitialize(bond);
 }
 
 /*------------------------- Module initialization ---------------------------*/
@@ -4258,6 +4299,20 @@
 	return -1;
 }
 
+/**
+ * Notify ECM about the change in bond slave
+ */
+void bond_notify_l2da(uint8_t *slave_mac_addr)
+{
+	spin_lock_bh(&bond_cb_lock);
+	if (bond_cb && bond_cb->bond_cb_delete_by_mac) {
+		bond_cb->bond_cb_delete_by_mac(slave_mac_addr);
+		pr_info("Deleted fast path rules with mac-id: %pM\n",
+			slave_mac_addr);
+	}
+	spin_unlock_bh(&bond_cb_lock);
+}
+
 static int bond_check_params(struct bond_params *params)
 {
 	int arp_validate_value, fail_over_mac_value, primary_reselect_value, i;
@@ -4386,6 +4441,19 @@
 		all_slaves_active = 0;
 	}
 
+	if (bond_mode == BOND_MODE_L2DA) {
+		if (!all_slaves_active) {
+			pr_warn("Warning: all_slaves_active must be set, otherwise bonding will not be able to route packets that are essential for l2da operation\n");
+			pr_warn("Forcing all_slaves_active to 1\n");
+			all_slaves_active = 1;
+		}
+		if (!miimon) {
+			pr_warn("Warning: miimon must be specified, otherwise bonding will not detect link failure which is essential for l2da operation\n");
+			pr_warn("Forcing miimon to 100msec\n");
+			miimon = 100;
+		}
+	}
+
 	if (resend_igmp < 0 || resend_igmp > 255) {
 		pr_warning("Warning: resend_igmp (%d) should be between "
 			   "0 and 255, resetting to %d\n",
@@ -4642,6 +4710,7 @@
 	struct bonding *bond = netdev_priv(bond_dev);
 	struct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);
 	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
+	int ret;
 
 	pr_debug("Begin bond_init for %s\n", bond_dev->name);
 
@@ -4654,6 +4723,15 @@
 	spin_lock_init(&(bond_info->tx_hashtbl_lock));
 	spin_lock_init(&(bond_info->rx_hashtbl_lock));
 
+	if (bond_is_l2da(bond)) {
+		ret = bond_l2da_initialize(bond);
+		if (ret) {
+			pr_err("%s: l2da mode cannot be initialized\n",
+			       bond->dev->name);
+			return ret;
+		}
+	}
+
 	bond->wq = create_singlethread_workqueue(bond_dev->name);
 	if (!bond->wq)
 		return -ENOMEM;
@@ -4778,6 +4856,10 @@
 	if (res)
 		goto err_link;
 
+	res = bond_genl_initialize();
+	if (res)
+		goto err_genl;
+
 	bond_create_debugfs();
 
 	for (i = 0; i < max_bonds; i++) {
@@ -4791,6 +4873,8 @@
 	return res;
 err:
 	bond_destroy_debugfs();
+	bond_genl_deinitialize();
+err_genl:
 	bond_netlink_fini();
 err_link:
 	unregister_pernet_subsys(&bond_net_ops);
@@ -4804,6 +4888,7 @@
 
 	bond_destroy_debugfs();
 
+	bond_genl_deinitialize();
 	bond_netlink_fini();
 	unregister_pernet_subsys(&bond_net_ops);
 
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_options.c linux-3.14/drivers/net/bonding/bond_options.c
--- linux/drivers/net/bonding/bond_options.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_options.c	2016-09-01 11:52:04.000000000 +0800
@@ -28,6 +28,7 @@
 	{ "802.3ad",       BOND_MODE_8023AD,       0},
 	{ "balance-tlb",   BOND_MODE_TLB,          0},
 	{ "balance-alb",   BOND_MODE_ALB,          0},
+	{ "l2da",          BOND_MODE_L2DA,         0},
 	{ NULL,            -1,                     0},
 };
 
@@ -177,7 +178,7 @@
 		.name = "arp_interval",
 		.desc = "arp interval in milliseconds",
 		.unsuppmodes = BIT(BOND_MODE_8023AD) | BIT(BOND_MODE_TLB) |
-			       BIT(BOND_MODE_ALB),
+			       BIT(BOND_MODE_ALB) | BIT(BOND_MODE_L2DA),
 		.values = bond_intmax_tbl,
 		.set = bond_option_arp_interval_set
 	},
@@ -584,7 +585,8 @@
 
 int bond_option_mode_set(struct bonding *bond, struct bond_opt_value *newval)
 {
-	if (BOND_NO_USES_ARP(newval->value) && bond->params.arp_interval) {
+	if ((BOND_NO_USES_ARP(newval->value) || bond_is_l2da(bond)) &&
+	    bond->params.arp_interval) {
 		pr_info("%s: %s mode is incompatible with arp monitoring, start mii monitoring\n",
 			bond->dev->name, newval->string);
 		/* disable arp monitoring */
@@ -595,6 +597,19 @@
 			bond->dev->name, bond->params.miimon);
 	}
 
+	if (bond->params.mode != newval->value) {
+		if (newval->value == BOND_MODE_L2DA) {
+			int ret = bond_l2da_initialize(bond);
+			if (ret) {
+				pr_err("%s: l2da mode cannot be initialized\n",
+				       bond->dev->name);
+				return ret;
+			}
+		} else if (bond_is_l2da(bond)) {
+			bond_l2da_deinitialize(bond);
+		}
+	}
+
 	/* don't cache arp_validate between modes */
 	bond->params.arp_validate = BOND_ARP_VALIDATE_NONE;
 	bond->params.mode = newval->value;
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/bond_sysfs.c linux-3.14/drivers/net/bonding/bond_sysfs.c
--- linux/drivers/net/bonding/bond_sysfs.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/bonding/bond_sysfs.c	2016-09-01 11:52:04.000000000 +0800
@@ -41,11 +41,21 @@
 #include <linux/nsproxy.h>
 
 #include "bonding.h"
+#include "bond_l2da_ctrl.h"
 
 #define to_dev(obj)	container_of(obj, struct device, kobj)
 #define to_bond(cd)	((struct bonding *)(netdev_priv(to_net_dev(cd))))
 
 /*
+ * Used for internal use of bonding_show_l2da_table and
+ * bonding_show_l2da_table_clb
+*/
+struct bonding_show_l2da_table_clb_ctx {
+	char *buf; /* save the updated result data */
+	int   res; /* save the updated result */
+};
+
+/*
  * "show" function for the bond_masters attribute.
  * The class parameter is ignored.
  */
@@ -1067,6 +1077,175 @@
 		   bonding_show_packets_per_slave,
 		   bonding_store_packets_per_slave);
 
+static ssize_t bonding_show_l2da_default_slave(struct device *d,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct bonding *bond = to_bond(d);
+	char ifname[IFNAMSIZ + 1];
+	int ret;
+
+	ret = bond_l2da_ctrl_get_default(bond, ifname, sizeof(ifname));
+	return ret ? ret : snprintf(buf, PAGE_SIZE, "%s\n", ifname);
+}
+
+static ssize_t bonding_store_l2da_default_slave(struct device *d,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct bonding *bond = to_bond(d);
+	int ret = -EINVAL;
+	char ifname[IFNAMSIZ];
+	if (sscanf(buf, "%15s", ifname) != 1) {/* IFNAMSIZ */
+		pr_info("%s: no L2DA slave name specified\n",
+			netdev_name(bond->dev));
+		return -EINVAL;
+	}
+
+	ret = bond_l2da_ctrl_set_default(bond, ifname);
+	return ret ? ret : count;
+}
+
+static DEVICE_ATTR(l2da_default_slave, S_IRUGO | S_IWUSR,
+		   bonding_show_l2da_default_slave,
+		   bonding_store_l2da_default_slave);
+
+static int bonding_show_l2da_table_clb(const unsigned char *da,
+		struct slave *slave, void *_ctx)
+{
+	struct bonding_show_l2da_table_clb_ctx *ctx = _ctx;
+
+	/* Each entry reported as xx:xx:xx:xx:xx:xx@ifname,
+	 * so we have to make sure that we have enough space
+	 * before we put the next one
+	 */
+	if (ctx->res > (PAGE_SIZE - sizeof("xx:xx:xx:xx:xx:xx") + IFNAMSIZ)) {
+		/* not enough space for another da@interface_name pair */
+		if ((PAGE_SIZE - ctx->res) > sizeof("++more++"))
+			ctx->res = PAGE_SIZE - sizeof("++more++");
+		ctx->res += snprintf(ctx->buf + ctx->res, PAGE_SIZE - ctx->res,
+				     "++more++");
+		return 1;
+	}
+	ctx->res += snprintf(ctx->buf + ctx->res, PAGE_SIZE - ctx->res,
+			     "%pM@%s\n", da, netdev_name(slave->dev));
+	return 0;
+}
+
+static ssize_t bonding_show_l2da_table(struct device *d,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct bonding *bond = to_bond(d);
+	struct bonding_show_l2da_table_clb_ctx ctx = {
+		.buf = buf,
+		.res = 0,
+	};
+	int ret;
+
+	ret = _bond_l2da_ctrl_try_lock(bond, false);
+	if (ret)
+		return ret;
+
+	bond_l2da_call_foreach(bond, bonding_show_l2da_table_clb, &ctx);
+
+	_bond_l2da_ctrl_unlock(bond, false);
+
+	if (ctx.res)
+		buf[ctx.res-1] = '\n'; /* eat the leftover space */
+
+	return ctx.res;
+}
+
+static ssize_t bonding_store_l2da_table(struct device *d,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct bonding *bond = to_bond(d);
+	int ret = -EINVAL;
+	char *delim;
+	unsigned char da[ETH_ALEN];
+	unsigned char ifname[IFNAMSIZ] = {0};
+	char *slave_ifname = NULL;
+
+	/* Check command syntax and extract parameters */
+	if (buf[0] == '+') {
+		/* delim will point to slave interface name if successful */
+		delim = strchr(buf, '@');
+		if (!delim) {
+			pr_err("%s: Invalid L2DA command string: %s\n",
+			       netdev_name(bond->dev), buf);
+			return -EINVAL;
+		}
+		/* Terminate string that points to da and bump it up one, so we
+		 * can read the device name there.
+		 */
+		*delim = '\0';
+		if (sscanf(delim + 1, "%15s", ifname) != 1) { /* IFNAMSIZ */
+			pr_err("%s: no L2DA slave name specified\n",
+			       netdev_name(bond->dev));
+			return -EINVAL;
+		}
+		slave_ifname = ifname;
+	} else if (buf[0] != '-') {
+		pr_err("%s: Invalid L2DA command string: %s\n",
+		       netdev_name(bond->dev), buf);
+		return -EINVAL;
+	} else if (buf[1] == '*') {
+		bond_l2da_ctrl_reset_map(bond);
+		return count;
+	}
+
+	if (!mac_pton(buf + 1, da)) {
+		pr_err("%s: Invalid L2DA MAC address string: %s\n",
+		       netdev_name(bond->dev), buf + 1);
+		return -EINVAL;
+	}
+
+	ret = bond_l2da_ctrl_change_map_entry(bond, da, slave_ifname);
+	return ret ? ret : count;
+}
+
+static DEVICE_ATTR(l2da_table, S_IRUGO | S_IWUSR,
+		   bonding_show_l2da_table, bonding_store_l2da_table);
+
+static ssize_t bonding_show_l2da_opts(struct device *d,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct bonding *bond = to_bond(d);
+	u32 opts;
+	int ret;
+
+	ret = bond_l2da_ctrl_get_opts(bond, &opts);
+	return ret ? ret : snprintf(buf, PAGE_SIZE, "0x%08x\n", opts);
+}
+
+static ssize_t bonding_store_l2da_opts(struct device *d,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct bonding *bond = to_bond(d);
+	int ret = -EINVAL;
+	unsigned int new_value;
+
+	ret = kstrtouint(buf, 0, &new_value);
+	if (ret < 0) {
+		pr_err("%s: Ignoring invalid opts value %s.\n",
+		       bond->dev->name, buf);
+		return ret;
+	}
+
+	pr_info("%s: Setting opts value to 0x%08x\n",
+		bond->dev->name, new_value);
+	ret = bond_l2da_ctrl_set_opts(bond, new_value);
+	return ret ? ret : count;
+}
+
+static DEVICE_ATTR(l2da_opts, S_IRUGO | S_IWUSR,
+		   bonding_show_l2da_opts,
+		   bonding_store_l2da_opts);
+
 static struct attribute *per_bond_attrs[] = {
 	&dev_attr_slaves.attr,
 	&dev_attr_mode.attr,
@@ -1099,6 +1278,9 @@
 	&dev_attr_min_links.attr,
 	&dev_attr_lp_interval.attr,
 	&dev_attr_packets_per_slave.attr,
+	&dev_attr_l2da_default_slave.attr,
+	&dev_attr_l2da_table.attr,
+	&dev_attr_l2da_opts.attr,
 	NULL,
 };
 
diff -Naur -x .git --no-dereference linux/drivers/net/bonding/Makefile linux-3.14/drivers/net/bonding/Makefile
--- linux/drivers/net/bonding/Makefile	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/bonding/Makefile	2016-09-01 11:52:04.000000000 +0800
@@ -4,7 +4,8 @@
 
 obj-$(CONFIG_BONDING) += bonding.o
 
-bonding-objs := bond_main.o bond_3ad.o bond_alb.o bond_sysfs.o bond_sysfs_slave.o bond_debugfs.o bond_netlink.o bond_options.o
+bonding-objs := bond_main.o bond_3ad.o bond_alb.o bond_sysfs.o bond_sysfs_slave.o bond_debugfs.o \
+	bond_netlink.o bond_options.o bond_l2da.o bond_l2da_ctrl.o bond_genl.o
 
 proc-$(CONFIG_PROC_FS) += bond_procfs.o
 bonding-objs += $(proc-y)
diff -Naur -x .git --no-dereference linux/drivers/net/ethernet/qcom/essedma/edma_axi.c linux-3.14/drivers/net/ethernet/qcom/essedma/edma_axi.c
--- linux/drivers/net/ethernet/qcom/essedma/edma_axi.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/ethernet/qcom/essedma/edma_axi.c	2016-09-01 11:52:04.000000000 +0800
@@ -35,7 +35,7 @@
 
 char edma_tx_irq[16][64];
 char edma_rx_irq[8][64];
-struct net_device *netdev[2];
+struct net_device *netdev[EDMA_MAX_PORTID_SUPPORTED];
 u16 tx_start[4] = {EDMA_TXQ_START_CORE0, EDMA_TXQ_START_CORE1,
 			EDMA_TXQ_START_CORE2, EDMA_TXQ_START_CORE3};
 u32 tx_mask[4] = {EDMA_TXQ_IRQ_MASK_CORE0, EDMA_TXQ_IRQ_MASK_CORE1,
@@ -43,6 +43,12 @@
 
 int edma_default_ltag  __read_mostly = EDMA_LAN_DEFAULT_VLAN;
 int edma_default_wtag  __read_mostly = EDMA_WAN_DEFAULT_VLAN;
+int edma_default_group1_vtag  __read_mostly = EDMA_DEFAULT_GROUP1_VLAN;
+int edma_default_group2_vtag  __read_mostly = EDMA_DEFAULT_GROUP2_VLAN;
+int edma_default_group3_vtag  __read_mostly = EDMA_DEFAULT_GROUP3_VLAN;
+int edma_default_group4_vtag  __read_mostly = EDMA_DEFAULT_GROUP4_VLAN;
+int edma_default_group5_vtag  __read_mostly = EDMA_DEFAULT_GROUP5_VLAN;
+
 int edma_weight_assigned_to_q __read_mostly;
 int edma_queue_to_virtual_q __read_mostly;
 bool edma_enable_rstp  __read_mostly;
@@ -56,6 +62,10 @@
 module_param(overwrite_mode, int, 0);
 MODULE_PARM_DESC(overwrite_mode, "overwrite default page_mode setting");
 
+static int jumbo_mru = EDMA_RX_HEAD_BUFF_SIZE;
+module_param(jumbo_mru, int, 0);
+MODULE_PARM_DESC(jumbo_mru, "enable fraglist support");
+
 static int num_rxq = 4;
 module_param(num_rxq, int, 0);
 MODULE_PARM_DESC(num_rxq, "change the number of rx queues");
@@ -184,9 +194,16 @@
 static int edma_change_default_lan_vlan(struct ctl_table *table, int write,
 		void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct edma_adapter *adapter = netdev_priv(netdev[1]);
+	struct edma_adapter *adapter;
 	int ret;
 
+	if (!netdev[1]) {
+		pr_err("Netdevice for default_lan does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[1]);
+
 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
 
 	if (write)
@@ -198,9 +215,16 @@
 static int edma_change_default_wan_vlan(struct ctl_table *table, int write,
 		void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-	struct edma_adapter *adapter = netdev_priv(netdev[0]);
+	struct edma_adapter *adapter;
 	int ret;
 
+	if (!netdev[0]) {
+		pr_err("Netdevice for default_wan does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[0]);
+
 	ret = proc_dointvec(table, write, buffer, lenp, ppos);
 
 	if (write)
@@ -209,6 +233,121 @@
 	return ret;
 }
 
+static int edma_change_group1_vtag(struct ctl_table *table, int write,
+		void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct edma_adapter *adapter;
+	struct edma_common_info *edma_cinfo;
+	int ret;
+
+	if (!netdev[0]) {
+		pr_err("Netdevice for Group 1 does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[0]);
+	edma_cinfo = adapter->edma_cinfo;
+
+	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+
+	if (write)
+		adapter->default_vlan_tag = edma_default_group1_vtag;
+
+	return ret;
+}
+
+static int edma_change_group2_vtag(struct ctl_table *table, int write,
+		void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct edma_adapter *adapter;
+	struct edma_common_info *edma_cinfo;
+	int ret;
+
+	if (!netdev[1]) {
+		pr_err("Netdevice for Group 2 does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[1]);
+	edma_cinfo = adapter->edma_cinfo;
+
+	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+
+	if (write)
+		adapter->default_vlan_tag = edma_default_group2_vtag;
+
+	return ret;
+}
+
+static int edma_change_group3_vtag(struct ctl_table *table, int write,
+		void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct edma_adapter *adapter;
+	struct edma_common_info *edma_cinfo;
+	int ret;
+
+	if (!netdev[2]) {
+		pr_err("Netdevice for Group 3 does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[2]);
+	edma_cinfo = adapter->edma_cinfo;
+
+	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+
+	if (write)
+		adapter->default_vlan_tag = edma_default_group3_vtag;
+
+	return ret;
+}
+
+static int edma_change_group4_vtag(struct ctl_table *table, int write,
+		void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct edma_adapter *adapter;
+	struct edma_common_info *edma_cinfo;
+	int ret;
+
+	if (!netdev[3]) {
+		pr_err("Netdevice for Group 4 does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[3]);
+	edma_cinfo = adapter->edma_cinfo;
+
+	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+
+	if (write)
+		adapter->default_vlan_tag = edma_default_group4_vtag;
+
+	return ret;
+}
+
+static int edma_change_group5_vtag(struct ctl_table *table, int write,
+		void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	struct edma_adapter *adapter;
+	struct edma_common_info *edma_cinfo;
+	int ret;
+
+	if (!netdev[4]) {
+		pr_err("Netdevice for Group 5 does not exist\n");
+		return -1;
+	}
+
+	adapter = netdev_priv(netdev[4]);
+	edma_cinfo = adapter->edma_cinfo;
+
+	ret = proc_dointvec(table, write, buffer, lenp, ppos);
+
+	if (write)
+		adapter->default_vlan_tag = edma_default_group5_vtag;
+
+	return ret;
+}
+
 static int edma_weight_assigned_to_queues(struct ctl_table *table, int write,
 		void __user *buffer, size_t *lenp, loff_t *ppos)
 {
@@ -330,6 +469,41 @@
 		.mode           = 0644,
 		.proc_handler   = edma_ath_hdr_eth_type
 	},
+	{
+		.procname       = "default_group1_vlan_tag",
+		.data           = &edma_default_group1_vtag,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = edma_change_group1_vtag
+	},
+	{
+		.procname       = "default_group2_vlan_tag",
+		.data           = &edma_default_group2_vtag,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = edma_change_group2_vtag
+	},
+	{
+		.procname       = "default_group3_vlan_tag",
+		.data           = &edma_default_group3_vtag,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = edma_change_group3_vtag
+	},
+	{
+		.procname       = "default_group4_vlan_tag",
+		.data           = &edma_default_group4_vtag,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = edma_change_group4_vtag
+	},
+	{
+		.procname       = "default_group5_vlan_tag",
+		.data           = &edma_default_group5_vtag,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = edma_change_group5_vtag
+	},
 	{}
 };
 
@@ -370,7 +544,7 @@
 {
 	struct edma_common_info *edma_cinfo;
 	struct edma_hw *hw;
-	struct edma_adapter *adapter[2];
+	struct edma_adapter *adapter[EDMA_MAX_PORTID_SUPPORTED];
 	struct resource *res;
 	struct device_node *np = pdev->dev.of_node;
 	struct device_node *pnp;
@@ -380,41 +554,46 @@
 	struct edma_mdio_data *mdio_data = NULL;
 	int i, j, k, err = 0, ret = 0;
 	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
+	int num_gmac, portid_bmp;
+	int idx = 0, idx_mac = 0;
 
 	if ((num_rxq != 4) && (num_rxq != 8)) {
 		dev_err(&pdev->dev, "Invalid RX queue, edma probe failed\n");
 		return -EINVAL;
 	}
-
-	/* Use to allocate net devices for multiple TX/RX queues */
-	netdev[0] = alloc_etherdev_mqs(sizeof(struct edma_adapter),
-			EDMA_NETDEV_TX_QUEUE, EDMA_NETDEV_RX_QUEUE);
-	if (!netdev[0]) {
-		dev_err(&pdev->dev, "net device alloc fails=%p\n", netdev[0]);
+	edma_cinfo = vzalloc(sizeof(struct edma_common_info));
+	if (!edma_cinfo) {
+		err = -ENOMEM;
 		goto err_alloc;
 	}
 
-	netdev[1] = alloc_etherdev_mqs(sizeof(struct edma_adapter),
-			EDMA_NETDEV_TX_QUEUE, EDMA_NETDEV_RX_QUEUE);
-	if (!netdev[1]) {
-		dev_err(&pdev->dev, "net device alloc fails=%p\n", netdev[1]);
-		goto err_alloc;
+	edma_cinfo->pdev = pdev;
+
+	of_property_read_u32(np, "qcom,num_gmac", &edma_cinfo->num_gmac);
+	if (edma_cinfo->num_gmac > EDMA_MAX_PORTID_SUPPORTED) {
+		pr_err("Invalid DTSI Entry for qcom,num_gmac\n");
+		err = -EINVAL;
+		goto err_cinfo;
 	}
 
-	SET_NETDEV_DEV(netdev[0], &pdev->dev);
-	platform_set_drvdata(pdev, netdev[0]);
-	SET_NETDEV_DEV(netdev[1], &pdev->dev);
-	platform_set_drvdata(pdev, netdev[1]);
+	/* Initialize the netdev array before allocation to avoid double free */
+	for (i = 0 ; i < edma_cinfo->num_gmac ; i++)
+		netdev[i] = NULL;
 
-	edma_cinfo = vzalloc(sizeof(struct edma_common_info));
-	if (!edma_cinfo) {
-		err = -ENOMEM;
-		goto err_ioremap;
-	}
+	for (i = 0 ; i < edma_cinfo->num_gmac ; i++) {
+		netdev[i] = alloc_etherdev_mqs(sizeof(struct edma_adapter),
+			EDMA_NETDEV_TX_QUEUE, EDMA_NETDEV_RX_QUEUE);
 
-	edma_cinfo->pdev = pdev;
-	edma_cinfo->netdev[0] = netdev[0];
-        edma_cinfo->netdev[1] = netdev[1];
+		if (!netdev[i]) {
+			dev_err(&pdev->dev, "net device alloc fails for index=%d\n", i);
+			err = -ENODEV;
+			goto err_ioremap;
+		}
+
+		SET_NETDEV_DEV(netdev[i], &pdev->dev);
+		platform_set_drvdata(pdev, netdev[i]);
+		edma_cinfo->netdev[i] = netdev[i];
+	}
 
 	/* Fill ring details */
 	edma_cinfo->num_tx_queues = EDMA_MAX_TRANSMIT_QUEUE;
@@ -435,15 +614,20 @@
 
 	of_property_read_u32(np, "qcom,page-mode", &edma_cinfo->page_mode);
 	of_property_read_u32(np, "qcom,rx_head_buf_size", &hw->rx_head_buff_size);
-	of_property_read_u32(np, "qcom,port_id_wan", &edma_cinfo->edma_port_id_wan);
 
 	if (overwrite_mode) {
 		dev_info(&pdev->dev, "page mode overwritten");
 		edma_cinfo->page_mode = page_mode;
 	}
 
+	if (jumbo_mru) {
+		edma_cinfo->fraglist_mode = 1;
+	}
+
 	if (edma_cinfo->page_mode)
 		hw->rx_head_buff_size = EDMA_RX_HEAD_BUFF_SIZE_JUMBO;
+	else if (edma_cinfo->fraglist_mode)
+		hw->rx_head_buff_size = jumbo_mru;
 	else if (!hw->rx_head_buff_size)
 		hw->rx_head_buff_size = EDMA_RX_HEAD_BUFF_SIZE;
 
@@ -464,8 +648,8 @@
 
 	edma_cinfo->hw.hw_addr = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(edma_cinfo->hw.hw_addr)) {
-		ret = PTR_ERR(edma_cinfo->hw.hw_addr);
-		goto err_hwaddr;
+		err = PTR_ERR(edma_cinfo->hw.hw_addr);
+		goto err_ioremap;
 	}
 
 	edma_hw_addr = (unsigned long)edma_cinfo->hw.hw_addr;
@@ -512,35 +696,83 @@
 		goto err_rx_rinit;
 	}
 
+	/* Initialize netdev and netdev bitmap for transmit descriptor rings */
+	for (i = 0; i < edma_cinfo->num_tx_queues; i++) {
+		struct edma_tx_desc_ring *etdr =  edma_cinfo->tpd_ring[i];
+		int j;
+
+		etdr->netdev_bmp = 0;
+		for (j = 0; j < EDMA_MAX_NETDEV_SUPPORTED_PER_QUEUE; j++) {
+			etdr->netdev[j] = NULL;
+			etdr->nq[j] = NULL;
+		}
+	}
+
+	if (of_property_read_bool(np, "qcom,mdio_supported")) {
+
+		mdio_node = of_find_compatible_node(NULL, NULL, "qcom,ipq40xx-mdio");
+		if (!mdio_node) {
+			dev_dbg(&pdev->dev, "cannot find mdio node by phandle");
+			err = -EIO;
+			goto err_mdiobus_init_fail;
+		}
+
+		mdio_plat = of_find_device_by_node(mdio_node);
+		if (!mdio_plat) {
+			dev_dbg(&pdev->dev, "cannot find platform device from mdio node");
+			of_node_put(mdio_node);
+			err = -EIO;
+			goto err_mdiobus_init_fail;
+		}
+
+		mdio_data = dev_get_drvdata(&mdio_plat->dev);
+		if (!mdio_data) {
+			dev_dbg(&pdev->dev, "cannot get mii bus reference from device data");
+			of_node_put(mdio_node);
+			err = -EIO;
+			goto err_mdiobus_init_fail;
+		}
+
+		miibus = mdio_data->mii_bus;
+	}
+
 	for_each_available_child_of_node(np, pnp) {
 		const char *mac_addr;
+
+		/*
+		 * this check is needed if parent and daughter dts have
+		 * different number of gmac nodes
+		 */
+		if (idx_mac == edma_cinfo->num_gmac)
+			break;
+
 		mac_addr = of_get_mac_address(pnp);
+		if (mac_addr)
+			memcpy(netdev[idx_mac]->dev_addr, mac_addr, ETH_ALEN);
 
-		if (mac_addr) {
-			if (!strcmp(pnp->name, "gmac0"))
-				memcpy(netdev[EDMA_WAN]->dev_addr, mac_addr,
-					ETH_ALEN);
-			else
-				memcpy(netdev[EDMA_LAN]->dev_addr, mac_addr,
-					ETH_ALEN);
-		}
+		idx_mac++;
 	}
 
 	/* Populate the adapter structure register the netdevice */
-	for (i = 0; i < EDMA_NR_NETDEV; i++) {
-		int k;
+	for (i = 0; i < edma_cinfo->num_gmac; i++) {
+		int k, m;
 		adapter[i] = netdev_priv(netdev[i]);
 		adapter[i]->netdev = netdev[i];
 		adapter[i]->pdev = pdev;
 		for (j = 0; j < EDMA_NR_CPU; j++) {
-			adapter[i]->tx_start_offset[j] = ((j << EDMA_TX_CPU_START_SHIFT) + (i << 1));
-			/* Map each ring netdev to either LAN or WAN netdevice
-			 * q0,q1,q4,q5,q8,q9,q12,q13 goes to WAN, others to LAN
+			m = i % 2;
+			adapter[i]->tx_start_offset[j] = ((j << EDMA_TX_CPU_START_SHIFT) + (m << 1));
+			/* Share the queues with available net-devices. For instance , with 5 net-devices
+			 * eth0/eth2/eth4 will share q0,q1,q4,q5,q8,q9,q12,q13 and eth1/eth3 will get the remaining.
 			 */
 			for (k = adapter[i]->tx_start_offset[j]; k < (adapter[i]->tx_start_offset[j] + 2); k++) {
-				edma_fill_netdev(edma_cinfo, k, i);
+				if (edma_fill_netdev(edma_cinfo, k, i, j)) {
+					pr_err("Netdev overflow Error\n");
+					goto err_register;
+				}
 			}
 		}
+
 		adapter[i]->edma_cinfo = edma_cinfo;
 		netdev[i]->netdev_ops = &edma_axi_netdev_ops;
 		netdev[i]->features = NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX
@@ -557,6 +789,14 @@
 		netdev[i]->vlan_features |= NETIF_F_RXHASH | NETIF_F_NTUPLE;
 		netdev[i]->wanted_features |= NETIF_F_RXHASH | NETIF_F_NTUPLE;
 #endif
+
+		if (edma_cinfo->fraglist_mode) {
+			netdev[i]->features |= NETIF_F_FRAGLIST;
+			netdev[i]->hw_features |= NETIF_F_FRAGLIST;
+			netdev[i]->vlan_features |= NETIF_F_FRAGLIST;
+			netdev[i]->wanted_features |= NETIF_F_FRAGLIST;
+		}
+
 		edma_set_ethtool_ops(netdev[i]);
 
 		/*
@@ -577,7 +817,7 @@
 		/* carrier off reporting is important to ethtool even BEFORE open */
 		netif_carrier_off(netdev[i]);
 
-               /* Allocate reverse irq cpu mapping structure for
+		/* Allocate reverse irq cpu mapping structure for
 		* receive queues
 		*/
 #ifdef CONFIG_RFS_ACCEL
@@ -590,62 +830,67 @@
 #endif
 	}
 
-	edma_cinfo->edma_ctl_table_hdr = register_net_sysctl(&init_net, "net/edma", edma_table);
-	if (!edma_cinfo->edma_ctl_table_hdr) {
-		dev_err(&pdev->dev, "edma sysctl table hdr not registered\n");
-		goto err_unregister_sysctl_tbl;
-	}
-
-	/* Set default LAN tag */
-	adapter[EDMA_LAN]->default_vlan_tag = EDMA_LAN_DEFAULT_VLAN;
-	/* Set default WAN tag */
-        adapter[EDMA_WAN]->default_vlan_tag = EDMA_WAN_DEFAULT_VLAN;
+	for (i = 0; i < EDMA_MAX_PORTID_BITMAP_INDEX; i++)
+		edma_cinfo->portid_netdev_lookup_tbl[i] = NULL;
 
+	for_each_available_child_of_node(np, pnp) {
+		const uint32_t *vlan_tag = NULL;
+		int len;
 
-	if (of_property_read_bool(np, "qcom,mdio_supported")) {
-		adapter[EDMA_WAN]->poll_required =
-			of_property_read_bool(np, "qcom,poll_required");
-		of_property_read_u32(np, "qcom,phy_mdio_addr",
-				&adapter[EDMA_WAN]->phy_mdio_addr);
-		of_property_read_u32(np, "qcom,forced_speed",
-				&adapter[EDMA_WAN]->forced_speed);
-		of_property_read_u32(np, "qcom,forced_duplex",
-				&adapter[EDMA_WAN]->forced_duplex);
-		if ((adapter[EDMA_WAN]->forced_speed != SPEED_10) &&
-				(adapter[EDMA_WAN]->forced_speed != SPEED_100)
-			&& (adapter[EDMA_WAN]->forced_speed != SPEED_1000)) {
-			adapter[EDMA_WAN]->forced_speed = SPEED_UNKNOWN;
-			adapter[EDMA_WAN]->forced_duplex = DUPLEX_UNKNOWN;
-		}
-
-		mdio_node = of_find_compatible_node(NULL, NULL, "qcom,ipq40xx-mdio");
-		if (!mdio_node) {
-			dev_dbg(&pdev->dev, "cannot find mdio node by phandle");
-			ret = -EIO;
-			goto err_mdiobus_init_fail;
+		/*
+		 * this check is needed if parent and daughter dts have
+		 * different number of gmac nodes
+		 */
+		if (idx == edma_cinfo->num_gmac)
+			break;
+
+		/* Populate port-id to netdev lookup table */
+		vlan_tag = of_get_property(pnp, "vlan_tag", &len);
+		if (!vlan_tag) {
+			pr_err("Vlan tag parsing Failed.\n");
+			goto err_rmap_alloc_fail;
 		}
 
-		mdio_plat = of_find_device_by_node(mdio_node);
-		if (!mdio_plat) {
-			dev_dbg(&pdev->dev, "cannot find platform device from mdio node");
-			of_node_put(mdio_node);
-			ret = -EIO;
-			goto err_mdiobus_init_fail;
+		adapter[idx]->default_vlan_tag = of_read_number(vlan_tag, 1);
+		vlan_tag++;
+		portid_bmp = of_read_number(vlan_tag, 1);
+		adapter[idx]->dp_bitmap = portid_bmp;
+
+		portid_bmp = portid_bmp >> 1; /* We ignore the bit for CPU Port */
+		while (portid_bmp) {
+			int port_bit = ffs(portid_bmp);
+			if (port_bit > EDMA_MAX_PORTID_SUPPORTED)
+				goto err_rmap_alloc_fail;
+			edma_cinfo->portid_netdev_lookup_tbl[port_bit] = netdev[idx];
+			portid_bmp &= ~(1 << (port_bit - 1));
 		}
 
-		mdio_data = dev_get_drvdata(&mdio_plat->dev);
-		if (!mdio_data) {
-			dev_dbg(&pdev->dev, "cannot get mii bus reference from device data");
-			of_node_put(mdio_node);
-			ret = -EIO;
-			goto err_mdiobus_init_fail;
+		if (!of_property_read_u32(pnp, "qcom,poll_required", &adapter[idx]->poll_required)) {
+			if (adapter[idx]->poll_required) {
+				of_property_read_u32(pnp, "qcom,phy_mdio_addr",
+					&adapter[idx]->phy_mdio_addr);
+				of_property_read_u32(pnp, "qcom,forced_speed",
+					&adapter[idx]->forced_speed);
+				of_property_read_u32(pnp, "qcom,forced_duplex",
+					&adapter[idx]->forced_duplex);
+
+				/* create a phyid using MDIO bus id and MDIO bus address */
+				snprintf(adapter[idx]->phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT,
+					miibus->id, adapter[idx]->phy_mdio_addr);
+			}
+		} else {
+			adapter[idx]->poll_required = 0;
+			adapter[idx]->forced_speed = SPEED_1000;
+			adapter[idx]->forced_duplex = DUPLEX_FULL;
 		}
 
-		miibus = mdio_data->mii_bus;
+		idx++;
+	}
 
-		/* create a phyid using MDIO bus id and MDIO bus address */
-		snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT,
-			miibus->id, adapter[EDMA_WAN]->phy_mdio_addr);
+	edma_cinfo->edma_ctl_table_hdr = register_net_sysctl(&init_net, "net/edma", edma_table);
+	if (!edma_cinfo->edma_ctl_table_hdr) {
+		dev_err(&pdev->dev, "edma sysctl table hdr not registered\n");
+		goto err_unregister_sysctl_tbl;
 	}
 
 	/* Disable all 16 Tx and 8 rx irqs */
@@ -681,12 +926,16 @@
 			sprintf(&edma_tx_irq[j][0], "edma_eth_tx%d", j);
 			err = request_irq(edma_cinfo->tx_irq[j], edma_interrupt,
 				IRQF_DISABLED, &edma_tx_irq[j][0], &edma_cinfo->edma_percpu_info[i]);
+			if (err)
+				goto err_reset;
 		}
 
 		for (j = edma_cinfo->edma_percpu_info[i].rx_start; j < (rx_start + ((edma_cinfo->num_rx_queues == 4) ? 1 : 2)); j++) {
 			sprintf(&edma_rx_irq[j][0], "edma_eth_rx%d", j);
 			err = request_irq(edma_cinfo->rx_irq[j], edma_interrupt,
 				IRQF_DISABLED, &edma_rx_irq[j][0], &edma_cinfo->edma_percpu_info[i]);
+			if (err)
+				goto err_reset;
 		}
 
 #ifdef CONFIG_RFS_ACCEL
@@ -730,23 +979,29 @@
 	edma_write_reg(EDMA_REG_VQ_CTRL0, EDMA_VQ_REG_VALUE);
 	edma_write_reg(EDMA_REG_VQ_CTRL1, EDMA_VQ_REG_VALUE);
 
+	/* Configure Max AXI Burst write size to 128 bytes*/
+	edma_write_reg(EDMA_REG_AXIW_CTRL_MAXWRSIZE, EDMA_AXIW_MAXWRSIZE_VALUE);
+
 	/* Enable All 16 tx and 8 rx irq mask */
 	edma_irq_enable(edma_cinfo);
 	edma_enable_tx_ctrl(&edma_cinfo->hw);
 	edma_enable_rx_ctrl(&edma_cinfo->hw);
 
-	if (adapter[EDMA_WAN]->poll_required) {
-		adapter[EDMA_WAN]->phydev =
-			phy_connect(netdev[EDMA_WAN], (const char *)phy_id,
-				&edma_adjust_link, PHY_INTERFACE_MODE_SGMII);
-		if (IS_ERR(adapter[EDMA_WAN]->phydev)) {
-			dev_dbg(&pdev->dev, "PHY attach FAIL");
-			ret = -EIO;
-			goto edma_phy_attach_fail;
-		} else {
-			adapter[EDMA_WAN]->phydev->advertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;
-			adapter[EDMA_WAN]->phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
-		}
+	for (i = 0; i < edma_cinfo->num_gmac; i++) {
+		if (adapter[i]->poll_required) {
+			adapter[i]->phydev =
+				phy_connect(netdev[i], (const char *)adapter[i]->phy_id,
+					&edma_adjust_link, PHY_INTERFACE_MODE_SGMII);
+			if (IS_ERR(adapter[i]->phydev)) {
+				dev_dbg(&pdev->dev, "PHY attach FAIL");
+				err = -EIO;
+				goto edma_phy_attach_fail;
+			} else {
+				adapter[i]->phydev->advertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;
+				adapter[i]->phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+			}
+		} else
+			adapter[i]->phydev = NULL;
 	}
 
 	spin_lock_init(&edma_cinfo->stats_lock);
@@ -763,23 +1018,22 @@
 	miibus = NULL;
 err_configure:
 #ifdef CONFIG_RFS_ACCEL
-	for (i = 0; i < EDMA_NR_NETDEV; i++) {
+	for (i = 0; i < edma_cinfo->num_gmac; i++) {
 		free_irq_cpu_rmap(adapter[i]->netdev->rx_cpu_rmap);
 		adapter[i]->netdev->rx_cpu_rmap = NULL;
 	}
 #endif
 err_rmap_add_fail:
-err_reset:
-	for (i = 0; i < EDMA_NR_NETDEV; i++)
-		edma_free_irqs(adapter[i]);
+	edma_free_irqs(adapter[0]);
 	for (i = 0; i < EDMA_NR_CPU; i++)
 		napi_disable(&edma_cinfo->edma_percpu_info[i].napi);
-err_mdiobus_init_fail:
+err_reset:
 err_unregister_sysctl_tbl:
 err_rmap_alloc_fail:
-	for (i = 0; i < EDMA_NR_NETDEV; i++)
+	for (i = 0; i < edma_cinfo->num_gmac; i++)
 		unregister_netdev(netdev[i]);
 err_register:
+err_mdiobus_init_fail:
 	edma_free_rx_rings(edma_cinfo);
 err_rx_rinit:
 	edma_free_tx_rings(edma_cinfo);
@@ -788,11 +1042,13 @@
 err_rx_qinit:
 err_tx_qinit:
 	iounmap(edma_cinfo->hw.hw_addr);
-err_hwaddr:
-	vfree(edma_cinfo);
 err_ioremap:
-	for (i = 0; i < EDMA_NR_NETDEV; i++)
-		free_netdev(netdev[i]);
+	for (i = 0; i < edma_cinfo->num_gmac; i++) {
+		if (netdev[i])
+			free_netdev(netdev[i]);
+	}
+err_cinfo:
+	vfree(edma_cinfo);
 err_alloc:
 	return err;
 }
@@ -810,8 +1066,7 @@
 	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 	struct edma_hw *hw = &edma_cinfo->hw;
 	int i;
-
-	for (i = 0; i < EDMA_NR_NETDEV; i++)
+	for (i = 0; i < edma_cinfo->num_gmac; i++)
 		unregister_netdev(netdev[i]);
 
 	edma_stop_rx_tx(hw);
@@ -822,22 +1077,27 @@
 	edma_write_reg(EDMA_REG_RX_ISR, 0xff);
 	edma_write_reg(EDMA_REG_TX_ISR, 0xffff);
 #ifdef CONFIG_RFS_ACCEL
-	for (i = 0; i < EDMA_NR_NETDEV; i++) {
+	for (i = 0; i < edma_cinfo->num_gmac; i++) {
 		free_irq_cpu_rmap(netdev[0]->rx_cpu_rmap);
 		netdev[0]->rx_cpu_rmap = NULL;
 	}
 #endif
 
-	phy_disconnect(adapter->phydev);
+	for (i = 0; i < edma_cinfo->num_gmac; i++) {
+		struct edma_adapter *adapter = netdev_priv(netdev[i]);
+		if (adapter->phydev)
+			phy_disconnect(adapter->phydev);
+	}
+
 	del_timer_sync(&edma_stats_timer);
 	edma_free_irqs(adapter);
 	unregister_net_sysctl_table(edma_cinfo->edma_ctl_table_hdr);
-        edma_free_tx_resources(edma_cinfo);
-        edma_free_rx_resources(edma_cinfo);
+	edma_free_tx_resources(edma_cinfo);
+	edma_free_rx_resources(edma_cinfo);
 	edma_free_tx_rings(edma_cinfo);
 	edma_free_rx_rings(edma_cinfo);
 	edma_free_queues(edma_cinfo);
-	for (i = 0; i < EDMA_NR_NETDEV; i++)
+	for (i = 0; i < edma_cinfo->num_gmac; i++)
 		free_netdev(netdev[i]);
 
 	vfree(edma_cinfo);
diff -Naur -x .git --no-dereference linux/drivers/net/ethernet/qcom/essedma/edma.c linux-3.14/drivers/net/ethernet/qcom/essedma/edma.c
--- linux/drivers/net/ethernet/qcom/essedma/edma.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/ethernet/qcom/essedma/edma.c	2016-09-01 11:52:04.000000000 +0800
@@ -18,7 +18,7 @@
 #include "ess_edma.h"
 #include "edma.h"
 
-extern struct net_device *netdev[2];
+extern struct net_device *netdev[EDMA_MAX_PORTID_SUPPORTED];
 bool edma_stp_rstp;
 u16 edma_ath_eth_type;
 
@@ -43,7 +43,6 @@
 	etdr->sw_next_to_fill = 0;
 	etdr->sw_next_to_clean = 0;
 
-
 	/* Allocate SW descriptors */
 	etdr->sw_desc = vzalloc(etdr->size);
 	if (!unlikely(etdr->sw_desc)) {
@@ -432,19 +431,21 @@
 				continue;
 			}
 
+			/* Get the number of RFD from RRD */
+			num_rfds = rd->rrd1 & EDMA_RRD_NUM_RFD_MASK;
+
 			port_id = (rd->rrd1 >> EDMA_PORT_ID_SHIFT) & EDMA_PORT_ID_MASK;
-			if (!unlikely(port_id)) {
-				dev_err(&pdev->dev, "No RRD source port bit set");
-				edma_clean_rfd(erdr, sw_next_to_clean);
-				sw_next_to_clean = (sw_next_to_clean + 1) & (erdr->count - 1);
-				cleaned_count++;
+			if ((unlikely(!port_id)) || (unlikely(port_id > EDMA_MAX_PORTID_SUPPORTED))) {
+				dev_err(&pdev->dev, "Invalid RRD source port bit set");
+				for (i = 0; i < num_rfds; i++) {
+					edma_clean_rfd(erdr, sw_next_to_clean);
+					sw_next_to_clean = (sw_next_to_clean + 1) & (erdr->count - 1);
+					cleaned_count++;
+				}
 				continue;
 			}
 
-			if (port_id == edma_cinfo->edma_port_id_wan)
-				netdev = edma_cinfo->netdev[0];
-			else
-				netdev = edma_cinfo->netdev[1];
+			netdev = edma_cinfo->portid_netdev_lookup_tbl[port_id];
 			adapter = netdev_priv(netdev);
 
 			/* This code is added to handle a usecase where high priority stream
@@ -459,7 +460,7 @@
 			 */
 			priority = (rd->rrd1 >> EDMA_RRD_PRIORITY_SHIFT)
 				& EDMA_RRD_PRIORITY_MASK;
-			if (likely(!priority && !edma_cinfo->page_mode)) {
+			if (likely(!priority && !edma_cinfo->page_mode && (num_rfds <= 1))) {
 				rfd_avail = (count + sw_next_to_clean - hw_next_to_clean - 1) & (count - 1);
 				if (rfd_avail < EDMA_RFD_AVAIL_THR) {
 					sw_desc->flags = EDMA_SW_DESC_FLAG_SKB_REUSE;
@@ -494,34 +495,85 @@
 			/* Get the packet size and allocate buffer */
                         length = rd->rrd6 & EDMA_RRD_PKT_SIZE_MASK;
 
-                        /* Get the number of RFD from RRD */
-                        num_rfds = rd->rrd1 & EDMA_RRD_NUM_RFD_MASK;
-
 			if (likely(!edma_cinfo->page_mode)) {
 				/* Addition of 16 bytes is required, as in the packet
 			 	 * first 16 bytes are rrd descriptors, so actual data
 			 	 * starts from an offset of 16.
 			 	 */
 				skb_reserve(skb, 16);
-				skb_put(skb, length);
+				if (likely(!edma_cinfo->fraglist_mode)) {
+					skb_put(skb, length);
+				} else {
+					if (likely(num_rfds <= 1)) {
+						skb_put(skb, length);
+					} else {
+						struct sk_buff *skb_temp;
+						struct edma_hw *hw = &edma_cinfo->hw;
+						u16 size_remaining;
+
+						skb->data_len = 0;
+						skb->tail += (hw->rx_head_buff_size - 16);
+						skb->len = skb->truesize = length;
+						size_remaining = length - (hw->rx_head_buff_size - 16);
+
+						/* clean-up all related sw_descs */
+						for (i = 1; i < num_rfds; i++) {
+							struct sk_buff *skb_prev;
+							sw_desc = &erdr->sw_desc[sw_next_to_clean];
+							skb_temp = sw_desc->skb;
+
+							dma_unmap_single(&pdev->dev, sw_desc->dma,
+								sw_desc->length, DMA_FROM_DEVICE);
+
+							if (size_remaining < hw->rx_head_buff_size)
+								skb_put(skb_temp, size_remaining);
+							else
+								skb_put(skb_temp, hw->rx_head_buff_size);
+
+							/*
+						 	 * If we are processing the first rfd, we link
+							 * skb->frag_list to the skb corresponding to the
+							 * first RFD
+						 	 */
+							if (i == 1)
+								skb_shinfo(skb)->frag_list = skb_temp;
+							else
+								skb_prev->next = skb_temp;
+							skb_prev = skb_temp;
+							skb_temp->next = NULL;
+
+							skb->data_len += skb_temp->len;
+							size_remaining -= skb_temp->len;
+
+							/* Increment SW index */
+							sw_next_to_clean = (sw_next_to_clean + 1) & (erdr->count - 1);
+							cleaned_count++;
+						}
+					}
+				}
 			} else {
 				skb_frag_t *frag = &skb_shinfo(skb)->frags[0];
-				frag->page_offset += 16;
 
 				/* Setup skbuff fields */
 				skb->len = length;
 
 				if (likely(num_rfds <= 1)) {
-					frag->size = length;
-					skb->data_len = frag->size;
+					skb->data_len = length;
+					skb->truesize += edma_cinfo->rx_page_buffer_len;
+					skb_fill_page_desc(skb, 0, skb_frag_page(frag),
+							16, length);
 				} else {
 					struct sk_buff *skb_temp;
 					u16 size_remaining;
 
 					frag->size -= 16;
 					skb->data_len = frag->size;
+					skb->truesize += edma_cinfo->rx_page_buffer_len;
 					size_remaining = length - frag->size;
 
+					skb_fill_page_desc(skb, 0, skb_frag_page(frag),
+							16, frag->size);
+
 					/* clean-up all related sw_descs */
 					for (i = 1; i < num_rfds; i++) {
 						sw_desc = &erdr->sw_desc[sw_next_to_clean];
@@ -534,13 +586,13 @@
 							frag->size = size_remaining;
 
 						skb_fill_page_desc(skb, i, skb_frag_page(frag),
-							frag->page_offset, frag->size);
+								0, frag->size);
 
 						skb_shinfo(skb_temp)->nr_frags = 0;
 						dev_kfree_skb_any(skb_temp);
 
 						skb->data_len += frag->size;
-						skb->truesize += frag->size;
+						skb->truesize += edma_cinfo->rx_page_buffer_len;
 						size_remaining -= frag->size;
 
 						/* Increment SW index */
@@ -630,7 +682,6 @@
 			EDMA_RFD_CONS_IDX_MASK;
 	} while (hw_next_to_clean != sw_next_to_clean);
 
-
 	erdr->sw_next_to_clean = sw_next_to_clean;
 
 	/* alloc_rx_buf */
@@ -796,6 +847,8 @@
 	struct edma_tx_desc_ring *etdr = edma_cinfo->tpd_ring[queue_id];
 	struct edma_sw_desc *sw_desc;
 	struct platform_device *pdev = edma_cinfo->pdev;
+	struct net_device *netdev;
+	int i;
 
 	u16 sw_next_to_clean = etdr->sw_next_to_clean;
 	u16 hw_next_to_clean = 0;
@@ -815,9 +868,16 @@
 	/* update the TPD consumer index register */
 	edma_write_reg(EDMA_REG_TX_SW_CONS_IDX_Q(queue_id), sw_next_to_clean);
 
-	if (netif_tx_queue_stopped(etdr->nq) &&
-		netif_carrier_ok(&(etdr->netdev)))
-			netif_tx_wake_queue(etdr->nq);
+	/* Wake the queue if queue is stopped and netdev link is up */
+	for (i = 0; i < EDMA_MAX_NETDEV_SUPPORTED_PER_QUEUE; i++) {
+		if (etdr->nq[i]) {
+			if (netif_tx_queue_stopped(etdr->nq[i])) {
+				if ((etdr->netdev[i]) && netif_carrier_ok(etdr->netdev[i]))
+					netif_tx_wake_queue(etdr->nq[i]);
+			}
+		} else
+			break;
+	}
 }
 
 /*
@@ -1005,7 +1065,7 @@
 		word3 |= dp_bitmap << EDMA_TPD_PORT_BITMAP_SHIFT;
 		word3 |= from_cpu << EDMA_TPD_FROM_CPU_SHIFT;
 	} else
-		word3 |= EDMA_PORT_ENABLE_ALL << EDMA_TPD_PORT_BITMAP_SHIFT;
+		word3 |= adapter->dp_bitmap << EDMA_TPD_PORT_BITMAP_SHIFT;
 
 	buf_len = skb_headlen(skb);
 
@@ -1207,10 +1267,11 @@
 	struct edma_adapter *adapter = netdev_priv(net_dev);
 	struct edma_common_info *edma_cinfo = adapter->edma_cinfo;
 	struct edma_tx_desc_ring *etdr;
-	u16 from_cpu, dp_bitmap, txq_id;
+	u16 from_cpu = 0, dp_bitmap = 0, txq_id;
 	int ret, nr_frags = 0, num_tpds_needed = 1, queue_id = 0;
 	unsigned int flags_transmit = 0;
 	bool packet_is_rstp = false;
+	struct netdev_queue *nq = NULL;
 
 	if (unlikely(skb_shinfo(skb)->nr_frags)) {
 		nr_frags = skb_shinfo(skb)->nr_frags;
@@ -1255,16 +1316,16 @@
 	txq_id = skb_get_queue_mapping(skb);
 	queue_id = edma_tx_queue_get(adapter, skb, txq_id);
 	etdr = edma_cinfo->tpd_ring[queue_id];
-        etdr->nq = netdev_get_tx_queue(net_dev, txq_id);
+	nq = netdev_get_tx_queue(net_dev, txq_id);
 
+	local_bh_disable();
 	/* Tx is not handled in bottom half context. Hence, we need to protect
 	 * Tx from tasks and bottom half
 	 */
-	local_bh_disable();
 
 	if (unlikely(num_tpds_needed > edma_tpd_available(edma_cinfo, queue_id))) {
 		/* not enough descriptor, just stop queue */
-		netif_tx_stop_queue(etdr->nq);
+		netif_tx_stop_queue(nq);
 		local_bh_enable();
 		dev_dbg(&net_dev->dev, "Not enough descriptors available");
 		edma_cinfo->edma_ethstats.tx_desc_error++;
@@ -1828,12 +1889,24 @@
  * edma_fill_netdev()
  * 	Fill netdev for each etdr
  */
-void edma_fill_netdev(struct edma_common_info *edma_cinfo, int queue_id, int dev)
+int edma_fill_netdev(struct edma_common_info *edma_cinfo, int queue_id, int dev, int txq_id)
 {
 	struct edma_tx_desc_ring *etdr;
+	int i = 0;
 
 	etdr = edma_cinfo->tpd_ring[queue_id];
-	etdr->netdev = *netdev[dev];
+
+	while (etdr->netdev[i])
+		i++;
+
+	if (i >= EDMA_MAX_NETDEV_SUPPORTED_PER_QUEUE)
+		return -1;
+
+	/* Populate the netdev associated with the tpd ring */
+	etdr->netdev[i] = netdev[dev];
+	etdr->nq[i] = netdev_get_tx_queue(netdev[dev], txq_id);
+
+	return 0;
 }
 
 /*
@@ -1930,14 +2003,12 @@
 	 */
 	if (adapter->poll_required) {
 		if (!IS_ERR(adapter->phydev)) {
-			genphy_resume(adapter->phydev);
 			phy_start(adapter->phydev);
 			phy_start_aneg(adapter->phydev);
 			adapter->link_state = __EDMA_LINKDOWN;
 		} else {
 			dev_dbg(&pdev->dev, "Invalid PHY device for a link polled interface\n");
 		}
-		return;
 	} else {
 		adapter->link_state = __EDMA_LINKUP;
 		netif_carrier_on(netdev);
diff -Naur -x .git --no-dereference linux/drivers/net/ethernet/qcom/essedma/edma_ethtool.c linux-3.14/drivers/net/ethernet/qcom/essedma/edma_ethtool.c
--- linux/drivers/net/ethernet/qcom/essedma/edma_ethtool.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/ethernet/qcom/essedma/edma_ethtool.c	2016-09-01 11:52:04.000000000 +0800
@@ -269,21 +269,18 @@
 		struct ethtool_cmd *ecmd)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
+	struct phy_device *phydev = NULL;
 
-	if (adapter->poll_required) {
-		struct phy_device *phydev = NULL;
+	if ((adapter->forced_speed != SPEED_UNKNOWN) && !adapter->poll_required)
+		return -EPERM;
 
-		if ((adapter->forced_speed != SPEED_UNKNOWN))
-			return -EPERM;
+	phydev = adapter->phydev;
+	phydev->advertising = ecmd->advertising;
+	phydev->autoneg = ecmd->autoneg;
+	phydev->speed = ethtool_cmd_speed(ecmd);
+	phydev->duplex = ecmd->duplex;
 
-		phydev = adapter->phydev;
-		phydev->advertising = ecmd->advertising;
-		phydev->autoneg = ecmd->autoneg;
-		phydev->speed = ethtool_cmd_speed(ecmd);
-		phydev->duplex = ecmd->duplex;
-
-		genphy_config_aneg(phydev);
-	}
+	genphy_config_aneg(phydev);
 
 	return 0;
 }
@@ -307,6 +304,8 @@
 	 */
 	ec->tx_coalesce_usecs = (((reg_val >> 16) & 0xFFFF) << 1);
 	ec->rx_coalesce_usecs = ((reg_val & 0xFFFF) << 1);
+
+	return 0;
 }
 
 /*
@@ -320,6 +319,8 @@
 		edma_change_tx_coalesce(ec->tx_coalesce_usecs);
 	if (ec->rx_coalesce_usecs)
 		edma_change_rx_coalesce(ec->rx_coalesce_usecs);
+
+	return 0;
 }
 
 /*
@@ -335,7 +336,7 @@
  * edma_get_priv_flags()
  *	get edma driver flags
  */
-static uint32_t edma_get_priv_flags(struct net_device *netdev)
+static u32 edma_get_priv_flags(struct net_device *netdev)
 {
 	return 0;
 }
@@ -344,7 +345,7 @@
  * edma_get_ringparam()
  *	get ring size
  */
-static int edma_get_ringparam(struct net_device *netdev,
+static void edma_get_ringparam(struct net_device *netdev,
 		struct ethtool_ringparam *ring)
 {
 	struct edma_adapter *adapter = netdev_priv(netdev);
diff -Naur -x .git --no-dereference linux/drivers/net/ethernet/qcom/essedma/edma.h linux-3.14/drivers/net/ethernet/qcom/essedma/edma.h
--- linux/drivers/net/ethernet/qcom/essedma/edma.h	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/ethernet/qcom/essedma/edma.h	2016-09-01 11:52:04.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014 - 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014 - 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -43,7 +43,13 @@
 
 /* Number of Core/queues */
 #define EDMA_NR_CPU 4
-#define EDMA_NR_NETDEV 2
+
+#define EDMA_MAX_PORTID_SUPPORTED 5
+#define EDMA_MAX_VLAN_SUPPORTED  EDMA_MAX_PORTID_SUPPORTED
+#define EDMA_MAX_PORTID_BITMAP_INDEX (EDMA_MAX_PORTID_SUPPORTED + 1)
+#define EDMA_MAX_PORTID_BITMAP_SUPPORTED 0x1f	/* 0001_1111 = 0x1f */
+#define EDMA_MAX_NETDEV_SUPPORTED_PER_QUEUE 4 /* 3 Netdev per queue, 1 space for indexing */
+
 #define EDMA_MAX_RECEIVE_QUEUE 8
 #define EDMA_MAX_TRANSMIT_QUEUE 16
 
@@ -55,6 +61,12 @@
 #define EDMA_LAN_DEFAULT_VLAN 1
 #define EDMA_WAN_DEFAULT_VLAN 2
 
+#define EDMA_DEFAULT_GROUP1_VLAN 1
+#define EDMA_DEFAULT_GROUP2_VLAN 2
+#define EDMA_DEFAULT_GROUP3_VLAN 3
+#define EDMA_DEFAULT_GROUP4_VLAN 4
+#define EDMA_DEFAULT_GROUP5_VLAN 5
+
 /* Queues exposed to linux kernel */
 #define EDMA_NETDEV_TX_QUEUE 4
 #define EDMA_NETDEV_RX_QUEUE 4
@@ -73,9 +85,6 @@
 
 #define EDMA_TPD_FROM_CPU_SHIFT 25
 
-/* Enable Tx for all ports */
-#define EDMA_PORT_ENABLE_ALL 0x3E
-
 #define EDMA_FROM_CPU_MASK 0x80
 #define EDMA_SKB_PRIORITY_MASK 0x38
 
@@ -300,15 +309,15 @@
 	struct edma_tx_desc_ring *tpd_ring[16]; /* 16 Tx queues */
 	struct edma_rfd_desc_ring *rfd_ring[8]; /* 8 Rx queues */
 	struct platform_device *pdev; /* device structure */
-	struct net_device *netdev[2]; /* net device */
+	struct net_device *netdev[EDMA_MAX_PORTID_SUPPORTED];
+	int num_gmac;
+	struct net_device *portid_netdev_lookup_tbl[EDMA_MAX_PORTID_BITMAP_INDEX];
 	struct edma_ethtool_statistics edma_ethstats; /* ethtool stats */
 	int num_rx_queues; /* number of rx queue */
 	int num_tx_queues; /* number of tx queue */
 	int tx_irq[16]; /* number of tx irq */
 	int rx_irq[8]; /* number of rx irq */
-	int edma_port_id_wan; /* wan port id */
 	int from_cpu; /* from CPU TPD field */
-	int dp_bitmap; /* port bitmap */
 	int num_rxq_per_core; /* Rx queues per core */
 	int num_txq_per_core; /* Tx queues per core */
 	u16 tx_ring_count; /* Tx ring count */
@@ -316,6 +325,7 @@
 	u16 rx_head_buffer_len; /* rx buffer length */
 	u16 rx_page_buffer_len; /* rx buffer length */
 	u32 page_mode; /* Jumbo frame supported flag */
+	u32 fraglist_mode; /* fraglist supported flag */
 	struct edma_hw hw; /* edma hw specific structure */
 	struct ctl_table_header *edma_ctl_table_hdr;
 	struct edma_per_cpu_queues_info edma_percpu_info[EDMA_NR_CPU]; /* per cpu information */
@@ -324,8 +334,10 @@
 
 /* transimit packet descriptor (tpd) ring */
 struct edma_tx_desc_ring {
-	struct netdev_queue *nq; /* Linux queue index */
-	struct net_device netdev;
+	struct netdev_queue *nq[EDMA_MAX_NETDEV_SUPPORTED_PER_QUEUE]; /* Linux queue index */
+	struct net_device *netdev[EDMA_MAX_NETDEV_SUPPORTED_PER_QUEUE];
+			/* Array of netdevs associated with the tpd ring */
+	int netdev_bmp; /* Bitmap for per-ring netdevs */
 	u16 size; /* descriptor ring length in bytes */
 	u16 count; /* number of descriptors in the ring */
 	void *hw_desc; /* descriptor ring virtual address */
@@ -384,6 +396,8 @@
 	bool poll_required; /* check if link polling is required */
 	u32 tx_start_offset[EDMA_NR_CPU]; /* tx queue start */
 	int default_vlan_tag; /* vlan tag */
+	uint8_t phy_id[MII_BUS_ID_SIZE + 3];
+	uint32_t dp_bitmap;
 };
 
 int edma_alloc_queues_tx(struct edma_common_info *edma_cinfo);
@@ -424,10 +438,10 @@
 void edma_assign_ath_hdr_type(int tag);
 int edma_get_default_vlan_tag(struct net_device *netdev);
 void edma_adjust_link(struct net_device *netdev);
-void edma_fill_netdev(struct edma_common_info *edma_cinfo, int qid, int num);
+int edma_fill_netdev(struct edma_common_info *edma_cinfo, int qid, int num, int txq_id);
 u16 edma_select_xps_queue(struct net_device *dev, struct sk_buff *skb,
 	void *accel_priv, select_queue_fallback_t fallback);
-void edma_read_append_stats(edma_cinfo);
+void edma_read_append_stats(struct edma_common_info *edma_cinfo);
 void edma_change_tx_coalesce(int usecs);
 void edma_change_rx_coalesce(int usecs);
 void edma_get_tx_rx_coalesce(u32 *reg_val);
diff -Naur -x .git --no-dereference linux/drivers/net/ethernet/qcom/essedma/ess_edma.h linux-3.14/drivers/net/ethernet/qcom/essedma/ess_edma.h
--- linux/drivers/net/ethernet/qcom/essedma/ess_edma.h	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/ethernet/qcom/essedma/ess_edma.h	2016-09-01 11:52:04.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014 - 2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014 - 2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -259,6 +259,10 @@
 #define EDMA_RXQ_CTRL_RMV_VLAN 0x00000002
 #define EDMA_RXQ_CTRL_EN 0x0000FF00
 
+/* AXI Burst Size Config */
+#define EDMA_REG_AXIW_CTRL_MAXWRSIZE 0xA1C
+#define EDMA_AXIW_MAXWRSIZE_VALUE 0x0
+
 /* Rx Statistics Register */
 #define EDMA_REG_RX_STAT_BYTE_Q(x) (0xA30 + ((x) << 2)) /* x = queue id */
 #define EDMA_REG_RX_STAT_PKT_Q(x) (0xA50 + ((x) << 2)) /* x = queue id */
diff -Naur -x .git --no-dereference linux/drivers/net/phy/aq_phy.c linux-3.14/drivers/net/phy/aq_phy.c
--- linux/drivers/net/phy/aq_phy.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/phy/aq_phy.c	2016-09-01 11:52:04.000000000 +0800
@@ -732,7 +732,6 @@
 	if (!prop) {
 		dev_dbg(&pdev->dev, "cannot get 'mdiobus' property\n", __func__);
 		phy_driver_unregister(&aq_phy_driver);
-		vfree(priv);
 		return -EIO;
 	}
 
@@ -740,7 +739,6 @@
 	if (!mdio_node) {
 		dev_dbg(&pdev->dev, "cannot find mdio node by phandle\n", __func__);
 		phy_driver_unregister(&aq_phy_driver);
-		vfree(priv);
 		return -EIO;
 	}
 
@@ -748,7 +746,6 @@
 	if (!mdio_plat) {
 		dev_dbg(&pdev->dev, "cannot find platform device from mdio node\n", __func__);
 		phy_driver_unregister(&aq_phy_driver);
-		vfree(priv);
 		return -EIO;
 	}
 
@@ -756,7 +753,6 @@
 	if (!miibus) {
 		dev_dbg(&pdev->dev, "cannot get mii bus reference from device data\n", __func__);
 		phy_driver_unregister(&aq_phy_driver);
-		vfree(priv);
 		return -EIO;
 	}
 
diff -Naur -x .git --no-dereference linux/drivers/net/phy/phy.c linux-3.14/drivers/net/phy/phy.c
--- linux/drivers/net/phy/phy.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/phy/phy.c	2016-09-01 11:52:04.000000000 +0800
@@ -729,6 +729,9 @@
  */
 void phy_start(struct phy_device *phydev)
 {
+	bool do_resume = false;
+	int err = 0;
+
 	mutex_lock(&phydev->lock);
 
 	switch (phydev->state) {
@@ -739,11 +742,21 @@
 		phydev->state = PHY_UP;
 		break;
 	case PHY_HALTED:
+		/* make sure interrupts are re-enabled for the PHY */
+		err = phy_enable_interrupts(phydev);
+		if (err < 0)
+			break;
+
 		phydev->state = PHY_RESUMING;
+		do_resume = true;
 	default:
 		break;
 	}
 	mutex_unlock(&phydev->lock);
+
+	/* if phy was suspended, bring the physical link up again */
+	if (do_resume)
+		phy_resume(phydev);
 }
 EXPORT_SYMBOL(phy_start);
 
diff -Naur -x .git --no-dereference linux/drivers/net/phy/qca_85xx_sw.c linux-3.14/drivers/net/phy/qca_85xx_sw.c
--- linux/drivers/net/phy/qca_85xx_sw.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/phy/qca_85xx_sw.c	2016-09-01 11:52:04.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * qca_85xx_sw.c: QCA 85xx switch driver
  *
- * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2016 The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -189,47 +189,55 @@
 		return;
 	}
 
+	/*
+	 * Configure MAC<->PHY auto-negotiation/speed settings.
+	 * Speed 2500 => Auto-negotiation is off, force speed is on
+	 * Speed 100/1000 => Auto-negotiation is on, force speed is off
+	 */
 	sgmii_ctrl0_val = priv->read(SGMII_CTRL0_PORT27);
 	val = priv->read(port_status_cfg(priv->sgmii_plus_port_num));
 
-	/* Clear the previous link speed and duplex setting */
-	if (priv->sgmii_plus_link_speed == SPEED_100 ||
-	    priv->sgmii_plus_link_speed == SPEED_1000 ||
-	    priv->sgmii_plus_link_speed == SPEED_UNKNOWN) {
-		sgmii_ctrl0_val &= ~(SGMII_CTRL0_SGMII_MODE_MAC |
-				     SGMII_CTRL0_FORCE_SPEED_100 |
-				     SGMII_CTRL0_FORCE_SPEED_1000 |
-				     SGMII_CTRL0_FORCE_DUPLEX_FULL);
-
-		val &= ~(PORT_STATUS_FORCE_SPEED_100 |
-			 PORT_STATUS_FORCE_SPEED_1000 |
-			 PORT_STATUS_FORCE_DUPLEX_FULL);
-
-	}
+	/* Clear the previous speed, duplex, settings */
+	sgmii_ctrl0_val &= ~(SGMII_CTRL0_SGMII_MODE_MAC |
+			     SGMII_CTRL0_FORCE_SPEED_100 |
+			     SGMII_CTRL0_FORCE_SPEED_1000 |
+			     SGMII_CTRL0_FORCE_DUPLEX_FULL |
+			     SGMII_CTRL0_MR_AN_EN |
+			     SGMII_CTRL0_FORCE_MODE_EN);
+
+	val &= ~(PORT_STATUS_FORCE_SPEED_100 |
+		 PORT_STATUS_FORCE_SPEED_1000 |
+		 PORT_STATUS_FORCE_DUPLEX_FULL);
 
-	if (curr_speed == SPEED_1000 || curr_speed == SPEED_2500) {
-		/* Force the 1000Mbps link speed and duplex setting */
+	if (curr_speed != SPEED_100) {
+		/* Enable 1000Mbps speed and duplex setting */
 		val |= PORT_STATUS_FORCE_SPEED_1000 |
 		       PORT_STATUS_FORCE_DUPLEX_FULL;
 		sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_SPEED_1000 |
 				   SGMII_CTRL0_FORCE_DUPLEX_FULL;
+	}
+
+	if (curr_speed == SPEED_2500) {
+		/* Disable auto-neg, enable force mode */
+		sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_MODE_EN;
+	} else if (curr_speed == SPEED_1000) {
+		/* Enable auto-neg, disable force mode */
+		sgmii_ctrl0_val |= SGMII_CTRL0_MR_AN_EN;
 	} else {
 		/* Force the 100Mbps link speed and duplex setting */
 		sgmii_ctrl0_val |= SGMII_CTRL0_SGMII_MODE_MAC |
-				   SGMII_CTRL0_FORCE_SPEED_100;
+				   SGMII_CTRL0_FORCE_SPEED_100 |
+				   SGMII_CTRL0_MR_AN_EN;
 
-		val |=  PORT_STATUS_FORCE_SPEED_100;
+		val |= PORT_STATUS_FORCE_SPEED_100;
 
 		if (curr_duplex) {
 			/* Set 100Mbps Full Duplex */
 			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_DUPLEX_FULL;
 			val |=  PORT_STATUS_FORCE_DUPLEX_FULL;
-		} else {
-			/* Set 100Mbps Half Duplex */
-			sgmii_ctrl0_val &= ~SGMII_CTRL0_FORCE_DUPLEX_FULL;
-			val &= ~PORT_STATUS_FORCE_DUPLEX_FULL;
 		}
 	}
+
 	priv->write(port_status_cfg(priv->sgmii_plus_port_num), val);
 	priv->write(SGMII_CTRL0_PORT27, sgmii_ctrl0_val);
 	priv->sgmii_plus_link_speed = curr_speed;
@@ -447,8 +455,11 @@
 	val = priv->read(port_status_cfg(port));
 
 	/* Settings to force speed if configured */
-	if (sgmii_cfg->is_speed_forced == false)
+	if (sgmii_cfg->is_speed_forced == false) {
 		val |= PORT_STATUS_AUTONEG_EN;
+		sgmii_ctrl0_val |= SGMII_CTRL0_MR_AN_EN;
+		sgmii_ctrl0_val &= ~SGMII_CTRL0_FORCE_MODE_EN;
+	}
 	else {
 		/* Disable Auto-negotiation */
 		val &= ~(PORT_STATUS_AUTONEG_EN
@@ -458,8 +469,8 @@
 				| PORT_STATUS_TX_FLOW_EN);
 		val |= (PORT_STATUS_RXMAC_EN | PORT_STATUS_TXMAC_EN);
 
-		if (sgmii_cfg->port_mode != QCA_85XX_SW_PORT_MODE_SGMII_PLUS)
-			sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_MODE_EN;
+		sgmii_ctrl0_val &= ~SGMII_CTRL0_MR_AN_EN;
+		sgmii_ctrl0_val |= SGMII_CTRL0_FORCE_MODE_EN;
 
 		/* Force the speed and duplex as configured */
 		switch (sgmii_cfg->forced_speed) {
@@ -1168,25 +1179,25 @@
 	/* Get MDIO BUS pointer */
 	prop = of_get_property(np, "sgmii-plus-if-phy-mdiobus", NULL);
 	if (!prop) {
-		dev_dbg(&pdev->dev, "cannot get 'mdiobus' property\n", __func__);
+		pr_debug("%s: cannot get 'mdiobus' property\n", __func__);
 		return NULL;
 	}
 
 	mdio_node = of_find_node_by_phandle(be32_to_cpup(prop));
 	if (!mdio_node) {
-		dev_dbg(&pdev->dev, "cannot find mdio node by phandle\n", __func__);
+		pr_debug("%s: cannot find mdio node by phandle\n", __func__);
 		return NULL;
 	}
 
 	mdio_plat = of_find_device_by_node(mdio_node);
 	if (!mdio_plat) {
-		dev_dbg(&pdev->dev, "cannot find platform device from mdio node\n", __func__);
+		pr_debug("%s: cannot find platform device from mdio node\n", __func__);
 		return NULL;
 	}
 
 	miibus = dev_get_drvdata(&mdio_plat->dev);
 	if (!miibus) {
-		dev_dbg(&pdev->dev, "cannot get mdio bus reference from device data\n", __func__);
+		pr_debug("%s: cannot get mdio bus reference from device data\n", __func__);
 		return NULL;
 	}
 
@@ -1696,25 +1707,25 @@
 	/* Get MDIO BUS pointer */
 	prop = of_get_property(np, "mdiobus", NULL);
 	if (!prop) {
-		dev_dbg(&pdev->dev, "cannot get 'mdiobus' property\n", __func__);
+		pr_debug("%s: cannot get 'mdiobus' property\n", __func__);
 		goto err;
 	}
 
 	mdio_node = of_find_node_by_phandle(be32_to_cpup(prop));
 	if (!mdio_node) {
-		dev_dbg(&pdev->dev, "cannot find mdio node by phandle\n", __func__);
+		pr_debug("%s: cannot find mdio node by phandle\n", __func__);
 		goto err;
 	}
 
 	mdio_plat = of_find_device_by_node(mdio_node);
 	if (!mdio_plat) {
-		dev_dbg(&pdev->dev, "cannot find platform device from mdio node\n", __func__);
+		pr_debug("%s: cannot find platform device from mdio node\n", __func__);
 		goto err;
 	}
 
 	mdio_bus = dev_get_drvdata(&mdio_plat->dev);
 	if (!mdio_bus) {
-		dev_dbg(&pdev->dev, "cannot get mdio bus reference from device data\n", __func__);
+		pr_debug("%s: cannot get mdio bus reference from device data\n", __func__);
 		goto err;
 	}
 	of_node_put(np);
diff -Naur -x .git --no-dereference linux/drivers/net/phy/qca_85xx_sw_regdef.h linux-3.14/drivers/net/phy/qca_85xx_sw_regdef.h
--- linux/drivers/net/phy/qca_85xx_sw_regdef.h	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/phy/qca_85xx_sw_regdef.h	2016-09-01 11:52:04.000000000 +0800
@@ -1,7 +1,7 @@
 /*
  * QCA 85xx switch register definitions
  *
- * Copyright (c) 2015 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2016 The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -270,6 +270,7 @@
 #define SGMII_CTRL0_FORCE_SPEED_10	0x0
 #define SGMII_CTRL0_FORCE_SPEED_100	0x4
 #define SGMII_CTRL0_FORCE_SPEED_1000	0x8
+#define SGMII_CTRL0_MR_AN_EN		0x400
 #define SGMII_CTRL0_FORCE_MODE_EN	0x200000
 
 #define SGMII_CTRL0_SGMII_MODE_1000BASE_X	0x0
diff -Naur -x .git --no-dereference linux/drivers/net/ppp/pptp.c linux-3.14/drivers/net/ppp/pptp.c
--- linux/drivers/net/ppp/pptp.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/net/ppp/pptp.c	2016-09-01 11:52:04.000000000 +0800
@@ -71,6 +71,8 @@
 static const struct ppp_channel_ops pptp_chan_ops;
 static const struct proto_ops pptp_ops;
 
+static pptp_gre_seq_offload_callback_t __rcu pptp_gre_offload_xmit_cb;
+
 #define PPP_LCP_ECHOREQ 0x09
 #define PPP_LCP_ECHOREP 0x0A
 #define SC_RCV_BITS	(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)
@@ -174,6 +176,28 @@
 	return -EINVAL;
 }
 
+/*
+ * If offload mode set then this function sends all packets to
+ * offload module instead of network stack
+ */
+static int pptp_client_skb_xmit(struct sk_buff *skb, struct net_device *pptp_dev)
+{
+	pptp_gre_seq_offload_callback_t pptp_gre_offload_cb_f;
+	int ret;
+
+	rcu_read_lock();
+	pptp_gre_offload_cb_f = rcu_dereference(pptp_gre_offload_xmit_cb);
+
+	if (!pptp_gre_offload_cb_f) {
+		rcu_read_unlock();
+		return -1;
+	}
+
+	ret = pptp_gre_offload_cb_f(skb, pptp_dev);
+	rcu_read_unlock();
+	return ret;
+}
+
 static int add_chan(struct pppox_sock *sock)
 {
 	static int call_id;
@@ -226,8 +250,11 @@
 
 	struct rtable *rt;
 	struct net_device *tdev;
+	struct net_device *pptp_dev;
 	struct iphdr  *iph;
 	int    max_headroom;
+	int    pptp_ifindex;
+	int ret;
 
 	if (sk_pppox(po)->sk_state & PPPOX_DEAD)
 		goto tx_error;
@@ -327,11 +354,34 @@
 	ip_select_ident(skb, NULL);
 	ip_send_check(iph);
 
+	pptp_ifindex = ppp_dev_index(chan);
+
 	/* set incoming interface as the ppp interface */
 	if (skb->skb_iif)
-		skb->skb_iif = ppp_dev_index(chan);
+		skb->skb_iif = pptp_ifindex;
+
+	/*
+	 * If the PPTP GRE seq number offload module is not enabled yet
+	 * then sends all PPTP GRE packets through linux network stack
+	 */
+	if (!opt->pptp_offload_mode) {
+		ip_local_out(skb);
+		return 1;
+	}
+
+	pptp_dev = dev_get_by_index(&init_net, pptp_ifindex);
+	if (!pptp_dev)
+		goto tx_error;
+
+	/*
+	 * If PPTP offload module is enabled then forward all PPTP GRE
+	 * packets to PPTP GRE offload module
+	 */
+	ret = pptp_client_skb_xmit(skb, pptp_dev);
+	dev_put(pptp_dev);
+	if (ret < 0)
+		goto tx_error;
 
-	ip_local_out(skb);
 	return 1;
 
 tx_error:
@@ -389,6 +439,14 @@
 		goto drop;
 
 	payload = skb->data + headersize;
+
+	/*
+	 * If offload is enabled, we expect the offload module
+	 * to handle PPTP GRE sequence number checks.
+	 */
+	if (opt->pptp_offload_mode)
+		goto allow_packet;
+
 	/* check for expected sequence number */
 	if (seq < opt->seq_recv + 1 || WRAPPED(opt->seq_recv, seq)) {
 		if ((payload[0] == PPP_ALLSTATIONS) && (payload[1] == PPP_UI) &&
@@ -541,6 +599,7 @@
 	}
 
 	opt->dst_addr = sp->sa_addr.pptp;
+	opt->pptp_offload_mode = false;
 	sk->sk_state = PPPOX_CONNECTED;
 
  end:
@@ -718,6 +777,92 @@
 EXPORT_SYMBOL(pptp_session_find);
 
 /*
+ * pptp_set_offload_mode()
+ * 	Function to change the offload mode true/false for a PPTP session
+ */
+static int pptp_set_offload_mode(bool accel_mode, __be16 peer_call_id, __be32 peer_ip_addr)
+{
+	struct pppox_sock *sock;
+	int i = 1;
+
+	rcu_read_lock();
+	for_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {
+		sock = rcu_dereference(callid_sock[i]);
+		if (!sock)
+			continue;
+
+		if (sock->proto.pptp.dst_addr.call_id == peer_call_id &&
+			  sock->proto.pptp.dst_addr.sin_addr.s_addr == peer_ip_addr) {
+			sock_hold(sk_pppox(sock));
+			sock->proto.pptp.pptp_offload_mode = accel_mode;
+			sock_put(sk_pppox(sock));
+			rcu_read_unlock();
+			return 0;
+		}
+	}
+	rcu_read_unlock();
+	return -EINVAL;
+}
+
+/*
+ * pptp_session_enable_offload_mode()
+ *	Enable the PPTP session offload flag
+ */
+int pptp_session_enable_offload_mode(__be16 peer_call_id, __be32 peer_ip_addr)
+{
+	return pptp_set_offload_mode(true, peer_call_id, peer_ip_addr);
+}
+EXPORT_SYMBOL(pptp_session_enable_offload_mode);
+
+/*
+ * pptp_session_disable_offload_mode()
+ *	Disable the PPTP session offload flag
+ */
+int pptp_session_disable_offload_mode(__be16 peer_call_id, __be32 peer_ip_addr)
+{
+	return pptp_set_offload_mode(false, peer_call_id, peer_ip_addr);
+}
+EXPORT_SYMBOL(pptp_session_disable_offload_mode);
+
+/*
+ * pptp_register_gre_seq_offload_callback()
+ * 	Register the offload callback function on behalf of the module which
+ * 	will own the sequence and acknowledgement number updates for all
+ * 	PPTP GRE packets. All PPTP GRE packets are then transmitted to this
+ * 	module after encapsulation in order to ensure the correct seq/ack fields
+ * 	are set in the packets before transmission. This is required when PPTP
+ * 	flows are offloaded to acceleration engines, in-order to ensure consistency
+ * 	in sequence and ack numbers between PPTP control (PPP LCP) and data packets.
+ */
+int pptp_register_gre_seq_offload_callback(pptp_gre_seq_offload_callback_t pptp_gre_offload_cb)
+{
+	pptp_gre_seq_offload_callback_t pptp_gre_offload_cb_f;
+
+	rcu_read_lock();
+	pptp_gre_offload_cb_f = rcu_dereference(pptp_gre_offload_xmit_cb);
+
+	if (pptp_gre_offload_cb_f) {
+		rcu_read_unlock();
+		return 1;
+	}
+
+	rcu_assign_pointer(pptp_gre_offload_xmit_cb, pptp_gre_offload_cb);
+	rcu_read_unlock();
+	return 0;
+}
+EXPORT_SYMBOL(pptp_register_gre_seq_offload_callback);
+
+/*
+ * pptp_register_gre_seq_offload_callback()
+ * 	Unregister the PPTP GRE packets sequence number offload callback
+ */
+void pptp_unregister_gre_seq_offload_callback(void)
+{
+	rcu_assign_pointer(pptp_gre_offload_xmit_cb, NULL);
+}
+EXPORT_SYMBOL(pptp_unregister_gre_seq_offload_callback);
+
+/*
  * pptp_hold_chan()
  */
 static void pptp_hold_chan(struct ppp_channel *chan)
diff -Naur -x .git --no-dereference linux/drivers/pci/host/pci-qcom.c linux-3.14/drivers/pci/host/pci-qcom.c
--- linux/drivers/pci/host/pci-qcom.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/pci/host/pci-qcom.c	2016-09-01 11:52:04.000000000 +0800
@@ -739,7 +739,7 @@
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct qcom_pcie *qcom_pcie;
-	int ret;
+	int ret, rc_enum;
 	uint32_t force_gen1 = 0;
 	static int rc_idx;
 
@@ -773,10 +773,10 @@
 
 	platform_set_drvdata(pdev, qcom_pcie);
 
-	qcom_pcie_enumerate(qcom_pcie);
+	rc_enum = qcom_pcie_enumerate(qcom_pcie);
 
 	/* create sysfs files to support power save mode */
-	if (!rc_idx) {
+	if ((!rc_idx) && (!rc_enum)) {
 		ret = bus_create_file(&pci_bus_type, &bus_attr_rcrescan);
 		if (ret != 0) {
 			dev_err(&pdev->dev,
@@ -792,8 +792,13 @@
 		}
 	}
 
-	qcom_pcie_dev[rc_idx++] = qcom_pcie;
-	return 0;
+	if (!rc_enum) {
+		qcom_pcie_dev[rc_idx++] = qcom_pcie;
+		ret = 0;
+	} else
+		ret = -ENODEV;
+
+	return ret;
 }
 
 static int qcom_pcie_enumerate(struct qcom_pcie *qcom_pcie)
@@ -900,6 +905,12 @@
 			(qcom_pcie->dwc_base + PCIE20_CAP_LINKCTRLSTATUS),
 			val, (val & BIT(29)), 10000, 100000);
 
+	if (ret) {
+		dev_err(qcom_pcie->dev, "link down(%d)\n", ret);
+		qcom_pcie->pci_bus = NULL;
+		goto link_fail;
+	}
+
 	dev_info(qcom_pcie->dev, "link initialized %d\n", ret);
 	qcom_pcie_config_controller(qcom_pcie);
 
@@ -911,7 +922,8 @@
 
 	pci_common_init_dev(qcom_pcie->dev, hw);
 
-	return 0;
+link_fail:
+	return ret;
 }
 
 
diff -Naur -x .git --no-dereference linux/drivers/pinctrl/qcom/pinctrl-ipq40xx.c linux-3.14/drivers/pinctrl/qcom/pinctrl-ipq40xx.c
--- linux/drivers/pinctrl/qcom/pinctrl-ipq40xx.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/pinctrl/qcom/pinctrl-ipq40xx.c	2016-09-01 11:52:04.000000000 +0800
@@ -33,7 +33,7 @@
 		.pins = gpio##id##_pins,		\
 		.npins = (unsigned)ARRAY_SIZE(gpio##id##_pins),	\
 		.funcs = (int[]){			\
-			qca_mux_NA, /* gpio mode */	\
+			qca_mux_gpio, /* gpio mode */	\
 			qca_mux_##f1,			\
 			qca_mux_##f2,			\
 			qca_mux_##f3,			\
@@ -236,6 +236,7 @@
 static const unsigned int sdc2_data_pins[] = { 75 };
 
 enum ipq40xx_functions {
+	qca_mux_gpio,
 	qca_mux_smart0,
 	qca_mux_jtag,
 	qca_mux_audio0,
@@ -979,8 +980,24 @@
 static const char * const wcss1_dbg13_groups[] = {
 	"gpio69",
 };
+static const char * const gpio_groups[] = {
+	"gpio0", "gpio1", "gpio2", "gpio3", "gpio4", "gpio5", "gpio6", "gpio7",
+	"gpio8", "gpio9", "gpio10", "gpio11", "gpio12", "gpio13", "gpio14",
+	"gpio15", "gpio16", "gpio17", "gpio18", "gpio19", "gpio20", "gpio21",
+	"gpio22", "gpio23", "gpio24", "gpio25", "gpio26", "gpio27", "gpio28",
+	"gpio29", "gpio30", "gpio31", "gpio32", "gpio33", "gpio34", "gpio35",
+	"gpio36", "gpio37", "gpio38", "gpio39", "gpio40", "gpio41", "gpio42",
+	"gpio43", "gpio44", "gpio45", "gpio46", "gpio47", "gpio48", "gpio49",
+	"gpio50", "gpio51", "gpio52", "gpio53", "gpio54", "gpio55", "gpio56",
+	"gpio57", "gpio58", "gpio59", "gpio60", "gpio61", "gpio62", "gpio63",
+	"gpio64", "gpio65", "gpio66", "gpio67", "gpio68", "gpio69", "gpio70",
+	"gpio71", "gpio72", "gpio73", "gpio74", "gpio75", "gpio76", "gpio77",
+	"gpio78", "gpio79", "gpio80", "gpio81", "gpio82", "gpio83", "gpio84",
+	"gpio85", "gpio86", "gpio87", "gpio88", "gpio89"
+};
 
 static const struct msm_function ipq40xx_functions[] = {
+	FUNCTION(gpio),
 	FUNCTION(smart0),
 	FUNCTION(jtag),
 	FUNCTION(audio0),
diff -Naur -x .git --no-dereference linux/drivers/pinctrl/qcom/pinctrl-msm.c linux-3.14/drivers/pinctrl/qcom/pinctrl-msm.c
--- linux/drivers/pinctrl/qcom/pinctrl-msm.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/pinctrl/qcom/pinctrl-msm.c	2016-09-01 11:52:04.000000000 +0800
@@ -31,6 +31,8 @@
 #include <linux/irqchip/chained_irq.h>
 #include <linux/spinlock.h>
 #include <linux/reboot.h>
+#include <soc/qcom/scm.h>
+#include <linux/io.h>
 
 #include "../core.h"
 #include "../pinconf.h"
@@ -39,7 +41,6 @@
 
 #define MAX_NR_GPIO 300
 #define PS_HOLD_OFFSET 0x820
-
 /**
  * struct msm_pinctrl - state for a pinctrl-msm device
  * @dev:            device handle.
@@ -696,7 +697,9 @@
 	struct msm_pinctrl *pctrl;
 	unsigned long flags;
 	u32 val;
-
+	u32 addr;
+	int ret = 0;
+	const __be32 *reg;
 	pctrl = irq_data_get_irq_chip_data(d);
 	g = &pctrl->soc->groups[d->hwirq];
 
@@ -710,12 +713,32 @@
 	else
 		clear_bit(d->hwirq, pctrl->dual_edge_irqs);
 
+	ret = of_device_is_compatible(pctrl->dev->of_node,
+					"qcom,ipq8064-pinctrl");
 	/* Route interrupts to application cpu */
-	val = readl(pctrl->regs + g->intr_target_reg);
-	val &= ~(7 << g->intr_target_bit);
-	val |= g->intr_target_kpss_val << g->intr_target_bit;
-	writel(val, pctrl->regs + g->intr_target_reg);
-
+	if (!ret) {
+		val = readl(pctrl->regs + g->intr_target_reg);
+		val &= ~(7 << g->intr_target_bit);
+		val |= g->intr_target_kpss_val << g->intr_target_bit;
+		writel(val, pctrl->regs + g->intr_target_reg);
+	} else {
+		reg = of_get_property(pctrl->dev->of_node, "reg", NULL);
+		if (reg) {
+			addr = be32_to_cpup(reg) + g->intr_target_reg;
+			val = scm_call_atomic1(SCM_SVC_IO_ACCESS,
+						SCM_IO_READ, addr);
+			__iormb();
+
+			val &= ~(7 << g->intr_target_bit);
+			val |= g->intr_target_kpss_val << g->intr_target_bit;
+
+			__iowmb();
+			ret = scm_call_atomic2(SCM_SVC_IO_ACCESS,
+						SCM_IO_WRITE, addr, val);
+		}
+		if (ret)
+			pr_err("\n Routing interrupts to Apps proc failed");
+	}
 	/* Update configuration for gpio.
 	 * RAW_STATUS_EN is left on for all gpio irqs. Due to the
 	 * internal circuitry of TLMM, toggling the RAW_STATUS
diff -Naur -x .git --no-dereference linux/drivers/platform/msm/bootconfig.c linux-3.14/drivers/platform/msm/bootconfig.c
--- linux/drivers/platform/msm/bootconfig.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/platform/msm/bootconfig.c	2016-09-01 11:52:04.000000000 +0800
@@ -38,7 +38,7 @@
 static struct proc_dir_entry *partname_dir[NUM_ALT_PARTITION];
 
 static unsigned int num_parts;
-static unsigned int flash_type;
+static unsigned int flash_type_emmc;
 
 struct sbl_if_dualboot_info_type_v2 *bootconfig1;
 struct sbl_if_dualboot_info_type_v2 *bootconfig2;
@@ -48,7 +48,6 @@
 	struct sbl_if_dualboot_info_type_v2 *sbl_info_v2;
 
 	sbl_info_v2 = m->private;
-	sbl_info_v2->age++;
 	memcpy(m->buf + m->count, sbl_info_v2,
 		sizeof(struct sbl_if_dualboot_info_type_v2));
 	m->count += sizeof(struct sbl_if_dualboot_info_type_v2);
@@ -83,7 +82,7 @@
 	 * we will take care of it here.
 	 */
 
-	if (flash_type && (part_info_t->primaryboot))
+	if (flash_type_emmc && (part_info_t->primaryboot))
 		seq_printf(m, "%s\n", part_info_t->name);
 	else
 		seq_printf(m, "%s_1\n", part_info_t->name);
@@ -167,6 +166,14 @@
 	struct sbl_if_dualboot_info_type_v2 *bootconfig_mtd;
 	int ret;
 
+	while (mtd_block_isbad(master, offset)) {
+		offset += master->erasesize;
+		if (offset >= master->size) {
+			pr_alert("Bad blocks occured while reading from \"%s\"\n",
+					master->name);
+			return NULL;
+		}
+	}
 	bootconfig_mtd = kmalloc(sizeof(struct sbl_if_dualboot_info_type_v2),
 				   GFP_ATOMIC);
 
@@ -229,11 +236,18 @@
 
 	memcpy(bootconfig_emmc, data, 512);
 
+	if (bootconfig_emmc->magic_start != SMEM_DUAL_BOOTINFO_MAGIC_START) {
+		pr_alert("Magic not found\n");
+		kfree(bootconfig_emmc);
+		return NULL;
+	}
+
 	return bootconfig_emmc;
 }
 
 #define BOOTCONFIG_PARTITION	"0:BOOTCONFIG"
 #define BOOTCONFIG_PARTITION1	"0:BOOTCONFIG1"
+#define ROOTFS_PARTITION	"rootfs"
 
 static int __init bootconfig_partition_init(void)
 {
@@ -245,6 +259,16 @@
 	struct mtd_info *mtd;
 	int partno;
 
+	/*
+	 * In case of NOR\NAND boot, there is a chance that emmc
+	 * might have bootconfig paritions. This will try to read
+	 * the bootconfig partitions and create a proc entry which
+	 * is not correct since it is not booting from emmc.
+	 */
+
+	mtd = get_mtd_device_nm(ROOTFS_PARTITION);
+	if (IS_ERR(mtd))
+		flash_type_emmc = 1;
 	mtd = get_mtd_device_nm(BOOTCONFIG_PARTITION);
 	if (!IS_ERR(mtd)) {
 
@@ -257,7 +281,8 @@
 		}
 
 		bootconfig2 = read_bootconfig_mtd(mtd, 0);
-	} else {
+	} else if (flash_type_emmc == 1) {
+		flash_type_emmc = 0;
 		disk = get_gendisk(MKDEV(MMC_BLOCK_MAJOR, 0), &partno);
 		if (!disk)
 			return 0;
@@ -276,7 +301,7 @@
 						BOOTCONFIG_PARTITION1)) {
 					bootconfig2 = read_bootconfig_emmc(disk,
 									 part);
-					flash_type = 1;
+					flash_type_emmc = 1;
 				}
 			}
 		}
@@ -284,32 +309,40 @@
 
 	}
 
-	if (!bootconfig1)
-		return 0;
-
-	if (!bootconfig2)
-		return 0;
+	if (!bootconfig1) {
+		if (bootconfig2)
+			bootconfig1 = bootconfig2;
+		else
+			return 0;
+	}
 
-	if (bootconfig1->age > bootconfig2->age) {
-		part_info = (struct per_part_info *)bootconfig1->per_part_entry;
-		bootconfig2->age ^= bootconfig1->age;
-		bootconfig1->age ^= bootconfig2->age;
-		bootconfig2->age ^= bootconfig1->age;
-		num_parts = bootconfig1->numaltpart;
-	} else {
-		part_info = (struct per_part_info *)bootconfig2->per_part_entry;
-		bootconfig1->age ^= bootconfig2->age;
-		bootconfig2->age ^= bootconfig1->age;
-		bootconfig1->age ^= bootconfig2->age;
-		num_parts = bootconfig2->numaltpart;
+	if (!bootconfig2) {
+		if (bootconfig1)
+			bootconfig2 = bootconfig1;
+		else
+			return 0;
 	}
+/*
+ * The following check is to handle the case when an image without
+ * apps upgrade support is upgraded to the image that supports APPS
+ * upgrade. Earlier, the bootconfig file will be chosen based on age,
+ * but now bootconfig1 only is considered and bootconfig2 is a backup.
+ * When bootconfig2 is active in the older image and sysupgrade
+ * is done to it, we copy the bootconfig2 to bootconfig1 so that the
+ * failsafe parameters can be retained.
+ */
+	if (bootconfig2->age > bootconfig1->age)
+		bootconfig1 = bootconfig2;
 
+	num_parts = bootconfig1->numaltpart;
+	bootconfig1->age++;
+	part_info = (struct per_part_info *)bootconfig1->per_part_entry;
 	boot_info_dir = proc_mkdir("boot_info", NULL);
 	if (!boot_info_dir)
 		return 0;
 
 	for (i = 0; i < num_parts; i++) {
-		if (!flash_type &&
+		if (!flash_type_emmc &&
 				(strncmp(part_info[i].name, "kernel",
 					ALT_PART_NAME_LENGTH) == 0))
 			continue;
@@ -330,7 +363,7 @@
 	proc_create_data("getbinary_bootconfig", S_IRUGO, boot_info_dir,
 			&getbinary_ops, bootconfig1);
 	proc_create_data("getbinary_bootconfig1", S_IRUGO, boot_info_dir,
-			&getbinary_ops, bootconfig2);
+			&getbinary_ops, bootconfig1);
 
 	return 0;
 }
@@ -349,7 +382,7 @@
 
 	part_info = (struct per_part_info *)bootconfig1->per_part_entry;
 	for (i = 0; i < num_parts; i++) {
-		if (!flash_type &&
+		if (!flash_type_emmc &&
 				(strncmp(part_info[i].name, "kernel",
 					ALT_PART_NAME_LENGTH) == 0))
 			continue;
diff -Naur -x .git --no-dereference linux/drivers/platform/msm/i2c-msm-prof-dbg.c linux-3.14/drivers/platform/msm/i2c-msm-prof-dbg.c
--- linux/drivers/platform/msm/i2c-msm-prof-dbg.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/platform/msm/i2c-msm-prof-dbg.c	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,736 @@
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+ /*
+  * I2C controller logging/Debugfs for QTI MSM platforms
+  */
+
+#include <linux/device.h>
+#include <linux/pm_runtime.h>
+#include <linux/debugfs.h>
+#include <linux/msm-sps.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c/i2c-msm-v2.h>
+
+#ifdef CONFIG_DEBUG_FS
+
+enum i2c_msm_dbgfs_file_type {
+	I2C_MSM_DFS_U8,
+	I2C_MSM_DFS_U32,
+	I2C_MSM_DFS_FILE,
+};
+
+/*
+ * i2c_msm_dbgfs_file: entry in a table of debugfs files
+ *
+ * @name      debugfs file name
+ * @mode      file permissions
+ * @fops      used when type == I2C_MSM_DFS_FILE
+ * @value_ptr used when type != I2C_MSM_DFS_FILE
+ */
+struct i2c_msm_dbgfs_file {
+	const char                   *name;
+	const umode_t                 mode;
+	enum i2c_msm_dbgfs_file_type  type;
+	const struct file_operations *fops;
+	u32                          *value_ptr;
+};
+
+static const umode_t I2C_MSM_DFS_MD_R  = S_IRUSR | S_IRGRP;
+static const umode_t I2C_MSM_DFS_MD_W  = S_IWUSR | S_IWGRP;
+static const umode_t I2C_MSM_DFS_MD_RW = S_IRUSR | S_IRGRP |
+					   S_IWUSR | S_IWGRP;
+
+void i2c_msm_dbgfs_create(struct i2c_msm_ctrl *ctrl,
+				struct i2c_msm_dbgfs_file *itr)
+{
+	struct dentry *file;
+
+	ctrl->dbgfs.root = debugfs_create_dir(dev_name(ctrl->dev), NULL);
+	if (!ctrl->dbgfs.root) {
+		dev_err(ctrl->dev, "error on creating debugfs root\n");
+		return;
+	}
+
+	for (; itr->name; ++itr) {
+		switch (itr->type) {
+		case I2C_MSM_DFS_FILE:
+			file = debugfs_create_file(itr->name,
+						   itr->mode,
+						   ctrl->dbgfs.root,
+						   ctrl, itr->fops);
+			break;
+		case I2C_MSM_DFS_U8:
+			file = debugfs_create_u8(itr->name,
+						 itr->mode,
+						 ctrl->dbgfs.root,
+						 (u8 *) itr->value_ptr);
+			break;
+		default: /* I2C_MSM_DFS_U32 */
+			file = debugfs_create_u32(itr->name,
+						 itr->mode,
+						 ctrl->dbgfs.root,
+						 (u32 *) itr->value_ptr);
+			break;
+		}
+		if (!file)
+			dev_err(ctrl->dev,
+				"error on creating debugfs entry:%s\n",
+				itr->name);
+	}
+}
+
+void i2c_msm_dbgfs_init(struct i2c_msm_ctrl *ctrl)
+{
+	struct i2c_msm_dbgfs_file i2c_msm_dbgfs_map[] = {
+		{"dbg-lvl",         I2C_MSM_DFS_MD_RW, I2C_MSM_DFS_U8,
+				NULL, &ctrl->dbgfs.dbg_lvl},
+		{"xfer-force-mode", I2C_MSM_DFS_MD_RW, I2C_MSM_DFS_U8,
+				NULL, &ctrl->dbgfs.force_xfer_mode},
+		{NULL, 0, 0, NULL , NULL}, /* null terminator */
+	};
+	return i2c_msm_dbgfs_create(ctrl, i2c_msm_dbgfs_map);
+}
+EXPORT_SYMBOL(i2c_msm_dbgfs_init);
+
+void i2c_msm_dbgfs_teardown(struct i2c_msm_ctrl *ctrl)
+{
+	debugfs_remove_recursive(ctrl->dbgfs.root);
+}
+EXPORT_SYMBOL(i2c_msm_dbgfs_teardown);
+
+#else
+void i2c_msm_dbgfs_init(struct i2c_msm_ctrl *ctrl) {}
+EXPORT_SYMBOL(i2c_msm_dbgfs_init);
+
+void i2c_msm_dbgfs_teardown(struct i2c_msm_ctrl *ctrl) {}
+EXPORT_SYMBOL(i2c_msm_dbgfs_teardown);
+#endif
+
+/*
+ * i2c_msm_dbg_tag_byte: accessor for tag as four bytes array
+ */
+static u8 *i2c_msm_dbg_tag_byte(struct i2c_msm_tag *tag, int byte_n)
+{
+	return ((u8 *)tag) + byte_n;
+}
+static const char * const i2c_msm_fifo_sz_str_tbl[]
+		= {"x2 blk sz", "x4 blk sz" , "x8 blk sz", "x16 blk sz"};
+static const char * const i2c_msm_fifo_block_sz_str_tbl[]
+						= {"16", "16" , "32", "0"};
+
+/* string table for qup_io_modes register */
+static const char * const i2c_msm_qup_mode_str_tbl[] = {
+	"FIFO", "Block", "Reserved", "BAM",
+};
+
+static const char * const i2c_msm_mini_core_str_tbl[] = {
+	"null", "SPI", "I2C", "reserved",
+};
+/*
+ * i2c_msm_qup_reg_fld: a register field descriptor
+ * @name   field name
+ * @to_str_tbl  when not null, used to interpret the bits value. The bits value
+ *         is the table entry number.
+ */
+struct i2c_msm_qup_reg_fld {
+	const char * const name;
+	int                bit_idx;
+	int                n_bits;
+	const char * const *to_str_tbl;
+};
+
+static const char * const i2c_msm_reg_qup_state_to_str[] = {
+	"Reset", "Run", "Clear", "Pause"
+};
+
+/* QUP_STATE register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_state_fields_map[] = {
+	{ "STATE",             0,   2, i2c_msm_reg_qup_state_to_str},
+	{ "VALID",             2,   1},
+	{ "MAST_GEN",          4,   1},
+	{ "WAIT_EOT",          5,   1},
+	{ "FLUSH",             6,   1},
+	{ NULL,                0,   1},
+};
+
+/* QUP_CONFIG register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_config_fields_map[] = {
+	{ "N",               0,   5},
+	{ "MINI_CORE",       8,   2, i2c_msm_mini_core_str_tbl},
+	{ "NO_OUTPUT",       6,   1},
+	{ "NO_INPUT",        7,   1},
+	{ "EN_EXT_OUT",     16,   1},
+	{ NULL,              0,   1},
+};
+
+/* QUP_OPERATIONAL register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_op_fields_map[] = {
+	{ "OUT_FF_N_EMPTY",  4,   1},
+	{ "IN_FF_N_EMPTY",   5,   1},
+	{ "OUT_FF_FUL",      6,   1},
+	{ "IN_FF_FUL",       7,   1},
+	{ "OUT_SRV_FLG",     8,   1},
+	{ "IN_SRV_FLG",      9,   1},
+	{ "MX_OUT_DN",      10,   1},
+	{ "MX_IN_DN",       11,   1},
+	{ "OUT_BLK_WR",     12,   1},
+	{ "IN_BLK_RD",      13,   1},
+	{ "DONE_TGL",       14,   1},
+	{ "NWD",            15,   1},
+	{ NULL,              0,   1},
+};
+
+/* QUP_I2C_STATUS (a.k.a I2C_MASTER_STATUS) register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_i2c_stat_fields_map[] = {
+	{ "BUS_ERR",        2,   1},
+	{ "NACK",           3,   1},
+	{ "ARB_LOST",       4,   1},
+	{ "INVLD_WR",       5,   1},
+	{ "FAIL",           6,   2},
+	{ "BUS_ACTV",       8,   1},
+	{ "BUS_MSTR",       9,   1},
+	{ "DAT_STATE",     10,   3},
+	{ "CLK_STATE",     13,   3},
+	{ "O_FSM_STAT",    16,   3},
+	{ "I_FSM_STAT",    19,   3},
+	{ "INVLD_TAG",     23,   1},
+	{ "INVLD_RD_ADDR", 24,   1},
+	{ "INVLD_RD_SEQ",  25,   1},
+	{ "SDA",           26,   1},
+	{ "SCL",           27,   1},
+	{ NULL,             0,   1},
+};
+
+/* QUP_ERROR_FLAGS register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_err_flags_fields_map[] = {
+	{ "IN_OVR_RUN",        2,   1},
+	{ "OUT_UNDR_RUN",      3,   1},
+	{ "IN_UNDR_RUN",       4,   1},
+	{ "OUT_OVR_RUN",       5,   1},
+	{ NULL,                0,   1},
+};
+
+/* QUP_OPERATIONAL_MASK register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_op_mask_fields_map[] = {
+	{ "OUT_SRVC_MASK",     8,   1},
+	{ "IN_SRVC_MASK",      9,   1},
+	{ NULL,                0,   1},
+};
+
+/* QUP_I2C_MASTER_CLK_CTL register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_master_clk_fields_map[] = {
+	{ "FS_DIV",            0,   8},
+	{ "HS_DIV",            8,   3},
+	{ "HI_TM_DIV",        16,   8},
+	{ "SCL_NS_RJCT",      24,   2},
+	{ "SDA_NS_RJCT",      26,   2},
+	{ "SCL_EXT_FRC_L",    28,   1},
+	{ NULL,                0,   1},
+};
+
+static const char * const i2c_msm_dbg_tag_val_str_tbl[] = {
+	"NOP_WAIT",		/* 0x80 */
+	"START",		/* 0x81 */
+	"DATAWRITE",		/* 0x82 */
+	"DATAWRT_and_STOP",	/* 0x83 */
+	NULL,			/* 0x84 */
+	"DATAREAD",		/* 0x85 */
+	"DATARD_and_NACK",	/* 0x86 */
+	"DATARD_and_STOP",	/* 0x87 */
+	"STOP_TAG",		/* 0x88 */
+	NULL,			/* 0x89 */
+	NULL,			/* 0x8A */
+	NULL,			/* 0x8B */
+	NULL,			/* 0x8C */
+	NULL,			/* 0x8D */
+	NULL,			/* 0x8E */
+	NULL,			/* 0x8F */
+	"NOP_MARK",		/* 0x90 */
+	"NOP_ID",		/* 0x91 */
+	"TIME_STAMP",		/* 0x92 */
+	"INPUT_EOT",		/* 0x93 */
+	"INPUT_EOT_FLUSH",	/* 0x94 */
+	"NOP_LOCAL",		/* 0x95 */
+	"FLUSH STOP",		/* 0x96 */
+};
+
+/* QUP_IO_MODES register fields */
+static struct i2c_msm_qup_reg_fld i2c_msm_qup_io_modes_map[] = {
+	{ "IN_BLK_SZ",         5,   2, i2c_msm_fifo_block_sz_str_tbl},
+	{ "IN_FF_SZ",          7,   3, i2c_msm_fifo_sz_str_tbl},
+	{ "OUT_BLK_SZ",        0,   2, i2c_msm_fifo_block_sz_str_tbl},
+	{ "OUT_FF_SZ",         2,   3, i2c_msm_fifo_sz_str_tbl},
+	{ "UNPACK",           14,   1},
+	{ "PACK",             15,   1},
+	{ "INP_MOD",          12,   2, i2c_msm_qup_mode_str_tbl},
+	{ "OUT_MOD",          10,   2, i2c_msm_qup_mode_str_tbl},
+	{ NULL,                0,   1},
+};
+
+/*
+ * i2c_msm_qup_reg_dump: desc fmt of reg to dump via i2c_msm_dbg_qup_reg_dump()
+ *
+ * @offset    the register's offset in the QUP
+ * @name      name to dump before value
+ * @field_map when set i2c_msm_dbg_qup_reg_flds_to_str() is used. Otherwise
+ *            if val_to_str_func() is set, then it is used. When both are NULL
+ *            none is used. Only the register's value is dumped.
+ */
+struct i2c_msm_qup_reg_dump {
+	u32                          offset;
+	const char                  *name;
+	struct i2c_msm_qup_reg_fld  *field_map;
+};
+
+static const struct i2c_msm_qup_reg_dump i2c_msm_qup_reg_dump_map[] = {
+{QUP_CONFIG,             "QUP_CONFIG",   i2c_msm_qup_config_fields_map    },
+{QUP_STATE,              "QUP_STATE",    i2c_msm_qup_state_fields_map     },
+{QUP_IO_MODES,           "QUP_IO_MDS",   i2c_msm_qup_io_modes_map         },
+{QUP_ERROR_FLAGS,        "QUP_ERR_FLGS", i2c_msm_qup_err_flags_fields_map },
+{QUP_OPERATIONAL,        "QUP_OP",       i2c_msm_qup_op_fields_map        },
+{QUP_OPERATIONAL_MASK,   "QUP_OP_MASK",  i2c_msm_qup_op_mask_fields_map   },
+{QUP_I2C_STATUS,         "QUP_I2C_STAT", i2c_msm_qup_i2c_stat_fields_map  },
+{QUP_I2C_MASTER_CLK_CTL, "QUP_MSTR_CLK", i2c_msm_qup_master_clk_fields_map},
+{QUP_IN_DEBUG,           "QUP_IN_DBG"  },
+{QUP_OUT_DEBUG,          "QUP_OUT_DBG" },
+{QUP_IN_FIFO_CNT,        "QUP_IN_CNT"  },
+{QUP_OUT_FIFO_CNT,       "QUP_OUT_CNT" },
+{QUP_MX_READ_COUNT,      "MX_RD_CNT"   },
+{QUP_MX_WRITE_COUNT,     "MX_WR_CNT"   },
+{QUP_MX_INPUT_COUNT,     "MX_IN_CNT"   },
+{QUP_MX_OUTPUT_COUNT,    "MX_OUT_CNT"  },
+{0,                       NULL         },
+};
+
+static const char *i2c_msm_dbg_tag_val_to_str(u8 tag_val)
+{
+	if ((tag_val < 0x80) || (tag_val > 0x96) || (tag_val == 0x84) ||
+	   ((tag_val > 0x88) && (0x90 > tag_val)))
+		return "Invalid_tag";
+
+	return i2c_msm_dbg_tag_val_str_tbl[tag_val - 0x80];
+}
+
+/*
+ * i2c_msm_dbg_qup_reg_flds_to_str: format register's fields using a field map
+ *
+ * @fld an array of fields mapping bits of val to fields/flags values
+ * @val the register's value
+ * @buf buffer to format the strings into
+ * @len buf's len
+ */
+static const char *i2c_msm_dbg_qup_reg_flds_to_str(
+	u32 val, char *buf, int len, const struct i2c_msm_qup_reg_fld *fld)
+{
+	char *ptr = buf;
+	int str_len;
+	int str_len_sum = 0;
+	int rem_len     = len;
+	u32 field_val;
+	for (; fld->name && (rem_len > 0); ++fld) {
+		if (fld->n_bits == 1) {
+			field_val = BIT_IS_SET(val, fld->bit_idx);
+			/*
+			 * Only dump interesting flags (skip flags who's value
+			 * is zero).
+			 */
+			if (!field_val)
+				continue;
+
+			str_len = snprintf(ptr, rem_len, "%s ", fld->name);
+		} else {
+			field_val = BITS_AT(val, fld->bit_idx, fld->n_bits);
+
+			/*
+			 * Only dump interesting fields (skip fields who's value
+			 * is zero).
+			 */
+			if (!field_val)
+				continue;
+
+			if (fld->to_str_tbl)
+				str_len = snprintf(ptr, rem_len, "%s:%s ",
+				   fld->name, fld->to_str_tbl[field_val]);
+			else
+				str_len = snprintf(ptr, rem_len, "%s:0x%x ",
+				   fld->name, field_val);
+		}
+
+		if (str_len > rem_len) {
+			pr_err("%s insufficient buffer space\n", __func__);
+			/* snprintf does not guarantee NULL terminator */
+			buf[len - 1] = 0;
+			return buf;
+		}
+
+		rem_len     -= str_len;
+		ptr         += str_len;
+		str_len_sum += str_len;
+	}
+
+	/* snprintf does not guarantee NULL terminator */
+	buf[len - 1] = 0;
+	return buf;
+}
+
+const char *i2c_msm_dbg_tag_to_str(const struct i2c_msm_tag *tag,
+						char *buf, size_t buf_len)
+{
+	/* cast const away. t is read-only here */
+	struct i2c_msm_tag *t = (struct i2c_msm_tag *) tag;
+	switch (tag->len) {
+	case 6:
+		snprintf(buf, buf_len, "val:0x%012llx %s:0x%x %s:0x%x %s:%d",
+			tag->val,
+			i2c_msm_dbg_tag_val_to_str(*i2c_msm_dbg_tag_byte(t, 0)),
+			*i2c_msm_dbg_tag_byte(t, 1),
+			i2c_msm_dbg_tag_val_to_str(*i2c_msm_dbg_tag_byte(t, 2)),
+			*i2c_msm_dbg_tag_byte(t, 3),
+			i2c_msm_dbg_tag_val_to_str(*i2c_msm_dbg_tag_byte(t, 4)),
+			*i2c_msm_dbg_tag_byte(t, 5));
+		break;
+	case 4:
+		snprintf(buf, buf_len, "val:0x%08llx %s:0x%x %s:%d",
+			(tag->val & 0xffffffff),
+			i2c_msm_dbg_tag_val_to_str(*i2c_msm_dbg_tag_byte(t, 0)),
+			*i2c_msm_dbg_tag_byte(t, 1),
+			i2c_msm_dbg_tag_val_to_str(*i2c_msm_dbg_tag_byte(t, 2)),
+			*i2c_msm_dbg_tag_byte(t, 3));
+		break;
+	default: /* 2 bytes tag */
+		snprintf(buf, buf_len, "val:0x%04llx %s:%d",
+			(tag->val & 0xffff),
+			i2c_msm_dbg_tag_val_to_str(*i2c_msm_dbg_tag_byte(t, 0)),
+			*i2c_msm_dbg_tag_byte(t, 1));
+	}
+
+	return buf;
+}
+EXPORT_SYMBOL(i2c_msm_dbg_tag_to_str);
+
+const char *
+i2c_msm_dbg_bam_tag_to_str(const struct i2c_msm_bam_tag *bam_tag, char *buf,
+								size_t buf_len)
+{
+	const char *ret;
+	u32        *val;
+	struct i2c_msm_tag tag;
+
+	val = phys_to_virt(bam_tag->buf);
+	if (!val) {
+		pr_err("Failed phys_to_virt(0x%llx)", (u64) bam_tag->buf);
+		return "Error";
+	}
+
+	tag = (struct i2c_msm_tag) {
+		.val = *val,
+		.len = bam_tag->len,
+	};
+
+	ret = i2c_msm_dbg_tag_to_str(&tag, buf, buf_len);
+	return ret;
+}
+EXPORT_SYMBOL(i2c_msm_dbg_bam_tag_to_str);
+
+/*
+ * see: struct i2c_msm_qup_reg_dump for more
+ */
+int i2c_msm_dbg_qup_reg_dump(struct i2c_msm_ctrl *ctrl)
+{
+	u32 val;
+	char buf[I2C_MSM_REG_2_STR_BUF_SZ];
+	void __iomem *base = ctrl->rsrcs.base;
+	const struct i2c_msm_qup_reg_dump *itr = i2c_msm_qup_reg_dump_map;
+
+	for (; itr->name; ++itr) {
+		val = readl_relaxed(base + itr->offset);
+		buf[0] = 0;
+		if (itr->field_map)
+			i2c_msm_dbg_qup_reg_flds_to_str(val, buf, sizeof(buf),
+								itr->field_map);
+		dev_err(ctrl->dev, "%-12s:0x%08x %s\n", itr->name, val, buf);
+	};
+	return 0;
+}
+EXPORT_SYMBOL(i2c_msm_dbg_qup_reg_dump);
+
+typedef void (*i2c_msm_prof_dump_func_func_t)(struct i2c_msm_ctrl *,
+			struct i2c_msm_prof_event *, size_t msec, size_t usec);
+
+/*
+ * i2c_msm_prof_evnt_add: pushes event into end of event array
+ *
+ * @dump_now log a copy immediately to kernel log
+ *
+ * Implementation of i2c_msm_prof_evnt_add(). When array overflows, the last
+ * entry is overwritten as many times as it overflows.
+ */
+void i2c_msm_prof_evnt_add(struct i2c_msm_ctrl *ctrl,
+				enum msm_i2_debug_level dbg_level,
+				enum i2c_msm_prof_evnt_type event_type,
+				u64 data0, u32 data1, u32 data2)
+{
+	struct i2c_msm_xfer       *xfer  = &ctrl->xfer;
+	struct i2c_msm_prof_event *event;
+	int idx;
+
+	if (ctrl->dbgfs.dbg_lvl < dbg_level)
+		return;
+
+	atomic_add_unless(&xfer->event_cnt, 1, I2C_MSM_PROF_MAX_EVNTS - 1);
+	idx = atomic_read(&xfer->event_cnt) - 1;
+	if (idx > (I2C_MSM_PROF_MAX_EVNTS - 1))
+		dev_err(ctrl->dev, "error event index:%d max:%d\n",
+						idx, I2C_MSM_PROF_MAX_EVNTS);
+	event = &xfer->event[idx];
+
+	getnstimeofday(&event->time);
+	event->dump_func_id = event_type;
+	event->data0 = data0;
+	event->data1 = data1;
+	event->data2 = data2;
+}
+EXPORT_SYMBOL(i2c_msm_prof_evnt_add);
+
+void i2c_msm_prof_dump_xfer_beg(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev,
+		"-->.%03zums XFER_BEG msg_cnt:%llx addr:0x%x\n",
+		usec, event->data0, event->data1);
+}
+
+void i2c_msm_prof_dump_actv_end(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev,
+	    "%3zu.%03zums ACTV_END ret:%lld jiffies_left:%u/%u read_cnt:%u\n",
+	    msec, usec, event->data0, event->data1,
+	    I2C_MSM_MAX_POLL_MSEC, event->data2);
+}
+
+void i2c_msm_prof_dump_bam_flsh(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev, "%3zu.%03zums  BAM_FLSH\n", msec, usec);
+}
+
+void i2c_msm_prof_dump_pip_dscn(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	struct i2c_msm_bam_pipe *pipe =
+			(struct i2c_msm_bam_pipe *) ((ulong) event->data0);
+	int ret = event->data1;
+	dev_info(ctrl->dev,
+		"%3zu.%03zums PIP_DCNCT sps_disconnect(hndl:0x%p %s):%d\n",
+		msec, usec, pipe->handle, pipe->name, ret);
+}
+
+void i2c_msm_prof_dump_pip_cnct(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	struct i2c_msm_bam_pipe *pipe =
+			(struct i2c_msm_bam_pipe *) ((ulong) event->data0);
+	int ret = event->data1;
+	dev_info(ctrl->dev,
+		"%3zu.%03zums PIP_CNCT sps_connect(hndl:0x%p %s):%d\n",
+		msec, usec, pipe->handle, pipe->name, ret);
+}
+
+void i2c_msm_prof_reset(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev, "%3zu.%03zums  QUP_RSET\n", msec, usec);
+}
+
+/* string table for enum i2c_msm_err_bit_field */
+const char * const i2c_msm_err_str_tbl[] = {
+	"NONE", "NACK", "ARB_LOST" , "ARB_LOST + NACK", "BUS_ERR",
+	"BUS_ERR + NACK", "BUS_ERR + ARB_LOST", "BUS_ERR + ARB_LOST + NACK",
+	"TIMEOUT", "TIMEOUT + NACK", "TIMEOUT + ARB_LOST",
+	"TIMEOUT + ARB_LOST + NACK", "TIMEOUT + BUS_ERR",
+	"TIMEOUT + BUS_ERR + NACK" , "TIMEOUT + BUS_ERR + ARB_LOST",
+	"TIMEOUT + BUS_ERR + ARB_LOST + NACK",
+};
+
+void i2c_msm_prof_dump_xfer_end(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	int ret = event->data0;
+	int err = event->data1;
+	int bc  = ctrl->xfer.rx_cnt + ctrl->xfer.rx_ovrhd_cnt +
+		  ctrl->xfer.tx_cnt + ctrl->xfer.tx_ovrhd_cnt;
+	int bc_sec = (bc * 1000000) / (msec * 1000 + usec);
+	const char *status = (!err && (ret == ctrl->xfer.msg_cnt)) ?
+								"OK" : "FAIL";
+	dev_info(ctrl->dev,
+		"%3zu.%03zums XFER_END ret:%d err:[%s] msgs_sent:%d BC:%d B/sec:%d i2c-stts:%s\n" ,
+		msec, usec, ret, i2c_msm_err_str_tbl[err], event->data2,
+		bc, bc_sec, status);
+}
+
+void i2c_msm_prof_dump_irq_begn(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev, "%3zu.%03zums  IRQ_BEG irq:%lld\n",
+						msec, usec, event->data0);
+}
+
+void i2c_msm_prof_dump_irq_end(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	char str[I2C_MSM_REG_2_STR_BUF_SZ];
+	u32 mstr_stts = event->data0;
+	u32 qup_oper  = event->data1;
+	u32 err_flgs  = event->data2;
+	dev_info(ctrl->dev,
+		"%3zu.%03zums  IRQ_END MSTR_STTS:0x%x QUP_OPER:0x%x ERR_FLGS:0x%x\n",
+		msec, usec, mstr_stts, qup_oper, err_flgs);
+
+	/*
+	 * Dump fields and flags only of registers with interesting info
+	 * (i.e. errors).
+	 */
+	 /* register I2C_MASTER_STATUS */
+	if (mstr_stts & QUP_MSTR_STTS_ERR_MASK) {
+		i2c_msm_dbg_qup_reg_flds_to_str(
+				mstr_stts, str, sizeof(str),
+				i2c_msm_qup_i2c_stat_fields_map);
+
+		dev_info(ctrl->dev, "            |->MSTR_STTS:0x%llx %s\n",
+						event->data0, str);
+	}
+	/* register QUP_OPERATIONAL */
+	if (qup_oper &
+	   (QUP_OUTPUT_SERVICE_FLAG | QUP_INPUT_SERVICE_FLAG)) {
+
+		i2c_msm_dbg_qup_reg_flds_to_str(
+				qup_oper, str, sizeof(str),
+				i2c_msm_qup_op_fields_map);
+
+		dev_info(ctrl->dev, "            |-> QUP_OPER:0x%x %s\n",
+						event->data1, str);
+	}
+	/* register ERR_FLAGS */
+	if (err_flgs) {
+		i2c_msm_dbg_qup_reg_flds_to_str(
+				err_flgs, str, sizeof(str),
+				i2c_msm_qup_err_flags_fields_map);
+
+		dev_info(ctrl->dev, "            |-> ERR_FLGS:0x%x %s\n",
+						event->data2, str);
+	}
+}
+
+void i2c_msm_prof_dump_next_buf(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	struct i2c_msg *msg = ctrl->xfer.msgs + event->data0;
+	dev_info(ctrl->dev,
+		"%3zu.%03zums XFER_BUF msg[%lld] pos:%d adr:0x%x len:%d is_rx:0x%x last:0x%x\n",
+		msec, usec, event->data0, event->data1, msg->addr, msg->len,
+		(msg->flags & I2C_M_RD),
+		event->data0 == (ctrl->xfer.msg_cnt - 1));
+
+}
+
+void i2c_msm_prof_dump_scan_sum(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	u32 bc_rx       = (event->data0 & 0xff);
+	u32 bc_rx_ovrhd = (event->data0 >> 16);
+	u32 bc_tx       = (event->data1 & 0xff);
+	u32 bc_tx_ovrhd = (event->data1 >> 16);
+	u32 timeout     = (event->data2 & 0xfff);
+	u32 mode        = (event->data2 >> 24);
+	u32 bc      = bc_rx + bc_rx_ovrhd + bc_tx + bc_tx_ovrhd;
+	dev_info(ctrl->dev,
+		"%3zu.%03zums SCN_SMRY BC:%u rx:%u+ovrhd:%u tx:%u+ovrhd:%u timeout:%umsec mode:%s\n",
+		msec, usec, bc, bc_rx, bc_rx_ovrhd, bc_tx, bc_tx_ovrhd,
+		jiffies_to_msecs(timeout), i2c_msm_mode_str_tbl[mode]);
+}
+
+void i2c_msm_prof_dump_cmplt_ok(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev,
+		"%3zu.%03zums  DONE_OK timeout-used:%umsec time_left:%umsec\n",
+		msec, usec, jiffies_to_msecs(event->data0),
+		jiffies_to_msecs(event->data1));
+}
+
+void i2c_msm_prof_dump_cmplt_fl(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	dev_info(ctrl->dev,
+		"%3zu.%03zums  TIMEOUT-error timeout-used:%umsec. Check GPIOs configuration\n",
+		msec, usec, jiffies_to_msecs(event->data0));
+}
+
+void i2c_msm_prof_dump_vlid_end(struct i2c_msm_ctrl *ctrl,
+		struct i2c_msm_prof_event *event, size_t msec, size_t usec)
+{
+	int  ret        = (int)(event->data0 & 0xff);
+	enum i2c_msm_qup_state state = ((event->data0 << 16) & 0xf);
+	u32  status     = event->data2;
+
+	dev_info(ctrl->dev,
+	"%3zu.%03zums SET_STTE set:%s ret:%d rd_cnt:%u reg_val:0x%x vld:%d\n",
+	msec, usec, i2c_msm_reg_qup_state_to_str[state], ret,
+	event->data1, status, BIT_IS_SET(status, 2));
+}
+/* match the corresponding prof event enum to the prof function declaration */
+static i2c_msm_prof_dump_func_func_t event_dump_func_tbl[] = {
+	[I2C_MSM_VALID_END]	= i2c_msm_prof_dump_vlid_end,
+	[I2C_MSM_PIP_DSCN]	= i2c_msm_prof_dump_pip_dscn,
+	[I2C_MSM_PIP_CNCT]	= i2c_msm_prof_dump_pip_cnct,
+	[I2C_MSM_ACTV_END]	= i2c_msm_prof_dump_actv_end,
+	[I2C_MSM_IRQ_BGN]	= i2c_msm_prof_dump_irq_begn,
+	[I2C_MSM_IRQ_END]	= i2c_msm_prof_dump_irq_end,
+	[I2C_MSM_XFER_BEG]	= i2c_msm_prof_dump_xfer_beg,
+	[I2C_MSM_XFER_END]	= i2c_msm_prof_dump_xfer_end,
+	[I2C_MSM_SCAN_SUM]	= i2c_msm_prof_dump_scan_sum,
+	[I2C_MSM_NEXT_BUF]	= i2c_msm_prof_dump_next_buf,
+	[I2C_MSM_COMPLT_OK]	= i2c_msm_prof_dump_cmplt_ok,
+	[I2C_MSM_COMPLT_FL]	= i2c_msm_prof_dump_cmplt_fl,
+	[I2C_MSM_PROF_RESET]	= i2c_msm_prof_reset,
+};
+
+/*
+ * i2c_msm_prof_evnt_dump: post processing, msg formatting and dumping of events
+ */
+void i2c_msm_prof_evnt_dump(struct i2c_msm_ctrl *ctrl)
+{
+	size_t                     cnt   = atomic_read(&ctrl->xfer.event_cnt);
+	struct i2c_msm_prof_event *event = ctrl->xfer.event;
+	struct timespec            time0 = event->time;
+	struct timespec            time_diff;
+	size_t                     diff_usec;
+	size_t                     diff_msec;
+	i2c_msm_prof_dump_func_func_t func;
+
+	for (; cnt; --cnt, ++event) {
+		time_diff = timespec_sub(event->time, time0);
+		diff_usec = time_diff.tv_sec  * USEC_PER_SEC +
+			    time_diff.tv_nsec / NSEC_PER_USEC;
+		diff_msec  = diff_usec / USEC_PER_MSEC;
+		diff_usec -= diff_msec * USEC_PER_MSEC;
+
+		func = event_dump_func_tbl[event->dump_func_id];
+		func(ctrl, event, diff_msec, diff_usec);
+	}
+}
+EXPORT_SYMBOL(i2c_msm_prof_evnt_dump);
diff -Naur -x .git --no-dereference linux/drivers/platform/msm/Kconfig linux-3.14/drivers/platform/msm/Kconfig
--- linux/drivers/platform/msm/Kconfig	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/platform/msm/Kconfig	2016-09-01 11:52:04.000000000 +0800
@@ -61,6 +61,15 @@
 	  Say Y here if you would like to use hard disks under Linux which
 	  were partitioned using MTD/EFI.
 
+config I2C_MSM_PROF_DBG
+	tristate "I2C_MSM_PROF_DBG"
+	depends on ARCH_MSM && I2C_MSM_V2
+	help
+	This option enables the enhanced logging, profiling and debugfs
+	support to the i2c-msm-v2 driver. If you say yes to this option,
+	you can change the deugging level to adjust the amount of debugging
+	information as needed at run time using debugfs.
 
+	This module can also be dynamically linked as a shared kernel object.
 endmenu
 
diff -Naur -x .git --no-dereference linux/drivers/platform/msm/Makefile linux-3.14/drivers/platform/msm/Makefile
--- linux/drivers/platform/msm/Makefile	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/platform/msm/Makefile	2016-09-01 11:52:04.000000000 +0800
@@ -6,3 +6,4 @@
 obj-$(CONFIG_MSM_BUS_SCALING) += msm_bus/
 obj-$(CONFIG_BUS_TOPOLOGY_ADHOC) += msm_bus/
 obj-$(CONFIG_BOOTCONFIG_PARTITION) += bootconfig.o
+obj-$(CONFIG_I2C_MSM_PROF_DBG) += i2c-msm-prof-dbg.o
diff -Naur -x .git --no-dereference linux/drivers/platform/msm/msm_bus/msm_bus_fabric.c linux-3.14/drivers/platform/msm/msm_bus/msm_bus_fabric.c
--- linux/drivers/platform/msm/msm_bus/msm_bus_fabric.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/platform/msm/msm_bus/msm_bus_fabric.c	2016-09-01 11:52:04.000000000 +0800
@@ -966,7 +966,7 @@
 	else
 		initialized = true;
 
-	MSM_BUS_ERR("msm_bus_fabric_init_driver\n");
+	MSM_BUS_DBG("msm_bus_fabric_init_driver\n");
 	msm_bus_arb_setops_legacy(&arb_ops);
 	return platform_driver_register(&msm_bus_fabric_driver);
 }
diff -Naur -x .git --no-dereference linux/drivers/platform/msm/msm_bus/msm_bus_of_adhoc.c linux-3.14/drivers/platform/msm/msm_bus/msm_bus_of_adhoc.c
--- linux/drivers/platform/msm/msm_bus/msm_bus_of_adhoc.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/platform/msm/msm_bus/msm_bus_of_adhoc.c	2016-09-01 11:52:04.000000000 +0800
@@ -365,7 +365,7 @@
 							"qcom,ap-owned");
 
 	if (node_device->node_info->is_fab_dev) {
-		dev_err(&pdev->dev, "Dev %d\n", node_device->node_info->id);
+		dev_dbg(&pdev->dev, "Dev %d\n", node_device->node_info->id);
 
 		if (!node_device->node_info->virt_dev) {
 			node_device->fabdev =
@@ -381,7 +381,7 @@
 							"bus_clk");
 
 		if (IS_ERR_OR_NULL(node_device->clk[DUAL_CTX].clk))
-			dev_err(&pdev->dev,
+			dev_dbg(&pdev->dev,
 				"%s:Failed to get bus clk for bus%d ctx%d",
 				__func__, node_device->node_info->id,
 								DUAL_CTX);
diff -Naur -x .git --no-dereference linux/drivers/pwm/Kconfig linux-3.14/drivers/pwm/Kconfig
--- linux/drivers/pwm/Kconfig	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/pwm/Kconfig	2016-09-01 11:52:04.000000000 +0800
@@ -89,6 +89,12 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-imx.
 
+config PWM_IPQ4019
+	tristate "IPQ4019 PWM support"
+	depends on ARCH_IPQ40XX
+	help
+	 Generic PWM framework driver for IPQ4019.
+
 config PWM_JZ4740
 	tristate "Ingenic JZ4740 PWM support"
 	depends on MACH_JZ4740
diff -Naur -x .git --no-dereference linux/drivers/pwm/Makefile linux-3.14/drivers/pwm/Makefile
--- linux/drivers/pwm/Makefile	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/pwm/Makefile	2016-09-01 11:52:04.000000000 +0800
@@ -1,3 +1,5 @@
+ccflags-$(CONFIG_PWM_IPQ4019) += -I$(srctree)/sound/soc/qca
+
 obj-$(CONFIG_PWM)		+= core.o
 obj-$(CONFIG_PWM_SYSFS)		+= sysfs.o
 obj-$(CONFIG_PWM_AB8500)	+= pwm-ab8500.o
@@ -13,6 +15,7 @@
 obj-$(CONFIG_PWM_PCA9685)	+= pwm-pca9685.o
 obj-$(CONFIG_PWM_PUV3)		+= pwm-puv3.o
 obj-$(CONFIG_PWM_PXA)		+= pwm-pxa.o
+obj-$(CONFIG_PWM_IPQ4019)	+= pwm-ipq4019.o
 obj-$(CONFIG_PWM_RENESAS_TPU)	+= pwm-renesas-tpu.o
 obj-$(CONFIG_PWM_SAMSUNG)	+= pwm-samsung.o
 obj-$(CONFIG_PWM_SPEAR)		+= pwm-spear.o
diff -Naur -x .git --no-dereference linux/drivers/pwm/pwm-ipq4019.c linux-3.14/drivers/pwm/pwm-ipq4019.c
--- linux/drivers/pwm/pwm-ipq4019.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/pwm/pwm-ipq4019.c	2016-09-01 11:52:04.000000000 +0800
@@ -0,0 +1,271 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include "ipq40xx-adss.h"
+
+#define SRC_FREQ		(200*1000*1000)
+#define MAX_PWM_DEVICES		4
+
+/* The default period and duty cycle values to be configured. */
+#define DEFAULT_PERIOD_NS	10
+#define DEFAULT_DUTY_CYCLE_NS	5
+
+/* The frequency range supported is 762Hz to 100MHz. */
+#define MIN_PERIOD_NS		10
+#define MAX_PERIOD_NS		1312335
+
+/* The max value specified for each field is based on the number of bits
+ * in the pwm control regitser for that filed
+ */
+#define MAX_PRE_DIV		0xFF
+#define MAX_PWM_DIV		0x3FF
+#define MAX_HI_DUR		0x7FF
+
+/* Enable bit is set to enable output toggling in pwm device.
+ * Update bit is set to reflect the changed divider and high duration
+ * values in register. Update bit is auto cleared after the update
+ */
+#define PWM_ENABLE		0x80000000
+#define PWM_UPDATE		0x40000000
+
+#define PWM_CTRL_PRE_DIV_SHIFT	22
+#define PWM_CTRL_DIV_SHIFT	0
+#define PWM_CTRL_HI_SHIFT	10
+
+struct ipq4019_pwm_chip {
+	struct pwm_chip chip;
+	struct clk *clk;
+};
+
+static ssize_t count;
+static uint32_t used_pwm[MAX_PWM_DEVICES];
+
+static const uint32_t pwm_ctrl_register[] = {
+	ADSS_GLB_PWM0_CTRL_REG,
+	ADSS_GLB_PWM1_CTRL_REG,
+	ADSS_GLB_PWM2_CTRL_REG,
+	ADSS_GLB_PWM3_CTRL_REG,
+};
+
+static struct ipq4019_pwm_chip *to_ipq4019_pwm_chip(struct pwm_chip *chip)
+{
+	return container_of(chip, struct ipq4019_pwm_chip, chip);
+}
+
+static void config_div_and_duty(struct pwm_device *pwm, int pre_div,
+				int pwm_div, int period_ns, int duty_ns)
+{
+	unsigned long hi_dur;
+	unsigned long ctrl_reg_val = 0;
+
+	/* high duration = pwm duty * ( pwm div + 1)
+	 * pwm duty = duty_ns / period_ns
+	 */
+	hi_dur = ((pwm_div + 1) * duty_ns) / period_ns;
+
+	ctrl_reg_val |= ((pre_div & MAX_PRE_DIV) << PWM_CTRL_PRE_DIV_SHIFT);
+	ctrl_reg_val |= ((hi_dur & MAX_HI_DUR) << PWM_CTRL_HI_SHIFT);
+	ctrl_reg_val |= ((pwm_div & MAX_PWM_DIV) << PWM_CTRL_DIV_SHIFT);
+	ipq40xx_audio_adss_writel(ctrl_reg_val, pwm_ctrl_register[pwm->hwpwm]);
+}
+
+static int ipq4019_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	unsigned long ctrl_reg_val;
+
+	ctrl_reg_val = ipq40xx_audio_adss_readl(pwm_ctrl_register[pwm->hwpwm]);
+	ctrl_reg_val |= (PWM_ENABLE | PWM_UPDATE);
+	ipq40xx_audio_adss_writel(ctrl_reg_val, pwm_ctrl_register[pwm->hwpwm]);
+
+	return 0;
+}
+
+static void ipq4019_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	unsigned long ctrl_reg_val;
+
+	ctrl_reg_val = ipq40xx_audio_adss_readl(pwm_ctrl_register[pwm->hwpwm]);
+	ctrl_reg_val &= ~PWM_ENABLE;
+	ipq40xx_audio_adss_writel(ctrl_reg_val, pwm_ctrl_register[pwm->hwpwm]);
+}
+
+static int ipq4019_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+						int duty_ns, int period_ns)
+{
+	struct ipq4019_pwm_chip *ipq4019_chip = to_ipq4019_pwm_chip(chip);
+	unsigned long freq;
+	int pre_div, close_pre_div, close_pwm_div;
+	int pwm_div = MAX_PWM_DIV;
+	long diff;
+	unsigned long rate = clk_get_rate(ipq4019_chip->clk);
+	unsigned long min_diff = rate;
+
+	/* freq in Hz for period in nano second*/
+	freq = NSEC_PER_SEC / period_ns;
+
+	if (period_ns > MAX_PERIOD_NS || period_ns < MIN_PERIOD_NS) {
+		pr_err("PWM Frequency range supported is 762Hz to 100MHz\n"
+			"Switching to default configuration values\n");
+		period_ns = DEFAULT_PERIOD_NS;
+		duty_ns = DEFAULT_DUTY_CYCLE_NS;
+		pwm->period = period_ns;
+		pwm->duty_cycle = duty_ns;
+	}
+
+	ipq4019_pwm_disable(chip, pwm);
+
+	do {
+		pre_div = 0;
+		while (pre_div <= MAX_PRE_DIV) {
+			diff = rate - (freq * (pre_div + 1) * (pwm_div + 1));
+			if (diff < 0)
+				diff = -diff;
+			if (!diff) {
+				close_pre_div = pre_div;
+				close_pwm_div = pwm_div;
+				break;
+			}
+			if (diff < min_diff) {
+				min_diff = diff;
+				close_pre_div = pre_div;
+				close_pwm_div = pwm_div;
+			}
+			pre_div++;
+		}
+		pwm_div--;
+	} while (pwm_div >= 0 && diff);
+
+	/* config divider values for the closest possible frequency */
+	config_div_and_duty(pwm, close_pre_div, close_pwm_div,
+					period_ns, duty_ns);
+	ipq4019_pwm_enable(chip, pwm);
+
+	return 0;
+}
+
+static int ipq4019_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	if (!used_pwm[pwm->hwpwm])
+		return -EINVAL;
+
+	pwm->period = DEFAULT_PERIOD_NS;
+	pwm->duty_cycle = DEFAULT_DUTY_CYCLE_NS;
+
+	ipq4019_pwm_config(chip, pwm, pwm->duty_cycle, pwm->period);
+
+	return 0;
+}
+
+static void ipq4019_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	ipq4019_pwm_disable(chip, pwm);
+}
+
+
+static struct pwm_ops ipq4019_pwm_ops = {
+	.request = ipq4019_pwm_request,
+	.free = ipq4019_pwm_free,
+	.config = ipq4019_pwm_config,
+	.enable = ipq4019_pwm_enable,
+	.disable = ipq4019_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int ipq4019_pwm_probe(struct platform_device *pdev)
+{
+	struct ipq4019_pwm_chip *pwm;
+	struct device *dev;
+	unsigned int base_index;
+	int ret;
+
+	dev = &pdev->dev;
+	pwm = devm_kzalloc(dev, sizeof(*pwm), GFP_KERNEL);
+	if (!pwm) {
+		dev_err(dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, pwm);
+
+	pwm->clk = devm_clk_get(dev, "core");
+	if (!IS_ERR(pwm->clk)) {
+		ret = clk_set_rate(pwm->clk, SRC_FREQ);
+		if (ret)
+			return ret;
+		ret = clk_prepare_enable(pwm->clk);
+		if (ret)
+			return ret;
+	}
+
+	if (of_property_read_u32(dev->of_node, "pwm-base-index", &base_index))
+		base_index = 0;
+
+	count = of_property_count_u32_elems(dev->of_node, "used-pwm-indices");
+
+	if (of_property_read_u32_array(dev->of_node, "used-pwm-indices",
+			used_pwm, count))
+		return -EINVAL;
+
+	pwm->chip.dev = dev;
+	pwm->chip.ops = &ipq4019_pwm_ops;
+	pwm->chip.base = base_index;
+	pwm->chip.npwm = count;
+
+	ret = pwmchip_add(&pwm->chip);
+	if (ret < 0) {
+		dev_err(dev, "pwmchip_add() failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ipq4019_pwm_remove(struct platform_device *pdev)
+{
+	struct ipq4019_pwm_chip *pwm = platform_get_drvdata(pdev);
+
+	return pwmchip_remove(&pwm->chip);
+}
+
+static struct of_device_id pwm_msm_dt_match[] = {
+	{
+		.compatible = "qca,ipq4019-pwm",
+	},
+	{}
+};
+
+static struct platform_driver ipq4019_pwm_driver = {
+	.driver = {
+		.name = "qca,ipq4019-pwm",
+		.owner = THIS_MODULE,
+		.of_match_table = pwm_msm_dt_match,
+	},
+	.probe = ipq4019_pwm_probe,
+	.remove = ipq4019_pwm_remove,
+};
+
+module_platform_driver(ipq4019_pwm_driver);
+
+MODULE_LICENSE("Dual BSD/GPL");
diff -Naur -x .git --no-dereference linux/drivers/soc/qcom/scm_restart_reason.c linux-3.14/drivers/soc/qcom/scm_restart_reason.c
--- linux/drivers/soc/qcom/scm_restart_reason.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/soc/qcom/scm_restart_reason.c	2016-09-01 11:52:04.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -29,12 +29,17 @@
 #define CLEAR_MAGIC	0x0
 #define SCM_CMD_TZ_CONFIG_HW_FOR_RAM_DUMP_ID	0x9
 #define SCM_CMD_TZ_FORCE_DLOAD_ID		0x10
+#define SCM_CMD_TZ_SET_DLOAD_FOR_SECURE_BOOT	0x14
+
+static int dload_dis;
 
 static void scm_restart_dload_mode_enable(void)
 {
-	unsigned int magic_cookie = SET_MAGIC;
-	scm_call(SCM_SVC_BOOT, SCM_CMD_TZ_FORCE_DLOAD_ID, &magic_cookie,
-		sizeof(magic_cookie), NULL, 0);
+	if (!dload_dis) {
+		unsigned int magic_cookie = SET_MAGIC;
+		scm_call(SCM_SVC_BOOT, SCM_CMD_TZ_FORCE_DLOAD_ID, &magic_cookie,
+			sizeof(magic_cookie), NULL, 0);
+	}
 }
 
 static void scm_restart_dload_mode_disable(void)
@@ -80,9 +85,34 @@
 
 static int scm_restart_reason_probe(struct platform_device *pdev)
 {
-	int ret;
+	int ret, dload_dis_sec;
+	struct device_node *np;
 
-	scm_restart_dload_mode_enable();
+	np = of_node_get(pdev->dev.of_node);
+	if (!np)
+		return 0;
+
+	ret = of_property_read_u32(np, "dload_status", &dload_dis);
+	if (ret)
+		dload_dis = 0;
+
+	ret = of_property_read_u32(np, "dload_sec_status", &dload_dis_sec);
+	if (ret)
+		dload_dis_sec = 0;
+
+	if (dload_dis_sec) {
+		scm_call(SCM_SVC_BOOT, SCM_CMD_TZ_SET_DLOAD_FOR_SECURE_BOOT,
+							NULL, 0, NULL, 0);
+	}
+
+	/* Ensure Disable before enabling the dload and sdi bits
+	 * to make sure they are disabled during boot */
+	if (dload_dis) {
+		scm_restart_dload_mode_disable();
+		scm_restart_sdi_disable();
+	} else {
+		scm_restart_dload_mode_enable();
+	}
 
 	ret = atomic_notifier_chain_register(&panic_notifier_list, &panic_nb);
 	if (ret) {
diff -Naur -x .git --no-dereference linux/drivers/spi/spi-qup.c linux-3.14/drivers/spi/spi-qup.c
--- linux/drivers/spi/spi-qup.c	2016-04-18 10:49:06.000000000 +0800
+++ linux-3.14/drivers/spi/spi-qup.c	2016-09-01 11:52:04.000000000 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2015, The Linux foundation. All rights reserved.
+ * Copyright (c) 2008-2016, The Linux foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License rev 2 and
@@ -24,6 +24,7 @@
 #include <linux/spi/spi.h>
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
+#include <linux/gpio.h>
 
 #define QUP_CONFIG			0x0000
 #define QUP_STATE			0x0004
@@ -837,6 +838,21 @@
 	return ret;
 }
 
+static int spi_qup_setup(struct spi_device *spi)
+{
+	if (!gpio_is_valid(spi->cs_gpio))
+		return 0;
+
+	if (spi->mode & SPI_CS_HIGH)
+		gpio_set_value(spi->cs_gpio, 0);
+	else
+		gpio_set_value(spi->cs_gpio, 1);
+
+	udelay(10);
+
+	return 0;
+}
+
 static int spi_qup_probe(struct platform_device *pdev)
 {
 	struct spi_master *master;
@@ -910,6 +926,7 @@
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
 	master->max_speed_hz = max_freq;
 	master->transfer_one = spi_qup_transfer_one;
+	master->setup = spi_qup_setup;
 	master->dev.of_node = pdev->dev.of_node;
 	master->auto_runtime_pm = true;
 	master->dma_alignment = dma_get_cache_alignment();
diff -Naur -x .git --no-dereference linux/drivers/staging/mt29f_spinand/giga_spinand.c linux-3.14/drivers/staging/mt29f_spinand/giga_spinand.c
--- linux/drivers/staging/mt29f_spinand/giga_spinand.c	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/staging/mt29f_spinand/giga_spinand.c	2016-09-01 11:52:04.000000000 +0800
@@ -37,6 +37,21 @@
 	chip->ecc.layout = NULL;
 }
 
+void gigadevice_set_defaults_512mb(struct spi_device *spi_nand)
+{
+	struct mtd_info *mtd = (struct mtd_info *)dev_get_drvdata
+						(&spi_nand->dev);
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+
+	chip->ecc.size	= 0x1000;
+	chip->ecc.bytes	= 0x0;
+	chip->ecc.steps	= 0x0;
+
+	chip->ecc.strength = 1;
+	chip->ecc.total	= 0;
+	chip->ecc.layout = NULL;
+}
+
 void gigadevice_read_cmd(struct spinand_cmd *cmd, u32 page_id)
 {
 	cmd->addr[0] = (u8) (page_id >> 16);
@@ -45,19 +60,20 @@
 
 }
 
-void gigadevice_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void gigadevice_read_data(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
+	cmd->addr[0] = 0xff; /*dummy byte*/
 	cmd->addr[1] = (u8)(column >> 8);
 	cmd->addr[2] = (u8)(column);
 }
 
-void macronix_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void macronix_read_data(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
 	cmd->addr[0] = ((u8)(column >> 8) & MACRONIX_NORM_RW_MASK);
 	cmd->addr[1] = (u8)(column);
 }
 
-void winbond_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void winbond_read_data(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
 	cmd->addr[0] = (u8)(column >> 8);
 	cmd->addr[1] = (u8)(column);
@@ -70,19 +86,19 @@
 	cmd->addr[2] = (u8)(page_id);
 }
 
-void gigadevice_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void gigadevice_write_data(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
-	cmd->addr[1] = (u8)(column >> 8);
-	cmd->addr[2] = (u8)(column);
+	cmd->addr[0] = (u8)(column >> 8);
+	cmd->addr[1] = (u8)(column);
 }
 
-void macronix_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void macronix_write_data(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
 	cmd->addr[0] = ((u8)(column >> 8) & MACRONIX_NORM_RW_MASK);
 	cmd->addr[1] = (u8)(column);
 }
 
-void winbond_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void winbond_write_data(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
 	cmd->addr[0] = (u8)(column >> 8);
 	cmd->addr[1] = (u8)(column);
@@ -101,7 +117,7 @@
 
 	if (ecc_status == STATUS_ECC_ERROR_GIGA)
 		return SPINAND_ECC_ERROR;
-	else if (ecc_status)
+	else if (ecc_status >= STATUS_ECC_BF_THRESHOLD_GIGA)
 		return SPINAND_ECC_CORRECTED;
 	else
 		return 0;
@@ -125,20 +141,23 @@
 	return 0;
 }
 
-int gigadevice_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id)
+int gigadevice_parse_id(struct spi_device *spi_nand,
+		struct spinand_ops *ops, u8 *nand_id, u8 *id)
 {
 	if (nand_id[0] != NAND_MFR_GIGA && nand_id[0] != NAND_MFR_ATO)
 		return -EINVAL;
 
-	if (nand_id[0] == NAND_MFR_GIGA) {
-		id[0] = nand_id[0];
-		id[1] = nand_id[1];
-	}
+	if (!(nand_id[0] == NAND_MFR_GIGA && nand_id[1] == ops->dev_id))
+		return -EINVAL;
+
+	id[0] = nand_id[0];
+	id[1] = nand_id[1];
 
 	return 0;
 }
 
-int macronix_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id)
+int macronix_parse_id(struct spi_device *spi_nand,
+	struct spinand_ops *ops, u8 *nand_id, u8 *id)
 {
 	if (nand_id[1] != NAND_MFR_MACRONIX)
 		return -EINVAL;
@@ -146,9 +165,10 @@
 	return 0;
 }
 
-int winbond_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id)
+int winbond_parse_id(struct spi_device *spi_nand,
+	struct spinand_ops *ops, u8 *nand_id, u8 *id)
 {
-	if (nand_id[1] != NAND_MFR_WINBOND)
+	if (!(nand_id[1] == NAND_MFR_WINBOND && nand_id[2] == ops->dev_id))
 		return -EINVAL;
 
 	return 0;
diff -Naur -x .git --no-dereference linux/drivers/staging/mt29f_spinand/giga_spinand.h linux-3.14/drivers/staging/mt29f_spinand/giga_spinand.h
--- linux/drivers/staging/mt29f_spinand/giga_spinand.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/staging/mt29f_spinand/giga_spinand.h	2016-09-01 11:52:04.000000000 +0800
@@ -21,36 +21,43 @@
 #include "mt29f_spinand.h"
 
 void gigadevice_set_defaults(struct spi_device *spi_nand);
+void gigadevice_set_defaults_512mb(struct spi_device *spi_nand);
 
 void gigadevice_read_cmd(struct spinand_cmd *cmd, u32 page_id);
 
-void gigadevice_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+void gigadevice_read_data(struct spinand_cmd *cmd, u16 column, u32 page_id);
 
 void gigadevice_write_cmd(struct spinand_cmd *cmd, u32 column);
 
-void gigadevice_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+void gigadevice_write_data(struct spinand_cmd *cmd, u16 column, u32 page_id);
 
 void gigadevice_erase_blk(struct spinand_cmd *cmd, u32 page_id);
 
-int gigadevice_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id);
+int gigadevice_parse_id(struct spi_device *spi_nand, struct spinand_ops *ops,
+							u8 *nand_id, u8 *id);
 
 int gigadevice_verify_ecc(u8 status);
 
 int dummy_verify_ecc(u8 status);
 
-void macronix_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+void macronix_read_data(struct spinand_cmd *cmd, u16 column, u32 page_id);
 
-void macronix_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+void macronix_write_data(struct spinand_cmd *cmd, u16 column, u32 page_id);
 
-int macronix_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id);
+int macronix_parse_id(struct spi_device *spi_nand, struct spinand_ops *ops,
+							u8 *nand_id, u8 *id);
 
 int macronix_verify_ecc(u8 status);
 
-void winbond_read_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+void winbond_read_data(struct spinand_cmd *cmd, u16 column, u32 page_id);
 
-void winbond_write_data(struct spinand_cmd *cmd, u16 column, u16 page_id);
+void winbond_write_data(struct spinand_cmd *cmd, u16 column, u32 page_id);
 
-int winbond_parse_id(struct spi_device *spi_nand, u8 *nand_id, u8 *id);
+int winbond_parse_id(struct spi_device *spi_nand, struct spinand_ops *ops,
+						u8 *nand_id, u8 *id);
+
+int winbond_die_select(struct spi_device *spi_nand,
+			struct spinand_ops *dev_ops, u8 die_id);
 
 /* Macronix Specfic defines */
 #define MACRONIX_NORM_RW_MASK	0x0F
diff -Naur -x .git --no-dereference linux/drivers/staging/mt29f_spinand/mt29f_spinand.c linux-3.14/drivers/staging/mt29f_spinand/mt29f_spinand.c
--- linux/drivers/staging/mt29f_spinand/mt29f_spinand.c	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/staging/mt29f_spinand/mt29f_spinand.c	2016-09-01 11:52:04.000000000 +0800
@@ -24,15 +24,20 @@
 #include "mt29f_spinand.h"
 #include "giga_spinand.h"
 
-#define BUFSIZE (10 * 64 * 2048)
-#define CACHE_BUF 2112
+#define BUFSIZE (10 * 64 * 4096)
+#define CACHE_BUF 4352
 
+static int spinand_disable_ecc(struct spi_device *spi_nand);
+static int spinand_lock_block(struct spi_device *spi_nand, u8 lock);
 
 struct spinand_ops spinand_dev[] = {
 #ifdef CONFIG_MTD_SPINAND_GIGADEVICE
 	{
 		NAND_MFR_GIGA,
+		1,
 		0xb1,
+		INT_MAX,
+		0x10000,
 		gigadevice_set_defaults,
 		gigadevice_read_cmd,
 		gigadevice_read_data,
@@ -41,10 +46,30 @@
 		gigadevice_erase_blk,
 		gigadevice_parse_id,
 		gigadevice_verify_ecc,
+		NULL,
+	},
+	{
+		NAND_MFR_GIGA,
+		1,
+		0xb4,
+		INT_MAX,
+		0x20000,
+		gigadevice_set_defaults_512mb,
+		gigadevice_read_cmd,
+		gigadevice_read_data,
+		gigadevice_write_cmd,
+		gigadevice_write_data,
+		gigadevice_erase_blk,
+		gigadevice_parse_id,
+		gigadevice_verify_ecc,
+		NULL,
 	},
 	{
 		NAND_MFR_GIGA,
+		1,
 		0xa1,
+		INT_MAX,
+		0x10000,
 		gigadevice_set_defaults,
 		gigadevice_read_cmd,
 		gigadevice_read_data,
@@ -53,10 +78,14 @@
 		gigadevice_erase_blk,
 		gigadevice_parse_id,
 		gigadevice_verify_ecc,
+		NULL,
 	},
 	{
 		NAND_MFR_ATO,
+		1,
 		0x12,
+		INT_MAX,
+		0x10000,
 		gigadevice_set_defaults,
 		gigadevice_read_cmd,
 		gigadevice_read_data,
@@ -65,11 +94,15 @@
 		gigadevice_erase_blk,
 		gigadevice_parse_id,
 		dummy_verify_ecc,
+		NULL,
 	},
 #endif
 	{
 		NAND_MFR_MACRONIX,
+		1,
 		0x12,
+		INT_MAX,
+		0x10000,
 		gigadevice_set_defaults,
 		gigadevice_read_cmd,
 		macronix_read_data,
@@ -78,10 +111,14 @@
 		gigadevice_erase_blk,
 		macronix_parse_id,
 		macronix_verify_ecc,
+		NULL,
 	},
 	{
 		NAND_MFR_WINBOND,
+		1,
 		0xaa,
+		INT_MAX,
+		0x10000,
 		gigadevice_set_defaults,
 		gigadevice_read_cmd,
 		winbond_read_data,
@@ -90,6 +127,23 @@
 		gigadevice_erase_blk,
 		winbond_parse_id,
 		macronix_verify_ecc,
+		NULL,
+	},
+	{
+		NAND_MFR_WINBOND,
+		2,
+		0xab,
+		INT_MAX,
+		0x10000,
+		gigadevice_set_defaults,
+		gigadevice_read_cmd,
+		winbond_read_data,
+		gigadevice_write_cmd,
+		winbond_write_data,
+		gigadevice_erase_blk,
+		winbond_parse_id,
+		macronix_verify_ecc,
+		winbond_die_select,
 	},
 	{ },
 };
@@ -101,7 +155,7 @@
 
 }
 
-void mt29f_read_from_cache(struct spinand_cmd *cmd, u16 column, u16 page_id)
+void mt29f_read_from_cache(struct spinand_cmd *cmd, u16 column, u32 page_id)
 {
 	cmd->addr[0] = (u8)((column & 0xff00) >> 8);
 	cmd->addr[0] |= (u8)(((page_id >> 6) & 0x1) << 4);
@@ -110,7 +164,7 @@
 }
 
 void mt29f_program_data_to_cache(struct spinand_cmd *cmd, u16 column,
-							u16 page_id)
+							u32 page_id)
 {
 	cmd->addr[0] = (u8)((column & 0xff00) >> 8);
 	cmd->addr[0] |= (u8)(((page_id >> 6) & 0x1) << 4);
@@ -143,6 +197,9 @@
 
 struct spinand_ops mt29f_spinand_ops = {
 		NAND_MFR_MICRON,
+		1,
+		0x0,
+		INT_MAX,
 		0x0,
 		NULL,
 		mt29f_read_page_to_cache,
@@ -152,6 +209,7 @@
 		mt29f_erase_block_erase,
 		NULL,
 		mt29f_verify_ecc,
+		NULL,
 };
 
 
@@ -177,11 +235,12 @@
 
 	for (tmp = 0; tmp < ARRAY_SIZE(spinand_dev) - 1; tmp++) {
 		tmp_ops = &spinand_dev[tmp];
-		if (tmp_ops->spinand_parse_id(spi_nand, nand_id, id) == 0) {
-			info->dev_ops = &spinand_dev[tmp];
-			info->dev_ops->spinand_set_defaults(spi_nand);
-			return;
-		}
+			if (tmp_ops->spinand_parse_id(spi_nand,
+						tmp_ops, nand_id, id) == 0) {
+				info->dev_ops = &spinand_dev[tmp];
+				info->dev_ops->spinand_set_defaults(spi_nand);
+				return;
+			}
 	}
 	info->dev_ops = &mt29f_spinand_ops;
 	return;
@@ -272,6 +331,58 @@
 	return spi_sync(spi, &message);
 }
 
+static int get_die_id(struct spinand_ops *dev_ops, u32 page_id)
+{
+	do_div(page_id, dev_ops->pages_per_die);
+	if (page_id > dev_ops->no_of_dies) {
+		pr_info("invalid die id : %d\n", page_id);
+		return -EINVAL;
+	}
+
+	return page_id;
+}
+
+/*
+ * winbond_die_select - send command 0xc2 to select die
+ * Description:
+ *   Die select function.
+ *   Die ID is given as either 0 or 1 to select die 0 or 1
+ *   respectively
+ */
+int winbond_die_select(struct spi_device *spi_nand,
+		struct spinand_ops *dev_ops, u8 die_id)
+{
+	int retval;
+	struct spinand_cmd cmd = {0};
+
+	if (die_id < 0)
+		return -1;
+
+	if (dev_ops->prev_die_id == die_id)
+		return 0;
+
+	cmd.cmd = CMD_DIE_SELECT,
+	cmd.n_addr = 1,
+	cmd.addr[0] = die_id,
+	retval = spinand_cmd(spi_nand, &cmd);
+	if (retval < 0)
+		dev_err(&spi_nand->dev, "error %d in die select\n", retval);
+	else
+		dev_ops->prev_die_id = die_id;
+
+	return retval;
+}
+
+static inline int do_die_select(struct spi_device *spi_nand,
+		struct spinand_ops *dev_ops, u32 page_id)
+{
+	if (dev_ops->spinand_die_select == NULL)
+		return 0;
+
+	return dev_ops->spinand_die_select(spi_nand,
+		dev_ops, get_die_id(dev_ops, page_id));
+}
+
 /*
  * spinand_read_id- Read SPI Nand ID
  * Description:
@@ -280,8 +391,10 @@
 static int spinand_read_id(struct spi_device *spi_nand, u8 *id)
 {
 	int retval;
+	int i;
 	u8 nand_id[3];
 	struct spinand_cmd cmd = {0};
+	struct spinand_ops *dev_ops;
 
 	cmd.cmd = CMD_READ_ID;
 	cmd.n_rx = 3;
@@ -295,6 +408,19 @@
 	id[0] = nand_id[1];
 	id[1] = nand_id[2];
 	spinand_parse_id(spi_nand, nand_id, id);
+	dev_ops = get_dev_ops(spi_nand);
+	if (dev_ops->spinand_die_select != NULL) {
+		for (i = 0; i < dev_ops->no_of_dies; i++) {
+			retval = dev_ops->spinand_die_select(spi_nand,
+						dev_ops, i);
+			if (retval < 0)
+				return retval;
+			spinand_lock_block(spi_nand, BL_ALL_UNLOCKED);
+			if (spinand_disable_ecc(spi_nand) < 0)
+				pr_info("%s: disable ecc failed!\n", __func__);
+		}
+	}
+
 	return retval;
 }
 
@@ -409,21 +535,33 @@
 static int spinand_enable_ecc(struct spi_device *spi_nand)
 {
 	int retval;
+	int i;
+	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 	u8 otp = 0;
 
-	retval = spinand_get_otp(spi_nand, &otp);
-	if (retval < 0)
-		return retval;
-
-	if ((otp & OTP_ECC_MASK) == OTP_ECC_MASK) {
-		return 0;
-	} else {
-		otp |= OTP_ECC_MASK;
-		retval = spinand_set_otp(spi_nand, &otp);
+	for (i = 0; i < dev_ops->no_of_dies; i++) {
+		if (dev_ops->spinand_die_select != NULL) {
+			retval = dev_ops->spinand_die_select(spi_nand,
+						dev_ops, i);
+			if (retval < 0)
+				return retval;
+		}
+		retval = spinand_get_otp(spi_nand, &otp);
 		if (retval < 0)
 			return retval;
-		return spinand_get_otp(spi_nand, &otp);
+
+		if ((otp & OTP_ECC_MASK) != OTP_ECC_MASK) {
+			otp |= OTP_ECC_MASK;
+			retval = spinand_set_otp(spi_nand, &otp);
+			if (retval < 0)
+				return retval;
+			retval = spinand_get_otp(spi_nand, &otp);
+			if (retval < 0)
+				return retval;
+		}
 	}
+
+	return 0;
 }
 #endif
 
@@ -457,10 +595,25 @@
  */
 static int spinand_write_enable(struct spi_device *spi_nand)
 {
+	int ret = 0;
+	int i;
+	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 	struct spinand_cmd cmd = {0};
 
-	cmd.cmd = CMD_WR_ENABLE;
-	return spinand_cmd(spi_nand, &cmd);
+	for (i = 0; i < dev_ops->no_of_dies; i++) {
+		if (dev_ops->spinand_die_select != NULL) {
+			ret = dev_ops->spinand_die_select(spi_nand,
+						dev_ops, i);
+			if (ret < 0)
+				return ret;
+		}
+		cmd.cmd = CMD_WR_ENABLE;
+		ret = spinand_cmd(spi_nand, &cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
 }
 
 /**
@@ -471,18 +624,35 @@
  */
 static int spinand_write_disable(struct spi_device *spi_nand)
 {
+	int ret = 0;
+	int i;
+	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 	struct spinand_cmd cmd = {0};
 
-	cmd.cmd = CMD_WR_DISABLE;
-	return spinand_cmd(spi_nand, &cmd);
+	for (i = 0; i < dev_ops->no_of_dies; i++) {
+		if (dev_ops->spinand_die_select != NULL) {
+			ret = dev_ops->spinand_die_select(spi_nand,
+						dev_ops, i);
+			if (ret < 0)
+				return ret;
+		}
+		cmd.cmd = CMD_WR_DISABLE;
+		ret = spinand_cmd(spi_nand, &cmd);
+		if (ret < 0)
+			return ret;
+	}
+
+	return ret;
 }
 
-static int spinand_read_page_to_cache(struct spi_device *spi_nand, u16 page_id)
+static int spinand_read_page_to_cache(struct spi_device *spi_nand, u32 page_id)
 {
 	struct spinand_cmd cmd = {0};
 	u16 row;
 	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 
+	do_die_select(spi_nand, dev_ops, page_id);
+
 	row = page_id;
 	cmd.cmd = CMD_READ;
 	cmd.n_addr = 3;
@@ -528,8 +698,8 @@
  *   The read includes two commands to the Nand: 0x13 and 0x03 commands
  *   Poll to read status to wait for tRD time.
  */
-static int spinand_read_page(struct spi_device *spi_nand, u16 page_id,
-		u16 offset, u16 len, u8 *rbuf)
+static int spinand_read_page(struct spi_device *spi_nand, u32 page_id,
+		u32 offset, u32 len, u8 *rbuf)
 {
 	int ret, ecc_error = 0, ecc_corrected = 0;
 	u8 status = 0;
@@ -609,18 +779,20 @@
  *   Since it is writing the data to cache, there is no tPROG time.
  */
 static int spinand_program_data_to_cache(struct spi_device *spi_nand,
-		u16 page_id, u16 byte_id, u16 len, u8 *wbuf)
+		u32 page_id, u16 byte_id, u16 len, u8 *wbuf)
 {
 	struct spinand_cmd cmd = {0};
 	u16 column;
 	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 
+	do_die_select(spi_nand, dev_ops, page_id);
+
 	column = byte_id;
 	cmd.cmd = CMD_PROG_PAGE_CLRCACHE;
 	cmd.n_addr = 2;
 	dev_ops->spinand_write_data(&cmd, column, page_id);
 	cmd.n_tx = len;
-	cmd.tx_buf = wbuf;
+	cmd.tx_buf = wbuf + column;
 
 	return spinand_cmd(spi_nand, &cmd);
 }
@@ -634,12 +806,14 @@
  *   the Nand array.
  *   Need to wait for tPROG time to finish the transaction.
  */
-static int spinand_program_execute(struct spi_device *spi_nand, u16 page_id)
+static int spinand_program_execute(struct spi_device *spi_nand, u32 page_id)
 {
 	struct spinand_cmd cmd = {0};
-	u16 row;
+	u32 row;
 	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 
+	do_die_select(spi_nand, dev_ops, page_id);
+
 	row = page_id;
 	cmd.cmd = CMD_PROG_PAGE_EXC;
 	cmd.n_addr = 3;
@@ -662,7 +836,7 @@
  *   Poll to wait for the tPROG time to finish the transaction.
  */
 static int spinand_program_page(struct spi_device *spi_nand,
-		u16 page_id, u16 offset, u16 len, u8 *buf)
+		u32 page_id, u16 offset, u16 len, u8 *buf)
 {
 	int retval = 0;
 	u8 status = 0;
@@ -677,7 +851,7 @@
 
 	spinand_read_page(spi_nand, page_id, 0, CACHE_BUF, wbuf);
 
-	for (i = offset, j = 0; i < len; i++, j++)
+	for (i = offset, j = 0; i < (offset + len); i++, j++)
 		wbuf[i] &= buf[j];
 
 	if (enable_hw_ecc) {
@@ -760,12 +934,14 @@
  *   one block--64 pages
  *   Need to wait for tERS.
  */
-static int spinand_erase_block_erase(struct spi_device *spi_nand, u16 block_id)
+static int spinand_erase_block_erase(struct spi_device *spi_nand, u32 block_id)
 {
 	struct spinand_cmd cmd = {0};
 	u16 row;
 	struct spinand_ops *dev_ops = get_dev_ops(spi_nand);
 
+	do_die_select(spi_nand, dev_ops, block_id);
+
 	row = block_id;
 	cmd.cmd = CMD_ERASE_BLK;
 	cmd.n_addr = 3;
@@ -785,7 +961,7 @@
  *   and then send the 0xd8 erase command
  *   Poll to wait for the tERS time to complete the tranaction.
  */
-static int spinand_erase_block(struct spi_device *spi_nand, u16 block_id)
+static int spinand_erase_block(struct spi_device *spi_nand, u32 block_id)
 {
 	int retval;
 	u8 status = 0;
diff -Naur -x .git --no-dereference linux/drivers/staging/mt29f_spinand/mt29f_spinand.h linux-3.14/drivers/staging/mt29f_spinand/mt29f_spinand.h
--- linux/drivers/staging/mt29f_spinand/mt29f_spinand.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/staging/mt29f_spinand/mt29f_spinand.h	2016-09-01 11:52:04.000000000 +0800
@@ -36,6 +36,7 @@
 #define CMD_RESET			0xff
 #define CMD_READ_REG			0x0f
 #define CMD_WRITE_REG			0x1f
+#define CMD_DIE_SELECT			0xC2
 
 /* feature/ status reg */
 #define REG_BLOCK_LOCK			0xa0
@@ -60,6 +61,7 @@
 
 #define STATUS_ECC_MASK_GIGA		0x70
 #define STATUS_ECC_ERROR_GIGA		0x70
+#define STATUS_ECC_BF_THRESHOLD_GIGA	0x40
 #define STATUS_ECC_MASK_MACRONIX	0x30
 #define STATUS_ECC_ERROR_MACRONIX	0x20
 #define SPINAND_ECC_ERROR		0x1
@@ -97,18 +99,23 @@
 
 struct spinand_ops {
 	u8   maf_id;
+	u8   no_of_dies;
 	u16   dev_id;
+	int   prev_die_id;
+	u64   pages_per_die;
 	void (*spinand_set_defaults)(struct spi_device *spi_nand);
 	void (*spinand_read_cmd)(struct spinand_cmd *cmd, u32 page_id);
 	void (*spinand_read_data)(struct spinand_cmd *cmd, u16 column,
-							u16 page_id);
+							u32 page_id);
 	void (*spinand_write_cmd)(struct spinand_cmd *cmd, u32 page_id);
 	void (*spinand_write_data)(struct spinand_cmd *cmd, u16 column,
-							u16 page_id);
+							u32 page_id);
 	void (*spinand_erase_blk)(struct spinand_cmd *cmd, u32 page_id);
-	int (*spinand_parse_id)(struct spi_device *spi_nand, u8 *nand_id,
-								u8 *id);
+	int (*spinand_parse_id)(struct spi_device *spi_nand,
+			struct spinand_ops *ops, u8 *nand_id, u8 *id);
 	int (*spinand_verify_ecc)(u8 status);
+	int (*spinand_die_select)(struct spi_device *spi_nand,
+			struct spinand_ops *dev_ops, u8 die_id);
 };
 
 struct spinand_info {
diff -Naur -x .git --no-dereference linux/drivers/thermal/Makefile linux-3.14/drivers/thermal/Makefile
--- linux/drivers/thermal/Makefile	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/thermal/Makefile	2016-09-01 11:52:05.000000000 +0800
@@ -7,6 +7,7 @@
 
 # interface to/from other layers providing sensors
 thermal_sys-$(CONFIG_THERMAL_HWMON)		+= thermal_hwmon.o
+thermal_sys-$(CONFIG_THERMAL_OF)		+= of-thermal.o
 
 # governors
 thermal_sys-$(CONFIG_THERMAL_GOV_FAIR_SHARE)	+= fair_share.o
diff -Naur -x .git --no-dereference linux/drivers/thermal/of-thermal.c linux-3.14/drivers/thermal/of-thermal.c
--- linux/drivers/thermal/of-thermal.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/drivers/thermal/of-thermal.c	2016-09-01 11:52:05.000000000 +0800
@@ -0,0 +1,929 @@
+/*
+ *  of-thermal.c - Generic Thermal Management device tree support.
+ *
+ *  Copyright (C) 2013 Texas Instruments
+ *  Copyright (C) 2013 Eduardo Valentin <eduardo.valentin@ti.com>
+ *
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/thermal.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/string.h>
+
+#include "thermal_core.h"
+
+/***   Private data structures to represent thermal device tree data ***/
+
+/**
+ * struct __thermal_trip - representation of a point in temperature domain
+ * @np: pointer to struct device_node that this trip point was created from
+ * @temperature: temperature value in miliCelsius
+ * @hysteresis: relative hysteresis in miliCelsius
+ * @type: trip point type
+ */
+
+struct __thermal_trip {
+	struct device_node *np;
+	unsigned long int temperature;
+	unsigned long int hysteresis;
+	enum thermal_trip_type type;
+};
+
+/**
+ * struct __thermal_bind_param - a match between trip and cooling device
+ * @cooling_device: a pointer to identify the referred cooling device
+ * @trip_id: the trip point index
+ * @usage: the percentage (from 0 to 100) of cooling contribution
+ * @min: minimum cooling state used at this trip point
+ * @max: maximum cooling state used at this trip point
+ */
+
+struct __thermal_bind_params {
+	struct device_node *cooling_device;
+	unsigned int trip_id;
+	unsigned int usage;
+	unsigned long min;
+	unsigned long max;
+};
+
+/**
+ * struct __thermal_zone - internal representation of a thermal zone
+ * @mode: current thermal zone device mode (enabled/disabled)
+ * @passive_delay: polling interval while passive cooling is activated
+ * @polling_delay: zone polling interval
+ * @ntrips: number of trip points
+ * @trips: an array of trip points (0..ntrips - 1)
+ * @num_tbps: number of thermal bind params
+ * @tbps: an array of thermal bind params (0..num_tbps - 1)
+ * @sensor_data: sensor private data used while reading temperature and trend
+ * @get_temp: sensor callback to read temperature
+ * @get_trend: sensor callback to read temperature trend
+ */
+
+struct __thermal_zone {
+	enum thermal_device_mode mode;
+	int passive_delay;
+	int polling_delay;
+
+	/* trip data */
+	int ntrips;
+	struct __thermal_trip *trips;
+	long prev_low_trip, prev_high_trip;
+
+	/* cooling binding data */
+	int num_tbps;
+	struct __thermal_bind_params *tbps;
+
+	/* sensor interface */
+	void *sensor_data;
+	int (*get_temp)(void *, long *);
+	int (*get_trend)(void *, int, long *);
+	int (*set_trips)(void *, long, long);
+};
+
+/***   Automatic trip handling   ***/
+
+static int of_thermal_set_trips(struct thermal_zone_device *tz, long temp)
+{
+	struct __thermal_zone *data = tz->devdata;
+	long low = LONG_MIN, high = LONG_MAX;
+	int i;
+
+	/* Hardware trip points not supported */
+	if (!data->set_trips)
+		return 0;
+
+	/* No need to change trip points */
+	if (temp > data->prev_low_trip && temp < data->prev_high_trip)
+		return 0;
+
+	for (i = 0; i < data->ntrips; ++i) {
+		struct __thermal_trip *trip = data->trips + i;
+		long trip_low = trip->temperature - trip->hysteresis;
+
+		if (trip_low < temp && trip_low > low)
+			low = trip_low;
+
+		if (trip->temperature > temp && trip->temperature < high)
+			high = trip->temperature;
+	}
+
+	dev_dbg(&tz->device,
+		"temperature %ld, updating trip points to %ld, %ld\n",
+		temp, low, high);
+
+	data->prev_low_trip = low;
+	data->prev_high_trip = high;
+
+	return data->set_trips(data->sensor_data, low, high);
+}
+
+/***   DT thermal zone device callbacks   ***/
+
+static int of_thermal_get_temp(struct thermal_zone_device *tz,
+			       unsigned long *temp)
+{
+	struct __thermal_zone *data = tz->devdata;
+	int err;
+
+	if (!data->get_temp)
+		return -EINVAL;
+
+	err = data->get_temp(data->sensor_data, temp);
+	if (err)
+		return err;
+
+	err = of_thermal_set_trips(tz, *temp);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int of_thermal_get_trend(struct thermal_zone_device *tz, int trip,
+				enum thermal_trend *trend)
+{
+	struct __thermal_zone *data = tz->devdata;
+	long dev_trend;
+	int r;
+
+	if (!data->get_trend)
+		return -EINVAL;
+
+	r = data->get_trend(data->sensor_data, trip, &dev_trend);
+	if (r)
+		return r;
+
+	*trend = dev_trend;
+
+	return 0;
+}
+
+static int of_thermal_bind(struct thermal_zone_device *thermal,
+			   struct thermal_cooling_device *cdev)
+{
+	struct __thermal_zone *data = thermal->devdata;
+	int i;
+
+	if (!data || IS_ERR(data))
+		return -ENODEV;
+
+	/* find where to bind */
+	for (i = 0; i < data->num_tbps; i++) {
+		struct __thermal_bind_params *tbp = data->tbps + i;
+
+		if (tbp->cooling_device == cdev->np) {
+			int ret;
+
+			ret = thermal_zone_bind_cooling_device(thermal,
+						tbp->trip_id, cdev,
+						tbp->min,
+						tbp->max);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int of_thermal_unbind(struct thermal_zone_device *thermal,
+			     struct thermal_cooling_device *cdev)
+{
+	struct __thermal_zone *data = thermal->devdata;
+	int i;
+
+	if (!data || IS_ERR(data))
+		return -ENODEV;
+
+	/* find where to unbind */
+	for (i = 0; i < data->num_tbps; i++) {
+		struct __thermal_bind_params *tbp = data->tbps + i;
+
+		if (tbp->cooling_device == cdev->np) {
+			int ret;
+
+			ret = thermal_zone_unbind_cooling_device(thermal,
+						tbp->trip_id, cdev);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int of_thermal_get_mode(struct thermal_zone_device *tz,
+			       enum thermal_device_mode *mode)
+{
+	struct __thermal_zone *data = tz->devdata;
+
+	*mode = data->mode;
+
+	return 0;
+}
+
+static int of_thermal_set_mode(struct thermal_zone_device *tz,
+			       enum thermal_device_mode mode)
+{
+	struct __thermal_zone *data = tz->devdata;
+
+	mutex_lock(&tz->lock);
+
+	if (mode == THERMAL_DEVICE_ENABLED)
+		tz->polling_delay = data->polling_delay;
+	else
+		tz->polling_delay = 0;
+
+	mutex_unlock(&tz->lock);
+
+	data->mode = mode;
+	thermal_zone_device_update(tz);
+
+	return 0;
+}
+
+static int of_thermal_update_trips(struct thermal_zone_device *tz)
+{
+	long temp;
+	int err;
+
+	err = of_thermal_get_temp(tz, &temp);
+	if (err)
+		return err;
+
+	err = of_thermal_set_trips(tz, temp);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int of_thermal_get_trip_type(struct thermal_zone_device *tz, int trip,
+				    enum thermal_trip_type *type)
+{
+	struct __thermal_zone *data = tz->devdata;
+
+	if (trip >= data->ntrips || trip < 0)
+		return -EDOM;
+
+	*type = data->trips[trip].type;
+
+	return 0;
+}
+
+static int of_thermal_get_trip_temp(struct thermal_zone_device *tz, int trip,
+				    unsigned long *temp)
+{
+	struct __thermal_zone *data = tz->devdata;
+
+	if (trip >= data->ntrips || trip < 0)
+		return -EDOM;
+
+	*temp = data->trips[trip].temperature;
+
+	return 0;
+}
+
+static int of_thermal_set_trip_temp(struct thermal_zone_device *tz, int trip,
+				    unsigned long temp)
+{
+	struct __thermal_zone *data = tz->devdata;
+	int err;
+
+	if (trip >= data->ntrips || trip < 0)
+		return -EDOM;
+
+	/* thermal framework should take care of data->mask & (1 << trip) */
+	data->trips[trip].temperature = temp;
+
+	err = of_thermal_update_trips(tz);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int of_thermal_get_trip_hyst(struct thermal_zone_device *tz, int trip,
+				    unsigned long *hyst)
+{
+	struct __thermal_zone *data = tz->devdata;
+
+	if (trip >= data->ntrips || trip < 0)
+		return -EDOM;
+
+	*hyst = data->trips[trip].hysteresis;
+
+	return 0;
+}
+
+static int of_thermal_set_trip_hyst(struct thermal_zone_device *tz, int trip,
+				    unsigned long hyst)
+{
+	struct __thermal_zone *data = tz->devdata;
+	int err;
+
+	if (trip >= data->ntrips || trip < 0)
+		return -EDOM;
+
+	/* thermal framework should take care of data->mask & (1 << trip) */
+	data->trips[trip].hysteresis = hyst;
+
+	err = of_thermal_update_trips(tz);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int of_thermal_get_crit_temp(struct thermal_zone_device *tz,
+				    unsigned long *temp)
+{
+	struct __thermal_zone *data = tz->devdata;
+	int i;
+
+	for (i = 0; i < data->ntrips; i++)
+		if (data->trips[i].type == THERMAL_TRIP_CRITICAL) {
+			*temp = data->trips[i].temperature;
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static struct thermal_zone_device_ops of_thermal_ops = {
+	.get_mode = of_thermal_get_mode,
+	.set_mode = of_thermal_set_mode,
+
+	.get_trip_type = of_thermal_get_trip_type,
+	.get_trip_temp = of_thermal_get_trip_temp,
+	.set_trip_temp = of_thermal_set_trip_temp,
+	.get_trip_hyst = of_thermal_get_trip_hyst,
+	.set_trip_hyst = of_thermal_set_trip_hyst,
+	.get_crit_temp = of_thermal_get_crit_temp,
+
+	.bind = of_thermal_bind,
+	.unbind = of_thermal_unbind,
+};
+
+/***   sensor API   ***/
+
+static struct thermal_zone_device *
+thermal_zone_of_add_sensor(struct device_node *zone,
+			   struct device_node *sensor, void *data,
+			   int (*get_temp)(void *, long *),
+			   int (*get_trend)(void *, int, long *),
+			   int (*set_trips)(void *, long, long))
+{
+	struct thermal_zone_device *tzd;
+	struct __thermal_zone *tz;
+
+	tzd = thermal_zone_get_zone_by_node(zone);
+	if (IS_ERR(tzd))
+		return ERR_PTR(-EPROBE_DEFER);
+
+	tz = tzd->devdata;
+
+	mutex_lock(&tzd->lock);
+	tz->get_temp = get_temp;
+	tz->get_trend = get_trend;
+	tz->set_trips = set_trips;
+	tz->sensor_data = data;
+
+	of_thermal_update_trips(tzd);
+
+	tzd->ops->get_temp = of_thermal_get_temp;
+	tzd->ops->get_trend = of_thermal_get_trend;
+	mutex_unlock(&tzd->lock);
+
+	return tzd;
+}
+
+/**
+ * thermal_zone_of_sensor_register - registers a sensor to a DT thermal zone
+ * @dev: a valid struct device pointer of a sensor device. Must contain
+ *       a valid .of_node, for the sensor node.
+ * @sensor_id: a sensor identifier, in case the sensor IP has more
+ *             than one sensors
+ * @data: a private pointer (owned by the caller) that will be passed
+ *        back, when a temperature reading is needed.
+ * @get_temp: a pointer to a function that reads the sensor temperature.
+ * @get_trend: a pointer to a function that reads the sensor temperature trend.
+ *
+ * This function will search the list of thermal zones described in device
+ * tree and look for the zone that refer to the sensor device pointed by
+ * @dev->of_node as temperature providers. For the zone pointing to the
+ * sensor node, the sensor will be added to the DT thermal zone device.
+ *
+ * The thermal zone temperature is provided by the @get_temp function
+ * pointer. When called, it will have the private pointer @data back.
+ *
+ * The thermal zone temperature trend is provided by the @get_trend function
+ * pointer. When called, it will have the private pointer @data back.
+ *
+ * TODO:
+ * 01 - This function must enqueue the new sensor instead of using
+ * it as the only source of temperature values.
+ *
+ * 02 - There must be a way to match the sensor with all thermal zones
+ * that refer to it.
+ *
+ * Return: On success returns a valid struct thermal_zone_device,
+ * otherwise, it returns a corresponding ERR_PTR(). Caller must
+ * check the return value with help of IS_ERR() helper.
+ */
+struct thermal_zone_device *
+thermal_zone_of_sensor_register(struct device *dev, int sensor_id,
+				void *data, int (*get_temp)(void *, long *),
+				int (*get_trend)(void *, int, long *),
+				int (*set_trips)(void *, long, long))
+{
+	struct device_node *np, *child, *sensor_np;
+
+	np = of_find_node_by_name(NULL, "thermal-zones");
+	if (!np)
+		return ERR_PTR(-ENODEV);
+
+	if (!dev || !dev->of_node)
+		return ERR_PTR(-EINVAL);
+
+	sensor_np = dev->of_node;
+
+	for_each_child_of_node(np, child) {
+		struct of_phandle_args sensor_specs;
+		int ret, id;
+
+		/* For now, thermal framework supports only 1 sensor per zone */
+		ret = of_parse_phandle_with_args(child, "thermal-sensors",
+						 "#thermal-sensor-cells",
+						 0, &sensor_specs);
+		if (ret)
+			continue;
+
+		if (sensor_specs.args_count >= 1) {
+			id = sensor_specs.args[0];
+			WARN(sensor_specs.args_count > 1,
+			     "%s: too many cells in sensor specifier %d\n",
+			     sensor_specs.np->name, sensor_specs.args_count);
+		} else {
+			id = 0;
+		}
+
+		if (sensor_specs.np == sensor_np && id == sensor_id) {
+			of_node_put(np);
+			return thermal_zone_of_add_sensor(child, sensor_np,
+							  data,
+							  get_temp,
+							  get_trend,
+							  set_trips);
+		}
+	}
+	of_node_put(np);
+
+	return ERR_PTR(-ENODEV);
+}
+EXPORT_SYMBOL_GPL(thermal_zone_of_sensor_register);
+
+/**
+ * thermal_zone_of_sensor_unregister - unregisters a sensor from a DT thermal zone
+ * @dev: a valid struct device pointer of a sensor device. Must contain
+ *       a valid .of_node, for the sensor node.
+ * @tzd: a pointer to struct thermal_zone_device where the sensor is registered.
+ *
+ * This function removes the sensor callbacks and private data from the
+ * thermal zone device registered with thermal_zone_of_sensor_register()
+ * API. It will also silent the zone by remove the .get_temp() and .get_trend()
+ * thermal zone device callbacks.
+ *
+ * TODO: When the support to several sensors per zone is added, this
+ * function must search the sensor list based on @dev parameter.
+ *
+ */
+void thermal_zone_of_sensor_unregister(struct device *dev,
+				       struct thermal_zone_device *tzd)
+{
+	struct __thermal_zone *tz;
+
+	if (!dev || !tzd || !tzd->devdata)
+		return;
+
+	tz = tzd->devdata;
+
+	/* no __thermal_zone, nothing to be done */
+	if (!tz)
+		return;
+
+	mutex_lock(&tzd->lock);
+	tzd->ops->get_temp = NULL;
+	tzd->ops->get_trend = NULL;
+
+	tz->get_temp = NULL;
+	tz->get_trend = NULL;
+	tz->set_trips = NULL;
+	tz->sensor_data = NULL;
+	mutex_unlock(&tzd->lock);
+}
+EXPORT_SYMBOL_GPL(thermal_zone_of_sensor_unregister);
+
+/***   functions parsing device tree nodes   ***/
+
+/**
+ * thermal_of_populate_bind_params - parse and fill cooling map data
+ * @np: DT node containing a cooling-map node
+ * @__tbp: data structure to be filled with cooling map info
+ * @trips: array of thermal zone trip points
+ * @ntrips: number of trip points inside trips.
+ *
+ * This function parses a cooling-map type of node represented by
+ * @np parameter and fills the read data into @__tbp data structure.
+ * It needs the already parsed array of trip points of the thermal zone
+ * in consideration.
+ *
+ * Return: 0 on success, proper error code otherwise
+ */
+static int thermal_of_populate_bind_params(struct device_node *np,
+					   struct __thermal_bind_params *__tbp,
+					   struct __thermal_trip *trips,
+					   int ntrips)
+{
+	struct of_phandle_args cooling_spec;
+	struct device_node *trip;
+	int ret, i;
+	u32 prop;
+
+	/* Default weight. Usage is optional */
+	__tbp->usage = 0;
+	ret = of_property_read_u32(np, "contribution", &prop);
+	if (ret == 0)
+		__tbp->usage = prop;
+
+	trip = of_parse_phandle(np, "trip", 0);
+	if (!trip) {
+		pr_err("missing trip property\n");
+		return -ENODEV;
+	}
+
+	/* match using device_node */
+	for (i = 0; i < ntrips; i++)
+		if (trip == trips[i].np) {
+			__tbp->trip_id = i;
+			break;
+		}
+
+	if (i == ntrips) {
+		ret = -ENODEV;
+		goto end;
+	}
+
+	ret = of_parse_phandle_with_args(np, "cooling-device", "#cooling-cells",
+					 0, &cooling_spec);
+	if (ret < 0) {
+		pr_err("missing cooling_device property\n");
+		goto end;
+	}
+	__tbp->cooling_device = cooling_spec.np;
+	if (cooling_spec.args_count >= 2) { /* at least min and max */
+		__tbp->min = cooling_spec.args[0];
+		__tbp->max = cooling_spec.args[1];
+	} else {
+		pr_err("wrong reference to cooling device, missing limits\n");
+	}
+
+end:
+	of_node_put(trip);
+
+	return ret;
+}
+
+/**
+ * It maps 'enum thermal_trip_type' found in include/linux/thermal.h
+ * into the device tree binding of 'trip', property type.
+ */
+static const char * const trip_types[] = {
+	[THERMAL_TRIP_ACTIVE]	= "active",
+	[THERMAL_TRIP_PASSIVE]	= "passive",
+	[THERMAL_TRIP_HOT]	= "hot",
+	[THERMAL_TRIP_CRITICAL]	= "critical",
+};
+
+/**
+ * thermal_of_get_trip_type - Get phy mode for given device_node
+ * @np:	Pointer to the given device_node
+ * @type: Pointer to resulting trip type
+ *
+ * The function gets trip type string from property 'type',
+ * and store its index in trip_types table in @type,
+ *
+ * Return: 0 on success, or errno in error case.
+ */
+static int thermal_of_get_trip_type(struct device_node *np,
+				    enum thermal_trip_type *type)
+{
+	const char *t;
+	int err, i;
+
+	err = of_property_read_string(np, "type", &t);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(trip_types); i++)
+		if (!strcasecmp(t, trip_types[i])) {
+			*type = i;
+			return 0;
+		}
+
+	return -ENODEV;
+}
+
+/**
+ * thermal_of_populate_trip - parse and fill one trip point data
+ * @np: DT node containing a trip point node
+ * @trip: trip point data structure to be filled up
+ *
+ * This function parses a trip point type of node represented by
+ * @np parameter and fills the read data into @trip data structure.
+ *
+ * Return: 0 on success, proper error code otherwise
+ */
+static int thermal_of_populate_trip(struct device_node *np,
+				    struct __thermal_trip *trip)
+{
+	int prop;
+	int ret;
+
+	ret = of_property_read_u32(np, "temperature", &prop);
+	if (ret < 0) {
+		pr_err("missing temperature property\n");
+		return ret;
+	}
+	trip->temperature = prop;
+
+	ret = of_property_read_u32(np, "hysteresis", &prop);
+	if (ret < 0) {
+		pr_err("missing hysteresis property\n");
+		return ret;
+	}
+	trip->hysteresis = prop;
+
+	ret = thermal_of_get_trip_type(np, &trip->type);
+	if (ret < 0) {
+		pr_err("wrong trip type property\n");
+		return ret;
+	}
+
+	/* Required for cooling map matching */
+	trip->np = np;
+
+	return 0;
+}
+
+/**
+ * thermal_of_build_thermal_zone - parse and fill one thermal zone data
+ * @np: DT node containing a thermal zone node
+ *
+ * This function parses a thermal zone type of node represented by
+ * @np parameter and fills the read data into a __thermal_zone data structure
+ * and return this pointer.
+ *
+ * TODO: Missing properties to parse: thermal-sensor-names and coefficients
+ *
+ * Return: On success returns a valid struct __thermal_zone,
+ * otherwise, it returns a corresponding ERR_PTR(). Caller must
+ * check the return value with help of IS_ERR() helper.
+ */
+static struct __thermal_zone *
+thermal_of_build_thermal_zone(struct device_node *np)
+{
+	struct device_node *child = NULL, *gchild;
+	struct __thermal_zone *tz;
+	int ret, i;
+	u32 prop;
+
+	if (!np) {
+		pr_err("no thermal zone np\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	tz = kzalloc(sizeof(*tz), GFP_KERNEL);
+	if (!tz)
+		return ERR_PTR(-ENOMEM);
+
+	ret = of_property_read_u32(np, "polling-delay-passive", &prop);
+	if (ret < 0) {
+		pr_err("missing polling-delay-passive property\n");
+		goto free_tz;
+	}
+	tz->passive_delay = prop;
+
+	ret = of_property_read_u32(np, "polling-delay", &prop);
+	if (ret < 0) {
+		pr_err("missing polling-delay property\n");
+		goto free_tz;
+	}
+	tz->polling_delay = prop;
+
+	/* trips */
+	child = of_get_child_by_name(np, "trips");
+
+	tz->prev_high_trip = LONG_MIN;
+	tz->prev_low_trip = LONG_MAX;
+
+	/* No trips provided */
+	if (!child)
+		goto finish;
+
+	tz->ntrips = of_get_child_count(child);
+	if (tz->ntrips == 0) /* must have at least one child */
+		goto finish;
+
+	tz->trips = kzalloc(tz->ntrips * sizeof(*tz->trips), GFP_KERNEL);
+	if (!tz->trips) {
+		ret = -ENOMEM;
+		goto free_tz;
+	}
+
+	i = 0;
+	for_each_child_of_node(child, gchild) {
+		ret = thermal_of_populate_trip(gchild, &tz->trips[i++]);
+		if (ret)
+			goto free_trips;
+	}
+
+	of_node_put(child);
+
+	/* cooling-maps */
+	child = of_get_child_by_name(np, "cooling-maps");
+
+	/* cooling-maps not provided */
+	if (!child)
+		goto finish;
+
+	tz->num_tbps = of_get_child_count(child);
+	if (tz->num_tbps == 0)
+		goto finish;
+
+	tz->tbps = kzalloc(tz->num_tbps * sizeof(*tz->tbps), GFP_KERNEL);
+	if (!tz->tbps) {
+		ret = -ENOMEM;
+		goto free_trips;
+	}
+
+	i = 0;
+	for_each_child_of_node(child, gchild)
+		ret = thermal_of_populate_bind_params(gchild, &tz->tbps[i++],
+						      tz->trips, tz->ntrips);
+		if (ret)
+			goto free_tbps;
+
+finish:
+	of_node_put(child);
+	tz->mode = THERMAL_DEVICE_DISABLED;
+
+	return tz;
+
+free_tbps:
+	kfree(tz->tbps);
+free_trips:
+	kfree(tz->trips);
+free_tz:
+	kfree(tz);
+	of_node_put(child);
+
+	return ERR_PTR(ret);
+}
+
+static inline void of_thermal_free_zone(struct __thermal_zone *tz)
+{
+	kfree(tz->tbps);
+	kfree(tz->trips);
+	kfree(tz);
+}
+
+/**
+ * of_parse_thermal_zones - parse device tree thermal data
+ *
+ * Initialization function that can be called by machine initialization
+ * code to parse thermal data and populate the thermal framework
+ * with hardware thermal zones info. This function only parses thermal zones.
+ * Cooling devices and sensor devices nodes are supposed to be parsed
+ * by their respective drivers.
+ *
+ * Return: 0 on success, proper error code otherwise
+ *
+ */
+int __init of_parse_thermal_zones(void)
+{
+	struct device_node *np, *child;
+	struct __thermal_zone *tz;
+	struct thermal_zone_device_ops *ops;
+
+	np = of_find_node_by_name(NULL, "thermal-zones");
+	if (!np) {
+		pr_debug("unable to find thermal zones\n");
+		return 0; /* Run successfully on systems without thermal DT */
+	}
+
+	for_each_child_of_node(np, child) {
+		struct thermal_zone_device *zone;
+		struct thermal_zone_params *tzp;
+
+		tz = thermal_of_build_thermal_zone(child);
+		if (IS_ERR(tz)) {
+			pr_err("failed to build thermal zone %s: %ld\n",
+			       child->name,
+			       PTR_ERR(tz));
+			continue;
+		}
+
+		ops = kmemdup(&of_thermal_ops, sizeof(*ops), GFP_KERNEL);
+		if (!ops)
+			goto exit_free;
+
+		tzp = kzalloc(sizeof(*tzp), GFP_KERNEL);
+		if (!tzp) {
+			kfree(ops);
+			goto exit_free;
+		}
+
+		/* No hwmon because there might be hwmon drivers registering */
+		tzp->no_hwmon = true;
+
+		zone = thermal_zone_device_register(child->name, tz->ntrips,
+						    0, tz,
+						    ops, tzp,
+						    tz->passive_delay,
+						    tz->polling_delay);
+		if (IS_ERR(zone)) {
+			pr_err("Failed to build %s zone %ld\n", child->name,
+			       PTR_ERR(zone));
+			kfree(tzp);
+			kfree(ops);
+			of_thermal_free_zone(tz);
+			/* attempting to build remaining zones still */
+		}
+
+		zone->np = child;
+	}
+
+	return 0;
+
+exit_free:
+	of_thermal_free_zone(tz);
+
+	/* no memory available, so free what we have built */
+	of_thermal_destroy_zones();
+
+	return -ENOMEM;
+}
+
+/**
+ * of_thermal_destroy_zones - remove all zones parsed and allocated resources
+ *
+ * Finds all zones parsed and added to the thermal framework and remove them
+ * from the system, together with their resources.
+ *
+ */
+void of_thermal_destroy_zones(void)
+{
+	struct device_node *np, *child;
+
+	np = of_find_node_by_name(NULL, "thermal-zones");
+	if (!np) {
+		pr_err("unable to find thermal zones\n");
+		return;
+	}
+
+	for_each_child_of_node(np, child) {
+		struct thermal_zone_device *zone;
+
+		zone = thermal_zone_get_zone_by_node(child);
+		if (IS_ERR(zone))
+			continue;
+
+		thermal_zone_device_unregister(zone);
+		kfree(zone->tzp);
+		kfree(zone->ops);
+		of_thermal_free_zone(zone->devdata);
+	}
+}
diff -Naur -x .git --no-dereference linux/drivers/tty/serial/msm_serial_hs_lite.c linux-3.14/drivers/tty/serial/msm_serial_hs_lite.c
--- linux/drivers/tty/serial/msm_serial_hs_lite.c	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/tty/serial/msm_serial_hs_lite.c	2016-09-01 11:52:05.000000000 +0800
@@ -1762,7 +1762,7 @@
 
 		msm_hsl_port->bus_scale_table = msm_bus_cl_get_pdata(pdev);
 		if (!msm_hsl_port->bus_scale_table) {
-			pr_err("Bus scaling is disabled\n");
+			pr_info("Bus scaling is disabled\n");
 		} else {
 			msm_hsl_port->bus_perf_client =
 				msm_bus_scale_register_client(
diff -Naur -x .git --no-dereference linux/drivers/tty/serial/qca_serial_hs.c linux-3.14/drivers/tty/serial/qca_serial_hs.c
--- linux/drivers/tty/serial/qca_serial_hs.c	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/tty/serial/qca_serial_hs.c	2016-09-01 11:52:05.000000000 +0800
@@ -3,7 +3,7 @@
  * MSM 7k High speed uart driver
  *
  * Copyright (c) 2008 Google Inc.
- * Copyright (c) 2007-2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2007-2014, 2016, The Linux Foundation. All rights reserved.
  * Modified: Nick Pelly <npelly@google.com>
  *
  * All source code in this file is licensed under the following license
@@ -68,9 +68,9 @@
 #define UART_SPS_CONS_PERIPHERAL 0
 #define UART_SPS_PROD_PERIPHERAL 1
 
-static void *ipc_msm_hs_log_ctxt;
 #define IPC_MSM_HS_LOG_PAGES 5
 #define UART_DMA_DESC_NR 8
+#define BUF_DUMP_SIZE 20
 
 /* If the debug_mask gets set to FATAL_LEV,
  * a fatal error has happened and further IPC logging
@@ -84,32 +84,26 @@
 	DBG_LEV = 4U,
 };
 
-/* Default IPC log level INFO */
-static int hs_serial_debug_mask = WARN_LEV;
-module_param_named(debug_mask, hs_serial_debug_mask,
-		   int, S_IRUGO | S_IWUSR | S_IWGRP);
-
 #define MSM_HS_DBG(x...) do { \
-	if (hs_serial_debug_mask >= DBG_LEV) { \
-		pr_debug(x); \
-		if (ipc_msm_hs_log_ctxt) \
-			ipc_log_string(ipc_msm_hs_log_ctxt, x); \
+	if (msm_uport->ipc_debug_mask >= DBG_LEV) { \
+		if (msm_uport->ipc_msm_hs_log_ctxt) \
+			ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
 	} \
 } while (0)
 
 #define MSM_HS_INFO(x...) do { \
-	if (hs_serial_debug_mask >= INFO_LEV) {\
-		pr_info(x); \
-		if (ipc_msm_hs_log_ctxt) \
-			ipc_log_string(ipc_msm_hs_log_ctxt, x); \
+	if (msm_uport->ipc_debug_mask >= INFO_LEV) {\
+		if (msm_uport->ipc_msm_hs_log_ctxt) \
+			ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
 	} \
 } while (0)
 
 /* warnings and errors show up on console always */
 #define MSM_HS_WARN(x...) do { \
 	pr_warn(x); \
-	if (ipc_msm_hs_log_ctxt && hs_serial_debug_mask >= WARN_LEV) \
-		ipc_log_string(ipc_msm_hs_log_ctxt, x); \
+	if (msm_uport->ipc_msm_hs_log_ctxt && \
+			msm_uport->ipc_debug_mask >= WARN_LEV) \
+		ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
 } while (0)
 
 /* ERROR condition in the driver sets the hs_serial_debug_mask
@@ -118,9 +112,10 @@
  */
 #define MSM_HS_ERR(x...) do { \
 	pr_err(x); \
-	if (ipc_msm_hs_log_ctxt && hs_serial_debug_mask >= ERR_LEV) { \
-		ipc_log_string(ipc_msm_hs_log_ctxt, x); \
-		hs_serial_debug_mask = FATAL_LEV; \
+	if (msm_uport->ipc_msm_hs_log_ctxt && \
+			msm_uport->ipc_debug_mask >= ERR_LEV) { \
+		ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
+		msm_uport->ipc_debug_mask = FATAL_LEV; \
 	} \
 } while (0)
 
@@ -219,6 +214,7 @@
 	struct msm_hs_rx rx;
 	atomic_t clk_count;
 	struct msm_hs_wakeup wakeup;
+	struct wakeup_source ws;
 
 	struct dentry *loopback_dir;
 	struct work_struct clock_off_w; /* work for actual clock off */
@@ -247,9 +243,11 @@
 	struct pinctrl_state *gpio_state_suspend;
 	bool flow_control;
 	enum msm_hs_pm_state pm_state;
-	atomic_t ioctl_count;
+	atomic_t client_count;
 	bool obs; /* out of band sleep flag */
 	atomic_t client_req_state;
+	void *ipc_msm_hs_log_ctxt;
+	int ipc_debug_mask;
 };
 
 static struct of_device_id msm_hs_match_table[] = {
@@ -290,26 +288,14 @@
 {
 	int ret = 0, state = 1;
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
-	int ioctl_count = atomic_read(&msm_uport->ioctl_count);
 
 	switch (cmd) {
 	case MSM_ENABLE_UART_CLOCK: {
-		MSM_HS_DBG("%s():ENABLE UART CLOCK: cmd=%d, ioc %d\n", __func__,
-			cmd, ioctl_count);
-		atomic_inc(&msm_uport->ioctl_count);
 		qca_hs_request_clock_on(&msm_uport->uport);
 		break;
 	}
 	case MSM_DISABLE_UART_CLOCK: {
-		MSM_HS_DBG("%s():DISABLE UART CLOCK: cmd=%d ioc %d\n", __func__,
-			cmd, ioctl_count);
-		if (ioctl_count <= 0) {
-			MSM_HS_WARN("%s():ioctl count -ve, client check voting",
-				__func__);
-		} else {
-			atomic_dec(&msm_uport->ioctl_count);
-			qca_hs_request_clock_off(&msm_uport->uport);
-		}
+		qca_hs_request_clock_off(&msm_uport->uport);
 		break;
 	}
 	case MSM_GET_UART_CLOCK_STATUS: {
@@ -319,7 +305,7 @@
 		if (msm_uport->pm_state != MSM_HS_PM_ACTIVE)
 			state = 0;
 		ret = state;
-		MSM_HS_DBG("%s():GET UART CLOCK STATUS: cmd=%d state=%d\n",
+		MSM_HS_INFO("%s():GET UART CLOCK STATUS: cmd=%d state=%d\n",
 			__func__, cmd, state);
 		break;
 	}
@@ -416,7 +402,7 @@
 
 	if ((!msm_uport) || (msm_uport->uport.line != pdev->id
 	   && msm_uport->uport.line != pdata->userid)) {
-		MSM_HS_ERR("uport line number mismatch!");
+		pr_err("uport line number mismatch!");
 		WARN_ON(1);
 		return NULL;
 	}
@@ -456,10 +442,12 @@
 		state = buf[0] - '0';
 		switch (state) {
 		case 0:
+			MSM_HS_DBG("%s: Request clock OFF\n", __func__);
 			qca_hs_request_clock_off(&msm_uport->uport);
 			ret = count;
 			break;
 		case 1:
+			MSM_HS_DBG("%s: Request clock ON\n", __func__);
 			qca_hs_request_clock_on(&msm_uport->uport);
 			ret = count;
 			break;
@@ -472,6 +460,46 @@
 
 static DEVICE_ATTR(clock, S_IWUSR | S_IRUGO, show_clock, set_clock);
 
+static ssize_t show_debug_mask(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct platform_device *pdev = container_of(dev, struct
+						    platform_device, dev);
+	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
+
+	/* This check should not fail */
+	if (msm_uport)
+		ret = snprintf(buf, sizeof(int), "%u\n",
+					msm_uport->ipc_debug_mask);
+	return ret;
+}
+
+static ssize_t set_debug_mask(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct platform_device *pdev = container_of(dev, struct
+						    platform_device, dev);
+	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
+
+	/* This check should not fail */
+	if (msm_uport) {
+		msm_uport->ipc_debug_mask = buf[0] - '0';
+		if (msm_uport->ipc_debug_mask < FATAL_LEV ||
+				msm_uport->ipc_debug_mask > DBG_LEV) {
+			/* set to default level */
+			msm_uport->ipc_debug_mask = INFO_LEV;
+			MSM_HS_ERR("Range is 0 to 4;Set to default level 3\n");
+			return -EINVAL;
+		}
+	}
+	return count;
+}
+
+static DEVICE_ATTR(debug_mask, S_IWUSR | S_IRUGO, show_debug_mask,
+							set_debug_mask);
+
 static inline bool is_use_low_power_wakeup(struct msm_hs_port *msm_uport)
 {
 	return msm_uport->wakeup.irq > 0;
@@ -522,12 +550,13 @@
 	return sps_disconnect(sps_pipe_handler);
 }
 
-static void hex_dump_ipc(char *prefix, char *string, int size)
+static void hex_dump_ipc(struct msm_hs_port *msm_uport,
+			char *prefix, char *string, int size)
 {
 	unsigned char linebuf[512];
 	unsigned char firstbuf[40], lastbuf[40];
 
-	if ((hs_serial_debug_mask != DBG_LEV) && (size > 20)) {
+	if ((msm_uport->ipc_debug_mask != DBG_LEV) && (size > BUF_DUMP_SIZE)) {
 		hex_dump_to_buffer(string, 10, 16, 1,
 				firstbuf, sizeof(firstbuf), 1);
 		hex_dump_to_buffer(string + (size - 10), 10, 16, 1,
@@ -655,7 +684,7 @@
 	struct device *dev;
 
 	if (pdev->id < 0 || pdev->id >= UARTDM_NR) {
-		MSM_HS_ERR("Invalid plaform device ID = %d\n", pdev->id);
+		pr_err("Invalid plaform device ID = %d\n", pdev->id);
 		return -EINVAL;
 	}
 
@@ -665,6 +694,7 @@
 
 	dev = msm_uport->uport.dev;
 	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_clock.attr);
+	sysfs_remove_file(&pdev->dev.kobj, &dev_attr_debug_mask.attr);
 	debugfs_remove(msm_uport->loopback_dir);
 
 	dma_free_coherent(msm_uport->uport.dev,
@@ -674,6 +704,7 @@
 	msm_uport->rx.buffer = NULL;
 	msm_uport->rx.rbuffer = 0;
 
+	wakeup_source_trash(&msm_uport->ws);
 	destroy_workqueue(msm_uport->hsuart_wq);
 	mutex_destroy(&msm_uport->mtx);
 
@@ -884,6 +915,7 @@
 	case 3500000:
 	case 3000000:
 	case 2500000:
+	case 2000000:
 	case 1500000:
 	case 1152000:
 	case 1000000:
@@ -988,12 +1020,12 @@
 	qca_hs_write(uport, UART_DM_IPR, data);
 }
 
-static void qca_hs_enable_flow_control(struct uart_port *uport)
+static void qca_hs_enable_flow_control(struct uart_port *uport, bool override)
 {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
 	unsigned int data;
 
-	if (msm_uport->flow_control) {
+	if (msm_uport->flow_control || override) {
 		/* Enable RFR line */
 		qca_hs_write(uport, UART_DM_CR, RFR_LOW);
 		/* Enable auto RFR */
@@ -1005,7 +1037,7 @@
 	}
 }
 
-static void qca_hs_disable_flow_control(struct uart_port *uport)
+static void qca_hs_disable_flow_control(struct uart_port *uport, bool override)
 {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
 	unsigned int data;
@@ -1016,7 +1048,7 @@
 	 * data while we change the parameters
 	 */
 
-	if (msm_uport->flow_control) {
+	if (msm_uport->flow_control || override) {
 		data = qca_hs_read(uport, UART_DM_MR1);
 		/* disable auto ready-for-receiving */
 		data &= ~UARTDM_MR1_RX_RDY_CTL_BMSK;
@@ -1040,10 +1072,8 @@
 {
 	unsigned int bps;
 	unsigned long data;
-	int ret;
 	unsigned int c_cflag = termios->c_cflag;
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
-	struct msm_hs_rx *rx = &msm_uport->rx;
 
 	/**
 	 * set_termios can be invoked from the framework when
@@ -1055,8 +1085,7 @@
 	qca_hs_write(uport, UART_DM_IMR, 0);
 
 	MSM_HS_DBG("Entering %s\n", __func__);
-
-	qca_hs_disable_flow_control(uport);
+	qca_hs_disable_flow_control(uport, true);
 
 	/*
 	 * Disable Rx channel of UARTDM
@@ -1070,9 +1099,16 @@
 	data = qca_hs_read(uport, UART_DM_DMEN);
 	/* Disable UARTDM RX BAM Interface */
 	data &= ~UARTDM_RX_BAM_ENABLE_BMSK;
-
 	qca_hs_write(uport, UART_DM_DMEN, data);
 
+	/*
+	 * Reset RX and TX.
+	 * Resetting the RX enables it, therefore we must reset and disable.
+	 */
+	qca_hs_write(uport, UART_DM_CR, RESET_RX);
+	qca_hs_write(uport, UART_DM_CR, UARTDM_CR_RX_DISABLE_BMSK);
+	qca_hs_write(uport, UART_DM_CR, RESET_TX);
+
 	/* 300 is the minimum baud support by the driver  */
 	bps = uart_get_baud_rate(uport, termios, oldtermios, 200, 4000000);
 
@@ -1132,35 +1168,19 @@
 
 	uport->read_status_mask = (termios->c_cflag & CREAD);
 
-
 	/* Set Transmit software time out */
 	uart_update_timeout(uport, c_cflag, bps);
 
-	qca_hs_write(uport, UART_DM_CR, RESET_RX);
-	qca_hs_write(uport, UART_DM_CR, RESET_TX);
-	/* Issue TX BAM Start IFC command */
+	/* Enable UARTDM Rx BAM Interface */
+	data = qca_hs_read(uport, UART_DM_DMEN);
+	data |= UARTDM_RX_BAM_ENABLE_BMSK;
+	qca_hs_write(uport, UART_DM_DMEN, data);
+	qca_hs_write(uport, UART_DM_CR, UARTDM_CR_RX_EN_BMSK);
+	/* Issue TX,RX BAM Start IFC command */
 	qca_hs_write(uport, UART_DM_CR, START_TX_BAM_IFC);
-
-	if (msm_uport->rx.flush == FLUSH_NONE) {
-		flush_kthread_worker(&msm_uport->rx.kworker);
-		msm_uport->rx.flush = FLUSH_DATA_INVALID;
-		/* Ensure register IO completion */
-		mb();
-		if (msm_uport->rx_bam_inprogress)
-			ret = wait_event_timeout(msm_uport->rx.wait,
-				msm_uport->rx_bam_inprogress == false,
-				RX_FLUSH_COMPLETE_TIMEOUT);
-		ret = disconnect_rx_endpoint(msm_uport);
-		if (ret)
-			MSM_HS_ERR("%s(): sps_disconnect failed\n", __func__);
-		if (msm_uport->rx.pending_flag)
-			MSM_HS_WARN("%s(): buffers may be pending 0x%lx",
-				__func__, msm_uport->rx.pending_flag);
-		MSM_HS_DBG("%s(): clearing desc usage flag", __func__);
-		qca_hs_spsconnect_rx(uport);
-		msm_uport->rx.flush = FLUSH_IGNORE;
-		qca_serial_hs_rx_work(&rx->kwork);
-	}
+	qca_hs_write(uport, UART_DM_CR, START_RX_BAM_IFC);
+	/* Ensure Register Writes Complete */
+	mb();
 
 	/* Configure HW flow control
 	 * UART Core would see status of CTS line when it is sending data
@@ -1179,9 +1199,6 @@
 	}
 	qca_hs_write(uport, UART_DM_MR1, data);
 
-	qca_hs_write(uport, UART_DM_IMR, msm_uport->imr_reg);
-	/* Ensure register IO completion */
-	mb();
 	mutex_unlock(&msm_uport->mtx);
 
 	MSM_HS_DBG("Exit %s\n", __func__);
@@ -1353,12 +1370,11 @@
 	int ret;
 
 	if (uart_circ_empty(tx_buf) || uport->state->port.tty->stopped) {
+		tx->dma_in_flight = false;
 		qca_hs_stop_tx_locked(uport);
 		return;
 	}
 
-	tx->dma_in_flight = true;
-
 	tx_count = uart_circ_chars_pending(tx_buf);
 
 	if (UARTDM_TX_BUF_SIZE < tx_count)
@@ -1369,7 +1385,9 @@
 	if (tx_count > left)
 		tx_count = left;
 	MSM_HS_INFO("%s(): [UART_TX]<%d>\n", __func__, tx_count);
-	hex_dump_ipc("HSUART write: ", &tx_buf->buf[tx_buf->tail], tx_count);
+	hex_dump_ipc(msm_uport, "HSUART write: ",
+		&tx_buf->buf[tx_buf->tail], tx_count);
+
 	src_addr = tx->dma_base + tx_buf->tail;
 	/* Mask the src_addr to align on a cache
 	 * and add those bytes to tx_count */
@@ -1685,10 +1703,10 @@
 		rx_count = msm_uport->rx.iovec[msm_uport->rx.rx_inx].size;
 
 		MSM_HS_INFO("%s():[UART_RX]<%d>\n", __func__, rx_count);
-		hex_dump_ipc("HSUART Read: ",
-			(msm_uport->rx.buffer +
-			(msm_uport->rx.rx_inx * UARTDM_RX_BUF_SIZE)),
-			rx_count);
+		hex_dump_ipc(msm_uport, "HSUART Read: ",
+				(msm_uport->rx.buffer +
+				(msm_uport->rx.rx_inx * UARTDM_RX_BUF_SIZE)),
+				rx_count);
 
 		 /*
 		  * We are in a spin locked context, spin lock taken at
@@ -1788,14 +1806,15 @@
 	struct msm_hs_port *msm_uport =
 		(struct msm_hs_port *)
 		((struct sps_event_notify *)notify)->user;
+	phys_addr_t addr = DESC_FULL_ADDR(notify->data.transfer.iovec.flags,
+		notify->data.transfer.iovec.addr);
 
 	msm_uport->notify = *notify;
-	MSM_HS_DBG("%s: ev_id=%d, addr=0x%x, size=0x%x, flags=0x%x, line=%d\n",
-		 __func__, notify->event_id,
-	notify->data.transfer.iovec.addr,
-	notify->data.transfer.iovec.size,
-	notify->data.transfer.iovec.flags,
-	msm_uport->uport.line);
+	MSM_HS_DBG("%s: ev_id=%d, addr=0x%pa, size=0x%x, flags=0x%x, line=%d\n",
+		 __func__, notify->event_id, &addr,
+		notify->data.transfer.iovec.size,
+		notify->data.transfer.iovec.flags,
+		msm_uport->uport.line);
 
 	del_timer(&msm_uport->tx.tx_timeout_timer);
 	MSM_HS_DBG("%s(): Queue kthread work", __func__);
@@ -1834,7 +1853,6 @@
 	else
 		MSM_HS_DBG("%s:circ buffer is empty\n", __func__);
 
-	tx->dma_in_flight = false;
 	wake_up(&msm_uport->tx.wait);
 
 	uport->icount.tx += tx->tx_count;
@@ -1860,8 +1878,10 @@
 			struct sps_event_notify *notify)
 {
 	struct msm_hs_rx *rx = &msm_uport->rx;
+	phys_addr_t addr = DESC_FULL_ADDR(notify->data.transfer.iovec.flags,
+		notify->data.transfer.iovec.addr);
 	/* divide by UARTDM_RX_BUF_SIZE */
-	int inx = (notify->data.transfer.iovec.addr - rx->rbuffer) >> 9;
+	int inx = (addr - rx->rbuffer) >> 9;
 
 	set_bit(inx, &rx->pending_flag);
 	clear_bit(inx, &rx->queued_flag);
@@ -1888,14 +1908,15 @@
 	struct uart_port *uport;
 	unsigned long flags;
 	struct msm_hs_rx *rx = &msm_uport->rx;
+	phys_addr_t addr = DESC_FULL_ADDR(notify->data.transfer.iovec.flags,
+		notify->data.transfer.iovec.addr);
 	/* divide by UARTDM_RX_BUF_SIZE */
-	int inx = (notify->data.transfer.iovec.addr - rx->rbuffer) >> 9;
+	int inx = (addr - rx->rbuffer) >> 9;
 
 	uport = &(msm_uport->uport);
 	msm_uport->notify = *notify;
-	MSM_HS_DBG("\n%s: sps ev_id=%d, addr=0x%x, size=0x%x, flags=0x%x\n",
-		__func__, notify->event_id,
-		notify->data.transfer.iovec.addr,
+	MSM_HS_DBG("\n%s: sps ev_id=%d, addr=0x%pa, size=0x%x, flags=0x%x\n",
+		__func__, notify->event_id, &addr,
 		notify->data.transfer.iovec.size,
 		notify->data.transfer.iovec.flags);
 
@@ -1957,9 +1978,9 @@
 	set_rts = TIOCM_RTS & mctrl ? 0 : 1;
 
 	if (set_rts)
-		qca_hs_disable_flow_control(uport);
+		qca_hs_disable_flow_control(uport, false);
 	else
-		qca_hs_enable_flow_control(uport);
+		qca_hs_enable_flow_control(uport, false);
 }
 
 void qca_hs_set_mctrl(struct uart_port *uport,
@@ -2160,11 +2181,11 @@
 		return;
 
 	if (!(msm_uport->wakeup.enabled)) {
-		spin_lock_irqsave(&uport->lock, flags);
-		msm_uport->wakeup.ignore = 1;
 		MSM_HS_DBG("%s(): Enable Wakeup IRQ", __func__);
 		enable_irq(msm_uport->wakeup.irq);
 		disable_irq(uport->irq);
+		spin_lock_irqsave(&uport->lock, flags);
+		msm_uport->wakeup.ignore = 1;
 		msm_uport->wakeup.enabled = true;
 		spin_unlock_irqrestore(&uport->lock, flags);
 	} else {
@@ -2183,7 +2204,7 @@
 	unsigned int data;
 
 	MSM_HS_DBG("%s(): begin", __func__);
-	qca_hs_disable_flow_control(uport);
+	qca_hs_disable_flow_control(uport, false);
 	if (msm_uport->rx.flush == FLUSH_NONE)
 		qca_hs_disconnect_rx(uport);
 
@@ -2199,7 +2220,7 @@
 		sps_tx_disconnect(msm_uport);
 	}
 	if (!atomic_read(&msm_uport->client_req_state))
-		qca_hs_enable_flow_control(uport);
+		qca_hs_enable_flow_control(uport, false);
 }
 
 void qca_hs_resource_on(struct msm_hs_port *msm_uport)
@@ -2229,16 +2250,31 @@
 void qca_hs_request_clock_off(struct uart_port *uport)
 {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
+
+	if (atomic_read(&msm_uport->client_count) <= 0) {
+		MSM_HS_WARN("%s(): ioctl count -ve, client check voting",
+			__func__);
+		return;
+	}
 	/* Set the flag to disable flow control and wakeup irq */
 	if (msm_uport->obs)
 		atomic_set(&msm_uport->client_req_state, 1);
 	qca_hs_resource_unvote(msm_uport);
+	atomic_dec(&msm_uport->client_count);
+	MSM_HS_INFO("%s():DISABLE UART CLOCK: ioc %d\n",
+			__func__, atomic_read(&msm_uport->client_count));
 }
 EXPORT_SYMBOL(qca_hs_request_clock_off);
 
 void qca_hs_request_clock_on(struct uart_port *uport)
 {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
+	int client_count;
+
+	atomic_inc(&msm_uport->client_count);
+	client_count = atomic_read(&msm_uport->client_count);
+	MSM_HS_INFO("%s():ENABLE UART CLOCK: ioc %d\n",
+		__func__, client_count);
 	qca_hs_resource_vote(UARTDM_TO_MSM(uport));
 
 	/* Clear the flag */
@@ -2302,8 +2338,16 @@
 	struct platform_device *pdev = to_platform_device(uport->dev);
 	const struct msm_serial_hs_platform_data *pdata =
 					pdev->dev.platform_data;
+	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
+	int ret;
 
-	if (pdata) {
+	if (msm_uport->use_pinctrl) {
+		ret = pinctrl_select_state(msm_uport->pinctrl,
+				msm_uport->gpio_state_suspend);
+		if (ret)
+			MSM_HS_ERR("%s(): Failed to pinctrl set_state",
+				__func__);
+	} else if (pdata) {
 		if (gpio_is_valid(pdata->uart_tx_gpio))
 			gpio_free(pdata->uart_tx_gpio);
 		if (gpio_is_valid(pdata->uart_rx_gpio))
@@ -2464,10 +2508,32 @@
 	/* turn on uart clk */
 	qca_hs_resource_vote(msm_uport);
 
+	if (is_use_low_power_wakeup(msm_uport)) {
+		ret = request_threaded_irq(msm_uport->wakeup.irq, NULL,
+					qca_hs_wakeup_isr,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"qca_hs_wakeup", msm_uport);
+		if (unlikely(ret)) {
+			MSM_HS_ERR("%s():Err getting uart wakeup_irq %d\n",
+				  __func__, ret);
+			goto unvote_exit;
+		}
+
+		msm_uport->wakeup.freed = false;
+		disable_irq(msm_uport->wakeup.irq);
+		msm_uport->wakeup.enabled = false;
+
+		ret = irq_set_irq_wake(msm_uport->wakeup.irq, 1);
+		if (unlikely(ret)) {
+			MSM_HS_ERR("%s():Err setting wakeup irq\n", __func__);
+			goto free_uart_irq;
+		}
+	}
+
 	ret = qca_hs_config_uart_gpios(uport);
 	if (ret) {
 		MSM_HS_ERR("Uart GPIO request failed\n");
-		goto deinit_uart_clk;
+		goto deinit_ws;
 	}
 
 	qca_hs_write(uport, UART_DM_DMEN, 0);
@@ -2512,6 +2578,8 @@
 
 	/* Assume no flow control, unless termios sets it */
 	msm_uport->flow_control = false;
+	qca_hs_disable_flow_control(uport, true);
+
 
 	/* Reset TX */
 	qca_hs_write(uport, UART_DM_CR, RESET_TX);
@@ -2547,33 +2615,13 @@
 	ret = request_irq(uport->irq, qca_hs_isr, IRQF_TRIGGER_HIGH,
 			  "msm_hs_uart", msm_uport);
 	if (unlikely(ret)) {
-		MSM_HS_ERR("%s():Error getting uart irq\n", __func__);
+		MSM_HS_ERR("%s():Error %d getting uart irq\n", __func__, ret);
 		goto sps_disconnect_rx;
 	}
-	if (is_use_low_power_wakeup(msm_uport)) {
-		ret = request_threaded_irq(msm_uport->wakeup.irq, NULL,
-					qca_hs_wakeup_isr,
-					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-					"msm_hs_wakeup", msm_uport);
-		if (unlikely(ret)) {
-			MSM_HS_ERR("%s():Err getting uart wakeup_irq\n",
-				  __func__);
-			goto free_uart_irq;
-		}
 
-		msm_uport->wakeup.freed = false;
-		disable_irq(msm_uport->wakeup.irq);
-		msm_uport->wakeup.enabled = false;
-
-		ret = irq_set_irq_wake(msm_uport->wakeup.irq, 1);
-		if (unlikely(ret)) {
-			MSM_HS_ERR("%s():Err setting wakeup irq\n", __func__);
-			goto free_uart_irq;
-		}
-	}
 
 	spin_lock_irqsave(&uport->lock, flags);
-	atomic_set(&msm_uport->ioctl_count, 0);
+	atomic_set(&msm_uport->client_count, 0);
 	atomic_set(&msm_uport->client_req_state, 0);
 	qca_hs_start_rx_locked(uport);
 
@@ -2582,15 +2630,17 @@
 	qca_hs_resource_unvote(msm_uport);
 	return 0;
 
-free_uart_irq:
-	free_irq(uport->irq, msm_uport);
 sps_disconnect_rx:
 	sps_disconnect(sps_pipe_handle_rx);
 sps_disconnect_tx:
 	sps_disconnect(sps_pipe_handle_tx);
 unconfig_uart_gpios:
 	qca_hs_unconfig_uart_gpios(uport);
-deinit_uart_clk:
+deinit_ws:
+	wakeup_source_trash(&msm_uport->ws);
+free_uart_irq:
+	free_irq(uport->irq, msm_uport);
+unvote_exit:
 	qca_hs_resource_unvote(msm_uport);
 	MSM_HS_ERR("%s(): Error return\n", __func__);
 	return ret;
@@ -2664,7 +2714,7 @@
 
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata) {
-		MSM_HS_ERR("unable to allocate memory for platform data\n");
+		pr_err("unable to allocate memory for platform data\n");
 		return ERR_PTR(-ENOMEM);
 	}
 
@@ -2673,25 +2723,25 @@
 	pdata->uart_tx_gpio = of_get_named_gpio(node,
 					"qcom,tx-gpio", 0);
 	if (pdata->uart_tx_gpio < 0)
-		MSM_HS_DBG("uart_tx_gpio is not available\n");
+		pr_err("uart_tx_gpio is not available\n");
 
 	/* UART RX GPIO */
 	pdata->uart_rx_gpio = of_get_named_gpio(node,
 					"qcom,rx-gpio", 0);
 	if (pdata->uart_rx_gpio < 0)
-		MSM_HS_DBG("uart_rx_gpio is not available\n");
+		pr_err("uart_rx_gpio is not available\n");
 
 	/* UART CTS GPIO */
 	pdata->uart_cts_gpio = of_get_named_gpio(node,
 					"qcom,cts-gpio", 0);
 	if (pdata->uart_cts_gpio < 0)
-		MSM_HS_DBG("uart_cts_gpio is not available\n");
+		pr_err("uart_cts_gpio is not available\n");
 
 	/* UART RFR GPIO */
 	pdata->uart_rfr_gpio = of_get_named_gpio(node,
 					"qcom,rfr-gpio", 0);
 	if (pdata->uart_rfr_gpio < 0)
-		MSM_HS_DBG("uart_rfr_gpio is not available\n");
+		pr_err("uart_rfr_gpio is not available\n");
 
 	pdata->no_suspend_delay = of_property_read_bool(node,
 				"qcom,no-suspend-delay");
@@ -2699,7 +2749,7 @@
 	pdata->obs = of_property_read_bool(node,
 				"qcom,msm-obs");
 	if (pdata->obs)
-		MSM_HS_DBG("%s:Out of Band sleep flag is set\n", __func__);
+		pr_err("%s:Out of Band sleep flag is set\n", __func__);
 
 	pdata->inject_rx_on_wakeup = of_property_read_bool(node,
 				"qcom,inject-rx-on-wakeup");
@@ -2708,7 +2758,7 @@
 		ret = of_property_read_u32(node, "qcom,rx-char-to-inject",
 						&rx_to_inject);
 		if (ret < 0) {
-			MSM_HS_ERR("Error: Rx_char_to_inject not specified.\n");
+			pr_err("Error: Rx_char_to_inject not specified.\n");
 			return ERR_PTR(ret);
 		}
 		pdata->rx_to_inject = (u8)rx_to_inject;
@@ -2717,30 +2767,30 @@
 	ret = of_property_read_u32(node, "qcom,bam-tx-ep-pipe-index",
 				&pdata->bam_tx_ep_pipe_index);
 	if (ret < 0) {
-		MSM_HS_ERR("Error: Getting UART BAM TX EP Pipe Index.\n");
+		pr_err("Error: Getting UART BAM TX EP Pipe Index.\n");
 		return ERR_PTR(ret);
 	}
 
 	if (!(pdata->bam_tx_ep_pipe_index >= BAM_PIPE_MIN &&
 		pdata->bam_tx_ep_pipe_index <= BAM_PIPE_MAX)) {
-		MSM_HS_ERR("Error: Invalid UART BAM TX EP Pipe Index.\n");
+		pr_err("Error: Invalid UART BAM TX EP Pipe Index.\n");
 		return ERR_PTR(-EINVAL);
 	}
 
 	ret = of_property_read_u32(node, "qcom,bam-rx-ep-pipe-index",
 					&pdata->bam_rx_ep_pipe_index);
 	if (ret < 0) {
-		MSM_HS_ERR("Error: Getting UART BAM RX EP Pipe Index.\n");
+		pr_err("Error: Getting UART BAM RX EP Pipe Index.\n");
 		return ERR_PTR(ret);
 	}
 
 	if (!(pdata->bam_rx_ep_pipe_index >= BAM_PIPE_MIN &&
 		pdata->bam_rx_ep_pipe_index <= BAM_PIPE_MAX)) {
-		MSM_HS_ERR("Error: Invalid UART BAM RX EP Pipe Index.\n");
+		pr_err("Error: Invalid UART BAM RX EP Pipe Index.\n");
 		return ERR_PTR(-EINVAL);
 	}
 
-	MSM_HS_DBG("tx_ep_pipe_index:%d rx_ep_pipe_index:%d\n"
+	pr_debug("tx_ep_pipe_index:%d rx_ep_pipe_index:%d\n"
 		"tx_gpio:%d rx_gpio:%d rfr_gpio:%d cts_gpio:%d",
 		pdata->bam_tx_ep_pipe_index, pdata->bam_rx_ep_pipe_index,
 		pdata->uart_tx_gpio, pdata->uart_rx_gpio, pdata->uart_cts_gpio,
@@ -3012,14 +3062,15 @@
 	}
 
 	if (pdev->id < 0 || pdev->id >= UARTDM_NR) {
-		MSM_HS_ERR("Invalid plaform device ID = %d\n", pdev->id);
+		dev_err(&pdev->dev, "Invalid plaform device ID = %d\n",
+								pdev->id);
 		return -EINVAL;
 	}
 
 	msm_uport = devm_kzalloc(&pdev->dev, sizeof(struct msm_hs_port),
 			GFP_KERNEL);
 	if (!msm_uport) {
-		MSM_HS_ERR("Memory allocation failed\n");
+		dev_err(&pdev->dev, "Memory allocation failed\n");
 		return -ENOMEM;
 	}
 
@@ -3035,29 +3086,31 @@
 	core_resource = platform_get_resource_byname(pdev,
 				IORESOURCE_MEM, "core_mem");
 	if (!core_resource) {
-		MSM_HS_ERR("Invalid core HSUART Resources.\n");
+		dev_err(&pdev->dev, "Invalid core HSUART Resources.\n");
 		return -ENXIO;
 	}
 	bam_resource = platform_get_resource_byname(pdev,
 				IORESOURCE_MEM, "bam_mem");
 	if (!bam_resource) {
-		MSM_HS_ERR("Invalid BAM HSUART Resources.\n");
+		dev_err(&pdev->dev, "Invalid BAM HSUART Resources.\n");
 		return -ENXIO;
 	}
 	core_irqres = platform_get_irq_byname(pdev, "core_irq");
 	if (core_irqres < 0) {
-		MSM_HS_ERR("Invalid core irqres Resources.\n");
+		dev_err(&pdev->dev, "Error %d, invalid core irq resources.\n",
+			core_irqres);
 		return -ENXIO;
 	}
 	bam_irqres = platform_get_irq_byname(pdev, "bam_irq");
 	if (bam_irqres < 0) {
-		MSM_HS_ERR("Invalid bam irqres Resources.\n");
+		dev_err(&pdev->dev, "Error %d, invalid bam irq resources.\n",
+			bam_irqres);
 		return -ENXIO;
 	}
 	wakeup_irqres = platform_get_irq_byname(pdev, "wakeup_irq");
 	if (wakeup_irqres < 0) {
 		wakeup_irqres = -1;
-		MSM_HS_DBG("Wakeup irq not specified.\n");
+		pr_info("Wakeup irq not specified.\n");
 	}
 
 	uport->mapbase = core_resource->start;
@@ -3065,17 +3118,34 @@
 	uport->membase = ioremap(uport->mapbase,
 				resource_size(core_resource));
 	if (unlikely(!uport->membase)) {
-		MSM_HS_ERR("UART Resource ioremap Failed.\n");
+		dev_err(&pdev->dev, "UART Resource ioremap Failed.\n");
 		return -ENOMEM;
 	}
 	msm_uport->bam_mem = bam_resource->start;
 	msm_uport->bam_base = ioremap(msm_uport->bam_mem,
 				resource_size(bam_resource));
 	if (unlikely(!msm_uport->bam_base)) {
-		MSM_HS_ERR("UART BAM Resource ioremap Failed.\n");
+		dev_err(&pdev->dev, "UART BAM Resource ioremap Failed.\n");
 		iounmap(uport->membase);
 		return -ENOMEM;
 	}
+	msm_uport->ipc_msm_hs_log_ctxt =
+			ipc_log_context_create(IPC_MSM_HS_LOG_PAGES,
+					dev_name(msm_uport->uport.dev), 0);
+	pr_debug("%s: Device name is %s\n", __func__,
+				dev_name(msm_uport->uport.dev));
+	if (!msm_uport->ipc_msm_hs_log_ctxt) {
+#if defined(CONFIG_IPC_LOGGING)
+		dev_err(&pdev->dev, "%s: error creating logging context",
+								__func__);
+#endif
+	} else {
+		msm_uport->ipc_debug_mask = INFO_LEV;
+		ret = sysfs_create_file(&pdev->dev.kobj,
+				&dev_attr_debug_mask.attr);
+		if (unlikely(ret))
+			MSM_HS_WARN("%s: Failed to create dev. attr", __func__);
+	}
 
 	uport->irq = core_irqres;
 	msm_uport->bam_irq = bam_irqres;
@@ -3191,6 +3261,7 @@
 		uport->line = pdata->userid;
 	ret = uart_add_one_port(&msm_hs_driver, uport);
 	if (!ret) {
+		wakeup_source_init(&msm_uport->ws, dev_name(&pdev->dev));
 		return ret;
 	}
 
@@ -3221,30 +3292,24 @@
 {
 	int ret;
 
-	ipc_msm_hs_log_ctxt = ipc_log_context_create(IPC_MSM_HS_LOG_PAGES,
-							"qca_serial_hs", 0);
-#if defined(CONFIG_IPC_LOGGING)
-	if (!ipc_msm_hs_log_ctxt)
-		MSM_HS_WARN("%s: error creating logging context", __func__);
-#endif
 	ret = uart_register_driver(&msm_hs_driver);
 	if (unlikely(ret)) {
-		MSM_HS_ERR("%s failed to load\n", __func__);
+		pr_err("%s failed to load\n", __func__);
 		return ret;
 	}
 	debug_base = debugfs_create_dir("qca_serial_hs", NULL);
 	if (IS_ERR_OR_NULL(debug_base))
-		pr_info("qca_serial_hs: Cannot create debugfs dir\n");
+		pr_err("qca_serial_hs: Cannot create debugfs dir\n");
 
 	ret = platform_driver_register(&msm_serial_hs_platform_driver);
 	if (ret) {
-		MSM_HS_ERR("%s failed to load\n", __func__);
+		pr_err("%s failed to load\n", __func__);
 		debugfs_remove_recursive(debug_base);
 		uart_unregister_driver(&msm_hs_driver);
 		return ret;
 	}
 
-	MSM_HS_INFO("qca_serial_hs module loaded\n");
+	pr_info("qca_serial_hs module loaded\n");
 	return ret;
 }
 
@@ -3259,6 +3324,7 @@
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
 	struct circ_buf *tx_buf = &uport->state->xmit;
 	int data;
+	unsigned long flags;
 
 	if (is_use_low_power_wakeup(msm_uport))
 		irq_set_irq_wake(msm_uport->wakeup.irq, 0);
@@ -3268,7 +3334,19 @@
 	else
 		disable_irq(uport->irq);
 
+	spin_lock_irqsave(&uport->lock, flags);
 	msm_uport->wakeup.enabled = false;
+	msm_uport->wakeup.ignore = 1;
+	spin_unlock_irqrestore(&uport->lock, flags);
+
+	/* Free the interrupt */
+	free_irq(uport->irq, msm_uport);
+	if (is_use_low_power_wakeup(msm_uport)) {
+		free_irq(msm_uport->wakeup.irq, msm_uport);
+		MSM_HS_DBG("%s(): wakeup irq freed", __func__);
+	}
+	msm_uport->wakeup.freed = true;
+
 	/* make sure tx lh finishes */
 	flush_kthread_worker(&msm_uport->tx.kworker);
 	ret = wait_event_timeout(msm_uport->tx.wait,
@@ -3278,7 +3356,7 @@
 
 	qca_hs_resource_vote(msm_uport);
 	/* Stop remote side from sending data */
-	qca_hs_disable_flow_control(uport);
+	qca_hs_disable_flow_control(uport, false);
 	/* make sure rx lh finishes */
 	flush_kthread_worker(&msm_uport->rx.kworker);
 
@@ -3334,20 +3412,13 @@
 		MSM_HS_WARN("%s: Client clock vote imbalance\n", __func__);
 		atomic_set(&msm_uport->client_req_state, 0);
 	}
-	/* Free the interrupt */
-	free_irq(uport->irq, msm_uport);
-	if (is_use_low_power_wakeup(msm_uport)) {
-		free_irq(msm_uport->wakeup.irq, msm_uport);
-		MSM_HS_DBG("%s(): wakeup irq freed", __func__);
-	}
-	msm_uport->wakeup.freed = true;
-
 	qca_hs_unconfig_uart_gpios(uport);
+	MSM_HS_INFO("%s:UART port closed successfully\n", __func__);
 }
 
 static void __exit qca_serial_hs_exit(void)
 {
-	MSM_HS_INFO("qca_serial_hs module removed\n");
+	pr_info("qca_serial_hs module removed\n");
 	debugfs_remove_recursive(debug_base);
 	platform_driver_unregister(&msm_serial_hs_platform_driver);
 	uart_unregister_driver(&msm_hs_driver);
diff -Naur -x .git --no-dereference linux/drivers/video/msm/Kconfig linux-3.14/drivers/video/msm/Kconfig
--- linux/drivers/video/msm/Kconfig	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/video/msm/Kconfig	2016-09-01 11:52:05.000000000 +0800
@@ -8,6 +8,7 @@
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	select FB_SYS_FOPS
+	select FB_DEFERRED_IO
 	select SYNC
 	select SW_SYNC
 	---help---
diff -Naur -x .git --no-dereference linux/drivers/video/msm/mdss/mdss_fb.c linux-3.14/drivers/video/msm/mdss/mdss_fb.c
--- linux/drivers/video/msm/mdss/mdss_fb.c	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/video/msm/mdss/mdss_fb.c	2016-09-01 11:52:05.000000000 +0800
@@ -83,6 +83,7 @@
 };
 
 static struct msm_mdp_interface *mdp_instance;
+static struct fb_deferred_io mdss_fb_defio;
 
 static int mdss_fb_register(struct msm_fb_data_type *mfd);
 static int mdss_fb_open(struct fb_info *info, int user);
@@ -711,6 +712,7 @@
 	mfd->ad_bl_level = 0;
 	mfd->fb_imgType = MDP_RGBA_8888;
 
+	mfd->fbi->fbdefio = &mdss_fb_defio;
 	mfd->pdev = pdev;
 
 	mfd->split_mode = MDP_SPLIT_MODE_NONE;
@@ -755,6 +757,7 @@
 			lcd_backlight_registered = 1;
 	}
 
+	fb_deferred_io_init(mfd->fbi);
 	mdss_fb_create_sysfs(mfd);
 	mdss_fb_send_panel_event(mfd, MDSS_EVENT_FB_REGISTERED, fbi);
 
@@ -1763,7 +1766,11 @@
 	atomic_inc(&mfd->commits_pending);
 	wake_up_all(&mfd->commit_wait_q);
 }
-
+static void mdss_fb_deferred_io(struct fb_info *info,
+				struct list_head *pagelist)
+{
+	mdss_fb_pan_display(&info->var, info);
+}
 static ssize_t mdss_fb_write(struct fb_info *info, const char __user *buf,
 		size_t count, loff_t *ppos)
 {
@@ -1838,6 +1845,11 @@
 	.fb_imageblit	= mdss_fb_imageblit,
 };
 
+static struct fb_deferred_io mdss_fb_defio = {
+	.delay		= HZ,
+	.deferred_io	= mdss_fb_deferred_io,
+};
+
 static int mdss_fb_alloc_fbmem_iommu(struct msm_fb_data_type *mfd, int dom)
 {
 	void *virt = NULL;
@@ -2318,6 +2330,7 @@
 
 	pr_debug("release_all = %s\n", release_all ? "true" : "false");
 
+	fb_deferred_io_cleanup(mfd->fbi);
 	list_for_each_entry_safe(pinfo, temp_pinfo, &mfd->proc_list, list) {
 		if (!release_all && (pinfo->pid != pid))
 			continue;
diff -Naur -x .git --no-dereference linux/drivers/watchdog/qcom-wdt.c linux-3.14/drivers/watchdog/qcom-wdt.c
--- linux/drivers/watchdog/qcom-wdt.c	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/drivers/watchdog/qcom-wdt.c	2016-09-01 11:52:05.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2014, 2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -16,10 +16,14 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
 #include <linux/watchdog.h>
 #include <soc/qcom/scm.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/utsname.h>
 
 #define WDT_RST		0x0
 #define WDT_EN		0x8
@@ -28,10 +32,12 @@
 
 #define SCM_CMD_SET_REGSAVE  0x2
 static int in_panic;
+
 struct qcom_wdt {
 	struct watchdog_device	wdd;
 	struct clk		*clk;
 	unsigned long		rate;
+	unsigned int		bite;
 	struct notifier_block	restart_nb;
 	void __iomem		*base;
 	void __iomem		*wdt_reset;
@@ -40,6 +46,75 @@
 	void __iomem		*wdt_bite_time;
 };
 
+struct qcom_wdt_scm_tlv_msg {
+	unsigned char *msg_buffer;
+	unsigned char *cur_msg_buffer_pos;
+	unsigned int len;
+};
+
+struct qcom_crashdump_tlv_info {
+	unsigned int tlv_base;
+	unsigned int tlv_size;
+};
+
+struct qcom_crashdump_tlv_info ipq40xx_tlv = { 0x87B70000u, 0x10000u };
+
+#define CFG_TLV_MSG_OFFSET 2048
+#define QCOM_WDT_SCM_TLV_TYPE_SIZE 1
+#define QCOM_WDT_SCM_TLV_LEN_SIZE 2
+#define QCOM_WDT_SCM_TLV_TYPE_LEN_SIZE (QCOM_WDT_SCM_TLV_TYPE_SIZE +\
+						QCOM_WDT_SCM_TLV_LEN_SIZE)
+enum {
+	QCOM_WDT_LOG_DUMP_TYPE_INVALID,
+	QCOM_WDT_LOG_DUMP_TYPE_UNAME,
+};
+
+static int qcom_wdt_scm_add_tlv(struct qcom_wdt_scm_tlv_msg *scm_tlv_msg,
+			unsigned char type, unsigned int size, const char *data)
+{
+	unsigned char *x = scm_tlv_msg->cur_msg_buffer_pos;
+	unsigned char *y = scm_tlv_msg->msg_buffer + scm_tlv_msg->len;
+
+	if ((x + QCOM_WDT_SCM_TLV_TYPE_LEN_SIZE + size) >= y)
+		return -ENOBUFS;
+
+	x[0] = type;
+	x[1] = size;
+	x[2] = size >> 8;
+
+	memcpy(x + 3, data, size);
+
+	scm_tlv_msg->cur_msg_buffer_pos +=
+		(size + QCOM_WDT_SCM_TLV_TYPE_LEN_SIZE);
+
+	return 0;
+}
+
+static int qcom_wdt_scm_fill_log_dump_tlv(
+			struct qcom_wdt_scm_tlv_msg *scm_tlv_msg)
+{
+	struct new_utsname *uname;
+	int ret_val;
+
+	uname = utsname();
+
+	ret_val = qcom_wdt_scm_add_tlv(scm_tlv_msg,
+			QCOM_WDT_LOG_DUMP_TYPE_UNAME,
+			sizeof(*uname),
+			(unsigned char *)uname);
+
+	if (ret_val)
+		return ret_val;
+
+	if (scm_tlv_msg->cur_msg_buffer_pos >=
+		scm_tlv_msg->msg_buffer + scm_tlv_msg->len)
+		return -ENOBUFS;
+
+	*scm_tlv_msg->cur_msg_buffer_pos++ = QCOM_WDT_LOG_DUMP_TYPE_INVALID;
+
+	return 0;
+}
+
 static inline
 struct qcom_wdt *to_qcom_wdt(struct watchdog_device *wdd)
 {
@@ -56,6 +131,7 @@
 static struct notifier_block panic_blk = {
 	.notifier_call  = panic_prep_restart,
 };
+
 static long qcom_wdt_configure_bark_dump(void *arg)
 {
 	long ret = -ENOMEM;
@@ -63,22 +139,76 @@
 		unsigned addr;
 		int len;
 	} cmd_buf;
+	struct qcom_wdt_scm_tlv_msg tlv_msg;
+	struct qcom_crashdump_tlv_info *tlv_info =
+					(struct qcom_crashdump_tlv_info *)arg;
+	struct resource *res;
+	void *tlv_ptr;
+	unsigned int tlv_base;
+	unsigned int tlv_size;
+	void *scm_regsave;
 
 	/* Area for context dump in secure mode */
-	void *scm_regsave = (void *)__get_free_page(GFP_KERNEL);
+	scm_regsave = (void *)__get_free_page(GFP_KERNEL);
+	if (!scm_regsave) {
+		pr_err("Failed to allocate 4K page\n");
+		return ret;
+	}
 
-	if (scm_regsave) {
+	if (!arg) {
 		cmd_buf.addr = virt_to_phys(scm_regsave);
 		cmd_buf.len  = PAGE_SIZE;
 
 		ret = scm_call(SCM_SVC_UTIL, SCM_CMD_SET_REGSAVE,
-			       &cmd_buf, sizeof(cmd_buf), NULL, 0);
+				&cmd_buf, sizeof(cmd_buf), NULL, 0);
+		if (ret) {
+			pr_err("Setting register save address failed.\n"
+				"Registers won't be dumped on a dog bite\n");
+			return ret;
+		}
 	}
 
-	if (ret)
-		pr_err("Setting register save address failed.\n"
-				"Registers won't be dumped on a dog bite\n");
-	return ret;
+	/* Initialize the tlv and fill all the details */
+	tlv_msg.msg_buffer = scm_regsave + CFG_TLV_MSG_OFFSET;
+	tlv_msg.cur_msg_buffer_pos = tlv_msg.msg_buffer;
+	tlv_msg.len = PAGE_SIZE - CFG_TLV_MSG_OFFSET;
+
+	ret = qcom_wdt_scm_fill_log_dump_tlv(&tlv_msg);
+
+	/* if failed, we still return 0 because it should not
+	 * affect the boot flow. The return value 0 does not
+	 * necessarily indicate success in this function.
+	 */
+	if (ret) {
+		pr_err("log dump initialization failed\n");
+		return 0;
+	}
+
+	if (arg) {
+		tlv_base = tlv_info->tlv_base;
+		tlv_size = tlv_info->tlv_size;
+
+		res = request_mem_region(tlv_base, tlv_size, "tlv_dump");
+
+		if (!res) {
+			pr_err("requesting memory region failed\n");
+			return 0;
+		}
+
+		tlv_ptr = ioremap(tlv_base, tlv_size);
+
+		if (!tlv_ptr) {
+			pr_err("mapping physical mem failed\n");
+			release_mem_region(tlv_base, tlv_size);
+			return 0;
+		}
+
+		memcpy_toio(tlv_ptr, tlv_msg.msg_buffer, tlv_msg.len);
+		iounmap(tlv_ptr);
+		release_mem_region(tlv_base, tlv_size);
+	}
+
+	return 0;
 }
 
 static int qcom_wdt_start_secure(struct watchdog_device *wdd)
@@ -87,8 +217,15 @@
 
 	writel(0, wdt->wdt_enable);
 	writel(1, wdt->wdt_reset);
-	writel(wdd->timeout * wdt->rate, wdt->wdt_bark_time);
-	writel(0x0FFFFFFF, wdt->wdt_bite_time);
+
+	if (wdt->bite) {
+		writel((wdd->timeout - 1) * wdt->rate, wdt->wdt_bark_time);
+		writel(wdd->timeout * wdt->rate, wdt->wdt_bite_time);
+	} else {
+		writel(wdd->timeout * wdt->rate, wdt->wdt_bark_time);
+		writel(0x0FFFFFFF, wdt->wdt_bite_time);
+	}
+
 	writel(1, wdt->wdt_enable);
 	return 0;
 }
@@ -150,6 +287,15 @@
 	.identity	= KBUILD_MODNAME,
 };
 
+static const struct of_device_id qcom_wdt_of_table[] = {
+	{ .compatible = "qcom,kpss-wdt-msm8960", },
+	{ .compatible = "qcom,kpss-wdt-apq8064", },
+	{ .compatible = "qcom,kpss-wdt-ipq8064", },
+	{ .compatible = "qcom,kpss-wdt-ipq40xx", .data = &ipq40xx_tlv},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, qcom_wdt_of_table);
+
 static int qcom_wdt_restart(struct notifier_block *nb, unsigned long action,
 			    void *data)
 {
@@ -184,22 +330,61 @@
 	 */
 	wmb();
 
-	msleep(150);
+	mdelay(150);
 	return NOTIFY_DONE;
 }
 
+static irqreturn_t wdt_bark_isr(int irq, void *wdd)
+{
+	struct qcom_wdt *wdt = to_qcom_wdt(wdd);
+	unsigned long nanosec_rem;
+	unsigned long long t = sched_clock();
+
+	nanosec_rem = do_div(t, 1000000000);
+	pr_info("Watchdog bark! Now = %lu.%06lu\n", (unsigned long) t,
+							nanosec_rem / 1000);
+	pr_info("Causing a watchdog bite!");
+	writel(0, wdt->wdt_enable);
+	writel(1, wdt->wdt_bite_time);
+	mb(); /* Avoid unpredictable behaviour in concurrent executions */
+	pr_info("Configuring Watchdog Timer\n");
+	writel(1, wdt->wdt_reset);
+	writel(1, wdt->wdt_enable);
+	mb(); /* Make sure the above sequence hits hardware before Reboot. */
+	pr_info("Waiting for Reboot\n");
+
+	mdelay(1);
+	pr_err("Wdog - CTL: 0x%x, BARK TIME: 0x%x, BITE TIME: 0x%x",
+		readl(wdt->wdt_enable),
+		readl(wdt->wdt_bark_time),
+		readl(wdt->wdt_bite_time));
+	return IRQ_HANDLED;
+}
+
+void register_wdt_bark_irq(int irq, struct qcom_wdt *wdt)
+{
+	int ret;
+	ret = request_irq(irq, wdt_bark_isr, IRQF_TRIGGER_HIGH,
+						"watchdog bark", wdt);
+	if (ret)
+		pr_err("error request_irq(irq_num:%d ) ret:%d\n",
+								irq, ret);
+}
+
 static int qcom_wdt_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *id;
 	struct device_node *np;
 	struct qcom_wdt *wdt;
 	struct resource *res;
-	int ret;
+	int ret, irq = 0;
 	uint32_t val;
 
 	wdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);
 	if (!wdt)
 		return -ENOMEM;
 
+	irq = platform_get_irq_byname(pdev, "bark_irq");
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	wdt->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(wdt->base))
@@ -227,6 +412,16 @@
 	else
 		wdt->wdt_bite_time = wdt->base + val;
 
+	id = of_match_device(qcom_wdt_of_table, &pdev->dev);
+	if (!id)
+		return -ENODEV;
+
+	if (id->data)
+		wdt->bite = 1;
+
+	if (irq > 0)
+		register_wdt_bark_irq(irq, wdt);
+
 	wdt->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(wdt->clk)) {
 		dev_err(&pdev->dev, "failed to get input clock\n");
@@ -255,7 +450,7 @@
 		goto err_clk_unprepare;
 	}
 
-	ret = work_on_cpu(0, qcom_wdt_configure_bark_dump, NULL);
+	ret = work_on_cpu(0, qcom_wdt_configure_bark_dump, id->data);
 
 	wdt->wdd.dev = &pdev->dev;
 	wdt->wdd.info = &qcom_wdt_info;
@@ -307,15 +502,6 @@
 	return 0;
 }
 
-static const struct of_device_id qcom_wdt_of_table[] = {
-	{ .compatible = "qcom,kpss-wdt-msm8960", },
-	{ .compatible = "qcom,kpss-wdt-apq8064", },
-	{ .compatible = "qcom,kpss-wdt-ipq8064", },
-	{ .compatible = "qcom,kpss-wdt-ipq40xx", },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, qcom_wdt_of_table);
-
 static struct platform_driver qcom_watchdog_driver = {
 	.probe	= qcom_wdt_probe,
 	.remove	= qcom_wdt_remove,
diff -Naur -x .git --no-dereference linux/include/dt-bindings/clock/qcom,gcc-ipq806x.h linux-3.14/include/dt-bindings/clock/qcom,gcc-ipq806x.h
--- linux/include/dt-bindings/clock/qcom,gcc-ipq806x.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/dt-bindings/clock/qcom,gcc-ipq806x.h	2016-09-01 11:52:05.000000000 +0800
@@ -249,7 +249,7 @@
 #define PLL14					232
 #define PLL14_VOTE				233
 #define PLL18					234
-#define CE5_SRC					235
+#define CE5_A_CLK				235
 #define CE5_H_CLK				236
 #define CE5_CORE_CLK				237
 #define CE3_SLEEP_CLK				238
@@ -292,5 +292,8 @@
 #define NSSTCM_CLK_SRC				281
 #define NSSTCM_CLK				282
 #define NSS_CORE_CLK				283 /* Virtual */
+#define CE5_A_CLK_SRC				284
+#define CE5_H_CLK_SRC				285
+#define CE5_CORE_CLK_SRC			286
 
 #endif
diff -Naur -x .git --no-dereference linux/include/linux/ath9k_platform.h linux-3.14/include/linux/ath9k_platform.h
--- linux/include/linux/ath9k_platform.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/ath9k_platform.h	2016-09-01 11:52:05.000000000 +0800
@@ -31,11 +31,16 @@
 	u32 gpio_mask;
 	u32 gpio_val;
 
+	u32 bt_active_pin;
+	u32 bt_priority_pin;
+	u32 wlan_active_pin;
+
 	bool endian_check;
 	bool is_clk_25mhz;
 	bool tx_gain_buffalo;
 	bool disable_2ghz;
 	bool disable_5ghz;
+	bool led_active_high;
 
 	int (*get_mac_revision)(void);
 	int (*external_reset)(void);
diff -Naur -x .git --no-dereference linux/include/linux/crypto.h linux-3.14/include/linux/crypto.h
--- linux/include/linux/crypto.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/crypto.h	2016-09-01 11:52:05.000000000 +0800
@@ -95,6 +95,11 @@
 #define CRYPTO_ALG_KERN_DRIVER_ONLY	0x00001000
 
 /*
+ * Set this flag if algorithm does not support SG list transforms
+ */
+#define CRYPTO_ALG_NOSUPP_SG		0x00002000
+
+/*
  * Transform masks and values (for crt_flags).
  */
 #define CRYPTO_TFM_REQ_MASK		0x000fff00
@@ -535,6 +540,11 @@
 	return tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;
 }
 
+static inline u32 crypto_tfm_alg_flags(struct crypto_tfm *tfm)
+{
+	return tfm->__crt_alg->cra_flags & ~CRYPTO_ALG_TYPE_MASK;
+}
+
 static inline unsigned int crypto_tfm_alg_blocksize(struct crypto_tfm *tfm)
 {
 	return tfm->__crt_alg->cra_blocksize;
diff -Naur -x .git --no-dereference linux/include/linux/i2c/i2c-msm-v2.h linux-3.14/include/linux/i2c/i2c-msm-v2.h
--- linux/include/linux/i2c/i2c-msm-v2.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/include/linux/i2c/i2c-msm-v2.h	2016-09-01 11:52:05.000000000 +0800
@@ -0,0 +1,683 @@
+/* Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+/*
+ * I2C controller driver for Qualcomm Technologies Inc platforms
+ */
+
+#ifndef _I2C_MSM_V2_H
+#define _I2C_MSM_V2_H
+
+#include <linux/bitops.h>
+
+enum msm_i2_debug_level {
+	MSM_ERR,	/* Error messages only. Always on */
+	MSM_PROF,	/* High level events. Use for profiling */
+	MSM_DBG,	/* Low level details. Use for debugging */
+};
+
+#define i2c_msm_dbg(ctrl, dbg_level, fmt, ...) do {\
+		if (ctrl->dbgfs.dbg_lvl >= dbg_level)\
+			dev_info(ctrl->dev, pr_fmt(fmt), ##__VA_ARGS__);\
+	} while (0)
+
+#define BIT_IS_SET(val, idx)        ((val >> idx) & 0x1)
+#define BITS_AT(val, idx, n_bits)(((val) & (((1 << n_bits) - 1) << idx)) >> idx)
+#define MASK_IS_SET(val, mask)      ((val & mask) == mask)
+#define MASK_IS_SET_BOOL(val, mask) (MASK_IS_SET(val, mask) ? 1 : 0)
+#define KHz(freq) (1000 * freq)
+#define I2C_MSM_CLK_FAST_PLUS_FREQ  (1000000)
+
+/* QUP Registers */
+enum {
+	QUP_CONFIG              = 0x0,
+	QUP_STATE               = 0x4,
+	QUP_IO_MODES            = 0x8,
+	QUP_SW_RESET            = 0xC,
+	QUP_OPERATIONAL         = 0x18,
+	QUP_ERROR_FLAGS         = 0x1C,
+	QUP_ERROR_FLAGS_EN      = 0x20,
+	QUP_TEST_CTRL           = 0x24,
+	QUP_OPERATIONAL_MASK    = 0x28,
+	QUP_HW_VERSION          = 0x30,
+	QUP_MX_READ_COUNT       = 0x208,
+	QUP_MX_WRITE_COUNT      = 0x150,
+	QUP_MX_OUTPUT_COUNT     = 0x100,
+	QUP_MX_INPUT_COUNT      = 0x200,
+	QUP_MX_WR_CNT           = 0x100,
+	QUP_OUT_DEBUG           = 0x108,
+	QUP_OUT_FIFO_CNT        = 0x10C,
+	QUP_OUT_FIFO_BASE       = 0x110,
+	QUP_IN_READ_CUR         = 0x20C,
+	QUP_IN_DEBUG            = 0x210,
+	QUP_IN_FIFO_CNT         = 0x214,
+	QUP_IN_FIFO_BASE        = 0x218,
+	QUP_I2C_MASTER_CLK_CTL  = 0x400,
+	QUP_I2C_STATUS          = 0x404,
+	QUP_I2C_MASTER_CONFIG   = 0x408,
+	QUP_I2C_MASTER_BUS_CLR  = 0x40C,
+};
+
+/* Register:QUP_STATE state field values */
+enum i2c_msm_qup_state {
+	QUP_STATE_RESET         = 0,
+	QUP_STATE_RUN           = 1U,
+	QUP_STATE_PAUSE         = 3U,
+};
+
+/* Register:QUP_STATE fields */
+enum {
+	QUP_STATE_MASK          = 3U,
+	QUP_STATE_VALID         = BIT(2),
+	QUP_I2C_MAST_GEN        = BIT(4),
+	QUP_I2C_FLUSH           = BIT(6),
+	QUP_I2C_STATUS_RESET    = 0x42,
+};
+
+
+/* Register:QUP_CONFIG fields */
+enum {
+	QUP_MINI_CORE_MASK      = 0xF00,
+	QUP_MINI_CORE_I2C_VAL   = 0x200,
+	QUP_N_MASK              = 0x1F,
+	QUP_N_VAL               = 0x7, /* 0xF for A family */
+	QUP_NO_OUPUT            = BIT(6),
+	QUP_NO_INPUT            = BIT(7),
+	QUP_APP_CLK_ON_EN       = BIT(12),
+	QUP_CORE_CLK_ON_EN      = BIT(13),
+	QUP_FIFO_CLK_GATE_EN    = BIT(14),
+};
+
+/* Register:QUP_OPERATIONAL fields */
+enum {
+	QUP_INPUT_FIFO_NOT_EMPTY = BIT(5),
+	QUP_OUTPUT_SERVICE_FLAG  = BIT(8),
+	QUP_INPUT_SERVICE_FLAG   = BIT(9),
+	QUP_MAX_OUTPUT_DONE_FLAG = BIT(10),
+	QUP_MAX_INPUT_DONE_FLAG  = BIT(11),
+	QUP_OUT_BLOCK_WRITE_REQ  = BIT(12),
+	QUP_IN_BLOCK_READ_REQ    = BIT(13),
+};
+
+/* Register:QUP_OPERATIONAL_MASK fields */
+enum {
+	QUP_INPUT_SERVICE_MASK  = BIT(9),
+	QUP_OUTPUT_SERVICE_MASK = BIT(8),
+};
+
+/* Register:QUP_IO_MODES fields */
+enum {
+	QUP_OUTPUT_MODE         = BIT(10) | BIT(11),
+	QUP_INPUT_MODE          = BIT(12) | BIT(13),
+	QUP_UNPACK_EN           = BIT(14),
+	QUP_PACK_EN             = BIT(15),
+	QUP_OUTPUT_BIT_SHIFT_EN = BIT(16),
+};
+
+/* Register:QUP_I2C_STATUS (a.k.a I2C_MASTER_STATUS) fields */
+enum {
+	QUP_BUS_ERROR           = BIT(2),
+	QUP_PACKET_NACKED       = BIT(3),
+	QUP_ARB_LOST            = BIT(4),
+	QUP_INVALID_WRITE       = BIT(5),
+	QUP_FAILED              = BIT(6),
+	QUP_BUS_ACTIVE          = BIT(8),
+	QUP_BUS_MASTER          = BIT(9),
+	QUP_INVALID_TAG         = BIT(23),
+	QUP_INVALID_READ_ADDR   = BIT(24),
+	QUP_INVALID_READ_SEQ    = BIT(25),
+	QUP_I2C_SDA             = BIT(26),
+	QUP_I2C_SCL             = BIT(27),
+	QUP_MSTR_STTS_ERR_MASK  = 0x380003C,
+};
+
+/* Register:QUP_I2C_MASTER_CONFIG fields */
+enum {
+	QUP_EN_VERSION_TWO_TAG  = 1U,
+};
+
+/* Register:QUP_I2C_MASTER_CLK_CTL field setters */
+#define I2C_MSM_SCL_NOISE_REJECTION(reg_val, noise_rej_val) \
+		(((reg_val) & ~(0x3 << 24)) | (((noise_rej_val) & 0x3) << 24))
+#define I2C_MSM_SDA_NOISE_REJECTION(reg_val, noise_rej_val) \
+		(((reg_val) & ~(0x3 << 26)) | (((noise_rej_val) & 0x3) << 26))
+
+/* Register:QUP_ERROR_FLAGS_EN flags */
+enum {
+	QUP_OUTPUT_OVER_RUN_ERR_EN  = BIT(5),
+	QUP_INPUT_UNDER_RUN_ERR_EN  = BIT(4),
+	QUP_OUTPUT_UNDER_RUN_ERR_EN = BIT(3),
+	QUP_INPUT_OVER_RUN_ERR_EN   = BIT(2),
+};
+
+/* Status, Error flags */
+enum {
+	I2C_STATUS_WR_BUFFER_FULL  = BIT(0),
+	I2C_STATUS_BUS_ACTIVE      = BIT(8),
+	I2C_STATUS_BUS_MASTER      = BIT(9),
+	I2C_STATUS_ERROR_MASK      = 0x38000FC,
+	QUP_I2C_NACK_FLAG          = BIT(3),
+	QUP_IN_NOT_EMPTY           = BIT(5),
+	QUP_ERR_FLGS_MASK           = 0x3C,
+};
+
+/* Master status clock states */
+enum {
+	I2C_CLK_RESET_BUSIDLE_STATE = 0,
+	I2C_CLK_FORCED_LOW_STATE    = 5,
+};
+
+/* Controller's power state */
+enum i2c_msm_power_state {
+	I2C_MSM_PM_RT_ACTIVE,
+	I2C_MSM_PM_RT_SUSPENDED,
+	I2C_MSM_PM_SYS_SUSPENDED
+};
+
+/*
+ * The max buffer size required for tags is for holding the following sequence:
+ * [start] + [start | slv-addr] + [ rd/wr | len]
+ * which sum up to 6 bytes. However, we use u64 to hold the value, thus we say
+ * that max length is 8 bytes.
+ */
+#define I2C_MSM_TAG2_MAX_LEN            (4)
+#define I2C_MSM_BAM_CONS_SZ             (64) /* consumer pipe n entries */
+#define I2C_MSM_BAM_PROD_SZ             (32) /* producer pipe n entries */
+#define I2C_MSM_BAM_DESC_ARR_SIZ  (I2C_MSM_BAM_CONS_SZ + I2C_MSM_BAM_PROD_SZ)
+#define I2C_MSM_REG_2_STR_BUF_SZ        (128)
+/* Optimal value to hold the error strings */
+#define I2C_MSM_MAX_ERR_BUF_SZ		(256)
+#define I2C_MSM_BUF_DUMP_MAX_BC         (20)
+#define I2C_MSM_MAX_POLL_MSEC           (100)
+#define I2C_MSM_TIMEOUT_SAFTY_COEF      (10)
+#define I2C_MSM_TIMEOUT_MIN_USEC        (500000)
+#define I2C_QUP_MAX_BUS_RECOVERY_RETRY  (10)
+
+/* QUP v2 tags */
+#define QUP_TAG2_DATA_WRITE        (0x82ULL)
+#define QUP_TAG2_DATA_WRITE_N_STOP (0x83ULL)
+#define QUP_TAG2_DATA_READ         (0x85ULL)
+#define QUP_TAG2_DATA_READ_N_STOP  (0x87ULL)
+#define QUP_TAG2_START             (0x81ULL)
+#define QUP_TAG2_DATA_READ_N_NACK  (0x86ULL)
+#define QUP_TAG2_START_STOP        (0x8AULL)
+#define QUP_TAG2_INPUT_EOT         (0x93ULL)
+#define QUP_TAG2_FLUSH_STOP        (0x96ULL)
+#define QUP_BUF_OVERHD_BC          (2)
+#define QUP_MAX_BUF_SZ             (256)
+
+enum i2c_msm_clk_path_vec_idx {
+	I2C_MSM_CLK_PATH_SUSPEND_VEC,
+	I2C_MSM_CLK_PATH_RESUME_VEC,
+};
+#define I2C_MSM_CLK_PATH_AVRG_BW(ctrl) (0)
+#define I2C_MSM_CLK_PATH_BRST_BW(ctrl) (76800000)
+
+enum i2c_msm_gpio_name_idx {
+	I2C_MSM_GPIO_SCL,
+	I2C_MSM_GPIO_SDA,
+};
+
+extern const char * const i2c_msm_mode_str_tbl[];
+
+struct i2c_msm_ctrl;
+
+/*
+ * i2c_msm_xfer_mode: transfer modes such as FIFO and BAM define these callbacks
+ */
+struct i2c_msm_xfer_mode {
+	void                     (*teardown)(struct i2c_msm_ctrl *);
+	int                      (*xfer)    (struct i2c_msm_ctrl *);
+};
+
+/*
+ *  i2c_msm_dma_mem: utility struct which holds both physical and virtual addr
+ */
+struct i2c_msm_dma_mem {
+	dma_addr_t               phy_addr;
+	void                    *vrtl_addr;
+};
+
+/*
+ * i2c_msm_tag: tag's data and its length.
+ *
+ * @len tag len can be two, four or six bytes.
+ */
+struct i2c_msm_tag {
+	u64                    val;
+	int                    len;
+};
+
+/*
+ * i2c_msm_bam_tag: similar to struct i2c_msm_tag but holds physical address.
+ *
+ * @buf physical address of entry in the tag_arr of
+ *          struct i2c_msm_xfer_mode_bam
+ * @len tag len.
+ *
+ * Hold the information from i2c_msm_bam_xfer_prepare() which is used by
+ * i2c_msm_bam_xfer_process() and freed by i2c_msm_bam_xfer_unprepare()
+ */
+struct i2c_msm_bam_tag {
+	dma_addr_t             buf;
+	size_t                 len;
+};
+
+/*
+ * i2c_msm_bam_buf: dma mapped pointer to i2c_msg data buffer and related tag
+ * @vir_addr ptr to i2c_msg buf beginning or with offset (when buf len > 256)
+ */
+struct i2c_msm_bam_buf {
+	struct i2c_msm_dma_mem   ptr;
+	enum dma_data_direction  dma_dir;
+	size_t                   len;
+	bool                     is_rx;
+	bool                     is_last;
+	struct i2c_msm_bam_tag   tag;
+};
+
+/*
+ * i2c_msm_bam_pipe: per pipe info
+ *
+ * @is_init true when the pipe is initialized and requires eventual teardown.
+ * @name pipe name (consumer/producer) for debugging.
+ * @desc_cnt_max size of descriptors space
+ * @desc_cnt_cur number of occupied descriptors
+ */
+struct i2c_msm_bam_pipe {
+	bool                     is_init;
+	struct sps_pipe         *handle;
+	struct sps_connect       config;
+	const char              *name;
+	size_t                   desc_cnt_max;
+	size_t                   desc_cnt_cur;
+};
+
+enum i2c_msm_bam_pipe_dir {
+	I2C_MSM_BAM_CONS = 0,
+	I2C_MSM_BAM_PROD = 1,
+};
+
+static const char * const i2c_msm_bam_pipe_name[] = {"consumer", "producer"};
+
+/*
+ * struct i2c_msm_xfer_mode_bam: bam mode configuration and work space
+ *
+ * @is_init true when BAM and its pipes are fully initialized.
+ * @is_core_init true when BAM core is initialised.
+ * @ops     "base class" of i2c_msm_xfer_mode_bam. Contains the operations while
+ *          the rest of the fields contain the data.
+ * @deregister_required deregister is required when this driver has registerd
+ *          the BAM device. When another kernel module has registered BAM
+ *          prior to this driver, then deregister is not required.
+ * @buf_arr_cnt current number of vaid buffers in buf_arr. The valid buffers
+ *          are at index 0..buf_arr_cnt excluding buf_arr_cnt.
+ * @buf_arr array of descriptors which point to the user's buffer
+ *     virtual and physical address, and hold meta data about the buffer
+ *     and respective tag.
+ * @tag_arr array of tags in DMAable memory. Holds a tag per buffer of the same
+ *          index, that is tag_arr[i] is related to buf_arr[i]. Also, tag_arr[i]
+ *          is queued in the consumer pipe just befor buf_arr[i] is queued in
+ *          the consumer (output buf) or producer pipe (input buffer).
+ * @eot_n_flush_stop_tags EOT and flush-stop tags to be queued to the consumer
+ *          bam pipe after the last transfer when it is a read.
+ * @input_tag hw is placing input tags in the producer pipe on read operations.
+ *          The value of these tags is "don't care" from bam transfer
+ *          perspective. Thus, this single buffer is used for all the input
+ *          tags. The field is used as write only.
+ * @mem pointer to platform data describing the BAM's register space.
+ */
+struct i2c_msm_xfer_mode_bam {
+	struct i2c_msm_xfer_mode ops;
+	bool                     is_init;
+	bool                     is_core_init;
+	bool                     deregister_required;
+
+	size_t                   buf_arr_cnt;
+	struct i2c_msm_bam_buf   buf_arr[I2C_MSM_BAM_DESC_ARR_SIZ];
+	struct i2c_msm_dma_mem   tag_arr;
+	struct i2c_msm_dma_mem   eot_n_flush_stop_tags;
+	struct i2c_msm_dma_mem   input_tag;
+
+	struct resource         *mem;
+	void __iomem            *base;
+	ulong                    handle;
+	int                      irq;
+	struct i2c_msm_bam_pipe  pipe[2];
+};
+
+/*
+ * I2C_MSM_BAM_TAG_MEM_SZ includes the following fields of
+ * struct i2c_msm_xfer_mode_bam (in order):
+ *
+ * Buffer of DMA memory:
+ * +-----------+---------+-----------+-----------+----+-----------+
+ * | input_tag | eot_... | tag_arr 0 | tag_arr 1 | .. | tag_arr n |
+ * +-----------+---------+-----------+-----------+----+-----------+
+ *
+ * Why +2?
+ * One tag buffer for the input tags. This is a write only buffer for BAM, it is
+ *    used to read the tags of the input fifo. We let them overwrite each other,
+ *    since it is a throw-away from the driver's perspective.
+ * Second tag buffer for the EOT and flush-stop tags. This is a read only
+ *    buffer (from BAM perspective). It is used to put EOT and flush-stop at the
+ *    end of every transaction.
+ */
+#define I2C_MSM_BAM_TAG_MEM_SZ  \
+	((I2C_MSM_BAM_DESC_ARR_SIZ + 2) * I2C_MSM_TAG2_MAX_LEN)
+
+/*
+ * i2c_msm_xfer_mode_fifo: operations and state of FIFO mode
+ *
+ * @ops     "base class" of i2c_msm_xfer_mode_bam. Contains the operations while
+ *          the rest of the fields contain the data.
+ * @input_fifo_sz input fifo size in bytes
+ * @output_fifo_sz output fifo size in bytes
+ * @in_rem  remaining u32 entries in input FIFO before empty
+ * @out_rem remaining u32 entries in output FIFO before full
+ * @out_buf buffer for collecting bytes to four bytes groups (u32) before
+ *          writing them to the output fifo.
+ * @out_buf_idx next free index in out_buf. 0..3
+ */
+struct i2c_msm_xfer_mode_fifo {
+	size_t                   input_fifo_sz;
+	size_t                   output_fifo_sz;
+	size_t                   in_rem;
+	size_t                   out_rem;
+	u8                       out_buf[4];
+	int                      out_buf_idx;
+};
+
+/* i2c_msm_xfer_mode_blk: operations and state of Block mode
+ *
+ * @is_init when true, struct is initialized and requires mem free on exit
+ * @in_blk_sz size of input/rx block
+ * @out_blk_sz size of output/tx block
+ * @tx_cache internal buffer to store tx data
+ * @rx_cache internal buffer to store rx data
+ * @rx_cache_idx points to the next unread index in rx cache
+ * @tx_cache_idx points to the next unwritten index in tx cache
+ * @wait_rx_blk completion object to wait on for end of blk rx transfer.
+ * @wait_tx_blk completion object to wait on for end of blk tx transfer.
+ * @complete_mask applied to QUP_OPERATIONAL to determine when blk
+ *  xfer is complete.
+ */
+struct i2c_msm_xfer_mode_blk {
+	bool                     is_init;
+	size_t                   in_blk_sz;
+	size_t                   out_blk_sz;
+	u8                       *tx_cache;
+	u8                       *rx_cache;
+	int                      rx_cache_idx;
+	int                      tx_cache_idx;
+	struct completion        wait_rx_blk;
+	struct completion        wait_tx_blk;
+	u32                      complete_mask;
+};
+
+/* INPUT_MODE and OUTPUT_MODE filds of QUP_IO_MODES register */
+enum i2c_msm_xfer_mode_id {
+	I2C_MSM_XFER_MODE_FIFO,
+	I2C_MSM_XFER_MODE_BLOCK,
+	I2C_MSM_XFER_MODE_BAM,
+	I2C_MSM_XFER_MODE_NONE, /* keep last as a counter */
+};
+
+
+struct i2c_msm_dbgfs {
+	struct dentry             *root;
+	enum msm_i2_debug_level    dbg_lvl;
+	enum i2c_msm_xfer_mode_id  force_xfer_mode;
+};
+
+/*
+ * qup_i2c_clk_path_vote: data to use bus scaling driver for clock path vote
+ *
+ * @mstr_id master id number of the i2c core or its wrapper (BLSP/GSBI).
+ *       When zero, clock path voting is disabled.
+ * @client_hdl when zero, client is not registered with the bus scaling driver,
+ *      and bus scaling functionality should not be used. When non zero, it
+ *      is a bus scaling client id and may be used to vote for clock path.
+ * @reg_err when true, registration error was detected and an error message was
+ *      logged. i2c will attempt to re-register but will log error only once.
+ *      once registration succeed, the flag is set to false.
+ * @actv_only when set, votes when system active and removes the vote when
+ *       system goes idle (optimises for performance). When unset, voting using
+ *       runtime pm (optimizes for power).
+ */
+struct qup_i2c_clk_path_vote {
+	u32                         mstr_id;
+	u32                         client_hdl;
+	struct msm_bus_scale_pdata *pdata;
+	bool                        reg_err;
+	bool                        actv_only;
+};
+
+/*
+ * i2c_msm_resources: OS resources
+ *
+ * @mem  I2C controller memory resource from platform data.
+ * @base I2C controller virtual base address
+ * @clk_freq_in core clock frequency in Hz
+ * @clk_freq_out bus clock frequency in Hz
+ * @bam_pipe_idx_cons index of BAM's consumer pipe
+ * @bam_pipe_idx_prod index of BAM's producer pipe
+ */
+struct i2c_msm_resources {
+	struct resource             *mem;
+	void __iomem                *base; /* virtual */
+	struct clk                  *core_clk;
+	struct clk                  *iface_clk;
+	int                          clk_freq_in;
+	int                          clk_freq_out;
+	struct qup_i2c_clk_path_vote clk_path_vote;
+	int                          irq;
+	bool                         disable_dma;
+	u32                          bam_pipe_idx_cons;
+	u32                          bam_pipe_idx_prod;
+	struct pinctrl              *pinctrl;
+	struct pinctrl_state        *gpio_state_active;
+	struct pinctrl_state        *gpio_state_suspend;
+};
+
+#define I2C_MSM_PINCTRL_ACTIVE       "i2c_active"
+#define I2C_MSM_PINCTRL_SUSPEND      "i2c_sleep"
+
+/*
+ * i2c_msm_xfer_buf: current xfer position and preprocessed tags
+ *
+ * @is_init the buf is marked initialized by the first call to
+ *          i2c_msm_xfer_next_buf()
+ * @msg_idx   index of the message that the buffer is pointing to
+ * @byte_idx  index of first byte in the current buffer
+ * @end_idx   count of bytes processed from the current message. This value
+ *            is compared against len to find out if buffer is done processing.
+ * @len       number of bytes in current buffer.
+ * @is_rx when true, current buffer is pointing to a i2c read operation.
+ * @slv_addr 8 bit address. This is the i2c_msg->addr + rd/wr bit.
+ *
+ * Keep track of current position in the client's transfer request and
+ * pre-process a transfer's buffer and tags.
+ */
+struct i2c_msm_xfer_buf {
+	bool                       is_init;
+	int                        msg_idx;
+	int                        byte_idx;
+	int                        end_idx;
+	int                        len;
+	bool                       is_rx;
+	bool                       is_last;
+	u16                        slv_addr;
+	struct i2c_msm_tag         in_tag;
+	struct i2c_msm_tag         out_tag;
+};
+
+#ifdef DEBUG
+#define I2C_MSM_PROF_MAX_EVNTS   (64)
+#else
+#define I2C_MSM_PROF_MAX_EVNTS   (16)
+#endif
+
+/*
+ * i2c_msm_prof_event: profiling event
+ *
+ * @data Additional data about the event. The interpretation of the data is
+ *       dependant on the type field.
+ * @type event type (see enum i2c_msm_prof_event_type)
+ */
+struct i2c_msm_prof_event {
+	struct timespec time;
+	u64             data0;
+	u32             data1;
+	u32             data2;
+	u8              type;
+	u8              dump_func_id;
+};
+
+enum i2c_msm_err {
+	I2C_MSM_NO_ERR = 0,
+	I2C_MSM_ERR_NACK,
+	I2C_MSM_ERR_ARB_LOST,
+	I2C_MSM_ERR_BUS_ERR,
+	I2C_MSM_ERR_TIMEOUT,
+	I2C_MSM_ERR_CORE_CLK,
+	I2C_MSM_ERR_OVR_UNDR_RUN,
+};
+
+/*
+ * i2c_msm_xfer: A client transfer request. A list of one or more i2c messages
+ *
+ * @msgs         NULL when no active xfer. Points to array of i2c_msgs
+ *               given by the client.
+ * @msg_cnt      number of messages in msgs array.
+ * @complete     completion object to wait on for end of transfer.
+ * @rx_cnt       number of input  bytes in the client's request.
+ * @tx_cnt       number of output bytes in the client's request.
+ * @rx_ovrhd_cnt number of input  bytes due to tags.
+ * @tx_ovrhd_cnt number of output bytes due to tags.
+ * @event        profiling data. An array of timestamps of transfer events
+ * @event_cnt    number of items in event array.
+ * @is_active    true during xfer process and false after xfer end
+ * @mtx          mutex to solve multithreaded problem in xfer
+ */
+struct i2c_msm_xfer {
+	struct i2c_msg            *msgs;
+	int                        msg_cnt;
+	enum i2c_msm_xfer_mode_id  mode_id;
+	struct completion          complete;
+	size_t                     rx_cnt;
+	size_t                     tx_cnt;
+	size_t                     rx_ovrhd_cnt;
+	size_t                     tx_ovrhd_cnt;
+	struct i2c_msm_xfer_buf    cur_buf;
+	u32                        timeout;
+	bool                       last_is_rx;
+	enum i2c_msm_err           err;
+	struct i2c_msm_prof_event  event[I2C_MSM_PROF_MAX_EVNTS];
+	atomic_t                   event_cnt;
+	atomic_t                   is_active;
+	struct mutex               mtx;
+	struct i2c_msm_xfer_mode_fifo	fifo;
+	struct i2c_msm_xfer_mode_blk	blk;
+	struct i2c_msm_xfer_mode_bam	bam;
+};
+
+/*
+ * i2c_msm_ctrl: the driver's main struct
+ *
+ * @is_init true when
+ * @ver info that is different between i2c controller versions
+ * @ver_num  ha
+ * @xfer     state of the currently processed transfer.
+ * @dbgfs    debug-fs root and values that may be set via debug-fs.
+ * @rsrcs    resources from platform data including clocks, gpios, irqs, and
+ *           memory regions.
+ * @mstr_clk_ctl cached value for programming to mstr_clk_ctl register
+ */
+struct i2c_msm_ctrl {
+	struct device             *dev;
+	struct i2c_adapter         adapter;
+	struct i2c_msm_xfer        xfer;
+	struct i2c_msm_dbgfs       dbgfs;
+	struct i2c_msm_resources   rsrcs;
+	u32                        mstr_clk_ctl;
+	enum i2c_msm_power_state   pwr_state;
+};
+
+/* Enum for the profiling event types */
+enum i2c_msm_prof_evnt_type {
+	I2C_MSM_VALID_END,
+	I2C_MSM_PIP_DSCN,
+	I2C_MSM_PIP_CNCT,
+	I2C_MSM_ACTV_END,
+	I2C_MSM_IRQ_BGN,
+	I2C_MSM_IRQ_END,
+	I2C_MSM_XFER_BEG,
+	I2C_MSM_XFER_END,
+	I2C_MSM_SCAN_SUM,
+	I2C_MSM_NEXT_BUF,
+	I2C_MSM_COMPLT_OK,
+	I2C_MSM_COMPLT_FL,
+	I2C_MSM_PROF_RESET,
+};
+
+#ifdef CONFIG_I2C_MSM_PROF_DBG
+extern void i2c_msm_dbgfs_init(struct i2c_msm_ctrl *ctrl);
+
+extern void i2c_msm_dbgfs_teardown(struct i2c_msm_ctrl *ctrl);
+
+/* diagonisis the i2c registers and dump the errors accordingly */
+extern const char *i2c_msm_dbg_tag_to_str(const struct i2c_msm_tag *tag,
+						char *buf, size_t buf_len);
+
+extern void i2c_msm_prof_evnt_dump(struct i2c_msm_ctrl *ctrl);
+
+/* function definitions to be used from the i2c-msm-v2-debug file */
+extern void i2c_msm_prof_evnt_add(struct i2c_msm_ctrl *ctrl,
+				enum msm_i2_debug_level dbg_level,
+				enum i2c_msm_prof_evnt_type event,
+				u64 data0, u32 data1, u32 data2);
+
+extern int i2c_msm_dbg_qup_reg_dump(struct i2c_msm_ctrl *ctrl);
+
+extern const char *
+i2c_msm_dbg_bam_tag_to_str(const struct i2c_msm_bam_tag *bam_tag, char *buf,
+								size_t buf_len);
+#else
+/* use dummy functions */
+static inline void i2c_msm_dbgfs_init(struct i2c_msm_ctrl *ctrl) {}
+static inline void i2c_msm_dbgfs_teardown(struct i2c_msm_ctrl *ctrl) {}
+
+static inline const char *i2c_msm_dbg_tag_to_str(const struct i2c_msm_tag *tag,
+						char *buf, size_t buf_len)
+{
+	return NULL;
+}
+static inline void i2c_msm_prof_evnt_dump(struct i2c_msm_ctrl *ctrl) {}
+
+/* function definitions to be used from the i2c-msm-v2-debug file */
+void i2c_msm_prof_evnt_add(struct i2c_msm_ctrl *ctrl,
+				enum msm_i2_debug_level dbg_level,
+				enum i2c_msm_prof_evnt_type event,
+				u64 data0, u32 data1, u32 data2) {}
+
+static inline int i2c_msm_dbg_qup_reg_dump(struct i2c_msm_ctrl *ctrl)
+{
+	return true;
+}
+static inline const char *i2c_msm_dbg_bam_tag_to_str(const struct
+			i2c_msm_bam_tag * bam_tag, char *buf, size_t buf_len)
+{
+	return NULL;
+}
+#endif /* I2C_MSM_V2_PROF_DBG */
+#endif /* _I2C_MSM_V2_H */
diff -Naur -x .git --no-dereference linux/include/linux/if_bridge.h linux-3.14/include/linux/if_bridge.h
--- linux/include/linux/if_bridge.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/if_bridge.h	2016-09-01 11:52:05.000000000 +0800
@@ -34,7 +34,7 @@
 
 extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
 extern struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
-		struct sk_buff *skb);
+		struct sk_buff *skb, unsigned int cookie);
 extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
 extern void br_dev_update_stats(struct net_device *dev, struct rtnl_link_stats64 *nlstats);
 extern bool br_fdb_has_entry(struct net_device *dev, const char *addr, __u16 vid);
@@ -64,7 +64,7 @@
 extern br_get_dst_hook_t __rcu *br_get_dst_hook;
 
 typedef struct net_bridge_port *br_port_dev_get_hook_t(struct net_device *dev,
-		struct sk_buff *skb);
+		struct sk_buff *skb, unsigned char *addr, unsigned int cookie);
 extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
 
 typedef void (br_notify_hook_t)(int group, int event, const void *ptr);
diff -Naur -x .git --no-dereference linux/include/linux/if_pppox.h linux-3.14/include/linux/if_pppox.h
--- linux/include/linux/if_pppox.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/if_pppox.h	2016-09-01 11:52:05.000000000 +0800
@@ -57,6 +57,7 @@
 	u32 ack_sent, ack_recv;
 	u32 seq_sent, seq_recv;
 	int ppp_flags;
+	bool pptp_offload_mode;
 };
 #include <net/sock.h>
 
@@ -119,6 +120,9 @@
 	void (*get_addressing)(struct ppp_channel *, struct pppoe_opt *);
 };
 
+/* PPTP client callback */
+typedef int (*pptp_gre_seq_offload_callback_t)(struct sk_buff *skb, struct net_device *pptp_dev);
+
 /* Return PPPoE channel specific addressing information */
 extern void pppoe_channel_addressing_get(struct ppp_channel *chan, struct pppoe_opt *addressing);
 
@@ -131,4 +135,16 @@
 /* Return PPTP session information given the channel */
 extern void pptp_channel_addressing_get(struct pptp_opt *opt, struct ppp_channel *chan);
 
+/* Enable the PPTP session offload flag */
+extern int pptp_session_enable_offload_mode(__be16 peer_call_id, __be32 peer_ip_addr);
+
+/* Disable the PPTP session offload flag */
+extern int pptp_session_disable_offload_mode(__be16 peer_call_id, __be32 peer_ip_addr);
+
+/* Register the PPTP GRE packets sequence number offload callback */
+extern int pptp_register_gre_seq_offload_callback(pptp_gre_seq_offload_callback_t pptp_client_cb);
+
+/* Unregister the PPTP GRE packets sequence number offload callback */
+extern void pptp_unregister_gre_seq_offload_callback(void);
+
 #endif /* !(__LINUX_IF_PPPOX_H) */
diff -Naur -x .git --no-dereference linux/include/linux/if_vlan.h linux-3.14/include/linux/if_vlan.h
--- linux/include/linux/if_vlan.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/if_vlan.h	2016-09-01 11:52:05.000000000 +0800
@@ -114,6 +114,7 @@
 extern struct net_device *__vlan_find_dev_deep(struct net_device *real_dev,
 					       __be16 vlan_proto, u16 vlan_id);
 extern struct net_device *vlan_dev_real_dev(const struct net_device *dev);
+extern struct net_device *vlan_dev_next_dev(const struct net_device *dev);
 extern u16 vlan_dev_vlan_id(const struct net_device *dev);
 
 /**
diff -Naur -x .git --no-dereference linux/include/linux/netdevice.h linux-3.14/include/linux/netdevice.h
--- linux/include/linux/netdevice.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/netdevice.h	2016-09-01 11:52:05.000000000 +0800
@@ -1982,11 +1982,6 @@
 	return skb->data + offset;
 }
 
-static inline void *skb_gro_mac_header(struct sk_buff *skb)
-{
-	return NAPI_GRO_CB(skb)->frag0 ?: skb_mac_header(skb);
-}
-
 static inline void *skb_gro_network_header(struct sk_buff *skb)
 {
 	return (NAPI_GRO_CB(skb)->frag0 ?: skb->data) +
diff -Naur -x .git --no-dereference linux/include/linux/qcom-tsens.h linux-3.14/include/linux/qcom-tsens.h
--- linux/include/linux/qcom-tsens.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/qcom-tsens.h	2016-09-01 11:52:05.000000000 +0800
@@ -12,12 +12,12 @@
  */
 
  /*
- * Qualcomm TSENS Header file
+ * Qualcomm Atheros TSENS Header file
  *
  */
 
-#ifndef __QCOM_TSENS_H
-#define __QCOM_TSENS_H
+#ifndef __QCA_TSENS_H
+#define __QCA_TSENS_H
 
 #define TSENS_MAX_SENSORS	11
 
@@ -39,4 +39,4 @@
 int32_t tsens_get_temp(struct tsens_device *dev, unsigned long *temp);
 int msm_tsens_early_init(struct tsens_platform_data *pdata);
 
-#endif /*QCOM_TSENS_H */
+#endif /*QCA_TSENS_H */
diff -Naur -x .git --no-dereference linux/include/linux/skbuff.h linux-3.14/include/linux/skbuff.h
--- linux/include/linux/skbuff.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/linux/skbuff.h	2016-09-01 11:52:05.000000000 +0800
@@ -549,7 +549,10 @@
 	unsigned int		truesize;
 	atomic_t		users;
 #ifdef CONFIG_DEBUG_OBJECTS_SKBUFF
-	void *			free_addr;
+#define DEBUG_OBJECTS_SKBUFF_STACKSIZE	20
+	void			*free_addr[DEBUG_OBJECTS_SKBUFF_STACKSIZE];
+	void			*alloc_addr[DEBUG_OBJECTS_SKBUFF_STACKSIZE];
+	u32			sum;
 #endif
 };
 
diff -Naur -x .git --no-dereference linux/include/net/neighbour.h linux-3.14/include/net/neighbour.h
--- linux/include/net/neighbour.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/net/neighbour.h	2016-09-01 11:52:05.000000000 +0800
@@ -225,6 +225,11 @@
 	return p->tbl->family;
 }
 
+struct neigh_mac_update {
+	unsigned char old_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
+	unsigned char update_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
+};
+
 #define NEIGH_PRIV_ALIGN	sizeof(long long)
 #define NEIGH_ENTRY_SIZE(size)	ALIGN((size), NEIGH_PRIV_ALIGN)
 
@@ -303,6 +308,9 @@
 void pneigh_for_each(struct neigh_table *tbl,
 		     void (*cb)(struct pneigh_entry *));
 
+extern void neigh_mac_update_register_notify(struct notifier_block *nb);
+extern void neigh_mac_update_unregister_notify(struct notifier_block *nb);
+
 struct neigh_seq_state {
 	struct seq_net_private p;
 	struct neigh_table *tbl;
diff -Naur -x .git --no-dereference linux/include/soc/qcom/scm.h linux-3.14/include/soc/qcom/scm.h
--- linux/include/soc/qcom/scm.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/soc/qcom/scm.h	2016-09-01 11:52:05.000000000 +0800
@@ -15,9 +15,14 @@
 #define SCM_SVC_BOOT			0x1
 #define SCM_SVC_PIL			0x2
 #define SCM_SVC_UTIL			0x3
+#define SCM_SVC_IO_ACCESS		0x5
 #define SCM_SVC_INFO			0x6
 #define SCM_SVC_FUSE			0x8
 #define SCM_SVC_TZSCHEDULER		0xFC
+
+#define SCM_IO_READ	1
+#define SCM_IO_WRITE	2
+
 extern int scm_call(u32 svc_id, u32 cmd_id, const void *cmd_buf, size_t cmd_len,
 		void *resp_buf, size_t resp_len);
 
diff -Naur -x .git --no-dereference linux/include/uapi/linux/if_bonding_genl.h linux-3.14/include/uapi/linux/if_bonding_genl.h
--- linux/include/uapi/linux/if_bonding_genl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/include/uapi/linux/if_bonding_genl.h	2016-09-01 11:52:05.000000000 +0800
@@ -0,0 +1,123 @@
+/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __LINUX_IF_BONDING_GENL_H
+#define __LINUX_IF_BONDING_GENL_H
+
+/* Bond GENL related defines - to be used by user space application for
+ * communication with bonding driver via GENL
+ */
+#define BOND_GENL_NAME "bond"
+#define BOND_GENL_VERSION 0x1
+
+/**
+ * enum bond_genl_commands - supported bonding commands
+ *
+ * @BOND_GENL_CMD_UNSPEC: unspecified command to catch errors
+ *
+ * @BOND_GENL_CMD_L2DA_SET_DEFAULT: set default L2DA slave, requires
+ *     %BOND_GENL_ATTR_BOND_NAME and %BOND_GENL_ATTR_SLAVE_NAME
+ *
+ * @BOND_GENL_CMD_L2DA_GET_DEFAULT: get default L2DA slave, requires
+ *     %BOND_GENL_ATTR_BOND_NAME
+ *     Returns the default L2DA slave name in %BOND_GENL_ATTR_SLAVE_NAME string
+ *
+ * @BOND_GENL_CMD_L2DA_ADD_MAP_ENTRY: add L2DA map entry, requires
+ *     %BOND_GENL_ATTR_BOND_NAME, %BOND_GENL_ATTR_SLAVE_NAME and
+ *     %BOND_GENL_ATTR_MAC
+ *
+ * @BOND_GENL_CMD_L2DA_DEL_MAP_ENTRY: delete L2DA map entry, requires
+ *     %BOND_GENL_ATTR_BOND_NAME and %BOND_GENL_ATTR_MAC
+ *
+ * @BOND_GENL_CMD_L2DA_GET_MAP: get entire L2DA map, requires
+ *     %BOND_GENL_ATTR_BOND_NAME
+ *     Returns the L2DA map entries as %BOND_GENL_ATTR_L2DA_MAP
+ *
+ * @BOND_GENL_CMD_L2DA_RESET_MAP: deletes all the L2DA map entries, requires
+ *     %BOND_GENL_ATTR_BOND_NAME
+ *
+ * @BOND_GENL_CMD_L2DA_SET_OPTS: set L2DA mode options, requires
+ *     %BOND_GENL_ATTR_BOND_NAME and %BOND_GENL_ATTR_L2DA_OPTS
+ *
+ * @BOND_GENL_CMD_L2DA_GET_OPTS: get L2DA mode options, requires
+ *     %BOND_GENL_ATTR_BOND_NAME
+ *     Returns L2DA mode options value in %BOND_GENL_ATTR_L2DA_OPTS
+ *
+ */
+
+enum bond_genl_commands {
+	BOND_GENL_CMD_UNSPEC,
+	BOND_GENL_CMD_L2DA_SET_DEFAULT,
+	BOND_GENL_CMD_L2DA_GET_DEFAULT,
+	BOND_GENL_CMD_L2DA_ADD_MAP_ENTRY,
+	BOND_GENL_CMD_L2DA_DEL_MAP_ENTRY,
+	BOND_GENL_CMD_L2DA_GET_MAP,
+	BOND_GENL_CMD_L2DA_RESET_MAP,
+	BOND_GENL_CMD_L2DA_SET_OPTS,
+	BOND_GENL_CMD_L2DA_GET_OPTS,
+	BOND_GENL_CMD_LAST,
+};
+
+/**
+ * enum bond_genl_attrs - bonding netlink attributes
+ *
+ * @BOND_GENL_ATTR_UNSPEC: unspecified attribute to catch errors
+ * @BOND_GENL_ATTR_BOND_NAME: bonding interface name,
+ *     enclosed data - string of max IFNAMSIZ + 1 chars
+ * @BOND_GENL_ATTR_SLAVE_NAME: slave interface name
+ *     enclosed data - string of max IFNAMSIZ + 1 chars
+ * @BOND_GENL_ATTR_MAC: MAC address,
+ *     enclosed data - ETH_ALEN bytes
+ * @BOND_GENL_ATTR_L2DA_MAP: L2DA map,
+ *     enclosed data - nested array of slave interface name/MAC address
+ *     pairs, i.e. %BOND_GENL_ATTR_SLAVE_NAME and %BOND_GENL_ATTR_MAC
+ *     correspondingly
+ * @BOND_GENL_ATTR_L2DA_OPTS: L2DA mode options, bitmask of
+ *     enum bond_genl_l2da_opts values
+ *     enclosed data - u32
+ */
+enum bond_genl_attrs {
+	BOND_GENL_ATTR_UNSPEC,
+	BOND_GENL_ATTR_BOND_NAME,
+	BOND_GENL_ATTR_SLAVE_NAME,
+	BOND_GENL_ATTR_MAC,
+	BOND_GENL_ATTR_L2DA_MAP,
+	BOND_GENL_ATTR_L2DA_OPTS,
+	BOND_GENL_ATTR_LAST,
+};
+
+/**
+ * enum bond_genl_l2da_opts -  L2DA mode related options
+ *
+ * @BOND_L2DA_OPT_DUP_MC_TX: duplicate multicast packets on TX and send them
+ *     over all the available slaves
+ * @BOND_L2DA_OPT_DEDUP_RX: de-duplicate RX traffic, allowing EAPOLs from all
+ *     interfaces and any other packets from active interface only
+ * @BOND_L2DA_OPT_FORWARD_RX: forward received packets between slaves according
+ *     to the following logic:
+ *           - for multicast packets: clone and send to all the slaves
+ *             (except the one it came from) and also deliver to local network
+ *             stack
+ *           - for unicast packets: search packet's destination address in
+ *             L2DA map; if found, send the packet to the corresponding slave;
+ *             otherwise - deliver to local network stack
+ */
+enum bond_genl_l2da_opts {
+	BOND_L2DA_OPT_DUP_MC_TX = 1<<0,
+	BOND_L2DA_OPT_DEDUP_RX  = 1<<1,
+	BOND_L2DA_OPT_FORWARD_RX  = 1<<2,
+};
+
+#endif /* __LINUX_IF_BONDING_GENL_H */
diff -Naur -x .git --no-dereference linux/include/uapi/linux/if_bonding.h linux-3.14/include/uapi/linux/if_bonding.h
--- linux/include/uapi/linux/if_bonding.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/uapi/linux/if_bonding.h	2016-09-01 11:52:05.000000000 +0800
@@ -70,6 +70,7 @@
 #define BOND_MODE_8023AD        4
 #define BOND_MODE_TLB           5
 #define BOND_MODE_ALB		6 /* TLB + RLB (receive load balancing) */
+#define BOND_MODE_L2DA          7
 
 /* each slave's link has 4 states */
 #define BOND_LINK_UP    0           /* link is up and running */
@@ -122,6 +123,8 @@
 	void (*bond_cb_link_down)(struct net_device *slave);
 	void (*bond_cb_enslave)(struct net_device *slave);
 	void (*bond_cb_release)(struct net_device *slave);
+	void (*bond_cb_delete_by_slave)(struct net_device *slave);
+	void (*bond_cb_delete_by_mac)(uint8_t *mac_addr);
 };
 
 extern void bond_register_cb(struct bond_cb *cb);
diff -Naur -x .git --no-dereference linux/include/uapi/linux/Kbuild linux-3.14/include/uapi/linux/Kbuild
--- linux/include/uapi/linux/Kbuild	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/include/uapi/linux/Kbuild	2016-09-01 11:52:05.000000000 +0800
@@ -154,6 +154,7 @@
 header-y += if_arcnet.h
 header-y += if_arp.h
 header-y += if_bonding.h
+header-y += if_bonding_genl.h
 header-y += if_bridge.h
 header-y += if_cablemodem.h
 header-y += if_eql.h
diff -Naur -x .git --no-dereference linux/lib/Kconfig.debug linux-3.14/lib/Kconfig.debug
--- linux/lib/Kconfig.debug	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/lib/Kconfig.debug	2016-09-01 11:52:05.000000000 +0800
@@ -438,6 +438,7 @@
 
 config HAVE_DEBUG_KMEMLEAK
 	bool
+	default y
 
 config DEBUG_KMEMLEAK
 	bool "Kernel memory leak detector"
diff -Naur -x .git --no-dereference linux/lib/mpi/mpi-inline.h linux-3.14/lib/mpi/mpi-inline.h
--- linux/lib/mpi/mpi-inline.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/lib/mpi/mpi-inline.h	2016-09-01 11:52:05.000000000 +0800
@@ -30,7 +30,7 @@
 #define G10_MPI_INLINE_H
 
 #ifndef G10_MPI_INLINE_DECL
-#define G10_MPI_INLINE_DECL  extern inline
+#define G10_MPI_INLINE_DECL  static inline
 #endif
 
 G10_MPI_INLINE_DECL mpi_limb_t
diff -Naur -x .git --no-dereference linux/lib/mpi/mpi-internal.h linux-3.14/lib/mpi/mpi-internal.h
--- linux/lib/mpi/mpi-internal.h	2016-04-18 10:49:07.000000000 +0800
+++ linux-3.14/lib/mpi/mpi-internal.h	2016-09-01 11:52:05.000000000 +0800
@@ -168,18 +168,22 @@
 int mpi_lshift_limbs(MPI a, unsigned int count);
 
 /*-- mpihelp-add.c --*/
+static inline
 mpi_limb_t mpihelp_add_1(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
 			 mpi_size_t s1_size, mpi_limb_t s2_limb);
 mpi_limb_t mpihelp_add_n(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
 			 mpi_ptr_t s2_ptr, mpi_size_t size);
+static inline
 mpi_limb_t mpihelp_add(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr, mpi_size_t s1_size,
 		       mpi_ptr_t s2_ptr, mpi_size_t s2_size);
 
 /*-- mpihelp-sub.c --*/
+static inline
 mpi_limb_t mpihelp_sub_1(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
 			 mpi_size_t s1_size, mpi_limb_t s2_limb);
 mpi_limb_t mpihelp_sub_n(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
 			 mpi_ptr_t s2_ptr, mpi_size_t size);
+static inline
 mpi_limb_t mpihelp_sub(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr, mpi_size_t s1_size,
 		       mpi_ptr_t s2_ptr, mpi_size_t s2_size);
 
diff -Naur -x .git --no-dereference linux/net/8021q/vlan_core.c linux-3.14/net/8021q/vlan_core.c
--- linux/net/8021q/vlan_core.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/8021q/vlan_core.c	2016-09-01 11:52:05.000000000 +0800
@@ -137,6 +137,12 @@
 }
 EXPORT_SYMBOL(vlan_dev_real_dev);
 
+struct net_device *vlan_dev_next_dev(const struct net_device *dev)
+{
+	return vlan_dev_priv(dev)->real_dev;
+}
+EXPORT_SYMBOL(vlan_dev_next_dev);
+
 u16 vlan_dev_vlan_id(const struct net_device *dev)
 {
 	return vlan_dev_priv(dev)->vlan_id;
diff -Naur -x .git --no-dereference linux/net/bridge/br_if.c linux-3.14/net/bridge/br_if.c
--- linux/net/bridge/br_if.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/bridge/br_if.c	2016-09-01 11:52:05.000000000 +0800
@@ -479,7 +479,7 @@
  * NOTE: Return NULL if given dev is not a bridge or the mac has no associated port
  */
 struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
-	struct sk_buff *skb)
+	struct sk_buff *skb, unsigned int cookie)
 {
 	struct net_bridge_fdb_entry *fdbe;
 	struct net_bridge *br;
@@ -501,7 +501,8 @@
 		port_dev_get_hook = rcu_dereference(br_port_dev_get_hook);
 		if (port_dev_get_hook) {
 			struct net_bridge_port *pdst =
-				__br_get(port_dev_get_hook, NULL, dev, skb);
+				__br_get(port_dev_get_hook, NULL, dev, skb,
+					 addr, cookie);
 			if (pdst) {
 				dev_hold(pdst->dev);
 				netdev = pdst->dev;
diff -Naur -x .git --no-dereference linux/net/core/dev.c linux-3.14/net/core/dev.c
--- linux/net/core/dev.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/core/dev.c	2016-09-01 11:52:05.000000000 +0800
@@ -3887,10 +3887,10 @@
 		diffs |= p->vlan_tci ^ skb->vlan_tci;
 		if (maclen == ETH_HLEN)
 			diffs |= compare_ether_header(skb_mac_header(p),
-						      skb_gro_mac_header(skb));
+						      skb_mac_header(skb));
 		else if (!diffs)
 			diffs = memcmp(skb_mac_header(p),
-				       skb_gro_mac_header(skb),
+				       skb_mac_header(skb),
 				       maclen);
 		NAPI_GRO_CB(p)->same_flow = !diffs;
 	}
@@ -3913,6 +3913,27 @@
 	}
 }
 
+static void gro_pull_from_frag0(struct sk_buff *skb, int grow)
+{
+	struct skb_shared_info *pinfo = skb_shinfo(skb);
+
+	BUG_ON(skb->end - skb->tail < grow);
+
+	memcpy(skb_tail_pointer(skb), NAPI_GRO_CB(skb)->frag0, grow);
+
+	skb->data_len -= grow;
+	skb->tail += grow;
+
+	pinfo->frags[0].page_offset += grow;
+	skb_frag_size_sub(&pinfo->frags[0], grow);
+
+	if (unlikely(!skb_frag_size(&pinfo->frags[0]))) {
+		skb_frag_unref(skb, 0);
+		memmove(pinfo->frags, pinfo->frags + 1,
+			--pinfo->nr_frags * sizeof(pinfo->frags[0]));
+	}
+}
+
 static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)
 {
 	struct sk_buff **pp = NULL;
@@ -3921,6 +3942,7 @@
 	struct list_head *head = &offload_base;
 	int same_flow;
 	enum gro_result ret;
+	int grow;
 
 	if (!(skb->dev->features & NETIF_F_GRO) || netpoll_rx_on(skb))
 		goto normal;
@@ -3928,7 +3950,6 @@
 	if (skb_is_gso(skb) || skb_has_frag_list(skb))
 		goto normal;
 
-	skb_gro_reset_offset(skb);
 	gro_list_prepare(napi, skb);
 	NAPI_GRO_CB(skb)->csum = skb->csum; /* Needed for CHECKSUM_COMPLETE */
 
@@ -3993,27 +4014,9 @@
 	ret = GRO_HELD;
 
 pull:
-	if (skb_headlen(skb) < skb_gro_offset(skb)) {
-		int grow = skb_gro_offset(skb) - skb_headlen(skb);
-
-		BUG_ON(skb->end - skb->tail < grow);
-
-		memcpy(skb_tail_pointer(skb), NAPI_GRO_CB(skb)->frag0, grow);
-
-		skb->tail += grow;
-		skb->data_len -= grow;
-
-		skb_shinfo(skb)->frags[0].page_offset += grow;
-		skb_frag_size_sub(&skb_shinfo(skb)->frags[0], grow);
-
-		if (unlikely(!skb_frag_size(&skb_shinfo(skb)->frags[0]))) {
-			skb_frag_unref(skb, 0);
-			memmove(skb_shinfo(skb)->frags,
-				skb_shinfo(skb)->frags + 1,
-				--skb_shinfo(skb)->nr_frags * sizeof(skb_frag_t));
-		}
-	}
-
+	grow = skb_gro_offset(skb) - skb_headlen(skb);
+	if (grow > 0)
+		gro_pull_from_frag0(skb, grow);
 ok:
 	return ret;
 
@@ -4082,6 +4085,8 @@
 {
 	trace_napi_gro_receive_entry(skb);
 
+	skb_gro_reset_offset(skb);
+
 	return napi_skb_finish(dev_gro_receive(napi, skb), skb);
 }
 EXPORT_SYMBOL(napi_gro_receive);
@@ -4113,12 +4118,16 @@
 }
 EXPORT_SYMBOL(napi_get_frags);
 
-static gro_result_t napi_frags_finish(struct napi_struct *napi, struct sk_buff *skb,
-			       gro_result_t ret)
+static gro_result_t napi_frags_finish(struct napi_struct *napi,
+				      struct sk_buff *skb,
+				      gro_result_t ret)
 {
 	switch (ret) {
 	case GRO_NORMAL:
-		if (netif_receive_skb_internal(skb))
+	case GRO_HELD:
+		__skb_push(skb, ETH_HLEN);
+		skb->protocol = eth_type_trans(skb, skb->dev);
+		if (ret == GRO_NORMAL && netif_receive_skb_internal(skb))
 			ret = GRO_DROP;
 		break;
 
@@ -4127,7 +4136,6 @@
 		napi_reuse_skb(napi, skb);
 		break;
 
-	case GRO_HELD:
 	case GRO_MERGED:
 		break;
 	}
@@ -4135,17 +4143,41 @@
 	return ret;
 }
 
+/* Upper GRO stack assumes network header starts at gro_offset=0
+ * Drivers could call both napi_gro_frags() and napi_gro_receive()
+ * We copy ethernet header into skb->data to have a common layout.
+ */
 static struct sk_buff *napi_frags_skb(struct napi_struct *napi)
 {
 	struct sk_buff *skb = napi->skb;
+	const struct ethhdr *eth;
+	unsigned int hlen = sizeof(*eth);
 
 	napi->skb = NULL;
 
-	if (unlikely(!pskb_may_pull(skb, sizeof(struct ethhdr)))) {
-		napi_reuse_skb(napi, skb);
-		return NULL;
-	}
-	skb->protocol = eth_type_trans(skb, skb->dev);
+	skb_reset_mac_header(skb);
+	skb_gro_reset_offset(skb);
+
+	eth = skb_gro_header_fast(skb, 0);
+	if (unlikely(skb_gro_header_hard(skb, hlen))) {
+		eth = skb_gro_header_slow(skb, hlen, 0);
+		if (unlikely(!eth)) {
+			napi_reuse_skb(napi, skb);
+			return NULL;
+		}
+	} else {
+		gro_pull_from_frag0(skb, hlen);
+		NAPI_GRO_CB(skb)->frag0 += hlen;
+		NAPI_GRO_CB(skb)->frag0_len -= hlen;
+	}
+	__skb_pull(skb, hlen);
+
+	/*
+	 * This works because the only protocols we care about don't require
+	 * special handling.
+	 * We'll fix it up properly in napi_frags_finish()
+	 */
+	skb->protocol = eth->h_proto;
 
 	return skb;
 }
diff -Naur -x .git --no-dereference linux/net/core/neighbour.c linux-3.14/net/core/neighbour.c
--- linux/net/core/neighbour.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/core/neighbour.c	2016-09-01 11:52:05.000000000 +0800
@@ -1054,7 +1054,19 @@
 	}
 }
 
+ATOMIC_NOTIFIER_HEAD(neigh_mac_update_notifier_list);
 
+void neigh_mac_update_register_notify(struct notifier_block *nb)
+{
+	atomic_notifier_chain_register(&neigh_mac_update_notifier_list, nb);
+}
+EXPORT_SYMBOL_GPL(neigh_mac_update_register_notify);
+
+void neigh_mac_update_unregister_notify(struct notifier_block *nb)
+{
+	atomic_notifier_chain_unregister(&neigh_mac_update_notifier_list, nb);
+}
+EXPORT_SYMBOL_GPL(neigh_mac_update_unregister_notify);
 
 /* Generic update routine.
    -- lladdr is new lladdr or NULL, if it is not supplied.
@@ -1085,6 +1097,7 @@
 	int notify = 0;
 	struct net_device *dev;
 	int update_isrouter = 0;
+	struct neigh_mac_update nmu;
 
 	write_lock_bh(&neigh->lock);
 
@@ -1092,6 +1105,8 @@
 	old    = neigh->nud_state;
 	err    = -EPERM;
 
+	memset(&nmu, 0, sizeof(struct neigh_mac_update));
+
 	if (!(flags & NEIGH_UPDATE_F_ADMIN) &&
 	    (old & (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
@@ -1120,7 +1135,11 @@
 		   and a new address is proposed:
 		   - compare new & old
 		   - if they are different, check override flag
+		   - copy old and new addresses for neigh update notification
 		 */
+		memcpy(nmu.old_mac, neigh->ha, dev->addr_len);
+		memcpy(nmu.update_mac, lladdr, dev->addr_len);
+
 		if ((old & NUD_VALID) &&
 		    !memcmp(lladdr, neigh->ha, dev->addr_len))
 			lladdr = neigh->ha;
@@ -1232,8 +1251,11 @@
 	}
 	write_unlock_bh(&neigh->lock);
 
-	if (notify)
+	if (notify) {
 		neigh_update_notify(neigh);
+		atomic_notifier_call_chain(&neigh_mac_update_notifier_list, 0,
+					   (struct neigh_mac_update *)&nmu);
+	}
 
 	return err;
 }
diff -Naur -x .git --no-dereference linux/net/core/skbuff.c linux-3.14/net/core/skbuff.c
--- linux/net/core/skbuff.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/core/skbuff.c	2016-09-01 11:52:05.000000000 +0800
@@ -167,6 +167,7 @@
 				    gfp_mask & ~__GFP_DMA, node);
 	if (!skb)
 		goto out;
+	skbuff_debugobj_init_and_activate(skb);
 
 	/*
 	 * Only clear those fields we need to clear, not those that we will
@@ -179,7 +180,6 @@
 	atomic_set(&skb->users, 1);
 
 	skb->mac_header = (typeof(skb->mac_header))~0U;
-	skbuff_debugobj_init_and_activate(skb);
 out:
 	return skb;
 }
@@ -220,6 +220,7 @@
 	skb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);
 	if (!skb)
 		goto out;
+	skbuff_debugobj_init_and_activate(skb);
 	prefetchw(skb);
 
 	/* We do our best to align skb_shared_info on a separate cache
@@ -274,10 +275,10 @@
 		child->fclone = SKB_FCLONE_UNAVAILABLE;
 		child->pfmemalloc = pfmemalloc;
 	}
-	skbuff_debugobj_init_and_activate(skb);
 out:
 	return skb;
 nodata:
+	skbuff_debugobj_deactivate(skb);
 	kmem_cache_free(cache, skb);
 	skb = NULL;
 	goto out;
@@ -312,6 +313,7 @@
 	skb = kmem_cache_alloc(skbuff_head_cache, GFP_ATOMIC);
 	if (!skb)
 		return NULL;
+	skbuff_debugobj_init_and_activate(skb);
 
 	size -= SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
@@ -331,8 +333,6 @@
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
-	skbuff_debugobj_init_and_activate(skb);
-
 	return skb;
 }
 
@@ -963,11 +963,11 @@
 		n = kmem_cache_alloc(skbuff_head_cache, gfp_mask);
 		if (!n)
 			return NULL;
+		skbuff_debugobj_init_and_activate(n);
 
 		kmemcheck_annotate_bitfield(n, flags1);
 		kmemcheck_annotate_bitfield(n, flags2);
 		n->fclone = SKB_FCLONE_UNAVAILABLE;
-		skbuff_debugobj_init_and_activate(n);
 	}
 
 	return __skb_clone(n, skb);
@@ -3924,8 +3924,8 @@
 {
 	if (head_stolen) {
 		skb_release_head_state(skb);
-		kmem_cache_free(skbuff_head_cache, skb);
 		skbuff_debugobj_deactivate(skb);
+		kmem_cache_free(skbuff_head_cache, skb);
 	} else {
 		__kfree_skb(skb);
 	}
diff -Naur -x .git --no-dereference linux/net/core/skbuff_debug.c linux-3.14/net/core/skbuff_debug.c
--- linux/net/core/skbuff_debug.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/core/skbuff_debug.c	2016-09-01 11:52:05.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -14,12 +14,87 @@
  */
 
 #include <asm/stacktrace.h>
+#include <asm/current.h>
+#include <linux/sched.h>
 #include <linux/module.h>
 
 #include "skbuff_debug.h"
 
 static int skbuff_debugobj_enabled __read_mostly = 1;
 
+inline u32 skbuff_debugobj_sum(struct sk_buff *skb)
+{
+	int pos = offsetof(struct sk_buff, free_addr);
+	u32 sum = 0;
+
+	while (pos--)
+		sum += ((u8 *)skb)[pos];
+
+	return sum;
+}
+
+struct skbuff_debugobj_walking {
+	int pos;
+	void **d;
+};
+
+static int skbuff_debugobj_walkstack(struct stackframe *frame, void *p)
+{
+	struct skbuff_debugobj_walking *w = (struct skbuff_debugobj_walking *)p;
+	u32 pc = frame->pc;
+
+	if (w->pos < DEBUG_OBJECTS_SKBUFF_STACKSIZE - 1) {
+		w->d[w->pos++] = (void *)pc;
+		return 0;
+	}
+
+	return -ENOENT;
+}
+
+#ifdef CONFIG_ARM
+static void skbuff_debugobj_get_stack(void **ret)
+{
+	struct stackframe frame;
+	register unsigned long current_sp asm ("sp");
+	struct skbuff_debugobj_walking w = {0, ret};
+	void *p = &w;
+
+	frame.fp = (unsigned long)__builtin_frame_address(0);
+	frame.sp = current_sp;
+	frame.lr = (unsigned long)__builtin_return_address(0);
+	frame.pc = (unsigned long)skbuff_debugobj_get_stack;
+
+	walk_stackframe(&frame, skbuff_debugobj_walkstack, p);
+
+	ret[w.pos] = NULL;
+}
+#else
+#error
+static void skbuff_debugobj_get_stack(void **ret)
+{
+	/* not supported */
+	ret[0] = 0xdeadbeef;
+}
+#endif
+
+void skbuff_debugobj_print_stack(void **stack)
+{
+	int i;
+
+	for (i = 0; stack[i]; i++)
+		pr_emerg("\t %pS (0x%p)\n", stack[i], stack[i]);
+}
+
+void skbuff_debugobj_print_skb(struct sk_buff *skb)
+{
+	pr_emerg("skb_debug: current process = %s (pid %i)\n",
+			current->comm, current->pid);
+	pr_emerg("skbuff_debug: free stack:\n");
+	skbuff_debugobj_print_stack(skb->free_addr);
+	pr_emerg("skbuff_debug: alloc stack:\n");
+	skbuff_debugobj_print_stack(skb->alloc_addr);
+}
+
 /*
  * skbuff_debugobj_fixup():
  *      Called when an error is detected in the state machine for
@@ -29,8 +104,9 @@
 {
 	struct sk_buff *skb = (struct sk_buff *)addr;
 	ftrace_dump(DUMP_ALL);
-	pr_emerg("skbuff_debug: state = %d, skb = 0x%p last free = %pS\n",
-			state, skb, skb->free_addr);
+	pr_emerg("skbuff_debug: state = %d, skb = 0x%p sum = %d (%d)\n",
+			state, skb, skb->sum, skbuff_debugobj_sum(skb));
+	skbuff_debugobj_print_skb(skb);
 	BUG();
 
 	return 0;
@@ -46,19 +122,26 @@
 
 inline void skbuff_debugobj_activate(struct sk_buff *skb)
 {
-	int ret;
+	int ret = 0;
 
 	if (!skbuff_debugobj_enabled)
 		return;
 
+	skbuff_debugobj_get_stack(skb->alloc_addr);
 	ret = debug_object_activate(skb, &skbuff_debug_descr);
+	if (ret)
+		goto err_act;
 
-	if (ret) {
-		ftrace_dump(DUMP_ALL);
-		pr_emerg("skb_debug: failed to activate err = %d skb = 0x%p last free=%pS\n",
-				ret, skb, skb->free_addr);
-		BUG();
-	}
+	skbuff_debugobj_sum_validate(skb);
+
+	return;
+
+err_act:
+	ftrace_dump(DUMP_ALL);
+	pr_emerg("skb_debug: failed to activate err = %d skb = 0x%p sum = %d (%d)\n",
+			ret, skb, skb->sum, skbuff_debugobj_sum(skb));
+	skbuff_debugobj_print_skb(skb);
+	BUG();
 }
 
 inline void skbuff_debugobj_init_and_activate(struct sk_buff *skb)
@@ -66,50 +149,14 @@
 	if (!skbuff_debugobj_enabled)
 		return;
 
+	/* if we're coming from the slab, the skb->sum might
+	 * be invalid anyways */
+	skb->sum = skbuff_debugobj_sum(skb);
+
 	debug_object_init(skb, &skbuff_debug_descr);
 	skbuff_debugobj_activate(skb);
 }
 
-static int skbuff_debugobj_walkstack(struct stackframe *frame, void *d)
-{
-	u32 *pc = d;
-
-	*pc = frame->pc;
-
-	/* walk to outside kernel address space (e.g. module)
-	 * for the time being, need a whitelist here in the
-	 * future most likely */
-	if (is_module_text_address(*pc))
-		return -1;
-
-	return 0;
-}
-
-#ifdef CONFIG_ARM
-static void *skbuff_debugobj_get_free_addr(void)
-{
-	struct stackframe frame;
-	register unsigned long current_sp asm ("sp");
-	void *ret = NULL;
-
-	frame.fp = (unsigned long)__builtin_frame_address(0);
-	frame.sp = current_sp;
-	frame.lr = (unsigned long)__builtin_return_address(0);
-	frame.pc = (unsigned long)skbuff_debugobj_get_free_addr;
-
-	walk_stackframe(&frame, skbuff_debugobj_walkstack, &ret);
-
-	return ret;
-}
-#else
-#error
-static void *skbuff_debugobj_get_free_addr(void)
-{
-	/* not supported */
-	return 0xdeadbeef;
-}
-#endif
-
 inline void skbuff_debugobj_deactivate(struct sk_buff *skb)
 {
 	int obj_state;
@@ -117,20 +164,47 @@
 	if (!skbuff_debugobj_enabled)
 		return;
 
+	skb->sum = skbuff_debugobj_sum(skb);
+
 	obj_state = debug_object_get_state(skb);
 
 	if (obj_state == ODEBUG_STATE_ACTIVE) {
 		debug_object_deactivate(skb, &skbuff_debug_descr);
-		skb->free_addr = skbuff_debugobj_get_free_addr();
+		skbuff_debugobj_get_stack(skb->free_addr);
 		return;
 	}
 
 	ftrace_dump(DUMP_ALL);
-	pr_emerg("skbuff_debug: deactivating inactive object skb=0x%p state=%d last free=%pS\n",
-			skb, obj_state, skb->free_addr);
+	pr_emerg("skbuff_debug: deactivating inactive object skb=0x%p state=%d sum = %d (%d)\n",
+			skb, obj_state, skb->sum, skbuff_debugobj_sum(skb));
+	skbuff_debugobj_print_skb(skb);
 	BUG();
 }
 
+inline void skbuff_debugobj_sum_validate(struct sk_buff *skb)
+{
+
+	if (!skbuff_debugobj_enabled || skb == NULL)
+		return;
+
+	if (skb->sum == skbuff_debugobj_sum(skb))
+		return;
+
+	ftrace_dump(DUMP_ALL);
+	pr_emerg("skb_debug: skb changed while deactive skb = 0x%p sum = %d (%d)\n",
+			skb, skb->sum, skbuff_debugobj_sum(skb));
+	skbuff_debugobj_print_skb(skb);
+	BUG();
+}
+
+inline void skbuff_debugobj_sum_update(struct sk_buff *skb)
+{
+	if (!skbuff_debugobj_enabled || skb == NULL)
+		return;
+
+	skb->sum = skbuff_debugobj_sum(skb);
+}
+
 inline void skbuff_debugobj_destroy(struct sk_buff *skb)
 {
 	if (!skbuff_debugobj_enabled)
diff -Naur -x .git --no-dereference linux/net/core/skbuff_debug.h linux-3.14/net/core/skbuff_debug.h
--- linux/net/core/skbuff_debug.h	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/core/skbuff_debug.h	2016-09-01 11:52:05.000000000 +0800
@@ -24,11 +24,15 @@
 void skbuff_debugobj_activate(struct sk_buff *skb);
 void skbuff_debugobj_deactivate(struct sk_buff *skb);
 void skbuff_debugobj_destroy(struct sk_buff *skb);
+void skbuff_debugobj_sum_validate(struct sk_buff *skb);
+void skbuff_debugobj_sum_update(struct sk_buff *skb);
 #else
 static inline void skbuff_debugobj_init_and_activate(struct sk_buff *skb) { }
 static inline void skbuff_debugobj_activate(struct sk_buff *skb) { }
 static inline void skbuff_debugobj_deactivate(struct sk_buff *skb) { }
 static inline void skbuff_debugobj_destroy(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_sum_validate(struct sk_buff *skb) { }
+static inline void skbuff_debugobj_sum_update(struct sk_buff *skb) { }
 #endif
 
 #endif /* _LINUX_SKBBUFF_DEBUG_OBJECTS */
diff -Naur -x .git --no-dereference linux/net/core/skbuff_recycle.c linux-3.14/net/core/skbuff_recycle.c
--- linux/net/core/skbuff_recycle.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/core/skbuff_recycle.c	2016-09-01 11:52:05.000000000 +0800
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -40,6 +40,7 @@
 	unsigned long flags;
 	struct sk_buff_head *h;
 	struct sk_buff *skb = NULL;
+	struct sk_buff *ln = NULL;
 
 	if (unlikely(length > SKB_RECYCLE_SIZE)) {
 		return NULL;
@@ -47,7 +48,17 @@
 
 	h = &get_cpu_var(recycle_list);
 	local_irq_save(flags);
-	skb = __skb_dequeue(h);
+	skb = skb_peek(h);
+	if (skb) {
+		ln = skb_peek_next(skb, h);
+		skbuff_debugobj_activate(skb);
+		/* Recalculate the sum for skb->next as next and prev pointers
+		 * of skb->next will be updated in __skb_unlink
+		 */
+		skbuff_debugobj_sum_validate(ln);
+		__skb_unlink(skb, h);
+		skbuff_debugobj_sum_update(ln);
+	}
 #ifdef CONFIG_SKB_RECYCLER_MULTI_CPU
 	if (unlikely(!skb)) {
 		uint8_t head;
@@ -55,13 +66,32 @@
 		/* If global recycle list is not empty, use global buffers */
 		head = glob_recycler.head;
 		if (likely(head != glob_recycler.tail)) {
+			struct sk_buff *gn = glob_recycler.pool[head].next;
+			struct sk_buff *gp = glob_recycler.pool[head].prev;
+
 			/* Move SKBs from global list to CPU pool */
+			skbuff_debugobj_sum_validate(gn);
+			skbuff_debugobj_sum_validate(gp);
 			skb_queue_splice_init(&glob_recycler.pool[head], h);
+			skbuff_debugobj_sum_update(gn);
+			skbuff_debugobj_sum_update(gp);
+
 			head = (head + 1) & SKB_RECYCLE_MAX_SHARED_POOLS_MASK;
 			glob_recycler.head = head;
 			spin_unlock(&glob_recycler.lock);
 			/* We have refilled the CPU pool - dequeue */
-			skb = __skb_dequeue(h);
+			skb = skb_peek(h);
+			if (skb) {
+				/* Recalculate the sum for skb->next as next and
+				 * prev pointers of skb->next will be updated
+				 * in __skb_unlink
+				 */
+				ln = skb_peek_next(skb, h);
+				skbuff_debugobj_activate(skb);
+				skbuff_debugobj_sum_validate(ln);
+				__skb_unlink(skb, h);
+				skbuff_debugobj_sum_update(ln);
+			}
 		} else {
 			spin_unlock(&glob_recycler.lock);
 		}
@@ -92,7 +122,6 @@
 		skb_reset_tail_pointer(skb);
 
 		skb->dev = dev;
-		skbuff_debugobj_activate(skb);
 	}
 
 	return skb;
@@ -102,7 +131,7 @@
 {
 	unsigned long flags;
 	struct sk_buff_head *h;
-
+	struct sk_buff *ln = NULL;
 	/* Can we recycle this skb?  If not, simply return that we cannot */
 	if (unlikely(!consume_skb_can_recycle(skb, SKB_RECYCLE_MIN_SIZE,
 					      SKB_RECYCLE_MAX_SIZE)))
@@ -116,8 +145,14 @@
 	local_irq_save(flags);
 	/* Attempt to enqueue the CPU hot recycle list first */
 	if (likely(skb_queue_len(h) < skb_recycle_max_skbs)) {
+		ln = skb_peek(h);
+		/* Recalculate the sum for peek of list as next and prev
+		 * pointers of skb->next will be updated in __skb_queue_head
+		 */
+		skbuff_debugobj_sum_validate(ln);
 		__skb_queue_head(h, skb);
 		skbuff_debugobj_deactivate(skb);
+		skbuff_debugobj_sum_update(ln);
 		local_irq_restore(flags);
 		preempt_enable();
 		return true;
@@ -136,18 +171,30 @@
 		next_tail = (cur_tail + 1) & SKB_RECYCLE_MAX_SHARED_POOLS_MASK;
 		if (next_tail != glob_recycler.head) {
 			struct sk_buff_head *p = &glob_recycler.pool[cur_tail];
+			struct sk_buff *hn = h->next, *hp = h->prev;
 
 			/* Move SKBs from CPU pool to Global pool*/
+			skbuff_debugobj_sum_validate(hp);
+			skbuff_debugobj_sum_validate(hn);
 			skb_queue_splice_init(h, p);
+			skbuff_debugobj_sum_update(hp);
+			skbuff_debugobj_sum_update(hn);
 
 			/* Done with global list init */
 			glob_recycler.tail = next_tail;
 			spin_unlock(&glob_recycler.lock);
 
+			/* Recalculate the sum for peek of list as next and prev
+			 * pointers of skb->next will be updated in
+			 * __skb_queue_head
+			 */
+			ln = skb_peek(h);
+			skbuff_debugobj_sum_validate(ln);
 			/* We have now cleared room in the spare;
 			 * Intialize and enqueue skb into spare
 			 */
 			__skb_queue_head(h, skb);
+			skbuff_debugobj_sum_update(ln);
 			skbuff_debugobj_deactivate(skb);
 
 			local_irq_restore(flags);
@@ -158,8 +205,14 @@
 		spin_unlock(&glob_recycler.lock);
 	} else {
 		/* We have room in the spare list; enqueue to spare list */
+		ln = skb_peek(h);
+		/* Recalculate the sum for peek of list as next and prev
+		 * pointers of skb->next will be updated in __skb_queue_head
+		 */
+		skbuff_debugobj_sum_validate(ln);
 		__skb_queue_head(h, skb);
 		skbuff_debugobj_deactivate(skb);
+		skbuff_debugobj_sum_update(ln);
 		local_irq_restore(flags);
 		preempt_enable();
 		return true;
@@ -175,14 +228,18 @@
 static void skb_recycler_free_skb(struct sk_buff_head *list)
 {
 	struct sk_buff *skb = NULL;
+	unsigned long flags;
 
-	while ((skb = skb_dequeue(list)) != NULL) {
-		skb_release_data(skb);
+	spin_lock_irqsave(&list->lock, flags);
+	while ((skb = skb_peek(list)) != NULL) {
 		skbuff_debugobj_activate(skb);
+		__skb_unlink(skb, list);
+		skb_release_data(skb);
 		kfree_skbmem(skb);
 	}
-
+	spin_unlock_irqrestore(&list->lock, flags);
 }
+
 static int skb_cpu_callback(struct notifier_block *nfb,
 		unsigned long action, void *ocpu)
 {
diff -Naur -x .git --no-dereference linux/net/ipv4/esp4.c linux-3.14/net/ipv4/esp4.c
--- linux/net/ipv4/esp4.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/ipv4/esp4.c	2016-09-01 11:52:05.000000000 +0800
@@ -135,12 +135,19 @@
 	int sglists;
 	int seqhilen;
 	__be32 *seqhi;
+	bool nosupp_sg;
 
 	/* skb is pure payload to encrypt */
 
 	aead = x->data;
 	alen = crypto_aead_authsize(aead);
 
+	nosupp_sg = crypto_tfm_alg_flags(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
+	if (nosupp_sg && skb_linearize(skb)) {
+		err = -ENOMEM;
+		goto error;
+	}
+
 	tfclen = 0;
 	if (x->tfcpad) {
 		struct xfrm_dst *dst = (struct xfrm_dst *)skb_dst(skb);
@@ -385,6 +392,7 @@
 	struct scatterlist *sg;
 	struct scatterlist *asg;
 	int err = -EINVAL;
+	bool nosupp_sg;
 
 	if (!pskb_may_pull(skb, sizeof(*esph) + crypto_aead_ivsize(aead)))
 		goto out;
@@ -392,6 +400,12 @@
 	if (elen <= 0)
 		goto out;
 
+	nosupp_sg = crypto_tfm_alg_flags(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
+	if (nosupp_sg && skb_linearize(skb)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
 	if ((err = skb_cow_data(skb, 0, &trailer)) < 0)
 		goto out;
 	nfrags = err;
diff -Naur -x .git --no-dereference linux/net/ipv4/ipmr.c linux-3.14/net/ipv4/ipmr.c
--- linux/net/ipv4/ipmr.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/ipv4/ipmr.c	2016-09-01 11:52:05.000000000 +0800
@@ -1320,6 +1320,7 @@
 {
 	int line;
 	struct mfc_cache *c, *next;
+	uint32_t origin, group;
 
 	line = MFC_HASH(mfc->mfcc_mcastgrp.s_addr, mfc->mfcc_origin.s_addr);
 
@@ -1327,13 +1328,14 @@
 		if (c->mfc_origin == mfc->mfcc_origin.s_addr &&
 		    c->mfc_mcastgrp == mfc->mfcc_mcastgrp.s_addr &&
 		    (parent == -1 || parent == c->mfc_parent)) {
-			/*
-			 * Inform offload modules of the delete event
-			 */
-			ipmr_sync_entry_delete(c->mfc_origin, c->mfc_mcastgrp);
+			origin = c->mfc_origin;
+			group = c->mfc_mcastgrp;
 			list_del_rcu(&c->list);
 			mroute_netlink_event(mrt, c, RTM_DELROUTE);
 			ipmr_cache_free(c);
+
+			/* Inform offload modules of the delete event */
+			ipmr_sync_entry_delete(origin, group);
 			return 0;
 		}
 	}
diff -Naur -x .git --no-dereference linux/net/ipv6/esp6.c linux-3.14/net/ipv6/esp6.c
--- linux/net/ipv6/esp6.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/ipv6/esp6.c	2016-09-01 11:52:05.000000000 +0800
@@ -163,11 +163,18 @@
 	u8 *iv;
 	u8 *tail;
 	__be32 *seqhi;
+	bool nosupp_sg;
 
 	/* skb is pure payload to encrypt */
 	aead = x->data;
 	alen = crypto_aead_authsize(aead);
 
+	nosupp_sg = crypto_tfm_alg_flags(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
+	if (nosupp_sg && skb_linearize(skb)) {
+		err = -ENOMEM;
+		goto error;
+	}
+
 	tfclen = 0;
 	if (x->tfcpad) {
 		struct xfrm_dst *dst = (struct xfrm_dst *)skb_dst(skb);
@@ -334,6 +341,7 @@
 	u8 *iv;
 	struct scatterlist *sg;
 	struct scatterlist *asg;
+	bool nosupp_sg;
 
 	if (!pskb_may_pull(skb, sizeof(*esph) + crypto_aead_ivsize(aead))) {
 		ret = -EINVAL;
@@ -345,6 +353,12 @@
 		goto out;
 	}
 
+	nosupp_sg = crypto_tfm_alg_flags(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
+	if (nosupp_sg && skb_linearize(skb)) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
 	if ((nfrags = skb_cow_data(skb, 0, &trailer)) < 0) {
 		ret = -EINVAL;
 		goto out;
diff -Naur -x .git --no-dereference linux/net/ipv6/ip6mr.c linux-3.14/net/ipv6/ip6mr.c
--- linux/net/ipv6/ip6mr.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/ipv6/ip6mr.c	2016-09-01 11:52:05.000000000 +0800
@@ -404,9 +404,9 @@
  * Call the registered offload callback to inform of a multicast route entry
  * delete event
  */
-static void ip6mr_sync_entry_delete(struct mfc6_cache *c)
+static void ip6mr_sync_entry_delete(struct in6_addr *mc_origin,
+					struct in6_addr *mc_group)
 {
-	struct in6_addr mc_origin, mc_group;
 	ip6mr_mfc_event_offload_callback_t offload_update_cb_f;
 
 	rcu_read_lock();
@@ -416,12 +416,7 @@
 	if (!offload_update_cb_f)
 		return;
 
-	read_lock(&mrt_lock);
-	memcpy(&mc_origin, &c->mf6c_origin, sizeof(struct in6_addr));
-	memcpy(&mc_group, &c->mf6c_mcastgrp, sizeof(struct in6_addr));
-	read_unlock(&mrt_lock);
-
-	offload_update_cb_f(&mc_group, &mc_origin, 0, NULL,
+	offload_update_cb_f(mc_group, mc_origin, 0, NULL,
 				IP6MR_MFC_EVENT_DELETE);
 }
 
@@ -1525,6 +1520,7 @@
 {
 	int line;
 	struct mfc6_cache *c, *next;
+	struct in6_addr mc_origin, mc_group;
 
 	line = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);
 
@@ -1533,10 +1529,11 @@
 		    ipv6_addr_equal(&c->mf6c_mcastgrp,
 				    &mfc->mf6cc_mcastgrp.sin6_addr) &&
 		    (parent == -1 || parent == c->mf6c_parent)) {
-			/*
-			 * Inform offload modules of the delete event
-			 */
-			ip6mr_sync_entry_delete(c);
+
+			memcpy(&mc_origin, &c->mf6c_origin,
+					sizeof(struct in6_addr));
+			memcpy(&mc_group, &c->mf6c_mcastgrp,
+					sizeof(struct in6_addr));
 
 			write_lock_bh(&mrt_lock);
 			list_del(&c->list);
@@ -1544,6 +1541,9 @@
 
 			mr6_netlink_event(mrt, c, RTM_DELROUTE);
 			ip6mr_cache_free(c);
+
+			/* Inform offload modules of the delete event */
+			ip6mr_sync_entry_delete(&mc_origin, &mc_group);
 			return 0;
 		}
 	}
diff -Naur -x .git --no-dereference linux/net/ipv6/route.c linux-3.14/net/ipv6/route.c
--- linux/net/ipv6/route.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/ipv6/route.c	2016-09-01 11:52:05.000000000 +0800
@@ -887,9 +887,6 @@
 	err = fib6_add(&table->tb6_root, rt, info);
 	write_unlock_bh(&table->tb6_lock);
 
-	if (!err)
-		atomic_notifier_call_chain(&ip6route_chain,
-						RTM_NEWROUTE, rt);
 	return err;
 }
 
@@ -1722,7 +1719,11 @@
 
 	cfg->fc_nlinfo.nl_net = dev_net(dev);
 
-	return __ip6_ins_rt(rt, &cfg->fc_nlinfo);
+	err = __ip6_ins_rt(rt, &cfg->fc_nlinfo);
+	if (!err)
+		atomic_notifier_call_chain(&ip6route_chain, RTM_NEWROUTE, rt);
+
+	return err;
 
 out:
 	if (dev)
diff -Naur -x .git --no-dereference linux/net/netfilter/Kconfig linux-3.14/net/netfilter/Kconfig
--- linux/net/netfilter/Kconfig	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/netfilter/Kconfig	2016-09-01 11:52:05.000000000 +0800
@@ -782,6 +782,15 @@
 	(e.g. when running oldconfig). It selects
 	CONFIG_NETFILTER_XT_MARK (combined mark/MARK module).
 
+config NETFILTER_XT_TARGET_MARK2PRIO
+	tristate "mark2prio target support"
+	default m if NETFILTER_ADVANCED=n
+	select NETFILTER_XT_CONNMARK
+	help
+	  Move skb's mark to priority field if selected
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_TARGET_NETMAP
 	tristate '"NETMAP" target support'
 	depends on NF_NAT
diff -Naur -x .git --no-dereference linux/net/netfilter/Makefile linux-3.14/net/netfilter/Makefile
--- linux/net/netfilter/Makefile	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/netfilter/Makefile	2016-09-01 11:52:05.000000000 +0800
@@ -108,6 +108,7 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_LOG) += xt_LOG.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NETMAP) += xt_NETMAP.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NFLOG) += xt_NFLOG.o
+obj-$(CONFIG_NETFILTER_XT_TARGET_MARK2PRIO) += xt_mark2prio.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_NFQUEUE) += xt_NFQUEUE.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_RATEEST) += xt_RATEEST.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_REDIRECT) += xt_REDIRECT.o
diff -Naur -x .git --no-dereference linux/net/netfilter/nf_conntrack_ftp.c linux-3.14/net/netfilter/nf_conntrack_ftp.c
--- linux/net/netfilter/nf_conntrack_ftp.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/net/netfilter/nf_conntrack_ftp.c	2016-09-01 11:52:05.000000000 +0800
@@ -538,7 +538,9 @@
 	else {
 		/* Can't expect this?  Best to drop packet now. */
 		if (nf_ct_expect_related(exp) != 0) {
-			nf_ct_helper_log(skb, ct, "cannot add expectation");
+			if (net_ratelimit())
+				nf_ct_helper_log(skb, ct,
+					"cannot add expectation");
 			ret = NF_DROP;
 		} else
 			ret = NF_ACCEPT;
diff -Naur -x .git --no-dereference linux/net/netfilter/xt_mark2prio.c linux-3.14/net/netfilter/xt_mark2prio.c
--- linux/net/netfilter/xt_mark2prio.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14/net/netfilter/xt_mark2prio.c	2016-09-01 11:52:05.000000000 +0800
@@ -0,0 +1,75 @@
+/* Copyright (c) 2013,2016 The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/module.h>
+#include <linux/netfilter/x_tables.h>
+
+/* do our -amazing- copy */
+static unsigned int
+mark2prio(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	/* only override priority if it hasn't been set yet.
+	 * this prevents mark2prio from stomping on the CLASSIFY target.
+	 */
+	if (skb->priority == 0)
+		skb->priority = skb->mark;
+
+	return NF_ACCEPT;
+}
+
+/* always return 0, because there is no reason we can't
+ * copy skb->mark to skb->priority
+ */
+static int check_mark2prio(const struct xt_tgchk_param *par)
+{
+	return 0;
+}
+
+static struct xt_target mark2prio_target[] __read_mostly = {
+	{
+		.name		= "mark2prio",
+		.family		= NFPROTO_IPV4,
+		.target		= mark2prio,
+		.targetsize	= 0,
+		.table		= "mangle",
+		.hooks		= (1 << NF_INET_POST_ROUTING),
+		.checkentry	= check_mark2prio,
+		.me		= THIS_MODULE,
+	},
+	{
+		.name		= "mark2prio",
+		.family		= NFPROTO_IPV6,
+		.target		= mark2prio,
+		.targetsize	= 0,
+		.table		= "mangle",
+		.hooks		= (1 << NF_INET_POST_ROUTING),
+		.checkentry	= check_mark2prio,
+		.me		= THIS_MODULE,
+	},
+};
+
+static int __init mark2prio_init(void)
+{
+	return xt_register_targets(mark2prio_target,
+				   ARRAY_SIZE(mark2prio_target));
+}
+
+static void __exit mark2prio_exit(void)
+{
+	xt_unregister_targets(mark2prio_target, ARRAY_SIZE(mark2prio_target));
+}
+
+module_init(mark2prio_init);
+module_exit(mark2prio_exit);
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-adss.c linux-3.14/sound/soc/qca/ipq40xx-adss.c
--- linux/sound/soc/qca/ipq40xx-adss.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-adss.c	2016-09-01 11:52:06.000000000 +0800
@@ -39,13 +39,26 @@
 static spinlock_t tdm_ctrl_lock;
 static spinlock_t glb_mode_lock;
 
-void ipq40xx_gcc_audio_blk_rst(void)
+/* API to write ADSS registers */
+void ipq40xx_audio_adss_writel(uint32_t val, uint32_t offset)
 {
-	reset_control_assert(audio_blk_rst);
-	mdelay(5);
-	reset_control_deassert(audio_blk_rst);
+	if (!adss_audio_local_base) {
+		pr_err("adss_audio_local_base not mapped\n");
+		return;
+	}
+	writel(val, adss_audio_local_base + offset);
+}
+EXPORT_SYMBOL(ipq40xx_audio_adss_writel);
+
+/* API to read ADSS regitsers */
+uint32_t ipq40xx_audio_adss_readl(uint32_t offset)
+{
+	if (adss_audio_local_base)
+		return readl(adss_audio_local_base + offset);
+	pr_err("adss_audio_local_base not mapped\n");
+	return 0;
 }
-EXPORT_SYMBOL(ipq40xx_gcc_audio_blk_rst);
+EXPORT_SYMBOL(ipq40xx_audio_adss_readl);
 
 /* I2S Interface Enable */
 void ipq40xx_glb_i2s_interface_en(int enable)
@@ -399,6 +412,22 @@
 }
 EXPORT_SYMBOL(ipq40xx_glb_spdif_out_en);
 
+void ipq40xx_audio_adss_init(void)
+{
+	spin_lock_init(&i2s_ctrl_lock);
+	spin_lock_init(&tdm_ctrl_lock);
+	spin_lock_init(&glb_mode_lock);
+
+	/* I2S in reset */
+	ipq40xx_glb_i2s_reset(1);
+
+	/* Enable I2S interface */
+	ipq40xx_glb_i2s_interface_en(ENABLE);
+
+	ipq40xx_glb_audio_mode_B1K();
+}
+EXPORT_SYMBOL(ipq40xx_audio_adss_init);
+
 static const struct of_device_id ipq40xx_audio_adss_id_table[] = {
 	{ .compatible = "qca,ipq40xx-audio-adss" },
 	{},
@@ -423,19 +452,6 @@
 	if (IS_ERR(audio_blk_rst))
 		return PTR_ERR(audio_blk_rst);
 
-	spin_lock_init(&i2s_ctrl_lock);
-	spin_lock_init(&tdm_ctrl_lock);
-	spin_lock_init(&glb_mode_lock);
-
-	ipq40xx_gcc_audio_blk_rst();
-	/* I2S in reset */
-	ipq40xx_glb_i2s_reset(1);
-
-	/* Enable I2S interface */
-	ipq40xx_glb_i2s_interface_en(ENABLE);
-
-	ipq40xx_glb_audio_mode_B1K();
-
 	return 0;
 }
 
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-adss.h linux-3.14/sound/soc/qca/ipq40xx-adss.h
--- linux/sound/soc/qca/ipq40xx-adss.h	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-adss.h	2016-09-01 11:52:06.000000000 +0800
@@ -474,7 +474,7 @@
 
 /* I2S Parameters */
 #define IPQ40xx_I2S_NO_OF_PERIODS	(130)
-#define IPQ40xx_I2S_PERIOD_BYTES_MIN	(4032)
+#define IPQ40xx_I2S_PERIOD_BYTES_MIN	ALIGN(4032, L1_CACHE_BYTES)
 #define IPQ40xx_I2S_BUFF_SIZE		(IPQ40xx_I2S_PERIOD_BYTES_MIN * \
 						IPQ40xx_I2S_NO_OF_PERIODS)
 #define IPQ40xx_I2S_CAPTURE_BUFF_SIZE	(IPQ40xx_I2S_PERIOD_BYTES_MIN * \
@@ -482,7 +482,7 @@
 
 /* TDM Parameters */
 #define IPQ40xx_TDM_NO_OF_PERIODS	(260)
-#define IPQ40xx_TDM_PERIOD_BYTES_MIN	(4032)
+#define IPQ40xx_TDM_PERIOD_BYTES_MIN	ALIGN(4032, L1_CACHE_BYTES)
 #define IPQ40xx_TDM_BUFF_SIZE		(IPQ40xx_TDM_PERIOD_BYTES_MIN * \
 						IPQ40xx_TDM_NO_OF_PERIODS)
 #define IPQ40xx_TDM_CAPTURE_BUFF_SIZE	(IPQ40xx_TDM_PERIOD_BYTES_MIN * \
@@ -579,6 +579,9 @@
 extern void ipq40xx_glb_spdif_out_en(uint32_t enable);
 extern void ipq40xx_spdifin_cfg(void);
 extern void ipq40xx_glb_clk_enable_oe(uint32_t dir);
+extern void ipq40xx_audio_adss_init(void);
+extern void ipq40xx_audio_adss_writel(uint32_t val, uint32_t offset);
+extern uint32_t ipq40xx_audio_adss_readl(uint32_t offset);
 /* Stereo APIs */
 extern void ipq40xx_stereo_config_reset(uint32_t reset, uint32_t stereo_offset);
 extern void ipq40xx_stereo_config_mic_reset(uint32_t reset, uint32_t stereo_offset);
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx.c linux-3.14/sound/soc/qca/ipq40xx.c
--- linux/sound/soc/qca/ipq40xx.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx.c	2016-09-01 11:52:06.000000000 +0800
@@ -28,6 +28,9 @@
 #include <sound/pcm.h>
 #include <sound/jack.h>
 #include <asm/io.h>
+#include <linux/pinctrl/consumer.h>
+
+#include "ipq40xx-adss.h"
 
 static struct snd_soc_dai_link ipq40xx_snd_dai[] = {
 	/* Front end DAI Links */
@@ -93,8 +96,24 @@
 {
 	int ret;
 	struct snd_soc_card *card = &snd_soc_card_qca;
+	struct dev_pin_info *pins;
+	struct pinctrl_state *pin_state;
 
 	card->dev = &pdev->dev;
+	pins = card->dev->pins;
+
+/*
+ * If the sound card registration fails, then the audio TLMM change
+ * is also reverted. Due to this, the pins are seen to toggle causing
+ * pop noise. To avoid this, the pins are set to GPIO state and moved
+ * to audio functionality only when the sound card registration is
+ * successful.
+ */
+	pin_state = pinctrl_lookup_state(pins->p, "audio");
+	if (IS_ERR(pin_state)) {
+		pr_err("audio pinctrl state not available\n");
+		return PTR_ERR(pin_state);
+	}
 
 	ret = devm_snd_soc_register_card(&pdev->dev, card);
 	if (ret) {
@@ -102,6 +121,10 @@
 		return ret;
 	}
 
+	ipq40xx_audio_adss_init();
+
+	pinctrl_select_state(pins->p, pin_state);
+
 	return ret;
 }
 
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-cpu-dai.c linux-3.14/sound/soc/qca/ipq40xx-cpu-dai.c
--- linux/sound/soc/qca/ipq40xx-cpu-dai.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-cpu-dai.c	2016-09-01 11:52:06.000000000 +0800
@@ -242,24 +242,6 @@
 		mclk = bclk * MCLK_MULTI;
 	}
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		ret = ipq40xx_audio_clk_set(audio_tx_mclk, dev, mclk);
-		if (ret)
-			return ret;
-
-		ret = ipq40xx_audio_clk_set(audio_tx_bclk, dev, bclk);
-		if (ret)
-			return ret;
-
-	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		ret = ipq40xx_audio_clk_set(audio_rx_mclk, dev, mclk);
-		if (ret)
-			return ret;
-
-		ret = ipq40xx_audio_clk_set(audio_rx_bclk, dev, bclk);
-		if (ret)
-			return ret;
-	}
 	ipq40xx_glb_clk_enable_oe(substream->stream);
 
 	ipq40xx_config_master(ENABLE, stereo_id);
@@ -287,6 +269,26 @@
 
 	ipq40xx_stereo_config_reset(DISABLE, stereo_id);
 	ipq40xx_stereo_config_mic_reset(DISABLE, stereo_id);
+	ipq40xx_stereo_config_enable(ENABLE, stereo_id);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		ret = ipq40xx_audio_clk_set(audio_tx_mclk, dev, mclk);
+		if (ret)
+			return ret;
+
+		ret = ipq40xx_audio_clk_set(audio_tx_bclk, dev, bclk);
+		if (ret)
+			return ret;
+
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		ret = ipq40xx_audio_clk_set(audio_rx_mclk, dev, mclk);
+		if (ret)
+			return ret;
+
+		ret = ipq40xx_audio_clk_set(audio_rx_bclk, dev, bclk);
+		if (ret)
+			return ret;
+	}
 
 	return 0;
 }
@@ -311,6 +313,8 @@
 		ipq40xx_audio_clk_disable(&audio_rx_bclk, dev);
 		ipq40xx_audio_clk_disable(&audio_rx_mclk, dev);
 	}
+	/* Disable the I2S Stereo block */
+	ipq40xx_stereo_config_enable(DISABLE, get_stereo_id(substream, intf));
 }
 
 static int ipq40xx_audio_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-mbox.c linux-3.14/sound/soc/qca/ipq40xx-mbox.c
--- linux/sound/soc/qca/ipq40xx-mbox.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-mbox.c	2016-09-01 11:52:06.000000000 +0800
@@ -28,23 +28,6 @@
 
 #include "ipq40xx-mbox.h"
 
-/* When the mailbox operation is started, the mailbox would get one descriptor
- * for the current data transfer and prefetch one more descriptor. When less
- * than 3 descriptors are configured, then it is possible that before the CPU
- * handles the interrupt, the mailbox could check the pre fetched descriptor
- * and stop the DMA transfer.
- * To handle this, the design is use multiple descriptors, but they would
- * point to the same buffer address. This way  more number of descriptors
- * would satisfy the mbox requirement, and reusing the buffer address would
- * satisfy the upper layer's buffer requirement
- *
- * The value of 5 of repetition times was derived from trial and error testing
- * for minimum number of repetitions that would result in MBOX operations
- * without stopping.
- */
-#define MBOX_MIN_DESC_NUM       3
-#define MBOX_DESC_REPEAT_NUM    5
-
 enum {
 	CHN_DISABLED = 0x00,
 	CHN_ENABLED = 0x01, /* from dtsi */
@@ -54,6 +37,122 @@
 
 struct ipq40xx_mbox_rt_priv *mbox_rtime[ADSS_MBOX_NR_CHANNELS];
 
+static struct ipq40xx_mbox_desc *get_next(
+				struct ipq40xx_mbox_rt_dir_priv *rtdir,
+				struct ipq40xx_mbox_desc *desc)
+{
+	struct ipq40xx_mbox_desc *end;
+
+	end = rtdir->dma_virt_head + rtdir->ndescs;
+
+	desc++;
+
+	if (desc >= end)
+		desc = rtdir->dma_virt_head;
+
+	return desc;
+}
+
+void ipq40xx_mbox_desc_own(u32 channel_id, int desc_no, int own)
+{
+	struct ipq40xx_mbox_desc *desc;
+	struct ipq40xx_mbox_rt_dir_priv *rtdir;
+	u32 chan;
+	u32 dir;
+
+	chan = ipq40xx_convert_id_to_channel(channel_id);
+	dir = ipq40xx_convert_id_to_dir(channel_id);
+
+	rtdir = &mbox_rtime[chan]->dir_priv[dir];
+
+	desc = rtdir->dma_virt_head;
+	desc += desc_no;
+
+	rtdir->write = desc_no;
+
+	desc->OWN = own;
+	desc->ei = 1;
+}
+EXPORT_SYMBOL(ipq40xx_mbox_desc_own);
+
+uint32_t ipq40xx_mbox_get_played_offset(u32 channel_id)
+{
+	struct ipq40xx_mbox_desc *desc, *write;
+	struct ipq40xx_mbox_rt_dir_priv *rtdir;
+	unsigned int i, size_played = 0;
+	u32 chan, dir;
+
+	chan = ipq40xx_convert_id_to_channel(channel_id);
+	dir = ipq40xx_convert_id_to_dir(channel_id);
+
+	rtdir = &mbox_rtime[chan]->dir_priv[dir];
+
+	desc = rtdir->dma_virt_head;
+	write = &rtdir->dma_virt_head[rtdir->write];
+	desc += rtdir->read;
+
+	for (i = 0; i < rtdir->ndescs; i++) {
+		if (desc->OWN == 0) {
+			size_played = desc->size;
+			rtdir->read = (rtdir->read + 1) % rtdir->ndescs;
+		} else {
+			break;
+		}
+
+		if (desc == write)
+			break;
+
+		desc = get_next(rtdir, desc);
+	}
+
+	return size_played * rtdir->read;
+}
+
+uint32_t ipq40xx_mbox_get_played_offset_set_own(u32 channel_id)
+{
+	struct ipq40xx_mbox_desc *desc, *last_played, *prev;
+	struct ipq40xx_mbox_rt_dir_priv *rtdir;
+	unsigned int i, desc_own, size_played = 0;
+	u32 chan, dir;
+
+	chan = ipq40xx_convert_id_to_channel(channel_id);
+	dir = ipq40xx_convert_id_to_dir(channel_id);
+
+	rtdir = &mbox_rtime[chan]->dir_priv[dir];
+	last_played = NULL;
+
+	/* Point to the last desc */
+	prev = &rtdir->dma_virt_head[rtdir->ndescs - 1];
+	desc_own = prev->OWN;
+
+	/* point to first desc */
+	desc = &rtdir->dma_virt_head[0];
+
+	for (i = 0; i < rtdir->ndescs; i++) {
+		if (prev->OWN == 0) {
+			if (i == (rtdir->ndescs - 1)) {
+				if (desc_own == 1)
+					last_played = desc;
+			} else if (desc->OWN == 1) {
+				last_played = desc;
+			}
+			prev->OWN = 1;
+			prev->ei = 1;
+		}
+		prev = desc;
+		desc += 1;
+	}
+	if (last_played) {
+		desc = &rtdir->dma_virt_head[0];
+		size_played = last_played->BufPtr - desc->BufPtr;
+	} else {
+		pr_debug("%s last played buf not found\n", __func__);
+		rtdir->last_played_is_null++;
+	}
+
+	return size_played;
+}
+
 int ipq40xx_mbox_fifo_reset(int channel_id)
 {
 	volatile void __iomem *mbox_reg;
@@ -94,6 +193,7 @@
 		return -ENOMEM;
 
 	mbox_reg = mbox_rtime[index]->mbox_reg_base;
+	mbox_rtime[index]->mbox_started = 1;
 
 	switch (dir) {
 	case PLAYBACK:
@@ -122,6 +222,10 @@
 	if (!mbox_rtime[index])
 		return -ENOMEM;
 
+	/* resume is meaningful only when dma is started. */
+	if (!mbox_rtime[index]->mbox_started)
+		return 0;
+
 	mbox_reg = mbox_rtime[index]->mbox_reg_base;
 
 	switch (dir) {
@@ -143,6 +247,7 @@
 int ipq40xx_mbox_dma_stop(int channel_id)
 {
 	volatile void __iomem *mbox_reg;
+	struct ipq40xx_mbox_rt_dir_priv *mbox_cb;
 	uint32_t index, dir;
 
 	index = ipq40xx_convert_id_to_channel(channel_id);
@@ -152,6 +257,7 @@
 		return -ENOMEM;
 
 	mbox_reg = mbox_rtime[index]->mbox_reg_base;
+	mbox_rtime[index]->mbox_started = 0;
 
 	switch (dir) {
 	case PLAYBACK:
@@ -171,6 +277,10 @@
 
 	mdelay(10);
 
+	mbox_cb = &mbox_rtime[index]->dir_priv[dir];
+	mbox_cb->read = 0;
+	mbox_cb->write = 0;
+
 	return 0;
 
 }
@@ -354,13 +464,14 @@
 }
 EXPORT_SYMBOL(ipq40xx_mbox_vuc_setup);
 
-int ipq40xx_mbox_form_ring(int channel_id, dma_addr_t baseaddr,
-				int period_bytes, int bufsize)
+int ipq40xx_mbox_form_ring(int channel_id, dma_addr_t baseaddr, u8 *area,
+				int period_bytes, int bufsize, int own_bit)
 {
 	struct ipq40xx_mbox_desc *desc, *_desc_p;
 	dma_addr_t desc_p, baseaddr_const;
 	unsigned int i, ndescs;
 	uint32_t index, dir;
+	struct ipq40xx_mbox_rt_dir_priv *mbox_cb;
 
 	index = ipq40xx_convert_id_to_channel(channel_id);
 	dir = ipq40xx_convert_id_to_dir(channel_id);
@@ -368,20 +479,21 @@
 	if (!mbox_rtime[index])
 		return -ENOMEM;
 
+	mbox_cb = &mbox_rtime[index]->dir_priv[dir];
 	ndescs = ((bufsize + (period_bytes - 1)) / period_bytes);
 
-	if (ndescs < MBOX_MIN_DESC_NUM)
-		ndescs *= MBOX_DESC_REPEAT_NUM;
+	desc = (struct ipq40xx_mbox_desc *)(area + (ndescs * period_bytes));
+	desc_p = baseaddr + (ndescs * period_bytes);
 
-	desc = dma_alloc_coherent(mbox_rtime[index]->dir_priv[dir].dev,
-				(ndescs * sizeof(struct ipq40xx_mbox_desc)),
-				&desc_p, GFP_KERNEL);
-	if (!desc) {
-		pr_err("Mem alloc failed for MBOX DMA desc \n");
-		return -ENOMEM;
-	}
+	/* Finding whether duplicate desc entries are required or not should
+	 * be done after desc is initialized else if ndescs are less than
+	 * MBOX_MIN_DESC_NUM and this if condition is before desc initialization
+	 * then desc will point to a region beyond allocated coherent memory */
+	ndescs = ipq40xx_get_mbox_descs_duplicate(ndescs);
 
 	memset(desc, 0, ndescs * sizeof(struct ipq40xx_mbox_desc));
+	mbox_cb->read = 0;
+	mbox_cb->write = 0;
 	mbox_rtime[index]->dir_priv[dir].ndescs = ndescs;
 	mbox_rtime[index]->dir_priv[dir].dma_virt_head = desc;
 	mbox_rtime[index]->dir_priv[dir].dma_phys_head = desc_p;
@@ -391,7 +503,7 @@
 
 	for (i = 0; i < ndescs; i++) {
 
-		desc->OWN = 1;
+		desc->OWN = own_bit;
 		desc->ei = 1;
 		desc->rsvd1 = desc->rsvd2 = desc->rsvd3 = desc->EOM = 0;
 		desc->BufPtr = (baseaddr & 0xfffffff);
@@ -399,7 +511,7 @@
 			(dma_addr_t)(&_desc_p[(i + 1) % ndescs]) & 0xfffffff;
 		desc->size = period_bytes;
 		desc->length = desc->size;
-		baseaddr += period_bytes;
+		baseaddr += ALIGN(period_bytes, L1_CACHE_BYTES);
 		if (baseaddr >= (baseaddr_const + bufsize)) {
 			if (bufsize % period_bytes)
 				desc->size = bufsize % period_bytes;
@@ -432,15 +544,8 @@
 		ipq40xx_mbox_interrupt_disable(channel_id,
 				(MBOX_INT_ENABLE_TX_DMA_COMPLETE |
 					MBOX_INT_ENABLE_RX_DMA_COMPLETE));
-		if (mbox_rtime[index]->dir_priv[dir].dma_virt_head) {
-			dma_free_coherent(mbox_rtime[index]->dir_priv[dir].dev,
-				(mbox_rtime[index]->dir_priv[dir].ndescs *
-					sizeof(struct ipq40xx_mbox_desc)),
-				mbox_rtime[index]->dir_priv[dir].dma_virt_head,
-				mbox_rtime[index]->dir_priv[dir].dma_phys_head);
 
-			mbox_rtime[index]->dir_priv[dir].dma_virt_head = NULL;
-		}
+		mbox_rtime[index]->dir_priv[dir].dma_virt_head = NULL;
 		clear_bit(CHN_STARTED,
 				&mbox_rtime[index]->dir_priv[dir].status);
 		return 0;
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-mbox.h linux-3.14/sound/soc/qca/ipq40xx-mbox.h
--- linux/sound/soc/qca/ipq40xx-mbox.h	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-mbox.h	2016-09-01 11:52:06.000000000 +0800
@@ -60,6 +60,23 @@
  */
 #define SPDIF_CONSUMER_COMPRESD 0x01000006;
 
+/* When the mailbox operation is started, the mailbox would get one descriptor
+ * for the current data transfer and prefetch one more descriptor. When less
+ * than 3 descriptors are configured, then it is possible that before the CPU
+ * handles the interrupt, the mailbox could check the pre fetched descriptor
+ * and stop the DMA transfer.
+ * To handle this, the design is use multiple descriptors, but they would
+ * point to the same buffer address. This way  more number of descriptors
+ * would satisfy the mbox requirement, and reusing the buffer address would
+ * satisfy the upper layer's buffer requirement
+ *
+ * The value of 5 of repetition times was derived from trial and error testing
+ * for minimum number of repetitions that would result in MBOX operations
+ * without stopping.
+ */
+#define MBOX_MIN_DESC_NUM       3
+#define MBOX_DESC_REPEAT_NUM    5
+
 enum {
 	ADSS_MBOX_NR_CHANNELS = 5,
 };
@@ -98,12 +115,15 @@
 	uint32_t channel_id;
 	uint32_t err_stats;
 	uint32_t last_played_is_null;
+	u32 write;
+	u32 read;
 };
 
 struct ipq40xx_mbox_rt_priv {
 	int irq_no;
 	volatile void __iomem *mbox_reg_base;
 	struct ipq40xx_mbox_rt_dir_priv dir_priv[2];
+	int mbox_started;
 };
 
 /* Replaces struct ath_i2s_softc */
@@ -122,12 +142,16 @@
 int ipq40xx_mbox_dma_swap(int channel_id, snd_pcm_format_t format);
 int ipq40xx_mbox_dma_prepare(int channel_id);
 int ipq40xx_mbox_dma_resume(int channel_id);
-int ipq40xx_mbox_form_ring(int channel_id, dma_addr_t baseaddr,
-				int period_bytes, int bufsize);
+int ipq40xx_mbox_form_ring(int channel_id, dma_addr_t baseaddr, u8 *base,
+				int period_bytes, int bufsize, int own_bit);
 int ipq40xx_mbox_dma_release(int channel);
 int ipq40xx_mbox_dma_init(struct device *dev, int channel_id,
 	irq_handler_t callback, void *private_data);
 void ipq40xx_mbox_vuc_setup(int channel_id);
+void ipq40xx_mbox_desc_own(u32 channel_id, int desc_no, int own);
+
+uint32_t ipq40xx_mbox_get_played_offset(u32 channel_id);
+uint32_t ipq40xx_mbox_get_played_offset_set_own(u32 channel_id);
 
 static inline uint32_t ipq40xx_convert_id_to_channel(uint32_t id)
 {
@@ -286,55 +310,16 @@
 	return NULL;
 }
 
-static inline uint32_t ipq40xx_mbox_get_played_offset(uint32_t channel_id)
+/* If number of mbox descriptors are less than MBOX_MIN_DESC_NUM
+ * there should be duplicate mbox descriptors in order to compliant
+ * with the mbox operation logic described at the definitions of
+ * macros MBOX_MIN_DESC_NUM and MBOX_DESC_REPEAT_NUM in this file */
+static inline int ipq40xx_get_mbox_descs_duplicate(int ndescs)
 {
-	struct ipq40xx_mbox_desc *desc, *prev, *last_played;
-	unsigned int ndescs, i;
-	uint32_t index;
-	uint32_t dir;
-	uint32_t desc_own;
-	uint32_t played_size;
-
-	index = ipq40xx_convert_id_to_channel(channel_id);
-	dir = ipq40xx_convert_id_to_dir(channel_id);
-
-	if (!mbox_rtime[index])
-		return 0;
-
-	ndescs = mbox_rtime[index]->dir_priv[dir].ndescs;
-	played_size = 0;
-	last_played = NULL;
-
-	/* Point to the last desc */
-	prev = &mbox_rtime[index]->dir_priv[dir].dma_virt_head[ndescs - 1];
-	desc_own = prev->OWN;
-
-	/* Point to the first desc */
-	desc = &mbox_rtime[index]->dir_priv[dir].dma_virt_head[0];
-
-	for (i = 0; i < ndescs; i++) {
-		if (prev->OWN == 0) {
-			if (i == (ndescs - 1)) {
-				if (desc_own == 1)
-					last_played = desc;
-			} else if (desc->OWN == 1) {
-				last_played = desc;
-			}
-			prev->OWN = 1;
-			prev->ei = 1;
-		}
-		prev = desc;
-		desc += 1;
-	}
-	if (last_played) {
-		desc = &mbox_rtime[index]->dir_priv[dir].dma_virt_head[0];
-		played_size = last_played->BufPtr - desc->BufPtr;
-	} else {
-		pr_debug("%s last played buf not found\n", __func__);
-		mbox_rtime[index]->dir_priv[dir].last_played_is_null++;
-	}
+	if (ndescs < MBOX_MIN_DESC_NUM)
+		ndescs *= MBOX_DESC_REPEAT_NUM;
 
-	return played_size;
+	return ndescs;
 }
 
 #endif /* _IPQ40XX_MBOX_H_ */
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-pcm.h linux-3.14/sound/soc/qca/ipq40xx-pcm.h
--- linux/sound/soc/qca/ipq40xx-pcm.h	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-pcm.h	2016-09-01 11:52:06.000000000 +0800
@@ -30,6 +30,7 @@
 	unsigned int processed_size;
 	uint32_t period_size;
 	uint32_t curr_pos;
+	int mmap_flag;
 };
 
 #endif /* _IPQ40XX_PCM_H_ */
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-pcm-i2s.c linux-3.14/sound/soc/qca/ipq40xx-pcm-i2s.c
--- linux/sound/soc/qca/ipq40xx-pcm-i2s.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-pcm-i2s.c	2016-09-01 11:52:06.000000000 +0800
@@ -77,28 +77,90 @@
 	.fifo_size		=	0,
 };
 
+static size_t ip40xx_dma_buffer_size(struct snd_pcm_hardware *pcm_hw)
+{
+	return pcm_hw->buffer_bytes_max +
+		(pcm_hw->periods_min * sizeof(struct ipq40xx_mbox_desc));
+}
+
+/*
+ * The MBOX descriptors and buffers should lie within the same 256MB
+ * region. Because, the buffer address pointer (in the descriptor structure)
+ * and descriptor base address pointer register share the same MSB 4 bits
+ * which is configured in MBOX DMA Policy register.
+ *
+ * Hence ensure that the entire allocated region falls in a 256MB region.
+ */
+static int ipq40xx_mbox_buf_is_aligned(void *c_ptr, ssize_t size)
+{
+	u32 ptr = (u32)c_ptr;
+
+	return (ptr & 0xF0000000) == ((ptr + size - 1) & 0xF0000000);
+}
+
+static struct device *ss2dev(struct snd_pcm_substream *substream)
+{
+	return substream->pcm->card->dev;
+}
+
 static int ipq40xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 						int stream)
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_pcm_hardware *pcm_hw;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	size_t size;
+	u8 *area;
+	dma_addr_t addr;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		size = ipq40xx_pcm_hardware_playback.buffer_bytes_max;
+		pcm_hw = &ipq40xx_pcm_hardware_playback;
 	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		size = ipq40xx_pcm_hardware_capture.buffer_bytes_max;
+		pcm_hw = &ipq40xx_pcm_hardware_capture;
 	else
 		return -EINVAL;
 
+	size = ip40xx_dma_buffer_size(pcm_hw);
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
-	buf->area = dma_alloc_coherent(pcm->card->dev, size,
-					&buf->addr, GFP_KERNEL);
-	if (!buf->area)
+	/*
+	 * Currently payload uses uncached memory.
+	 * TODO: Eventually we will move to cached memory for payload
+	 * and dma_map_single() will be used for Invalidating/Flushing
+	 * the buffers.
+	 */
+
+	area = dma_alloc_coherent(pcm->card->dev, size, &addr, GFP_KERNEL);
+
+	if (!area) {
+		dev_info(ss2dev(substream), "Alloc coherent memory failed\n");
 		return -ENOMEM;
-	buf->bytes = size;
+	}
+
+	if (!ipq40xx_mbox_buf_is_aligned(area, size)) {
+		dev_info(ss2dev(substream),
+			 "First allocation %p not within 256M region\n", area);
+
+		buf->area = dma_alloc_coherent(pcm->card->dev, size,
+						&buf->addr, GFP_KERNEL);
+		/*
+		 * If we are here, the previously allocated buffer is not
+		 * usable for the driver. Have to free it anyway regardless
+		 * of the success/failure of the second allocation.
+		 */
+		dma_free_coherent(pcm->card->dev, size, area, addr);
+		if (!buf->area) {
+			dev_info(ss2dev(substream),
+				 "Second Alloc coherent memory failed\n");
+			return -ENOMEM;
+		}
+	} else {
+		buf->area = area;
+		buf->addr = addr;
+	}
+
+	buf->bytes = pcm_hw->buffer_bytes_max;
 
 	return 0;
 }
@@ -106,15 +168,26 @@
 static void ipq40xx_pcm_free_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 	struct snd_pcm_substream *substream;
+	struct snd_pcm_hardware *pcm_hw;
 	struct snd_dma_buffer *buf;
+	size_t size;
 
 	substream = pcm->streams[stream].substream;
 	buf = &substream->dma_buffer;
-	if (buf->area) {
-		dma_free_coherent(pcm->card->dev, buf->bytes,
-					buf->area, buf->addr);
+	switch (stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		pcm_hw = &ipq40xx_pcm_hardware_playback;
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		pcm_hw = &ipq40xx_pcm_hardware_capture;
+		break;
 	}
-	buf->area = NULL;
+
+	size = ip40xx_dma_buffer_size(pcm_hw);
+
+	dma_free_coherent(pcm->card->dev, size, buf->area, buf->addr);
+
+	buf->addr = 0;
 }
 
 static irqreturn_t ipq40xx_pcm_irq(int intrsrc, void *data)
@@ -124,8 +197,13 @@
 	struct ipq40xx_pcm_rt_priv *pcm_rtpriv =
 		(struct ipq40xx_pcm_rt_priv *)runtime->private_data;
 
-	pcm_rtpriv->curr_pos =
-		ipq40xx_mbox_get_played_offset(pcm_rtpriv->channel);
+	if (pcm_rtpriv->mmap_flag)
+		pcm_rtpriv->curr_pos =
+			ipq40xx_mbox_get_played_offset_set_own(
+					pcm_rtpriv->channel);
+	else
+		pcm_rtpriv->curr_pos =
+			ipq40xx_mbox_get_played_offset(pcm_rtpriv->channel);
 
 	snd_pcm_period_elapsed(substream);
 
@@ -145,10 +223,43 @@
 	return ret;
 }
 
+static int ipq40xx_pcm_i2s_copy(struct snd_pcm_substream *substream, int chan,
+				snd_pcm_uframes_t hwoff, void __user *ubuf,
+				snd_pcm_uframes_t frames)
+{
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct ipq40xx_pcm_rt_priv *pcm_rtpriv = runtime->private_data;
+	char *hwbuf;
+	u32 offset, size;
+
+	offset = frames_to_bytes(runtime, hwoff);
+	size = frames_to_bytes(runtime, frames);
+
+	hwbuf = buf->area + offset;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (copy_from_user(hwbuf, ubuf, size))
+			return -EFAULT;
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (copy_to_user(ubuf, hwbuf, size))
+			return -EFAULT;
+	}
+
+	ipq40xx_mbox_desc_own(pcm_rtpriv->channel, offset / size, 1);
+	ipq40xx_mbox_dma_resume(pcm_rtpriv->channel);
+
+	return 0;
+}
+
 static int ipq40xx_pcm_i2s_mmap(struct snd_pcm_substream *substream,
 				struct vm_area_struct *vma)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct ipq40xx_pcm_rt_priv *pcm_rtpriv =
+		(struct ipq40xx_pcm_rt_priv *)runtime->private_data;
+
+	pcm_rtpriv->mmap_flag = 1;
 
 	return dma_mmap_coherent(substream->pcm->card->dev, vma,
 		runtime->dma_area, runtime->dma_addr, runtime->dma_bytes);
@@ -190,8 +301,9 @@
 {
 	struct ipq40xx_pcm_rt_priv *pcm_rtpriv;
 	uint32_t ret;
-
 	pcm_rtpriv = substream->runtime->private_data;
+	pcm_rtpriv->mmap_flag = 0;
+
 	ret = ipq40xx_mbox_dma_release(pcm_rtpriv->channel);
 	if (ret) {
 		pr_err("%s: %d: Error in dma release\n",
@@ -209,17 +321,9 @@
 	struct ipq40xx_pcm_rt_priv *pcm_rtpriv =
 				substream->runtime->private_data;
 
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai *dai = rtd->cpu_dai;
-	uint32_t intf = dai->driver->id;
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		/* Enable the I2S Stereo block for operation */
-		ipq40xx_stereo_config_enable(ENABLE,
-					get_stereo_id(substream, intf));
-
 		ret = ipq40xx_mbox_dma_start(pcm_rtpriv->channel);
 		if (ret) {
 			pr_err("%s: %d: Error in dma start\n",
@@ -237,9 +341,6 @@
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		/* Disable the I2S Stereo block */
-		ipq40xx_stereo_config_enable(DISABLE,
-					get_stereo_id(substream, intf));
 
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		ret = ipq40xx_mbox_dma_stop(pcm_rtpriv->channel);
@@ -270,10 +371,12 @@
 
 	ret = ipq40xx_mbox_form_ring(pcm_rtpriv->channel,
 			substream->dma_buffer.addr,
+			substream->dma_buffer.area,
 			params_period_bytes(hw_params),
-			params_buffer_bytes(hw_params));
+			params_buffer_bytes(hw_params),
+			(substream->stream == SNDRV_PCM_STREAM_CAPTURE));
 	if (ret) {
-		pr_err("%s: %d: Error dma form ring \n",
+		pr_err("%s: %d: Error dma form ring\n",
 				__func__, __LINE__);
 		ipq40xx_mbox_dma_release(pcm_rtpriv->channel);
 		return ret;
@@ -315,6 +418,7 @@
 	pcm_rtpriv->dev = substream->pcm->card->dev;
 	pcm_rtpriv->channel = get_mbox_id(substream, intf);
 	substream->runtime->private_data = pcm_rtpriv;
+	pcm_rtpriv->mmap_flag = 0;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		runtime->dma_bytes =
@@ -363,6 +467,7 @@
 	.prepare	= ipq40xx_pcm_i2s_prepare,
 	.mmap		= ipq40xx_pcm_i2s_mmap,
 	.pointer	= ipq40xx_pcm_i2s_pointer,
+	.copy		= ipq40xx_pcm_i2s_copy,
 };
 
 static void ipq40xx_asoc_pcm_i2s_free(struct snd_pcm *pcm)
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-pcm-raw.c linux-3.14/sound/soc/qca/ipq40xx-pcm-raw.c
--- linux/sound/soc/qca/ipq40xx-pcm-raw.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-pcm-raw.c	2016-09-01 11:52:06.000000000 +0800
@@ -47,6 +47,8 @@
 #define PCM_STOP_VAL		0
 
 #define PCM_MULT_FACTOR		4
+#define SET_DESC_OWN		1
+
 /*
  * Global Constant Definitions
  */
@@ -90,7 +92,8 @@
 	uint32_t dma_at;
 	uint32_t rx_size;
 
-	rx_size = ipq40xx_mbox_get_played_offset(rx_dma_buffer->channel_id);
+	rx_size = ipq40xx_mbox_get_played_offset_set_own(
+			rx_dma_buffer->channel_id);
 
 	/* the buffer number calculated would actually point to the next
 	 * buffer to be played. We need to go to the previous buffer, keeping
@@ -294,8 +297,10 @@
 
 	ret = ipq40xx_mbox_form_ring(tx_dma_buffer->channel_id,
 			tx_dma_buffer->addr,
+			tx_dma_buffer->area,
 			single_buf_size,
-			tx_dma_buffer->size);
+			tx_dma_buffer->size,
+			SET_DESC_OWN);
 	if (ret) {
 		pr_err("\n%s: %d: Error dma form ring for playback, error %d\n",
 				__func__, __LINE__, ret);
@@ -322,8 +327,10 @@
 
 	ret = ipq40xx_mbox_form_ring(rx_dma_buffer->channel_id,
 			rx_dma_buffer->addr,
+			rx_dma_buffer->area,
 			single_buf_size,
-			rx_dma_buffer->size);
+			rx_dma_buffer->size,
+			SET_DESC_OWN);
 	if (ret) {
 		pr_err("\n %s: %d: Error dma form ring for capture, error: %d\n",
 				__func__, __LINE__, ret);
@@ -466,7 +473,6 @@
 
 		clk_disable_unprepare(pcm_clk);
 	}
-
 	if (tx_dma_buffer)
 		voice_free_dma_buffer(&pcm_pdev->dev, tx_dma_buffer);
 	if (rx_dma_buffer)
@@ -484,8 +490,16 @@
 static int voice_allocate_dma_buffer(struct device *dev,
 					struct voice_dma_buffer *dma_buffer)
 {
-	dma_buffer->area = dma_zalloc_coherent(dev, dma_buffer->size,
+	int size;
+	int ndescs;
+
+	ndescs = ipq40xx_get_mbox_descs_duplicate(NUM_BUFFERS);
+	size = (dma_buffer->size * NUM_BUFFERS) + (ndescs *
+				sizeof(struct ipq40xx_mbox_desc));
+
+	dma_buffer->area = dma_zalloc_coherent(dev, size,
 					&dma_buffer->addr, GFP_KERNEL);
+
 	if (!dma_buffer->area)
 		return -ENOMEM;
 
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-pcm-raw.h linux-3.14/sound/soc/qca/ipq40xx-pcm-raw.h
--- linux/sound/soc/qca/ipq40xx-pcm-raw.h	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-pcm-raw.h	2016-09-01 11:52:06.000000000 +0800
@@ -17,15 +17,7 @@
 #ifndef _IPQ40xx_PCM_RAW_H
 #define _IPQ40xx_PCM_RAW_H
 
-/* 8 bit 1 channel configuration */
-#define CHANNEL_BIT_WIDTH	8
-#define CHANNEL_SAMPLING_RATE	8000
-#define CHANNEL_BYTE_WIDTH	(CHANNEL_BIT_WIDTH / 8)
-#define SAMPLES_PER_TXN		800
 #define NUM_BUFFERS		2
-#define VOICE_BUFF_SIZE		(CHANNEL_BYTE_WIDTH *			\
-					SAMPLES_PER_TXN * NUM_BUFFERS)
-#define VOICE_PERIOD_SIZE	(VOICE_BUFF_SIZE / NUM_BUFFERS)
 
 #define IPQ40xx_PCM_SAMPLES_PER_10MS(rate) ((rate / 1000) * 10)
 
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-pcm-spdif.c linux-3.14/sound/soc/qca/ipq40xx-pcm-spdif.c
--- linux/sound/soc/qca/ipq40xx-pcm-spdif.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-pcm-spdif.c	2016-09-01 11:52:06.000000000 +0800
@@ -77,43 +77,117 @@
 	.fifo_size		=	0,
 };
 
+static size_t ip40xx_dma_buffer_size(struct snd_pcm_hardware *pcm_hw)
+{
+	return pcm_hw->buffer_bytes_max +
+		(pcm_hw->periods_min * sizeof(struct ipq40xx_mbox_desc));
+}
+
+/*
+ * The MBOX descriptors and buffers should lie within the same 256MB
+ * region. Because, the buffer address pointer (in the descriptor structure)
+ * and descriptor base address pointer register share the same MSB 4 bits
+ * which is configured in MBOX DMA Policy register.
+ *
+ * Hence ensure that the entire allocated region falls in a 256MB region.
+ */
+static int ipq40xx_mbox_buf_is_aligned(void *c_ptr, ssize_t size)
+{
+	u32 ptr = (u32)c_ptr;
+
+	return (ptr & 0xF0000000) == ((ptr + size - 1) & 0xF0000000);
+}
+
+static struct device *ss2dev(struct snd_pcm_substream *substream)
+{
+	return substream->pcm->card->dev;
+}
+
 static int ipq40xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 						int stream)
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_pcm_hardware *pcm_hw;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	size_t size;
+	u8 *area;
+	dma_addr_t addr;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		size = ipq40xx_pcm_hardware_playback.buffer_bytes_max;
+		pcm_hw = &ipq40xx_pcm_hardware_playback;
 	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		size = ipq40xx_pcm_hardware_capture.buffer_bytes_max;
+		pcm_hw = &ipq40xx_pcm_hardware_capture;
 	else
 		return -EINVAL;
 
+	size = ip40xx_dma_buffer_size(pcm_hw);
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
-	buf->area = dma_alloc_coherent(pcm->card->dev, size,
-					&buf->addr, GFP_KERNEL);
-	if (!buf->area)
+	/*
+	 * Currently payload uses uncached memory.
+	 * TODO: Eventually we will move to cached memory for payload
+	 * and dma_map_single() will be used for Invalidating/Flushing
+	 * the buffers.
+	 */
+
+	area = dma_alloc_coherent(pcm->card->dev, size, &addr, GFP_KERNEL);
+
+	if (!area) {
+		dev_info(ss2dev(substream), "Alloc coherent memory failed\n");
 		return -ENOMEM;
-	buf->bytes = size;
+	}
+
+	if (!ipq40xx_mbox_buf_is_aligned(area, size)) {
+		dev_info(ss2dev(substream),
+			 "First allocation %p not within 256M region\n", area);
+
+		buf->area = dma_alloc_coherent(pcm->card->dev, size,
+						&buf->addr, GFP_KERNEL);
+		/*
+		 * If we are here, the previously allocated buffer is not
+		 * usable for the driver. Have to free it anyway regardless
+		 * of the success/failure of the second allocation.
+		 */
+		dma_free_coherent(pcm->card->dev, size, area, addr);
+		if (!buf->area) {
+			dev_info(ss2dev(substream),
+				 "Second Alloc coherent memory failed\n");
+			return -ENOMEM;
+		}
+	} else {
+		buf->area = area;
+		buf->addr = addr;
+	}
+
+	buf->bytes = pcm_hw->buffer_bytes_max;
 
 	return 0;
+
 }
 
 static void ipq40xx_pcm_free_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 	struct snd_pcm_substream *substream;
+	struct snd_pcm_hardware *pcm_hw;
 	struct snd_dma_buffer *buf;
+	size_t size;
 
 	substream = pcm->streams[stream].substream;
 	buf = &substream->dma_buffer;
-	if (buf->area) {
-		dma_free_coherent(pcm->card->dev, buf->bytes,
-					buf->area, buf->addr);
+	switch (stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		pcm_hw = &ipq40xx_pcm_hardware_playback;
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		pcm_hw = &ipq40xx_pcm_hardware_capture;
+		break;
 	}
+
+	size = ip40xx_dma_buffer_size(pcm_hw);
+
+	dma_free_coherent(pcm->card->dev, size, buf->area, buf->addr);
+
 	buf->area = NULL;
 }
 
@@ -186,6 +260,36 @@
 	return ret;
 }
 
+static int ipq40xx_pcm_spdif_copy(struct snd_pcm_substream *substream, int chan,
+				snd_pcm_uframes_t hwoff, void __user *ubuf,
+				snd_pcm_uframes_t frames)
+{
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct ipq40xx_pcm_rt_priv *pcm_rtpriv = runtime->private_data;
+	char *hwbuf;
+	u32 offset, size;
+
+	offset = frames_to_bytes(runtime, hwoff);
+	size = frames_to_bytes(runtime, frames);
+
+	hwbuf = buf->area + offset;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (copy_from_user(hwbuf, ubuf, size))
+			return -EFAULT;
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (copy_to_user(ubuf, hwbuf, size))
+			return -EFAULT;
+	}
+
+	ipq40xx_mbox_desc_own(pcm_rtpriv->channel, offset / size, 1);
+
+	ipq40xx_mbox_dma_resume(pcm_rtpriv->channel);
+
+	return 0;
+}
+
 static int ipq40xx_pcm_spdif_mmap(struct snd_pcm_substream *substream,
 				struct vm_area_struct *vma)
 {
@@ -345,8 +449,10 @@
 	pcm_rtpriv = runtime->private_data;
 	ret = ipq40xx_mbox_form_ring(pcm_rtpriv->channel,
 			substream->dma_buffer.addr,
+			substream->dma_buffer.area,
 			params_period_bytes(hw_params),
-			params_buffer_bytes(hw_params));
+			params_buffer_bytes(hw_params),
+			(substream->stream == SNDRV_PCM_STREAM_CAPTURE));
 	if (ret) {
 		pr_err("%s: %d: Error dma form ring\n",	__func__, __LINE__);
 		ipq40xx_mbox_dma_release(pcm_rtpriv->channel);
@@ -440,6 +546,7 @@
 	.prepare	= ipq40xx_pcm_spdif_prepare,
 	.mmap		= ipq40xx_pcm_spdif_mmap,
 	.pointer	= ipq40xx_pcm_spdif_pointer,
+	.copy		= ipq40xx_pcm_spdif_copy,
 };
 
 static void ipq40xx_asoc_pcm_spdif_free(struct snd_pcm *pcm)
diff -Naur -x .git --no-dereference linux/sound/soc/qca/ipq40xx-pcm-tdm.c linux-3.14/sound/soc/qca/ipq40xx-pcm-tdm.c
--- linux/sound/soc/qca/ipq40xx-pcm-tdm.c	2016-04-18 10:49:08.000000000 +0800
+++ linux-3.14/sound/soc/qca/ipq40xx-pcm-tdm.c	2016-09-01 11:52:06.000000000 +0800
@@ -76,44 +76,117 @@
 	.periods_max		=	IPQ40xx_TDM_NO_OF_PERIODS,
 	.fifo_size		=	0,
 };
+static size_t ip40xx_dma_buffer_size(struct snd_pcm_hardware *pcm_hw)
+{
+	return pcm_hw->buffer_bytes_max +
+		(pcm_hw->periods_min * sizeof(struct ipq40xx_mbox_desc));
+}
+
+/*
+ * The MBOX descriptors and buffers should lie within the same 256MB
+ * region. Because, the buffer address pointer (in the descriptor structure)
+ * and descriptor base address pointer register share the same MSB 4 bits
+ * which is configured in MBOX DMA Policy register.
+ *
+ * Hence ensure that the entire allocated region falls in a 256MB region.
+ */
+static int ipq40xx_mbox_buf_is_aligned(void *c_ptr, ssize_t size)
+{
+	u32 ptr = (u32)c_ptr;
+
+	return (ptr & 0xF0000000) == ((ptr + size - 1) & 0xF0000000);
+}
+
+static struct device *ss2dev(struct snd_pcm_substream *substream)
+{
+	return substream->pcm->card->dev;
+}
 
 static int ipq40xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 						int stream)
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_pcm_hardware *pcm_hw;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
 	size_t size;
+	u8 *area;
+	dma_addr_t addr;
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		size = ipq40xx_pcm_hardware_playback.buffer_bytes_max;
+		pcm_hw = &ipq40xx_pcm_hardware_playback;
 	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		size = ipq40xx_pcm_hardware_capture.buffer_bytes_max;
+		pcm_hw = &ipq40xx_pcm_hardware_capture;
 	else
 		return -EINVAL;
 
+	size = ip40xx_dma_buffer_size(pcm_hw);
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
 	buf->private_data = NULL;
-	buf->area = dma_alloc_coherent(pcm->card->dev, size,
-					&buf->addr, GFP_KERNEL);
-	if (!buf->area)
+	/*
+	 * Currently payload uses uncached memory.
+	 * TODO: Eventually we will move to cached memory for payload
+	 * and dma_map_single() will be used for Invalidating/Flushing
+	 * the buffers.
+	 */
+
+	area = dma_alloc_coherent(pcm->card->dev, size, &addr, GFP_KERNEL);
+
+	if (!area) {
+		dev_info(ss2dev(substream), "Alloc coherent memory failed\n");
 		return -ENOMEM;
-	buf->bytes = size;
+	}
+
+	if (!ipq40xx_mbox_buf_is_aligned(area, size)) {
+		dev_info(ss2dev(substream),
+			 "First allocation %p not within 256M region\n", area);
+
+		buf->area = dma_alloc_coherent(pcm->card->dev, size,
+						&buf->addr, GFP_KERNEL);
+		/*
+		 * If we are here, the previously allocated buffer is not
+		 * usable for the driver. Have to free it anyway regardless
+		 * of the success/failure of the second allocation.
+		 */
+		dma_free_coherent(pcm->card->dev, size, area, addr);
+		if (!buf->area) {
+			dev_info(ss2dev(substream),
+				 "Second Alloc coherent memory failed\n");
+			return -ENOMEM;
+		}
+	} else {
+		buf->area = area;
+		buf->addr = addr;
+	}
+
+	buf->bytes = pcm_hw->buffer_bytes_max;
 
 	return 0;
+
 }
 
 static void ipq40xx_pcm_free_dma_buffer(struct snd_pcm *pcm, int stream)
 {
 	struct snd_pcm_substream *substream;
+	struct snd_pcm_hardware *pcm_hw;
 	struct snd_dma_buffer *buf;
+	size_t size;
 
 	substream = pcm->streams[stream].substream;
 	buf = &substream->dma_buffer;
-	if (buf->area) {
-		dma_free_coherent(pcm->card->dev, buf->bytes,
-					buf->area, buf->addr);
+	switch (stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		pcm_hw = &ipq40xx_pcm_hardware_playback;
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		pcm_hw = &ipq40xx_pcm_hardware_capture;
+		break;
 	}
+
+	size = ip40xx_dma_buffer_size(pcm_hw);
+
+	dma_free_coherent(pcm->card->dev, size, buf->area, buf->addr);
+
 	buf->area = NULL;
 }
 
@@ -145,6 +218,36 @@
 	return ret;
 }
 
+static int ipq40xx_pcm_tdm_copy(struct snd_pcm_substream *substream, int chan,
+				snd_pcm_uframes_t hwoff, void __user *ubuf,
+				snd_pcm_uframes_t frames)
+{
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct ipq40xx_pcm_rt_priv *pcm_rtpriv = runtime->private_data;
+	char *hwbuf;
+	u32 offset, size;
+
+	offset = frames_to_bytes(runtime, hwoff);
+	size = frames_to_bytes(runtime, frames);
+
+	hwbuf = buf->area + offset;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (copy_from_user(hwbuf, ubuf, size))
+			return -EFAULT;
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (copy_to_user(ubuf, hwbuf, size))
+			return -EFAULT;
+	}
+
+	ipq40xx_mbox_desc_own(pcm_rtpriv->channel, offset / size, 1);
+
+	ipq40xx_mbox_dma_resume(pcm_rtpriv->channel);
+
+	return 0;
+}
+
 static int ipq40xx_pcm_tdm_mmap(struct snd_pcm_substream *substream,
 				struct vm_area_struct *vma)
 {
@@ -188,8 +291,12 @@
 static int ipq40xx_pcm_tdm_close(struct snd_pcm_substream *substream)
 {
 	struct ipq40xx_pcm_rt_priv *pcm_rtpriv;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	u32 intf = dai->driver->id;
 	uint32_t ret;
 
+	ipq40xx_stereo_config_enable(DISABLE, get_stereo_id(substream, intf));
 	pcm_rtpriv = substream->runtime->private_data;
 	if (!pcm_rtpriv)
 		return -EINVAL;
@@ -214,10 +321,6 @@
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		/* Enable the I2S Stereo block for operation */
-		ipq40xx_stereo_config_enable(ENABLE,
-					get_stereo_id(substream, TDM));
-
 		ret = ipq40xx_mbox_dma_start(pcm_rtpriv->channel);
 		if (ret) {
 			pr_err("%s: %d: Error in dma start\n",
@@ -235,10 +338,6 @@
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		/* Disable the I2S Stereo block */
-		ipq40xx_stereo_config_enable(DISABLE,
-					get_stereo_id(substream, TDM));
-
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		ret = ipq40xx_mbox_dma_stop(pcm_rtpriv->channel);
 		if (ret) {
@@ -268,10 +367,12 @@
 
 	ret = ipq40xx_mbox_form_ring(pcm_rtpriv->channel,
 			substream->dma_buffer.addr,
+			substream->dma_buffer.area,
 			params_period_bytes(hw_params),
-			params_buffer_bytes(hw_params));
+			params_buffer_bytes(hw_params),
+			(substream->stream == SNDRV_PCM_STREAM_CAPTURE));
 	if (ret) {
-		pr_err("%s: %d: Error dma form ring \n",
+		pr_err("%s: %d: Error dma form ring\n",
 				__func__, __LINE__);
 		ipq40xx_mbox_dma_release(pcm_rtpriv->channel);
 		return ret;
@@ -358,6 +459,7 @@
 	.prepare	= ipq40xx_pcm_tdm_prepare,
 	.mmap		= ipq40xx_pcm_tdm_mmap,
 	.pointer	= ipq40xx_pcm_tdm_pointer,
+	.copy		= ipq40xx_pcm_tdm_copy,
 };
 
 static void ipq40xx_asoc_pcm_tdm_free(struct snd_pcm *pcm)
